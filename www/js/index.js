/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/index.rb");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/index.rb":
/*!**********************!*\
  !*** ./app/index.rb ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {var __WEBPACK_AMD_DEFINE_RESULT__;(function(undefined) {\n  // @note\n  //   A few conventions for the documentation of this file:\n  //   1. Always use \"//\" (in contrast with \"/**/\")\n  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)\n  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to\n  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.\n  //   4. `nil` and `null` being unambiguous refer to the respective\n  //      objects/values in Ruby and JavaScript\n  //   5. This is still WIP :) so please give feedback and suggestions on how\n  //      to improve or for alternative solutions\n  //\n  //   The way the code is digested before going through Yardoc is a secret kept\n  //   in the docs repo (https://github.com/opal/docs/tree/master).\n\n  var global_object = this, console;\n\n  // Detect the global object\n  if (typeof(global) !== 'undefined') { global_object = global; }\n  if (typeof(window) !== 'undefined') { global_object = window; }\n\n  // Setup a dummy console object if missing\n  if (typeof(global_object.console) === 'object') {\n    console = global_object.console;\n  } else if (global_object.console == null) {\n    console = global_object.console = {};\n  } else {\n    console = {};\n  }\n\n  if (!('log' in console)) { console.log = function () {}; }\n  if (!('warn' in console)) { console.warn = console.log; }\n\n  if (typeof(this.Opal) !== 'undefined') {\n    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');\n    return this.Opal;\n  }\n\n  var nil;\n\n  // The actual class for BasicObject\n  var BasicObject;\n\n  // The actual Object class.\n  // The leading underscore is to avoid confusion with window.Object()\n  var _Object;\n\n  // The actual Module class\n  var Module;\n\n  // The actual Class class\n  var Class;\n\n  // Constructor for instances of BasicObject\n  function BasicObject_alloc(){}\n\n  // Constructor for instances of Object\n  function Object_alloc(){}\n\n  // Constructor for instances of Class\n  function Class_alloc(){}\n\n  // Constructor for instances of Module\n  function Module_alloc(){}\n\n  // Constructor for instances of NilClass (nil)\n  function NilClass_alloc(){}\n\n  // The Opal object that is exposed globally\n  var Opal = this.Opal = {};\n\n  // All bridged classes - keep track to donate methods from Object\n  var BridgedClasses = {};\n\n  // This is a useful reference to global object inside ruby files\n  Opal.global = global_object;\n  global_object.Opal = Opal;\n\n  // Configure runtime behavior with regards to require and unsupported fearures\n  Opal.config = {\n    missing_require_severity: 'error',        // error, warning, ignore\n    unsupported_features_severity: 'warning', // error, warning, ignore\n    enable_stack_trace: true                  // true, false\n  }\n\n  // Minify common function calls\n  var $hasOwn = Object.hasOwnProperty;\n  var $slice  = Opal.slice = Array.prototype.slice;\n\n  // Nil object id is always 4\n  var nil_id = 4;\n\n  // Generates even sequential numbers greater than 4\n  // (nil_id) to serve as unique ids for ruby objects\n  var unique_id = nil_id;\n\n  // Return next unique id\n  Opal.uid = function() {\n    unique_id += 2;\n    return unique_id;\n  };\n\n  // Retrieve or assign the id of an object\n  Opal.id = function(obj) {\n    if (obj.$$is_number) return (obj * 2)+1;\n    return obj.$$id || (obj.$$id = Opal.uid());\n  };\n\n  // Globals table\n  Opal.gvars = {};\n\n  // Exit function, this should be replaced by platform specific implementation\n  // (See nodejs and chrome for examples)\n  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };\n\n  // keeps track of exceptions for $!\n  Opal.exceptions = [];\n\n  // @private\n  // Pops an exception from the stack and updates `$!`.\n  Opal.pop_exception = function() {\n    Opal.gvars[\"!\"] = Opal.exceptions.pop() || nil;\n  }\n\n  // Inspect any kind of object, including non Ruby ones\n  Opal.inspect = function(obj) {\n    if (obj === undefined) {\n      return \"undefined\";\n    }\n    else if (obj === null) {\n      return \"null\";\n    }\n    else if (!obj.$$class) {\n      return obj.toString();\n    }\n    else {\n      return obj.$inspect();\n    }\n  }\n\n\n  // Truth\n  // -----\n\n  Opal.truthy = function(val) {\n    return (val !== nil && val != null && (!val.$$is_boolean || val == true));\n  };\n\n  Opal.falsy = function(val) {\n    return (val === nil || val == null || (val.$$is_boolean && val == false))\n  };\n\n\n  // Constants\n  // ---------\n  //\n  // For future reference:\n  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)\n  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)\n  //\n  // Legend of MRI concepts/names:\n  // - constant reference (cref): the module/class that acts as a namespace\n  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside\n  //            `module A; module B::C; end; end` is `[B::C, A]`\n\n  // Get the constant in the scope of the current cref\n  function const_get_name(cref, name) {\n    if (cref) return cref.$$const[name];\n  }\n\n  // Walk up the nesting array looking for the constant\n  function const_lookup_nesting(nesting, name) {\n    var i, ii, result, constant;\n\n    if (nesting.length === 0) return;\n\n    // If the nesting is not empty the constant is looked up in its elements\n    // and in order. The ancestors of those elements are ignored.\n    for (i = 0, ii = nesting.length; i < ii; i++) {\n      constant = nesting[i].$$const[name];\n      if (constant != null) return constant;\n    }\n  }\n\n  // Walk up the ancestors chain looking for the constant\n  function const_lookup_ancestors(cref, name) {\n    var i, ii, result, ancestors;\n\n    if (cref == null) return;\n\n    ancestors = Opal.ancestors(cref);\n\n    for (i = 0, ii = ancestors.length; i < ii; i++) {\n      if (ancestors[i].$$const && $hasOwn.call(ancestors[i].$$const, name)) {\n        return ancestors[i].$$const[name];\n      }\n    }\n  }\n\n  // Walk up Object's ancestors chain looking for the constant,\n  // but only if cref is missing or a module.\n  function const_lookup_Object(cref, name) {\n    if (cref == null || cref.$$is_module) {\n      return const_lookup_ancestors(_Object, name);\n    }\n  }\n\n  // Call const_missing if nothing else worked\n  function const_missing(cref, name, skip_missing) {\n    if (!skip_missing) {\n      return (cref || _Object).$const_missing(name);\n    }\n  }\n\n  // Look for the constant just in the current cref or call `#const_missing`\n  Opal.const_get_local = function(cref, name, skip_missing) {\n    var result;\n\n    if (cref == null) return;\n\n    if (cref === '::') cref = _Object;\n\n    if (!cref.$$is_a_module) {\n      throw new Opal.TypeError(cref.toString() + \" is not a class/module\");\n    }\n\n    result = const_get_name(cref, name);              if (result != null) return result;\n    result = const_missing(cref, name, skip_missing); if (result != null) return result;\n  }\n\n  // Look for the constant relative to a cref or call `#const_missing` (when the\n  // constant is prefixed by `::`).\n  Opal.const_get_qualified = function(cref, name, skip_missing) {\n    var result, cache, cached, current_version = Opal.const_cache_version;\n\n    if (cref == null) return;\n\n    if (cref === '::') cref = _Object;\n\n    if (!cref.$$is_a_module) {\n      throw new Opal.TypeError(cref.toString() + \" is not a class/module\");\n    }\n\n    if ((cache = cref.$$const_cache) == null) {\n      cache = cref.$$const_cache = Object.create(null);\n    }\n    cached = cache[name];\n\n    if (cached == null || cached[0] !== current_version) {\n      ((result = const_get_name(cref, name))              != null) ||\n      ((result = const_lookup_ancestors(cref, name))      != null);\n      cache[name] = [current_version, result];\n    } else {\n      result = cached[1];\n    }\n\n    return result != null ? result : const_missing(cref, name, skip_missing);\n  };\n\n  // Initialize the top level constant cache generation counter\n  Opal.const_cache_version = 1;\n\n  // Look for the constant in the open using the current nesting and the nearest\n  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).\n  Opal.const_get_relative = function(nesting, name, skip_missing) {\n    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;\n\n    if ((cache = nesting.$$const_cache) == null) {\n      cache = nesting.$$const_cache = Object.create(null);\n    }\n    cached = cache[name];\n\n    if (cached == null || cached[0] !== current_version) {\n      ((result = const_get_name(cref, name))              != null) ||\n      ((result = const_lookup_nesting(nesting, name))     != null) ||\n      ((result = const_lookup_ancestors(cref, name))      != null) ||\n      ((result = const_lookup_Object(cref, name))         != null);\n\n      cache[name] = [current_version, result];\n    } else {\n      result = cached[1];\n    }\n\n    return result != null ? result : const_missing(cref, name, skip_missing);\n  };\n\n  // Register the constant on a cref and opportunistically set the name of\n  // unnamed classes/modules.\n  Opal.const_set = function(cref, name, value) {\n    if (cref == null || cref === '::') cref = _Object;\n\n    if (value.$$is_a_module) {\n      if (value.$$name == null || value.$$name === nil) value.$$name = name;\n      if (value.$$base_module == null) value.$$base_module = cref;\n    }\n\n    cref.$$const = (cref.$$const || Object.create(null));\n    cref.$$const[name] = value;\n\n    Opal.const_cache_version++;\n\n    // Expose top level constants onto the Opal object\n    if (cref === _Object) Opal[name] = value;\n\n    return value;\n  };\n\n  // Get all the constants reachable from a given cref, by default will include\n  // inherited constants.\n  Opal.constants = function(cref, inherit) {\n    if (inherit == null) inherit = true;\n\n    var module, modules = [cref], module_constants, i, ii, constants = {}, constant;\n\n    if (inherit) modules = modules.concat(Opal.ancestors(cref));\n    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));\n\n    for (i = 0, ii = modules.length; i < ii; i++) {\n      module = modules[i];\n\n      // Don not show Objects constants unless we're querying Object itself\n      if (cref !== _Object && module == _Object) break;\n\n      for (constant in module.$$const) {\n        constants[constant] = true;\n      }\n    }\n\n    return Object.keys(constants);\n  };\n\n  // Remove a constant from a cref.\n  Opal.const_remove = function(cref, name) {\n    Opal.const_cache_version++;\n\n    if (cref.$$const[name] != null) {\n      var old = cref.$$const[name];\n      delete cref.$$const[name];\n      return old;\n    }\n\n    if (cref.$$autoload != null && cref.$$autoload[name] != null) {\n      delete cref.$$autoload[name];\n      return nil;\n    }\n\n    throw Opal.NameError.$new(\"constant \"+cref+\"::\"+cref.$name()+\" not defined\");\n  };\n\n\n  // Modules & Classes\n  // -----------------\n\n  // A `class Foo; end` expression in ruby is compiled to call this runtime\n  // method which either returns an existing class of the given name, or creates\n  // a new class in the given `base` scope.\n  //\n  // If a constant with the given name exists, then we check to make sure that\n  // it is a class and also that the superclasses match. If either of these\n  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one\n  // was not specified in the ruby code.\n  //\n  // We pass a constructor to this method of the form `function ClassName() {}`\n  // simply so that classes show up with nicely formatted names inside debuggers\n  // in the web browser (or node/sprockets).\n  //\n  // The `base` is the current `self` value where the class is being created\n  // from. We use this to get the scope for where the class should be created.\n  // If `base` is an object (not a class/module), we simple get its class and\n  // use that as the base instead.\n  //\n  // @param base        [Object] where the class is being created\n  // @param superclass  [Class,null] superclass of the new class (may be null)\n  // @param id          [String] the name of the class to be created\n  // @param constructor [JS.Function] function to use as constructor\n  //\n  // @return new [Class]  or existing ruby class\n  //\n  Opal.klass = function(base, superclass, name, constructor) {\n    var klass, bridged, alloc;\n\n    if (base == null) {\n      base = _Object;\n    }\n\n    // If base is an object, use its class\n    if (!base.$$is_class && !base.$$is_module) {\n      base = base.$$class;\n    }\n\n    // If the superclass is a function then we're bridging a native JS class\n    if (typeof(superclass) === 'function') {\n      bridged = superclass;\n      superclass = _Object;\n    }\n\n    // Try to find the class in the current scope\n    klass = const_get_name(base, name);\n\n    // If the class exists in the scope, then we must use that\n    if (klass) {\n      // Make sure the existing constant is a class, or raise error\n      if (!klass.$$is_class) {\n        throw Opal.TypeError.$new(name + \" is not a class\");\n      }\n\n      // Make sure existing class has same superclass\n      if (superclass && klass.$$super !== superclass) {\n        throw Opal.TypeError.$new(\"superclass mismatch for class \" + name);\n      }\n\n      return klass;\n    }\n\n    // Class doesnt exist, create a new one with given superclass...\n\n    // Not specifying a superclass means we can assume it to be Object\n    if (superclass == null) {\n      superclass = _Object;\n    }\n\n    // If bridged the JS class will also be the alloc function\n    alloc = bridged || Opal.boot_class_alloc(name, constructor, superclass);\n\n    // Create the class object (instance of Class)\n    klass = Opal.setup_class_object(name, alloc, superclass.$$name, superclass.constructor);\n\n    // @property $$super the superclass, doesn't get changed by module inclusions\n    klass.$$super = superclass;\n\n    // @property $$parent direct parent class\n    //                    starts with the superclass, after klass inclusion is\n    //                    the last included klass\n    klass.$$parent = superclass;\n\n    Opal.const_set(base, name, klass);\n\n    // Name new class directly onto current scope (Opal.Foo.Baz = klass)\n    base[name] = klass;\n\n    if (bridged) {\n      Opal.bridge(klass, alloc);\n    }\n    else {\n      // Call .inherited() hook with new class on the superclass\n      if (superclass.$inherited) {\n        superclass.$inherited(klass);\n      }\n    }\n\n    return klass;\n  };\n\n  // Boot a base class (makes instances).\n  //\n  // @param name [String,null] the class name\n  // @param constructor [JS.Function] the class' instances constructor/alloc function\n  // @param superclass  [Class,null] the superclass object\n  // @return [JS.Function] the consturctor holding the prototype for the class' instances\n  Opal.boot_class_alloc = function(name, constructor, superclass) {\n    if (superclass) {\n      var alloc_proxy = function() {};\n      alloc_proxy.prototype = superclass.$$proto || superclass.prototype;\n      constructor.prototype = new alloc_proxy();\n    }\n\n    if (name) {\n      constructor.displayName = name+'_alloc';\n    }\n\n    constructor.prototype.constructor = constructor;\n\n    return constructor;\n  };\n\n  Opal.setup_module_or_class = function(module) {\n    // @property $$id Each class/module is assigned a unique `id` that helps\n    //                comparation and implementation of `#object_id`\n    module.$$id = Opal.uid();\n\n    // @property $$is_a_module Will be true for Module and its subclasses\n    //                         instances (namely: Class).\n    module.$$is_a_module = true;\n\n    // @property $$inc included modules\n    module.$$inc = [];\n\n    // initialize the name with nil\n    module.$$name = nil;\n\n    // Initialize the constants table\n    module.$$const = Object.create(null);\n\n    // @property $$cvars class variables defined in the current module\n    module.$$cvars = Object.create(null);\n  }\n\n\n\n  // Adds common/required properties to class object (as in `Class.new`)\n  //\n  // @param name  [String,null] The name of the class\n  //\n  // @param alloc [JS.Function] The constructor of the class' instances\n  //\n  // @param superclass_name [String,null]\n  //   The name of the super class, this is\n  //   usefule to build the `.displayName` of the singleton class\n  //\n  // @param superclass_alloc [JS.Function]\n  //   The constructor of the superclass from which the singleton_class is\n  //   derived.\n  //\n  // @return [Class]\n  Opal.setup_class_object = function(name, alloc, superclass_name, superclass_alloc) {\n    // Grab the superclass prototype and use it to build an intermediary object\n    // in the prototype chain.\n    var superclass_alloc_proxy = function() {};\n        superclass_alloc_proxy.prototype = superclass_alloc.prototype;\n        superclass_alloc_proxy.displayName = superclass_name;\n\n    var singleton_class_alloc = function() {}\n        singleton_class_alloc.prototype = new superclass_alloc_proxy();\n\n    // The built class is the only instance of its singleton_class\n    var klass = new singleton_class_alloc();\n\n    Opal.setup_module_or_class(klass);\n\n    // @property $$alloc This is the constructor of instances of the current\n    //                   class. Its prototype will be used for method lookup\n    klass.$$alloc = alloc;\n\n    klass.$$name = name || nil;\n\n    // Set a displayName for the singleton_class\n    singleton_class_alloc.displayName = \"#<Class:\"+(name || (\"#<Class:\"+klass.$$id+\">\"))+\">\";\n\n    // @property $$proto This is the prototype on which methods will be defined\n    klass.$$proto = alloc.prototype;\n\n    // @property $$proto.$$class Make available to instances a reference to the\n    //                           class they belong to.\n    klass.$$proto.$$class = klass;\n\n    // @property constructor keeps a ref to the constructor, but apparently the\n    //                       constructor is already set on:\n    //\n    //                          `var klass = new constructor` is called.\n    //\n    //                       Maybe there are some browsers not abiding (IE6?)\n    klass.constructor = singleton_class_alloc;\n\n    // @property $$is_class Clearly mark this as a class\n    klass.$$is_class = true;\n\n    // @property $$class Classes are instances of the class Class\n    klass.$$class    = Class;\n\n    return klass;\n  };\n\n  // Define new module (or return existing module). The given `base` is basically\n  // the current `self` value the `module` statement was defined in. If this is\n  // a ruby module or class, then it is used, otherwise if the base is a ruby\n  // object then that objects real ruby class is used (e.g. if the base is the\n  // main object, then the top level `Object` class is used as the base).\n  //\n  // If a module of the given name is already defined in the base, then that\n  // instance is just returned.\n  //\n  // If there is a class of the given name in the base, then an error is\n  // generated instead (cannot have a class and module of same name in same base).\n  //\n  // Otherwise, a new module is created in the base with the given name, and that\n  // new instance is returned back (to be referenced at runtime).\n  //\n  // @param  base [Module, Class] class or module this definition is inside\n  // @param  id   [String] the name of the new (or existing) module\n  //\n  // @return [Module]\n  Opal.module = function(base, name) {\n    var module;\n\n    if (base == null) {\n      base = _Object;\n    }\n\n    if (!base.$$is_class && !base.$$is_module) {\n      base = base.$$class;\n    }\n\n    module = const_get_name(base, name);\n    if (module == null && base === _Object) module = const_lookup_ancestors(_Object, name);\n\n    if (module) {\n      if (!module.$$is_module && module !== _Object) {\n        throw Opal.TypeError.$new(name + \" is not a module\");\n      }\n    }\n    else {\n      module = Opal.module_allocate(Module);\n      Opal.const_set(base, name, module);\n    }\n\n    return module;\n  };\n\n  // The implementation for Module#initialize\n  // @param module [Module]\n  // @param block [Proc,nil]\n  // @return nil\n  Opal.module_initialize = function(module, block) {\n    if (block !== nil) {\n      var block_self = block.$$s;\n      block.$$s = null;\n      block.call(module);\n      block.$$s = block_self;\n    }\n    return nil;\n  };\n\n  // Internal function to create a new module instance. This simply sets up\n  // the prototype hierarchy and method tables.\n  //\n  Opal.module_allocate = function(superclass) {\n    var mtor = function() {};\n    mtor.prototype = superclass.$$alloc.prototype;\n\n    var module_constructor = function() {};\n    module_constructor.prototype = new mtor();\n\n    var module = new module_constructor();\n    var module_prototype = {};\n\n    Opal.setup_module_or_class(module);\n\n    // initialize dependency tracking\n    module.$$included_in = [];\n\n    // Set the display name of the singleton prototype holder\n    module_constructor.displayName = \"#<Class:#<Module:\"+module.$$id+\">>\"\n\n    // @property $$proto This is the prototype on which methods will be defined\n    module.$$proto = module_prototype;\n\n    // @property constructor\n    //   keeps a ref to the constructor, but apparently the\n    //   constructor is already set on:\n    //\n    //      `var module = new constructor` is called.\n    //\n    //   Maybe there are some browsers not abiding (IE6?)\n    module.constructor = module_constructor;\n\n    // @property $$is_module Clearly mark this as a module\n    module.$$is_module = true;\n    module.$$class     = Module;\n\n    // @property $$super\n    //   the superclass, doesn't get changed by module inclusions\n    module.$$super = superclass;\n\n    // @property $$parent\n    //   direct parent class or module\n    //   starts with the superclass, after module inclusion is\n    //   the last included module\n    module.$$parent = superclass;\n\n    return module;\n  };\n\n  // Return the singleton class for the passed object.\n  //\n  // If the given object alredy has a singleton class, then it will be stored on\n  // the object as the `$$meta` property. If this exists, then it is simply\n  // returned back.\n  //\n  // Otherwise, a new singleton object for the class or object is created, set on\n  // the object at `$$meta` for future use, and then returned.\n  //\n  // @param object [Object] the ruby object\n  // @return [Class] the singleton class for object\n  Opal.get_singleton_class = function(object) {\n    if (object.$$meta) {\n      return object.$$meta;\n    }\n\n    if (object.$$is_class || object.$$is_module) {\n      return Opal.build_class_singleton_class(object);\n    }\n\n    return Opal.build_object_singleton_class(object);\n  };\n\n  // Build the singleton class for an existing class. Class object are built\n  // with their singleton class already in the prototype chain and inheriting\n  // from their superclass object (up to `Class` itself).\n  //\n  // NOTE: Actually in MRI a class' singleton class inherits from its\n  // superclass' singleton class which in turn inherits from Class.\n  //\n  // @param klass [Class]\n  // @return [Class]\n  Opal.build_class_singleton_class = function(object) {\n    var alloc, superclass, klass;\n\n    if (object.$$meta) {\n      return object.$$meta;\n    }\n\n    // The constructor and prototype of the singleton_class instances is the\n    // current class constructor and prototype.\n    alloc = object.constructor;\n\n    // The singleton_class superclass is the singleton_class of its superclass;\n    // but BasicObject has no superclass (its `$$super` is null), thus we\n    // fallback on `Class`.\n    superclass = object === BasicObject ? Class : Opal.build_class_singleton_class(object.$$super);\n\n    klass = Opal.setup_class_object(null, alloc, superclass.$$name, superclass.constructor);\n    klass.$$super  = superclass;\n    klass.$$parent = superclass;\n\n    klass.$$is_singleton = true;\n    klass.$$singleton_of = object;\n\n    return object.$$meta = klass;\n  };\n\n  // Build the singleton class for a Ruby (non class) Object.\n  //\n  // @param object [Object]\n  // @return [Class]\n  Opal.build_object_singleton_class = function(object) {\n    var superclass = object.$$class,\n        name = \"#<Class:#<\" + superclass.$$name + \":\" + superclass.$$id + \">>\";\n\n    var alloc = Opal.boot_class_alloc(name, function(){}, superclass)\n    var klass = Opal.setup_class_object(name, alloc, superclass.$$name, superclass.constructor);\n\n    klass.$$super  = superclass;\n    klass.$$parent = superclass;\n    klass.$$class  = superclass.$$class;\n    klass.$$proto  = object;\n\n    klass.$$is_singleton = true;\n    klass.$$singleton_of = object;\n\n    return object.$$meta = klass;\n  };\n\n  // Returns an object containing all pairs of names/values\n  // for all class variables defined in provided +module+\n  // and its ancestors.\n  //\n  // @param module [Module]\n  // @return [Object]\n  Opal.class_variables = function(module) {\n    var ancestors = Opal.ancestors(module),\n        i, length = ancestors.length,\n        result = {};\n\n    for (i = length - 1; i >= 0; i--) {\n      var ancestor = ancestors[i];\n\n      for (var cvar in ancestor.$$cvars) {\n        result[cvar] = ancestor.$$cvars[cvar];\n      }\n    }\n\n    return result;\n  }\n\n  // Sets class variable with specified +name+ to +value+\n  // in provided +module+\n  //\n  // @param module [Module]\n  // @param name [String]\n  // @param value [Object]\n  Opal.class_variable_set = function(module, name, value) {\n    var ancestors = Opal.ancestors(module),\n        i, length = ancestors.length;\n\n    for (i = length - 2; i >= 0; i--) {\n      var ancestor = ancestors[i];\n\n      if ($hasOwn.call(ancestor.$$cvars, name)) {\n        ancestor.$$cvars[name] = value;\n        return value;\n      }\n    }\n\n    module.$$cvars[name] = value;\n\n    return value;\n  }\n\n  // Bridges a single method.\n  //\n  // @param target [JS::Function] the constructor of the bridged class\n  // @param from [Module] the module/class we are importing the method from\n  // @param name [String] the method name in JS land (i.e. starting with $)\n  // @param body [JS::Function] the body of the method\n  Opal.bridge_method = function(target_constructor, from, name, body) {\n    var ancestors, i, ancestor, length;\n\n    ancestors = target_constructor.$$bridge.$ancestors();\n\n    // order important here, we have to check for method presence in\n    // ancestors from the bridged class to the last ancestor\n    for (i = 0, length = ancestors.length; i < length; i++) {\n      ancestor = ancestors[i];\n\n      if ($hasOwn.call(ancestor.$$proto, name) &&\n          ancestor.$$proto[name] &&\n          !ancestor.$$proto[name].$$donated &&\n          !ancestor.$$proto[name].$$stub &&\n          ancestor !== from) {\n        break;\n      }\n\n      if (ancestor === from) {\n        target_constructor.prototype[name] = body\n        break;\n      }\n    }\n  };\n\n  // Bridges from *donator* to a *target*.\n  //\n  // @param target [Module] the potentially associated with bridged classes module\n  // @param donator [Module] the module/class source of the methods that should be bridged\n  Opal.bridge_methods = function(target, donator) {\n    var i,\n        bridged = BridgedClasses[target.$__id__()],\n        donator_id = donator.$__id__();\n\n    if (bridged) {\n      BridgedClasses[donator_id] = bridged.slice();\n\n      for (i = bridged.length - 1; i >= 0; i--) {\n        Opal_bridge_methods_to_constructor(bridged[i], donator)\n      }\n    }\n  };\n\n  // Actually bridge methods to the bridged (shared) prototype.\n  function Opal_bridge_methods_to_constructor(target_constructor, donator) {\n    var i,\n        method,\n        methods = donator.$instance_methods();\n\n    for (i = methods.length - 1; i >= 0; i--) {\n      method = '$' + methods[i];\n      Opal.bridge_method(target_constructor, donator, method, donator.$$proto[method]);\n    }\n  }\n\n  // Associate the target as a bridged class for the current \"donator\"\n  function Opal_add_bridged_constructor(target_constructor, donator) {\n    var donator_id = donator.$__id__();\n\n    if (!BridgedClasses[donator_id]) {\n      BridgedClasses[donator_id] = [];\n    }\n    BridgedClasses[donator_id].push(target_constructor);\n  }\n\n  // Walks the dependency tree detecting the presence of the base among its\n  // own dependencies.\n  //\n  // @param [Integer] base_id The id of the base module (eg. the \"includer\")\n  // @param [Array<Module>] deps The array of dependencies (eg. the included module, included.$$deps)\n  // @param [String] prop The property that holds dependencies (eg. \"$$deps\")\n  // @param [JS::Object] seen A JS object holding the cache of already visited objects\n  // @return [Boolean] true if a cyclic dependency is present\n  Opal.has_cyclic_dep = function has_cyclic_dep(base_id, deps, prop, seen) {\n    var i, dep_id, dep;\n\n    for (i = deps.length - 1; i >= 0; i--) {\n      dep = deps[i];\n      dep_id = dep.$$id;\n\n      if (seen[dep_id]) {\n        continue;\n      }\n      seen[dep_id] = true;\n\n      if (dep_id === base_id) {\n        return true;\n      }\n\n      if (has_cyclic_dep(base_id, dep[prop], prop, seen)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // The actual inclusion of a module into a class.\n  //\n  // ## Class `$$parent` and `iclass`\n  //\n  // To handle `super` calls, every class has a `$$parent`. This parent is\n  // used to resolve the next class for a super call. A normal class would\n  // have this point to its superclass. However, if a class includes a module\n  // then this would need to take into account the module. The module would\n  // also have to then point its `$$parent` to the actual superclass. We\n  // cannot modify modules like this, because it might be included in more\n  // then one class. To fix this, we actually insert an `iclass` as the class'\n  // `$$parent` which can then point to the superclass. The `iclass` acts as\n  // a proxy to the actual module, so the `super` chain can then search it for\n  // the required method.\n  //\n  // @param module [Module] the module to include\n  // @param includer [Module] the target class to include module into\n  // @return [null]\n  Opal.append_features = function(module, includer) {\n    var iclass, donator, prototype, methods, id, i;\n\n    // check if this module is already included in the class\n    for (i = includer.$$inc.length - 1; i >= 0; i--) {\n      if (includer.$$inc[i] === module) {\n        return;\n      }\n    }\n\n    // Check that the base module is not also a dependency, classes can't be\n    // dependencies so we have a special case for them.\n    if (!includer.$$is_class && Opal.has_cyclic_dep(includer.$$id, [module], '$$inc', {})) {\n      throw Opal.ArgumentError.$new('cyclic include detected')\n    }\n\n    Opal.const_cache_version++;\n    includer.$$inc.push(module);\n    module.$$included_in.push(includer);\n    Opal.bridge_methods(includer, module);\n\n    // iclass\n    iclass = {\n      $$name:   module.$$name,\n      $$proto:  module.$$proto,\n      $$parent: includer.$$parent,\n      $$module: module,\n      $$iclass: true\n    };\n\n    includer.$$parent = iclass;\n\n    methods = module.$instance_methods();\n\n    for (i = methods.length - 1; i >= 0; i--) {\n      Opal.update_includer(module, includer, '$' + methods[i])\n    }\n  };\n\n  // Table that holds all methods that have been defined on all objects\n  // It is used for defining method stubs for new coming native classes\n  Opal.stubs = {};\n\n  // For performance, some core Ruby classes are toll-free bridged to their\n  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).\n  //\n  // This method is used to setup a native constructor (e.g. Array), to have\n  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is\n  // created using the native constructor so that its prototype is set as the\n  // target for th new class. Note: all bridged classes are set to inherit\n  // from Object.\n  //\n  // Example:\n  //\n  //    Opal.bridge(self, Function);\n  //\n  // @param klass       [Class] the Ruby class to bridge\n  // @param constructor [JS.Function] native JavaScript constructor to use\n  // @return [Class] returns the passed Ruby class\n  //\n  Opal.bridge = function(klass, constructor) {\n    if (constructor.$$bridge) {\n      throw Opal.ArgumentError.$new(\"already bridged\");\n    }\n\n    Opal.stub_subscribers.push(constructor.prototype);\n\n    // Populate constructor with previously stored stubs\n    for (var method_name in Opal.stubs) {\n      if (!(method_name in constructor.prototype)) {\n        constructor.prototype[method_name] = Opal.stub_for(method_name);\n      }\n    }\n\n    constructor.prototype.$$class = klass;\n    constructor.$$bridge          = klass;\n\n    var ancestors = klass.$ancestors();\n\n    // order important here, we have to bridge from the last ancestor to the\n    // bridged class\n    for (var i = ancestors.length - 1; i >= 0; i--) {\n      Opal_add_bridged_constructor(constructor, ancestors[i]);\n      Opal_bridge_methods_to_constructor(constructor, ancestors[i]);\n    }\n\n    for (var name in BasicObject_alloc.prototype) {\n      var method = BasicObject_alloc.prototype[method];\n\n      if (method && method.$$stub && !(name in constructor.prototype)) {\n        constructor.prototype[name] = method;\n      }\n    }\n\n    return klass;\n  };\n\n  // Update `jsid` method cache of all classes / modules including `module`.\n  Opal.update_includer = function(module, includer, jsid) {\n    var dest, current, body,\n        klass_includees, j, jj, current_owner_index, module_index;\n\n    body    = module.$$proto[jsid];\n    dest    = includer.$$proto;\n    current = dest[jsid];\n\n    if (dest.hasOwnProperty(jsid) && !current.$$donated && !current.$$stub) {\n      // target class has already defined the same method name - do nothing\n    }\n    else if (dest.hasOwnProperty(jsid) && !current.$$stub) {\n      // target class includes another module that has defined this method\n      klass_includees = includer.$$inc;\n\n      for (j = 0, jj = klass_includees.length; j < jj; j++) {\n        if (klass_includees[j] === current.$$donated) {\n          current_owner_index = j;\n        }\n        if (klass_includees[j] === module) {\n          module_index = j;\n        }\n      }\n\n      // only redefine method on class if the module was included AFTER\n      // the module which defined the current method body. Also make sure\n      // a module can overwrite a method it defined before\n      if (current_owner_index <= module_index) {\n        dest[jsid] = body;\n        dest[jsid].$$donated = module;\n      }\n    }\n    else {\n      // neither a class, or module included by class, has defined method\n      dest[jsid] = body;\n      dest[jsid].$$donated = module;\n    }\n\n    // if the includer is a module, recursively update all of its includres.\n    if (includer.$$included_in) {\n      Opal.update_includers(includer, jsid);\n    }\n  };\n\n  // Update `jsid` method cache of all classes / modules including `module`.\n  Opal.update_includers = function(module, jsid) {\n    var i, ii, includee, included_in;\n\n    included_in = module.$$included_in;\n\n    if (!included_in) {\n      return;\n    }\n\n    for (i = 0, ii = included_in.length; i < ii; i++) {\n      includee = included_in[i];\n      Opal.update_includer(module, includee, jsid);\n    }\n  };\n\n  // The Array of ancestors for a given module/class\n  Opal.ancestors = function(module_or_class) {\n    var parent = module_or_class,\n        result = [],\n        modules, i, ii, j, jj;\n\n    while (parent) {\n      result.push(parent);\n      for (i = parent.$$inc.length-1; i >= 0; i--) {\n        modules = Opal.ancestors(parent.$$inc[i]);\n\n        for(j = 0, jj = modules.length; j < jj; j++) {\n          result.push(modules[j]);\n        }\n      }\n\n      // only the actual singleton class gets included in its ancestry\n      // after that, traverse the normal class hierarchy\n      if (parent.$$is_singleton && parent.$$singleton_of.$$is_module) {\n        parent = parent.$$singleton_of.$$super;\n      }\n      else {\n        parent = parent.$$is_class ? parent.$$super : null;\n      }\n    }\n\n    return result;\n  };\n\n\n  // Method Missing\n  // --------------\n\n  // Methods stubs are used to facilitate method_missing in opal. A stub is a\n  // placeholder function which just calls `method_missing` on the receiver.\n  // If no method with the given name is actually defined on an object, then it\n  // is obvious to say that the stub will be called instead, and then in turn\n  // method_missing will be called.\n  //\n  // When a file in ruby gets compiled to javascript, it includes a call to\n  // this function which adds stubs for every method name in the compiled file.\n  // It should then be safe to assume that method_missing will work for any\n  // method call detected.\n  //\n  // Method stubs are added to the BasicObject prototype, which every other\n  // ruby object inherits, so all objects should handle method missing. A stub\n  // is only added if the given property name (method name) is not already\n  // defined.\n  //\n  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will\n  // have this prefix as well (to make this method more performant).\n  //\n  //    Opal.add_stubs([\"$foo\", \"$bar\", \"$baz=\"]);\n  //\n  // All stub functions will have a private `$$stub` property set to true so\n  // that other internal methods can detect if a method is just a stub or not.\n  // `Kernel#respond_to?` uses this property to detect a methods presence.\n  //\n  // @param stubs [Array] an array of method stubs to add\n  // @return [undefined]\n  Opal.add_stubs = function(stubs) {\n    var subscriber, subscribers = Opal.stub_subscribers,\n        i, ilength = stubs.length,\n        j, jlength = subscribers.length,\n        method_name, stub,\n        opal_stubs = Opal.stubs;\n\n    for (i = 0; i < ilength; i++) {\n      method_name = stubs[i];\n\n      if(!opal_stubs.hasOwnProperty(method_name)) {\n        // Save method name to populate other subscribers with this stub\n        opal_stubs[method_name] = true;\n        stub = Opal.stub_for(method_name);\n\n        for (j = 0; j < jlength; j++) {\n          subscriber = subscribers[j];\n\n          if (!(method_name in subscriber)) {\n            subscriber[method_name] = stub;\n          }\n        }\n      }\n    }\n  };\n\n  // Keep a list of prototypes that want method_missing stubs to be added.\n  //\n  // @default [Prototype List] BasicObject_alloc.prototype\n  //\n  Opal.stub_subscribers = [BasicObject_alloc.prototype];\n\n  // Add a method_missing stub function to the given prototype for the\n  // given name.\n  //\n  // @param prototype [Prototype] the target prototype\n  // @param stub [String] stub name to add (e.g. \"$foo\")\n  // @return [undefined]\n  Opal.add_stub_for = function(prototype, stub) {\n    var method_missing_stub = Opal.stub_for(stub);\n    prototype[stub] = method_missing_stub;\n  };\n\n  // Generate the method_missing stub for a given method name.\n  //\n  // @param method_name [String] The js-name of the method to stub (e.g. \"$foo\")\n  // @return [undefined]\n  Opal.stub_for = function(method_name) {\n    function method_missing_stub() {\n      // Copy any given block onto the method_missing dispatcher\n      this.$method_missing.$$p = method_missing_stub.$$p;\n\n      // Set block property to null ready for the next call (stop false-positives)\n      method_missing_stub.$$p = null;\n\n      // call method missing with correct args (remove '$' prefix on method name)\n      var args_ary = new Array(arguments.length);\n      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }\n\n      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));\n    }\n\n    method_missing_stub.$$stub = true;\n\n    return method_missing_stub;\n  };\n\n\n  // Methods\n  // -------\n\n  // Arity count error dispatcher for methods\n  //\n  // @param actual [Fixnum] number of arguments given to method\n  // @param expected [Fixnum] expected number of arguments\n  // @param object [Object] owner of the method +meth+\n  // @param meth [String] method name that got wrong number of arguments\n  // @raise [ArgumentError]\n  Opal.ac = function(actual, expected, object, meth) {\n    var inspect = '';\n    if (object.$$is_class || object.$$is_module) {\n      inspect += object.$$name + '.';\n    }\n    else {\n      inspect += object.$$class.$$name + '#';\n    }\n    inspect += meth;\n\n    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments(' + actual + ' for ' + expected + ')');\n  };\n\n  // Arity count error dispatcher for blocks\n  //\n  // @param actual [Fixnum] number of arguments given to block\n  // @param expected [Fixnum] expected number of arguments\n  // @param context [Object] context of the block definition\n  // @raise [ArgumentError]\n  Opal.block_ac = function(actual, expected, context) {\n    var inspect = \"`block in \" + context + \"'\";\n\n    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (' + actual + ' for ' + expected + ')');\n  };\n\n  // Super dispatcher\n  Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, defs) {\n    var dispatcher, super_method;\n\n    if (defs) {\n      if (obj.$$is_class || obj.$$is_module) {\n        dispatcher = defs.$$super;\n      }\n      else {\n        dispatcher = obj.$$class.$$proto;\n      }\n    }\n    else {\n      dispatcher = Opal.find_obj_super_dispatcher(obj, mid, current_func);\n    }\n\n    super_method = dispatcher['$' + mid];\n\n    if (!defcheck && super_method.$$stub && Opal.Kernel.$method_missing === obj.$method_missing) {\n      // method_missing hasn't been explicitly defined\n      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+\"' for \"+obj, mid);\n    }\n\n    return super_method;\n  };\n\n  // Iter dispatcher for super in a block\n  Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {\n    var call_jsid = jsid;\n\n    if (!current_func) {\n      throw Opal.RuntimeError.$new(\"super called outside of method\");\n    }\n\n    if (implicit && current_func.$$define_meth) {\n      throw Opal.RuntimeError.$new(\"implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly\");\n    }\n\n    if (current_func.$$def) {\n      call_jsid = current_func.$$jsid;\n    }\n\n    return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);\n  };\n\n  Opal.find_obj_super_dispatcher = function(obj, mid, current_func) {\n    var klass = obj.$$meta || obj.$$class;\n\n    // first we need to find the class/module current_func is located on\n    klass = Opal.find_owning_class(klass, current_func);\n\n    if (!klass) {\n      throw new Error(\"could not find current class for super()\");\n    }\n\n    return Opal.find_super_func(klass, '$' + mid, current_func);\n  };\n\n  Opal.find_owning_class = function(klass, current_func) {\n    var owner = current_func.$$owner;\n\n    while (klass) {\n      // repeating for readability\n\n      if (klass.$$iclass && klass.$$module === current_func.$$donated) {\n        // this klass was the last one the module donated to\n        // case is also hit with multiple module includes\n        break;\n      }\n      else if (klass.$$iclass && klass.$$module === owner) {\n        // module has donated to other classes but klass isn't one of those\n        break;\n      }\n      else if (owner.$$is_singleton && klass === owner.$$singleton_of.$$class) {\n        // cases like stdlib `Singleton::included` that use a singleton of a singleton\n        break;\n      }\n      else if (klass === owner) {\n        // no modules, pure class inheritance\n        break;\n      }\n\n      klass = klass.$$parent;\n    }\n\n    return klass;\n  };\n\n  Opal.find_super_func = function(owning_klass, jsid, current_func) {\n    var klass = owning_klass.$$parent;\n\n    // now we can find the super\n    while (klass) {\n      var working = klass.$$proto[jsid];\n\n      if (working && working !== current_func) {\n        // ok\n        break;\n      }\n\n      klass = klass.$$parent;\n    }\n\n    return klass.$$proto;\n  };\n\n  // Used to return as an expression. Sometimes, we can't simply return from\n  // a javascript function as if we were a method, as the return is used as\n  // an expression, or even inside a block which must \"return\" to the outer\n  // method. This helper simply throws an error which is then caught by the\n  // method. This approach is expensive, so it is only used when absolutely\n  // needed.\n  //\n  Opal.ret = function(val) {\n    Opal.returner.$v = val;\n    throw Opal.returner;\n  };\n\n  // Used to break out of a block.\n  Opal.brk = function(val, breaker) {\n    breaker.$v = val;\n    throw breaker;\n  };\n\n  // Builds a new unique breaker, this is to avoid multiple nested breaks to get\n  // in the way of each other.\n  Opal.new_brk = function() {\n    return new Error('unexpected break');\n  };\n\n  // handles yield calls for 1 yielded arg\n  Opal.yield1 = function(block, arg) {\n    if (typeof(block) !== \"function\") {\n      throw Opal.LocalJumpError.$new(\"no block given\");\n    }\n\n    var has_mlhs = block.$$has_top_level_mlhs_arg,\n        has_trailing_comma = block.$$has_trailing_comma_in_args;\n\n    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {\n      arg = Opal.to_ary(arg);\n    }\n\n    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {\n      return block.apply(null, arg);\n    }\n    else {\n      return block(arg);\n    }\n  };\n\n  // handles yield for > 1 yielded arg\n  Opal.yieldX = function(block, args) {\n    if (typeof(block) !== \"function\") {\n      throw Opal.LocalJumpError.$new(\"no block given\");\n    }\n\n    if (block.length > 1 && args.length === 1) {\n      if (args[0].$$is_array) {\n        return block.apply(null, args[0]);\n      }\n    }\n\n    if (!args.$$is_array) {\n      var args_ary = new Array(args.length);\n      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }\n\n      return block.apply(null, args_ary);\n    }\n\n    return block.apply(null, args);\n  };\n\n  // Finds the corresponding exception match in candidates.  Each candidate can\n  // be a value, or an array of values.  Returns null if not found.\n  Opal.rescue = function(exception, candidates) {\n    for (var i = 0; i < candidates.length; i++) {\n      var candidate = candidates[i];\n\n      if (candidate.$$is_array) {\n        var result = Opal.rescue(exception, candidate);\n\n        if (result) {\n          return result;\n        }\n      }\n      else if (candidate === Opal.JS.Error) {\n        return candidate;\n      }\n      else if (candidate['$==='](exception)) {\n        return candidate;\n      }\n    }\n\n    return null;\n  };\n\n  Opal.is_a = function(object, klass) {\n    if (object.$$meta === klass || object.$$class === klass) {\n      return true;\n    }\n\n    if (object.$$is_number && klass.$$is_number_class) {\n      return true;\n    }\n\n    var i, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));\n\n    for (i = 0, length = ancestors.length; i < length; i++) {\n      if (ancestors[i] === klass) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  // Helpers for extracting kwsplats\n  // Used for: { **h }\n  Opal.to_hash = function(value) {\n    if (value.$$is_hash) {\n      return value;\n    }\n    else if (value['$respond_to?']('to_hash', true)) {\n      var hash = value.$to_hash();\n      if (hash.$$is_hash) {\n        return hash;\n      }\n      else {\n        throw Opal.TypeError.$new(\"Can't convert \" + value.$$class +\n          \" to Hash (\" + value.$$class + \"#to_hash gives \" + hash.$$class + \")\");\n      }\n    }\n    else {\n      throw Opal.TypeError.$new(\"no implicit conversion of \" + value.$$class + \" into Hash\");\n    }\n  };\n\n  // Helpers for implementing multiple assignment\n  // Our code for extracting the values and assigning them only works if the\n  // return value is a JS array.\n  // So if we get an Array subclass, extract the wrapped JS array from it\n\n  // Used for: a, b = something (no splat)\n  Opal.to_ary = function(value) {\n    if (value.$$is_array) {\n      return value;\n    }\n    else if (value['$respond_to?']('to_ary', true)) {\n      var ary = value.$to_ary();\n      if (ary === nil) {\n        return [value];\n      }\n      else if (ary.$$is_array) {\n        return ary;\n      }\n      else {\n        throw Opal.TypeError.$new(\"Can't convert \" + value.$$class +\n          \" to Array (\" + value.$$class + \"#to_ary gives \" + ary.$$class + \")\");\n      }\n    }\n    else {\n      return [value];\n    }\n  };\n\n  // Used for: a, b = *something (with splat)\n  Opal.to_a = function(value) {\n    if (value.$$is_array) {\n      // A splatted array must be copied\n      return value.slice();\n    }\n    else if (value['$respond_to?']('to_a', true)) {\n      var ary = value.$to_a();\n      if (ary === nil) {\n        return [value];\n      }\n      else if (ary.$$is_array) {\n        return ary;\n      }\n      else {\n        throw Opal.TypeError.$new(\"Can't convert \" + value.$$class +\n          \" to Array (\" + value.$$class + \"#to_a gives \" + ary.$$class + \")\");\n      }\n    }\n    else {\n      return [value];\n    }\n  };\n\n  // Used for extracting keyword arguments from arguments passed to\n  // JS function. If provided +arguments+ list doesn't have a Hash\n  // as a last item, returns a blank Hash.\n  //\n  // @param parameters [Array]\n  // @return [Hash]\n  //\n  Opal.extract_kwargs = function(parameters) {\n    var kwargs = parameters[parameters.length - 1];\n    if (kwargs != null && kwargs['$respond_to?']('to_hash', true)) {\n      Array.prototype.splice.call(parameters, parameters.length - 1, 1);\n      return kwargs.$to_hash();\n    }\n    else {\n      return Opal.hash2([], {});\n    }\n  }\n\n  // Used to get a list of rest keyword arguments. Method takes the given\n  // keyword args, i.e. the hash literal passed to the method containing all\n  // keyword arguemnts passed to method, as well as the used args which are\n  // the names of required and optional arguments defined. This method then\n  // just returns all key/value pairs which have not been used, in a new\n  // hash literal.\n  //\n  // @param given_args [Hash] all kwargs given to method\n  // @param used_args [Object<String: true>] all keys used as named kwargs\n  // @return [Hash]\n  //\n  Opal.kwrestargs = function(given_args, used_args) {\n    var keys      = [],\n        map       = {},\n        key       = null,\n        given_map = given_args.$$smap;\n\n    for (key in given_map) {\n      if (!used_args[key]) {\n        keys.push(key);\n        map[key] = given_map[key];\n      }\n    }\n\n    return Opal.hash2(keys, map);\n  };\n\n  // Calls passed method on a ruby object with arguments and block:\n  //\n  // Can take a method or a method name.\n  //\n  // 1. When method name gets passed it invokes it by its name\n  //    and calls 'method_missing' when object doesn't have this method.\n  //    Used internally by Opal to invoke method that takes a block or a splat.\n  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'\n  //    because it doesn't know the name of the actual method.\n  //    Used internally by Opal to invoke 'super'.\n  //\n  // @example\n  //   var my_array = [1, 2, 3, 4]\n  //   Opal.send(my_array, 'length')                    # => 4\n  //   Opal.send(my_array, my_array.$length)            # => 4\n  //\n  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]\n  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]\n  //\n  // @param recv [Object] ruby object\n  // @param method [Function, String] method body or name of the method\n  // @param args [Array] arguments that will be passed to the method call\n  // @param block [Function] ruby block\n  // @return [Object] returning value of the method call\n  Opal.send = function(recv, method, args, block) {\n    var body = (typeof(method) === 'string') ? recv['$'+method] : method;\n\n    if (body != null) {\n      body.$$p = block;\n      return body.apply(recv, args);\n    }\n\n    return recv.$method_missing.apply(recv, [method].concat(args));\n  }\n\n  // Used to define methods on an object. This is a helper method, used by the\n  // compiled source to define methods on special case objects when the compiler\n  // can not determine the destination object, or the object is a Module\n  // instance. This can get called by `Module#define_method` as well.\n  //\n  // ## Modules\n  //\n  // Any method defined on a module will come through this runtime helper.\n  // The method is added to the module body, and the owner of the method is\n  // set to be the module itself. This is used later when choosing which\n  // method should show on a class if more than 1 included modules define\n  // the same method. Finally, if the module is in `module_function` mode,\n  // then the method is also defined onto the module itself.\n  //\n  // ## Classes\n  //\n  // This helper will only be called for classes when a method is being\n  // defined indirectly; either through `Module#define_method`, or by a\n  // literal `def` method inside an `instance_eval` or `class_eval` body. In\n  // either case, the method is simply added to the class' prototype. A special\n  // exception exists for `BasicObject` and `Object`. These two classes are\n  // special because they are used in toll-free bridged classes. In each of\n  // these two cases, extra work is required to define the methods on toll-free\n  // bridged class' prototypes as well.\n  //\n  // ## Objects\n  //\n  // If a simple ruby object is the object, then the method is simply just\n  // defined on the object as a singleton method. This would be the case when\n  // a method is defined inside an `instance_eval` block.\n  //\n  // @param obj  [Object, Class] the actual obj to define method for\n  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')\n  // @param body [JS.Function] the literal JavaScript function used as method\n  // @return [null]\n  //\n  Opal.def = function(obj, jsid, body) {\n    // if instance_eval is invoked on a module/class, it sets inst_eval_mod\n    if (!obj.$$eval && (obj.$$is_class || obj.$$is_module)) {\n      Opal.defn(obj, jsid, body);\n    }\n    else {\n      Opal.defs(obj, jsid, body);\n    }\n  };\n\n  // Define method on a module or class (see Opal.def).\n  Opal.defn = function(obj, jsid, body) {\n    obj.$$proto[jsid] = body;\n    // for super dispatcher, etc.\n    body.$$owner = obj;\n    if (body.displayName == null) body.displayName = jsid.substr(1);\n\n    // is it a module?\n    if (obj.$$is_module) {\n      Opal.update_includers(obj, jsid);\n\n      if (obj.$$module_function) {\n        Opal.defs(obj, jsid, body);\n      }\n    }\n\n    // is it a bridged class?\n    var bridged = obj.$__id__ && !obj.$__id__.$$stub && BridgedClasses[obj.$__id__()];\n    if (bridged) {\n      for (var i = bridged.length - 1; i >= 0; i--) {\n        Opal.bridge_method(bridged[i], obj, jsid, body);\n      }\n    }\n\n    // method_added/singleton_method_added hooks\n    var singleton_of = obj.$$singleton_of;\n    if (obj.$method_added && !obj.$method_added.$$stub && !singleton_of) {\n      obj.$method_added(jsid.substr(1));\n    }\n    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {\n      singleton_of.$singleton_method_added(jsid.substr(1));\n    }\n\n    return nil;\n  };\n\n  // Define a singleton method on the given object (see Opal.def).\n  Opal.defs = function(obj, jsid, body) {\n    Opal.defn(Opal.get_singleton_class(obj), jsid, body)\n  };\n\n  // Called from #remove_method.\n  Opal.rdef = function(obj, jsid) {\n    // TODO: remove from BridgedClasses as well\n\n    if (!$hasOwn.call(obj.$$proto, jsid)) {\n      throw Opal.NameError.$new(\"method '\" + jsid.substr(1) + \"' not defined in \" + obj.$name());\n    }\n\n    delete obj.$$proto[jsid];\n\n    if (obj.$$is_singleton) {\n      if (obj.$$proto.$singleton_method_removed && !obj.$$proto.$singleton_method_removed.$$stub) {\n        obj.$$proto.$singleton_method_removed(jsid.substr(1));\n      }\n    }\n    else {\n      if (obj.$method_removed && !obj.$method_removed.$$stub) {\n        obj.$method_removed(jsid.substr(1));\n      }\n    }\n  };\n\n  // Called from #undef_method.\n  Opal.udef = function(obj, jsid) {\n    if (!obj.$$proto[jsid] || obj.$$proto[jsid].$$stub) {\n      throw Opal.NameError.$new(\"method '\" + jsid.substr(1) + \"' not defined in \" + obj.$name());\n    }\n\n    Opal.add_stub_for(obj.$$proto, jsid);\n\n    if (obj.$$is_singleton) {\n      if (obj.$$proto.$singleton_method_undefined && !obj.$$proto.$singleton_method_undefined.$$stub) {\n        obj.$$proto.$singleton_method_undefined(jsid.substr(1));\n      }\n    }\n    else {\n      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {\n        obj.$method_undefined(jsid.substr(1));\n      }\n    }\n  };\n\n  Opal.alias = function(obj, name, old) {\n    var id     = '$' + name,\n        old_id = '$' + old,\n        body   = obj.$$proto['$' + old],\n        alias;\n\n    // When running inside #instance_eval the alias refers to class methods.\n    if (obj.$$eval) {\n      return Opal.alias(Opal.get_singleton_class(obj), name, old);\n    }\n\n    if (typeof(body) !== \"function\" || body.$$stub) {\n      var ancestor = obj.$$super;\n\n      while (typeof(body) !== \"function\" && ancestor) {\n        body     = ancestor[old_id];\n        ancestor = ancestor.$$super;\n      }\n\n      if (typeof(body) !== \"function\" || body.$$stub) {\n        throw Opal.NameError.$new(\"undefined method `\" + old + \"' for class `\" + obj.$name() + \"'\")\n      }\n    }\n\n    // If the body is itself an alias use the original body\n    // to keep the max depth at 1.\n    if (body.$$alias_of) body = body.$$alias_of;\n\n    // We need a wrapper because otherwise method $$owner and other properties\n    // would be ovrewritten on the original body.\n    alias = function() {\n      var block = alias.$$p, args, i, ii;\n\n      args = new Array(arguments.length);\n      for(i = 0, ii = arguments.length; i < ii; i++) {\n        args[i] = arguments[i];\n      }\n\n      if (block != null) { alias.$$p = null }\n\n      return Opal.send(this, body, args, block);\n    };\n\n    // Try to make the browser pick the right name\n    alias.displayName       = name;\n    alias.length            = body.length;\n    alias.$$arity           = body.$$arity;\n    alias.$$parameters      = body.$$parameters;\n    alias.$$source_location = body.$$source_location;\n    alias.$$alias_of        = body;\n    alias.$$alias_name      = name;\n\n    Opal.defn(obj, id, alias);\n\n    return obj;\n  };\n\n  Opal.alias_native = function(obj, name, native_name) {\n    var id   = '$' + name,\n        body = obj.$$proto[native_name];\n\n    if (typeof(body) !== \"function\" || body.$$stub) {\n      throw Opal.NameError.$new(\"undefined native method `\" + native_name + \"' for class `\" + obj.$name() + \"'\")\n    }\n\n    Opal.defn(obj, id, body);\n\n    return obj;\n  };\n\n\n  // Hashes\n  // ------\n\n  Opal.hash_init = function(hash) {\n    hash.$$smap = Object.create(null);\n    hash.$$map  = Object.create(null);\n    hash.$$keys = [];\n  };\n\n  Opal.hash_clone = function(from_hash, to_hash) {\n    to_hash.$$none = from_hash.$$none;\n    to_hash.$$proc = from_hash.$$proc;\n\n    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {\n      key = keys[i];\n\n      if (key.$$is_string) {\n        value = smap[key];\n      } else {\n        value = key.value;\n        key = key.key;\n      }\n\n      Opal.hash_put(to_hash, key, value);\n    }\n  };\n\n  Opal.hash_put = function(hash, key, value) {\n    if (key.$$is_string) {\n      if (!$hasOwn.call(hash.$$smap, key)) {\n        hash.$$keys.push(key);\n      }\n      hash.$$smap[key] = value;\n      return;\n    }\n\n    var key_hash, bucket, last_bucket;\n    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();\n\n    if (!$hasOwn.call(hash.$$map, key_hash)) {\n      bucket = {key: key, key_hash: key_hash, value: value};\n      hash.$$keys.push(bucket);\n      hash.$$map[key_hash] = bucket;\n      return;\n    }\n\n    bucket = hash.$$map[key_hash];\n\n    while (bucket) {\n      if (key === bucket.key || key['$eql?'](bucket.key)) {\n        last_bucket = undefined;\n        bucket.value = value;\n        break;\n      }\n      last_bucket = bucket;\n      bucket = bucket.next;\n    }\n\n    if (last_bucket) {\n      bucket = {key: key, key_hash: key_hash, value: value};\n      hash.$$keys.push(bucket);\n      last_bucket.next = bucket;\n    }\n  };\n\n  Opal.hash_get = function(hash, key) {\n    if (key.$$is_string) {\n      if ($hasOwn.call(hash.$$smap, key)) {\n        return hash.$$smap[key];\n      }\n      return;\n    }\n\n    var key_hash, bucket;\n    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();\n\n    if ($hasOwn.call(hash.$$map, key_hash)) {\n      bucket = hash.$$map[key_hash];\n\n      while (bucket) {\n        if (key === bucket.key || key['$eql?'](bucket.key)) {\n          return bucket.value;\n        }\n        bucket = bucket.next;\n      }\n    }\n  };\n\n  Opal.hash_delete = function(hash, key) {\n    var i, keys = hash.$$keys, length = keys.length, value;\n\n    if (key.$$is_string) {\n      if (!$hasOwn.call(hash.$$smap, key)) {\n        return;\n      }\n\n      for (i = 0; i < length; i++) {\n        if (keys[i] === key) {\n          keys.splice(i, 1);\n          break;\n        }\n      }\n\n      value = hash.$$smap[key];\n      delete hash.$$smap[key];\n      return value;\n    }\n\n    var key_hash = key.$hash();\n\n    if (!$hasOwn.call(hash.$$map, key_hash)) {\n      return;\n    }\n\n    var bucket = hash.$$map[key_hash], last_bucket;\n\n    while (bucket) {\n      if (key === bucket.key || key['$eql?'](bucket.key)) {\n        value = bucket.value;\n\n        for (i = 0; i < length; i++) {\n          if (keys[i] === bucket) {\n            keys.splice(i, 1);\n            break;\n          }\n        }\n\n        if (last_bucket && bucket.next) {\n          last_bucket.next = bucket.next;\n        }\n        else if (last_bucket) {\n          delete last_bucket.next;\n        }\n        else if (bucket.next) {\n          hash.$$map[key_hash] = bucket.next;\n        }\n        else {\n          delete hash.$$map[key_hash];\n        }\n\n        return value;\n      }\n      last_bucket = bucket;\n      bucket = bucket.next;\n    }\n  };\n\n  Opal.hash_rehash = function(hash) {\n    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {\n\n      if (hash.$$keys[i].$$is_string) {\n        continue;\n      }\n\n      key_hash = hash.$$keys[i].key.$hash();\n\n      if (key_hash === hash.$$keys[i].key_hash) {\n        continue;\n      }\n\n      bucket = hash.$$map[hash.$$keys[i].key_hash];\n      last_bucket = undefined;\n\n      while (bucket) {\n        if (bucket === hash.$$keys[i]) {\n          if (last_bucket && bucket.next) {\n            last_bucket.next = bucket.next;\n          }\n          else if (last_bucket) {\n            delete last_bucket.next;\n          }\n          else if (bucket.next) {\n            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;\n          }\n          else {\n            delete hash.$$map[hash.$$keys[i].key_hash];\n          }\n          break;\n        }\n        last_bucket = bucket;\n        bucket = bucket.next;\n      }\n\n      hash.$$keys[i].key_hash = key_hash;\n\n      if (!$hasOwn.call(hash.$$map, key_hash)) {\n        hash.$$map[key_hash] = hash.$$keys[i];\n        continue;\n      }\n\n      bucket = hash.$$map[key_hash];\n      last_bucket = undefined;\n\n      while (bucket) {\n        if (bucket === hash.$$keys[i]) {\n          last_bucket = undefined;\n          break;\n        }\n        last_bucket = bucket;\n        bucket = bucket.next;\n      }\n\n      if (last_bucket) {\n        last_bucket.next = hash.$$keys[i];\n      }\n    }\n  };\n\n  Opal.hash = function() {\n    var arguments_length = arguments.length, args, hash, i, length, key, value;\n\n    if (arguments_length === 1 && arguments[0].$$is_hash) {\n      return arguments[0];\n    }\n\n    hash = new Opal.Hash.$$alloc();\n    Opal.hash_init(hash);\n\n    if (arguments_length === 1 && arguments[0].$$is_array) {\n      args = arguments[0];\n      length = args.length;\n\n      for (i = 0; i < length; i++) {\n        if (args[i].length !== 2) {\n          throw Opal.ArgumentError.$new(\"value not of length 2: \" + args[i].$inspect());\n        }\n\n        key = args[i][0];\n        value = args[i][1];\n\n        Opal.hash_put(hash, key, value);\n      }\n\n      return hash;\n    }\n\n    if (arguments_length === 1) {\n      args = arguments[0];\n      for (key in args) {\n        if ($hasOwn.call(args, key)) {\n          value = args[key];\n\n          Opal.hash_put(hash, key, value);\n        }\n      }\n\n      return hash;\n    }\n\n    if (arguments_length % 2 !== 0) {\n      throw Opal.ArgumentError.$new(\"odd number of arguments for Hash\");\n    }\n\n    for (i = 0; i < arguments_length; i += 2) {\n      key = arguments[i];\n      value = arguments[i + 1];\n\n      Opal.hash_put(hash, key, value);\n    }\n\n    return hash;\n  };\n\n  // A faster Hash creator for hashes that just use symbols and\n  // strings as keys. The map and keys array can be constructed at\n  // compile time, so they are just added here by the constructor\n  // function.\n  //\n  Opal.hash2 = function(keys, smap) {\n    var hash = new Opal.Hash.$$alloc();\n\n    hash.$$smap = smap;\n    hash.$$map  = Object.create(null);\n    hash.$$keys = keys;\n\n    return hash;\n  };\n\n  // Create a new range instance with first and last values, and whether the\n  // range excludes the last value.\n  //\n  Opal.range = function(first, last, exc) {\n    var range         = new Opal.Range.$$alloc();\n        range.begin   = first;\n        range.end     = last;\n        range.excl    = exc;\n\n    return range;\n  };\n\n  // Get the ivar name for a given name.\n  // Mostly adds a trailing $ to reserved names.\n  //\n  Opal.ivar = function(name) {\n    if (\n        // properties\n        name === \"constructor\" ||\n        name === \"displayName\" ||\n        name === \"__count__\" ||\n        name === \"__noSuchMethod__\" ||\n        name === \"__parent__\" ||\n        name === \"__proto__\" ||\n\n        // methods\n        name === \"hasOwnProperty\" ||\n        name === \"valueOf\"\n       )\n    {\n      return name + \"$\";\n    }\n\n    return name;\n  };\n\n\n  // Regexps\n  // -------\n\n  // Escape Regexp special chars letting the resulting string be used to build\n  // a new Regexp.\n  //\n  Opal.escape_regexp = function(str) {\n    return str.replace(/([-[\\]\\/{}()*+?.^$\\\\| ])/g, '\\\\$1')\n              .replace(/[\\n]/g, '\\\\n')\n              .replace(/[\\r]/g, '\\\\r')\n              .replace(/[\\f]/g, '\\\\f')\n              .replace(/[\\t]/g, '\\\\t');\n  }\n\n\n  // Require system\n  // --------------\n\n  Opal.modules         = {};\n  Opal.loaded_features = ['corelib/runtime'];\n  Opal.current_dir     = '.'\n  Opal.require_table   = {'corelib/runtime': true};\n\n  Opal.normalize = function(path) {\n    var parts, part, new_parts = [], SEPARATOR = '/';\n\n    if (Opal.current_dir !== '.') {\n      path = Opal.current_dir.replace(/\\/*$/, '/') + path;\n    }\n\n    path = path.replace(/^\\.\\//, '');\n    path = path.replace(/\\.(rb|opal|js)$/, '');\n    parts = path.split(SEPARATOR);\n\n    for (var i = 0, ii = parts.length; i < ii; i++) {\n      part = parts[i];\n      if (part === '') continue;\n      (part === '..') ? new_parts.pop() : new_parts.push(part)\n    }\n\n    return new_parts.join(SEPARATOR);\n  };\n\n  Opal.loaded = function(paths) {\n    var i, l, path;\n\n    for (i = 0, l = paths.length; i < l; i++) {\n      path = Opal.normalize(paths[i]);\n\n      if (Opal.require_table[path]) {\n        return;\n      }\n\n      Opal.loaded_features.push(path);\n      Opal.require_table[path] = true;\n    }\n  };\n\n  Opal.load = function(path) {\n    path = Opal.normalize(path);\n\n    Opal.loaded([path]);\n\n    var module = Opal.modules[path];\n\n    if (module) {\n      module(Opal);\n    }\n    else {\n      var severity = Opal.config.missing_require_severity;\n      var message  = 'cannot load such file -- ' + path;\n\n      if (severity === \"error\") {\n        Opal.LoadError ? Opal.LoadError.$new(message) : function(){throw message}();\n      }\n      else if (severity === \"warning\") {\n        console.warn('WARNING: LoadError: ' + message);\n      }\n    }\n\n    return true;\n  };\n\n  Opal.require = function(path) {\n    path = Opal.normalize(path);\n\n    if (Opal.require_table[path]) {\n      return false;\n    }\n\n    return Opal.load(path);\n  };\n\n\n  // Initialization\n  // --------------\n\n  // Constructors for *instances* of core objects\n  Opal.boot_class_alloc('BasicObject', BasicObject_alloc);\n  Opal.boot_class_alloc('Object',      Object_alloc,       BasicObject_alloc);\n  Opal.boot_class_alloc('Module',      Module_alloc,       Object_alloc);\n  Opal.boot_class_alloc('Class',       Class_alloc,        Module_alloc);\n\n  // Constructors for *classes* of core objects\n  Opal.BasicObject = BasicObject = Opal.setup_class_object('BasicObject', BasicObject_alloc, 'Class',       Class_alloc);\n  Opal.Object      = _Object     = Opal.setup_class_object('Object',      Object_alloc,      'BasicObject', BasicObject.constructor);\n  Opal.Module      = Module      = Opal.setup_class_object('Module',      Module_alloc,      'Object',      _Object.constructor);\n  Opal.Class       = Class       = Opal.setup_class_object('Class',       Class_alloc,       'Module',      Module.constructor);\n\n  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic\n  BasicObject.$$const[\"BasicObject\"] = BasicObject;\n\n  // Assign basic constants\n  Opal.const_set(_Object, \"BasicObject\",  BasicObject);\n  Opal.const_set(_Object, \"Object\",       _Object);\n  Opal.const_set(_Object, \"Module\",       Module);\n  Opal.const_set(_Object, \"Class\",        Class);\n\n\n  // Fix booted classes to use their metaclass\n  BasicObject.$$class = Class;\n  _Object.$$class     = Class;\n  Module.$$class      = Class;\n  Class.$$class       = Class;\n\n  // Fix superclasses of booted classes\n  BasicObject.$$super = null;\n  _Object.$$super     = BasicObject;\n  Module.$$super      = _Object;\n  Class.$$super       = Module;\n\n  BasicObject.$$parent = null;\n  _Object.$$parent     = BasicObject;\n  Module.$$parent      = _Object;\n  Class.$$parent       = Module;\n\n  // Forward .toString() to #to_s\n  _Object.$$proto.toString = function() {\n    var to_s = this.$to_s();\n    if (to_s.$$is_string && typeof(to_s) === 'object') {\n      // a string created using new String('string')\n      return to_s.valueOf();\n    } else {\n      return to_s;\n    }\n  };\n\n  // Make Kernel#require immediately available as it's needed to require all the\n  // other corelib files.\n  _Object.$$proto.$require = Opal.require;\n\n  // Instantiate the top object\n  Opal.top = new _Object.$$alloc();\n\n  // Nil\n  Opal.klass(_Object, _Object, 'NilClass', NilClass_alloc);\n  nil = Opal.nil = new NilClass_alloc();\n  nil.$$id = nil_id;\n  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };\n  Opal.breaker  = new Error('unexpected break (old)');\n  Opal.returner = new Error('unexpected return');\n\n  TypeError.$$super = Error;\n}).call(this);\nOpal.loaded([\"corelib/runtime\"]);\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/helpers\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$new', '$class', '$===', '$respond_to?', '$raise', '$type_error', '$__send__', '$coerce_to', '$nil?', '$<=>', '$coerce_to!', '$!=', '$[]', '$upcase']);\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Opal_bridge_1, TMP_Opal_type_error_2, TMP_Opal_coerce_to_3, TMP_Opal_coerce_to$B_4, TMP_Opal_coerce_to$q_5, TMP_Opal_try_convert_6, TMP_Opal_compare_7, TMP_Opal_destructure_8, TMP_Opal_respond_to$q_9, TMP_Opal_inspect_obj_10, TMP_Opal_instance_variable_name$B_11, TMP_Opal_class_variable_name$B_12, TMP_Opal_const_name$B_13, TMP_Opal_pristine_14;\n\n    \n    Opal.defs(self, '$bridge', TMP_Opal_bridge_1 = function $$bridge(klass, constructor) {\n      var self = this;\n\n      return Opal.bridge(klass, constructor)\n    }, TMP_Opal_bridge_1.$$arity = 2);\n    Opal.defs(self, '$type_error', TMP_Opal_type_error_2 = function $$type_error(object, type, method, coerced) {\n      var $a, self = this;\n\n      if (method == null) {\n        method = nil;\n      }\n      if (coerced == null) {\n        coerced = nil;\n      }\n      if ($truthy(($truthy($a = method) ? coerced : $a))) {\n        return Opal.const_get_relative($nesting, 'TypeError').$new(\"\" + \"can't convert \" + (object.$class()) + \" into \" + (type) + \" (\" + (object.$class()) + \"#\" + (method) + \" gives \" + (coerced.$class()))\n        } else {\n        return Opal.const_get_relative($nesting, 'TypeError').$new(\"\" + \"no implicit conversion of \" + (object.$class()) + \" into \" + (type))\n      }\n    }, TMP_Opal_type_error_2.$$arity = -3);\n    Opal.defs(self, '$coerce_to', TMP_Opal_coerce_to_3 = function $$coerce_to(object, type, method) {\n      var self = this;\n\n      \n      if ($truthy(type['$==='](object))) {\n        return object};\n      if ($truthy(object['$respond_to?'](method))) {\n        } else {\n        self.$raise(self.$type_error(object, type))\n      };\n      return object.$__send__(method);\n    }, TMP_Opal_coerce_to_3.$$arity = 3);\n    Opal.defs(self, '$coerce_to!', TMP_Opal_coerce_to$B_4 = function(object, type, method) {\n      var self = this, coerced = nil;\n\n      \n      coerced = self.$coerce_to(object, type, method);\n      if ($truthy(type['$==='](coerced))) {\n        } else {\n        self.$raise(self.$type_error(object, type, method, coerced))\n      };\n      return coerced;\n    }, TMP_Opal_coerce_to$B_4.$$arity = 3);\n    Opal.defs(self, '$coerce_to?', TMP_Opal_coerce_to$q_5 = function(object, type, method) {\n      var self = this, coerced = nil;\n\n      \n      if ($truthy(object['$respond_to?'](method))) {\n        } else {\n        return nil\n      };\n      coerced = self.$coerce_to(object, type, method);\n      if ($truthy(coerced['$nil?']())) {\n        return nil};\n      if ($truthy(type['$==='](coerced))) {\n        } else {\n        self.$raise(self.$type_error(object, type, method, coerced))\n      };\n      return coerced;\n    }, TMP_Opal_coerce_to$q_5.$$arity = 3);\n    Opal.defs(self, '$try_convert', TMP_Opal_try_convert_6 = function $$try_convert(object, type, method) {\n      var self = this;\n\n      \n      if ($truthy(type['$==='](object))) {\n        return object};\n      if ($truthy(object['$respond_to?'](method))) {\n        return object.$__send__(method)\n        } else {\n        return nil\n      };\n    }, TMP_Opal_try_convert_6.$$arity = 3);\n    Opal.defs(self, '$compare', TMP_Opal_compare_7 = function $$compare(a, b) {\n      var self = this, compare = nil;\n\n      \n      compare = a['$<=>'](b);\n      if ($truthy(compare === nil)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (a.$class()) + \" with \" + (b.$class()) + \" failed\")};\n      return compare;\n    }, TMP_Opal_compare_7.$$arity = 2);\n    Opal.defs(self, '$destructure', TMP_Opal_destructure_8 = function $$destructure(args) {\n      var self = this;\n\n      \n      if (args.length == 1) {\n        return args[0];\n      }\n      else if (args.$$is_array) {\n        return args;\n      }\n      else {\n        var args_ary = new Array(args.length);\n        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }\n\n        return args_ary;\n      }\n    \n    }, TMP_Opal_destructure_8.$$arity = 1);\n    Opal.defs(self, '$respond_to?', TMP_Opal_respond_to$q_9 = function(obj, method) {\n      var self = this;\n\n      \n      \n      if (obj == null || !obj.$$class) {\n        return false;\n      }\n    ;\n      return obj['$respond_to?'](method);\n    }, TMP_Opal_respond_to$q_9.$$arity = 2);\n    Opal.defs(self, '$inspect_obj', TMP_Opal_inspect_obj_10 = function $$inspect_obj(obj) {\n      var self = this;\n\n      return Opal.inspect(obj)\n    }, TMP_Opal_inspect_obj_10.$$arity = 1);\n    Opal.defs(self, '$instance_variable_name!', TMP_Opal_instance_variable_name$B_11 = function(name) {\n      var self = this;\n\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](name, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"'\" + (name) + \"' is not allowed as an instance variable name\", name))\n      };\n      return name;\n    }, TMP_Opal_instance_variable_name$B_11.$$arity = 1);\n    Opal.defs(self, '$class_variable_name!', TMP_Opal_class_variable_name$B_12 = function(name) {\n      var self = this;\n\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](name, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"`\" + (name) + \"' is not allowed as a class variable name\", name))};\n      return name;\n    }, TMP_Opal_class_variable_name$B_12.$$arity = 1);\n    Opal.defs(self, '$const_name!', TMP_Opal_const_name$B_13 = function(const_name) {\n      var self = this;\n\n      \n      const_name = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](const_name, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      if ($truthy(const_name['$[]'](0)['$!='](const_name['$[]'](0).$upcase()))) {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError'), \"\" + \"wrong constant name \" + (const_name))};\n      return const_name;\n    }, TMP_Opal_const_name$B_13.$$arity = 1);\n    Opal.defs(self, '$pristine', TMP_Opal_pristine_14 = function $$pristine(owner_class, $a_rest) {\n      var self = this, method_names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      method_names = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        method_names[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      \n      var method_name, method;\n      for (var i = method_names.length - 1; i >= 0; i--) {\n        method_name = method_names[i];\n        method = owner_class.$$proto['$'+method_name];\n        if (method && !method.$$stub) {\n          method.$$pristine = true;\n        }\n      }\n    ;\n      return nil;\n    }, TMP_Opal_pristine_14.$$arity = -2);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/module\"] = function(Opal) {\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$===', '$raise', '$equal?', '$<', '$>', '$nil?', '$attr_reader', '$attr_writer', '$class_variable_name!', '$new', '$const_name!', '$=~', '$inject', '$split', '$const_get', '$==', '$!', '$start_with?', '$to_proc', '$lambda', '$bind', '$call', '$class', '$append_features', '$included', '$name', '$cover?', '$size', '$merge', '$compile', '$proc', '$+', '$to_s', '$__id__', '$constants', '$include?', '$copy_class_variables', '$copy_constants']);\n  return (function($base, $super, $parent_nesting) {\n    function $Module(){};\n    var self = $Module = $klass($base, $super, 'Module', $Module);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Module_allocate_1, TMP_Module_initialize_2, TMP_Module_$eq$eq$eq_3, TMP_Module_$lt_4, TMP_Module_$lt$eq_5, TMP_Module_$gt_6, TMP_Module_$gt$eq_7, TMP_Module_$lt$eq$gt_8, TMP_Module_alias_method_9, TMP_Module_alias_native_10, TMP_Module_ancestors_11, TMP_Module_append_features_12, TMP_Module_attr_accessor_13, TMP_Module_attr_reader_14, TMP_Module_attr_writer_15, TMP_Module_autoload_16, TMP_Module_class_variables_17, TMP_Module_class_variable_get_18, TMP_Module_class_variable_set_19, TMP_Module_class_variable_defined$q_20, TMP_Module_remove_class_variable_21, TMP_Module_constants_22, TMP_Module_constants_23, TMP_Module_nesting_24, TMP_Module_const_defined$q_25, TMP_Module_const_get_27, TMP_Module_const_missing_28, TMP_Module_const_set_29, TMP_Module_public_constant_30, TMP_Module_define_method_31, TMP_Module_remove_method_33, TMP_Module_singleton_class$q_34, TMP_Module_include_35, TMP_Module_included_modules_36, TMP_Module_include$q_37, TMP_Module_instance_method_38, TMP_Module_instance_methods_39, TMP_Module_included_40, TMP_Module_extended_41, TMP_Module_method_added_42, TMP_Module_method_removed_43, TMP_Module_method_undefined_44, TMP_Module_module_eval_45, TMP_Module_module_exec_47, TMP_Module_method_defined$q_48, TMP_Module_module_function_49, TMP_Module_name_50, TMP_Module_remove_const_51, TMP_Module_to_s_52, TMP_Module_undef_method_53, TMP_Module_instance_variables_54, TMP_Module_dup_55, TMP_Module_copy_class_variables_56, TMP_Module_copy_constants_57;\n\n    \n    Opal.defs(self, '$allocate', TMP_Module_allocate_1 = function $$allocate() {\n      var self = this;\n\n      \n      var module;\n\n      module = Opal.module_allocate(self);\n      return module;\n    \n    }, TMP_Module_allocate_1.$$arity = 0);\n    \n    Opal.defn(self, '$initialize', TMP_Module_initialize_2 = function $$initialize() {\n      var self = this, $iter = TMP_Module_initialize_2.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Module_initialize_2.$$p = null;\n      return Opal.module_initialize(self, block)\n    }, TMP_Module_initialize_2.$$arity = 0);\n    \n    Opal.defn(self, '$===', TMP_Module_$eq$eq$eq_3 = function(object) {\n      var self = this;\n\n      \n      if ($truthy(object == null)) {\n        return false};\n      return Opal.is_a(object, self);\n    }, TMP_Module_$eq$eq$eq_3.$$arity = 1);\n    \n    Opal.defn(self, '$<', TMP_Module_$lt_4 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Module')['$==='](other))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"compared with non class/module\")\n      };\n      \n      var working = self,\n          ancestors,\n          i, length;\n\n      if (working === other) {\n        return false;\n      }\n\n      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {\n        if (ancestors[i] === other) {\n          return true;\n        }\n      }\n\n      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {\n        if (ancestors[i] === self) {\n          return false;\n        }\n      }\n\n      return nil;\n    ;\n    }, TMP_Module_$lt_4.$$arity = 1);\n    \n    Opal.defn(self, '$<=', TMP_Module_$lt$eq_5 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_lt(self, other))\n    }, TMP_Module_$lt$eq_5.$$arity = 1);\n    \n    Opal.defn(self, '$>', TMP_Module_$gt_6 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Module')['$==='](other))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"compared with non class/module\")\n      };\n      return $rb_lt(other, self);\n    }, TMP_Module_$gt_6.$$arity = 1);\n    \n    Opal.defn(self, '$>=', TMP_Module_$gt$eq_7 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_gt(self, other))\n    }, TMP_Module_$gt$eq_7.$$arity = 1);\n    \n    Opal.defn(self, '$<=>', TMP_Module_$lt$eq$gt_8 = function(other) {\n      var self = this, lt = nil;\n\n      \n      \n      if (self === other) {\n        return 0;\n      }\n    ;\n      if ($truthy(Opal.const_get_relative($nesting, 'Module')['$==='](other))) {\n        } else {\n        return nil\n      };\n      lt = $rb_lt(self, other);\n      if ($truthy(lt['$nil?']())) {\n        return nil};\n      if ($truthy(lt)) {\n        return -1\n        } else {\n        return 1\n      };\n    }, TMP_Module_$lt$eq$gt_8.$$arity = 1);\n    \n    Opal.defn(self, '$alias_method', TMP_Module_alias_method_9 = function $$alias_method(newname, oldname) {\n      var self = this;\n\n      \n      Opal.alias(self, newname, oldname);\n      return self;\n    }, TMP_Module_alias_method_9.$$arity = 2);\n    \n    Opal.defn(self, '$alias_native', TMP_Module_alias_native_10 = function $$alias_native(mid, jsid) {\n      var self = this;\n\n      if (jsid == null) {\n        jsid = mid;\n      }\n      \n      Opal.alias_native(self, mid, jsid);\n      return self;\n    }, TMP_Module_alias_native_10.$$arity = -2);\n    \n    Opal.defn(self, '$ancestors', TMP_Module_ancestors_11 = function $$ancestors() {\n      var self = this;\n\n      return Opal.ancestors(self)\n    }, TMP_Module_ancestors_11.$$arity = 0);\n    \n    Opal.defn(self, '$append_features', TMP_Module_append_features_12 = function $$append_features(includer) {\n      var self = this;\n\n      \n      Opal.append_features(self, includer);\n      return self;\n    }, TMP_Module_append_features_12.$$arity = 1);\n    \n    Opal.defn(self, '$attr_accessor', TMP_Module_attr_accessor_13 = function $$attr_accessor($a_rest) {\n      var self = this, names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      $send(self, 'attr_reader', Opal.to_a(names));\n      return $send(self, 'attr_writer', Opal.to_a(names));\n    }, TMP_Module_attr_accessor_13.$$arity = -1);\n    Opal.alias(self, \"attr\", \"attr_accessor\");\n    \n    Opal.defn(self, '$attr_reader', TMP_Module_attr_reader_14 = function $$attr_reader($a_rest) {\n      var self = this, names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      var proto = self.$$proto;\n\n      for (var i = names.length - 1; i >= 0; i--) {\n        var name = names[i],\n            id   = '$' + name,\n            ivar = Opal.ivar(name);\n\n        // the closure here is needed because name will change at the next\n        // cycle, I wish we could use let.\n        var body = (function(ivar) {\n          return function() {\n            if (this[ivar] == null) {\n              return nil;\n            }\n            else {\n              return this[ivar];\n            }\n          };\n        })(ivar);\n\n        // initialize the instance variable as nil\n        proto[ivar] = nil;\n\n        body.$$parameters = [];\n        body.$$arity = 0;\n\n        if (self.$$is_singleton) {\n          proto.constructor.prototype[id] = body;\n        }\n        else {\n          Opal.defn(self, id, body);\n        }\n      }\n    ;\n      return nil;\n    }, TMP_Module_attr_reader_14.$$arity = -1);\n    \n    Opal.defn(self, '$attr_writer', TMP_Module_attr_writer_15 = function $$attr_writer($a_rest) {\n      var self = this, names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      var proto = self.$$proto;\n\n      for (var i = names.length - 1; i >= 0; i--) {\n        var name = names[i],\n            id   = '$' + name + '=',\n            ivar = Opal.ivar(name);\n\n        // the closure here is needed because name will change at the next\n        // cycle, I wish we could use let.\n        var body = (function(ivar){\n          return function(value) {\n            return this[ivar] = value;\n          }\n        })(ivar);\n\n        body.$$parameters = [['req']];\n        body.$$arity = 1;\n\n        // initialize the instance variable as nil\n        proto[ivar] = nil;\n\n        if (self.$$is_singleton) {\n          proto.constructor.prototype[id] = body;\n        }\n        else {\n          Opal.defn(self, id, body);\n        }\n      }\n    ;\n      return nil;\n    }, TMP_Module_attr_writer_15.$$arity = -1);\n    \n    Opal.defn(self, '$autoload', TMP_Module_autoload_16 = function $$autoload(const$, path) {\n      var self = this;\n\n      \n      if (self.$$autoload == null) self.$$autoload = {};\n      Opal.const_cache_version++;\n      self.$$autoload[const$] = path;\n      return nil;\n    \n    }, TMP_Module_autoload_16.$$arity = 2);\n    \n    Opal.defn(self, '$class_variables', TMP_Module_class_variables_17 = function $$class_variables() {\n      var self = this;\n\n      return Object.keys(Opal.class_variables(self))\n    }, TMP_Module_class_variables_17.$$arity = 0);\n    \n    Opal.defn(self, '$class_variable_get', TMP_Module_class_variable_get_18 = function $$class_variable_get(name) {\n      var self = this;\n\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$class_variable_name!'](name);\n      \n      var value = Opal.class_variables(self)[name];\n      if (value == null) {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"uninitialized class variable \" + (name) + \" in \" + (self), name))\n      }\n      return value;\n    ;\n    }, TMP_Module_class_variable_get_18.$$arity = 1);\n    \n    Opal.defn(self, '$class_variable_set', TMP_Module_class_variable_set_19 = function $$class_variable_set(name, value) {\n      var self = this;\n\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$class_variable_name!'](name);\n      return Opal.class_variable_set(self, name, value);\n    }, TMP_Module_class_variable_set_19.$$arity = 2);\n    \n    Opal.defn(self, '$class_variable_defined?', TMP_Module_class_variable_defined$q_20 = function(name) {\n      var self = this;\n\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$class_variable_name!'](name);\n      return Opal.class_variables(self).hasOwnProperty(name);\n    }, TMP_Module_class_variable_defined$q_20.$$arity = 1);\n    \n    Opal.defn(self, '$remove_class_variable', TMP_Module_remove_class_variable_21 = function $$remove_class_variable(name) {\n      var self = this;\n\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$class_variable_name!'](name);\n      \n      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {\n        var value = self.$$cvars[name];\n        delete self.$$cvars[name];\n        return value;\n      } else {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"cannot remove \" + (name) + \" for \" + (self)))\n      }\n    ;\n    }, TMP_Module_remove_class_variable_21.$$arity = 1);\n    \n    Opal.defn(self, '$constants', TMP_Module_constants_22 = function $$constants(inherit) {\n      var self = this;\n\n      if (inherit == null) {\n        inherit = true;\n      }\n      return Opal.constants(self, inherit)\n    }, TMP_Module_constants_22.$$arity = -1);\n    Opal.defs(self, '$constants', TMP_Module_constants_23 = function $$constants(inherit) {\n      var self = this;\n\n      \n      if (inherit == null) {\n        var nesting = (self.$$nesting || []).concat(Opal.Object),\n            constant, constants = {},\n            i, ii;\n\n        for(i = 0, ii = nesting.length; i < ii; i++) {\n          for (constant in nesting[i].$$const) {\n            constants[constant] = true;\n          }\n        }\n        return Object.keys(constants);\n      } else {\n        return Opal.constants(self, inherit)\n      }\n    \n    }, TMP_Module_constants_23.$$arity = -1);\n    Opal.defs(self, '$nesting', TMP_Module_nesting_24 = function $$nesting() {\n      var self = this;\n\n      return self.$$nesting || []\n    }, TMP_Module_nesting_24.$$arity = 0);\n    \n    Opal.defn(self, '$const_defined?', TMP_Module_const_defined$q_25 = function(name, inherit) {\n      var self = this;\n\n      if (inherit == null) {\n        inherit = true;\n      }\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$const_name!'](name);\n      if ($truthy(name['$=~'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"wrong constant name \" + (name), name))\n      };\n      \n      var module, modules = [self], module_constants, i, ii;\n\n      // Add up ancestors if inherit is true\n      if (inherit) {\n        modules = modules.concat(Opal.ancestors(self));\n\n        // Add Object's ancestors if it's a module – modules have no ancestors otherwise\n        if (self.$$is_module) {\n          modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));\n        }\n      }\n\n      for (i = 0, ii = modules.length; i < ii; i++) {\n        module = modules[i];\n        if (module.$$const[name] != null) {\n          return true;\n        }\n      }\n\n      return false;\n    ;\n    }, TMP_Module_const_defined$q_25.$$arity = -2);\n    \n    Opal.defn(self, '$const_get', TMP_Module_const_get_27 = function $$const_get(name, inherit) {\n      var TMP_26, self = this;\n\n      if (inherit == null) {\n        inherit = true;\n      }\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$const_name!'](name);\n      \n      if (name.indexOf('::') === 0 && name !== '::'){\n        name = name.slice(2);\n      }\n    ;\n      if ($truthy(name.indexOf('::') != -1 && name != '::')) {\n        return $send(name.$split(\"::\"), 'inject', [self], (TMP_26 = function(o, c){var self = TMP_26.$$s || this;\nif (o == null) o = nil;if (c == null) c = nil;\n        return o.$const_get(c)}, TMP_26.$$s = self, TMP_26.$$arity = 2, TMP_26))};\n      if ($truthy(name['$=~'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"wrong constant name \" + (name), name))\n      };\n      \n      if (inherit) {\n        return Opal.const_get_relative([self], name);\n      } else {\n        return Opal.const_get_local(self, name);\n      }\n    ;\n    }, TMP_Module_const_get_27.$$arity = -2);\n    \n    Opal.defn(self, '$const_missing', TMP_Module_const_missing_28 = function $$const_missing(name) {\n      var self = this, full_const_name = nil;\n\n      \n      \n      if (self.$$autoload) {\n        var file = self.$$autoload[name];\n\n        if (file) {\n          self.$require(file);\n\n          return self.$const_get(name);\n        }\n      }\n    ;\n      full_const_name = (function() {if (self['$=='](Opal.const_get_relative($nesting, 'Object'))) {\n        return name\n        } else {\n        return \"\" + (self) + \"::\" + (name)\n      }; return nil; })();\n      return self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"uninitialized constant \" + (full_const_name), name));\n    }, TMP_Module_const_missing_28.$$arity = 1);\n    \n    Opal.defn(self, '$const_set', TMP_Module_const_set_29 = function $$const_set(name, value) {\n      var $a, self = this;\n\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$const_name!'](name);\n      if ($truthy(($truthy($a = name['$=~'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'CONST_NAME_REGEXP'))['$!']()) ? $a : name['$start_with?'](\"::\")))) {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"wrong constant name \" + (name), name))};\n      Opal.const_set(self, name, value);\n      return value;\n    }, TMP_Module_const_set_29.$$arity = 2);\n    \n    Opal.defn(self, '$public_constant', TMP_Module_public_constant_30 = function $$public_constant(const_name) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_public_constant_30.$$arity = 1);\n    \n    Opal.defn(self, '$define_method', TMP_Module_define_method_31 = function $$define_method(name, method) {\n      var $a, TMP_32, self = this, $iter = TMP_Module_define_method_31.$$p, block = $iter || nil, $case = nil;\n\n      if ($iter) TMP_Module_define_method_31.$$p = null;\n      \n      if ($truthy(method === undefined && block === nil)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"tried to create a Proc object without a block\")};\n      block = ($truthy($a = block) ? $a : (function() {$case = method;\n      if (Opal.const_get_relative($nesting, 'Proc')['$===']($case)) {return method}\n      else if (Opal.const_get_relative($nesting, 'Method')['$===']($case)) {return method.$to_proc().$$unbound}\n      else if (Opal.const_get_relative($nesting, 'UnboundMethod')['$===']($case)) {return $send(self, 'lambda', [], (TMP_32 = function($b_rest){var self = TMP_32.$$s || this, args, bound = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        bound = method.$bind(self);\n        return $send(bound, 'call', Opal.to_a(args));}, TMP_32.$$s = self, TMP_32.$$arity = -1, TMP_32))}\n      else {return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"wrong argument type \" + (block.$class()) + \" (expected Proc/Method)\")}})());\n      \n      var id = '$' + name;\n\n      block.$$jsid        = name;\n      block.$$s           = null;\n      block.$$def         = block;\n      block.$$define_meth = true;\n\n      Opal.defn(self, id, block);\n\n      return name;\n    ;\n    }, TMP_Module_define_method_31.$$arity = -2);\n    \n    Opal.defn(self, '$remove_method', TMP_Module_remove_method_33 = function $$remove_method($a_rest) {\n      var self = this, names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = 0, length = names.length; i < length; i++) {\n        Opal.rdef(self, \"$\" + names[i]);\n      }\n    ;\n      return self;\n    }, TMP_Module_remove_method_33.$$arity = -1);\n    \n    Opal.defn(self, '$singleton_class?', TMP_Module_singleton_class$q_34 = function() {\n      var self = this;\n\n      return !!self.$$is_singleton\n    }, TMP_Module_singleton_class$q_34.$$arity = 0);\n    \n    Opal.defn(self, '$include', TMP_Module_include_35 = function $$include($a_rest) {\n      var self = this, mods;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      mods = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        mods[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = mods.length - 1; i >= 0; i--) {\n        var mod = mods[i];\n\n        if (!mod.$$is_module) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"wrong argument type \" + ((mod).$class()) + \" (expected Module)\");\n        }\n\n        (mod).$append_features(self);\n        (mod).$included(self);\n      }\n    ;\n      return self;\n    }, TMP_Module_include_35.$$arity = -1);\n    \n    Opal.defn(self, '$included_modules', TMP_Module_included_modules_36 = function $$included_modules() {\n      var self = this;\n\n      \n      var results;\n\n      var module_chain = function(klass) {\n        var included = [];\n\n        for (var i = 0, ii = klass.$$inc.length; i < ii; i++) {\n          var mod_or_class = klass.$$inc[i];\n          included.push(mod_or_class);\n          included = included.concat(module_chain(mod_or_class));\n        }\n\n        return included;\n      };\n\n      results = module_chain(self);\n\n      // need superclass's modules\n      if (self.$$is_class) {\n        for (var cls = self; cls; cls = cls.$$super) {\n          results = results.concat(module_chain(cls));\n        }\n      }\n\n      return results;\n    \n    }, TMP_Module_included_modules_36.$$arity = 0);\n    \n    Opal.defn(self, '$include?', TMP_Module_include$q_37 = function(mod) {\n      var self = this;\n\n      \n      if (!mod.$$is_module) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"wrong argument type \" + ((mod).$class()) + \" (expected Module)\");\n      }\n\n      var i, ii, mod2, ancestors = Opal.ancestors(self);\n\n      for (i = 0, ii = ancestors.length; i < ii; i++) {\n        mod2 = ancestors[i];\n        if (mod2 === mod && mod2 !== self) {\n          return true;\n        }\n      }\n\n      return false;\n    \n    }, TMP_Module_include$q_37.$$arity = 1);\n    \n    Opal.defn(self, '$instance_method', TMP_Module_instance_method_38 = function $$instance_method(name) {\n      var self = this;\n\n      \n      var meth = self.$$proto['$' + name];\n\n      if (!meth || meth.$$stub) {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"undefined method `\" + (name) + \"' for class `\" + (self.$name()) + \"'\", name));\n      }\n\n      return Opal.const_get_relative($nesting, 'UnboundMethod').$new(self, meth.$$owner || self, meth, name);\n    \n    }, TMP_Module_instance_method_38.$$arity = 1);\n    \n    Opal.defn(self, '$instance_methods', TMP_Module_instance_methods_39 = function $$instance_methods(include_super) {\n      var self = this;\n\n      if (include_super == null) {\n        include_super = true;\n      }\n      \n      var value,\n          methods = [],\n          proto   = self.$$proto;\n\n      for (var prop in proto) {\n        if (prop.charAt(0) !== '$' || prop.charAt(1) === '$') {\n          continue;\n        }\n\n        value = proto[prop];\n\n        if (typeof(value) !== \"function\") {\n          continue;\n        }\n\n        if (value.$$stub) {\n          continue;\n        }\n\n        if (!self.$$is_module) {\n          if (self !== Opal.BasicObject && value === Opal.BasicObject.$$proto[prop]) {\n            continue;\n          }\n\n          if (!include_super && !proto.hasOwnProperty(prop)) {\n            continue;\n          }\n\n          if (!include_super && value.$$donated) {\n            continue;\n          }\n        }\n\n        methods.push(prop.substr(1));\n      }\n\n      return methods;\n    \n    }, TMP_Module_instance_methods_39.$$arity = -1);\n    \n    Opal.defn(self, '$included', TMP_Module_included_40 = function $$included(mod) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_included_40.$$arity = 1);\n    \n    Opal.defn(self, '$extended', TMP_Module_extended_41 = function $$extended(mod) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_extended_41.$$arity = 1);\n    \n    Opal.defn(self, '$method_added', TMP_Module_method_added_42 = function $$method_added($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_method_added_42.$$arity = -1);\n    \n    Opal.defn(self, '$method_removed', TMP_Module_method_removed_43 = function $$method_removed($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_method_removed_43.$$arity = -1);\n    \n    Opal.defn(self, '$method_undefined', TMP_Module_method_undefined_44 = function $$method_undefined($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_method_undefined_44.$$arity = -1);\n    \n    Opal.defn(self, '$module_eval', TMP_Module_module_eval_45 = function $$module_eval($a_rest) {\n      var $b, TMP_46, self = this, args, $iter = TMP_Module_module_eval_45.$$p, block = $iter || nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Module_module_eval_45.$$p = null;\n      \n      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {\n        \n        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {\n          } else {\n          Opal.const_get_relative($nesting, 'Kernel').$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"wrong number of arguments (0 for 1..3)\")\n        };\n        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;\n        default_eval_options = $hash2([\"file\", \"eval\"], {\"file\": ($truthy($b = file) ? $b : \"(eval)\"), \"eval\": true});\n        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);\n        compiled = Opal.const_get_relative($nesting, 'Opal').$compile(string, compiling_options);\n        block = $send(Opal.const_get_relative($nesting, 'Kernel'), 'proc', [], (TMP_46 = function(){var self = TMP_46.$$s || this;\n\n        \n          return (function(self) {\n            return eval(compiled);\n          })(self)\n        }, TMP_46.$$s = self, TMP_46.$$arity = 0, TMP_46));\n      } else if ($truthy($rb_gt(args.$size(), 0))) {\n        Opal.const_get_relative($nesting, 'Kernel').$raise(Opal.const_get_relative($nesting, 'ArgumentError'), $rb_plus(\"\" + \"wrong number of arguments (\" + (args.$size()) + \" for 0)\", \"\\n\\n  NOTE:If you want to enable passing a String argument please add \\\"require 'opal-parser'\\\" to your script\\n\"))};\n      \n      var old = block.$$s,\n          result;\n\n      block.$$s = null;\n      result = block.apply(self, [self]);\n      block.$$s = old;\n\n      return result;\n    ;\n    }, TMP_Module_module_eval_45.$$arity = -1);\n    Opal.alias(self, \"class_eval\", \"module_eval\");\n    \n    Opal.defn(self, '$module_exec', TMP_Module_module_exec_47 = function $$module_exec($a_rest) {\n      var self = this, args, $iter = TMP_Module_module_exec_47.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Module_module_exec_47.$$p = null;\n      \n      if (block === nil) {\n        self.$raise(Opal.const_get_relative($nesting, 'LocalJumpError'), \"no block given\")\n      }\n\n      var block_self = block.$$s, result;\n\n      block.$$s = null;\n      result = block.apply(self, args);\n      block.$$s = block_self;\n\n      return result;\n    \n    }, TMP_Module_module_exec_47.$$arity = -1);\n    Opal.alias(self, \"class_exec\", \"module_exec\");\n    \n    Opal.defn(self, '$method_defined?', TMP_Module_method_defined$q_48 = function(method) {\n      var self = this;\n\n      \n      var body = self.$$proto['$' + method];\n      return (!!body) && !body.$$stub;\n    \n    }, TMP_Module_method_defined$q_48.$$arity = 1);\n    \n    Opal.defn(self, '$module_function', TMP_Module_module_function_49 = function $$module_function($a_rest) {\n      var self = this, methods;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      methods = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        methods[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if (methods.length === 0) {\n        self.$$module_function = true;\n      }\n      else {\n        for (var i = 0, length = methods.length; i < length; i++) {\n          var meth = methods[i],\n              id   = '$' + meth,\n              func = self.$$proto[id];\n\n          Opal.defs(self, id, func);\n        }\n      }\n\n      return self;\n    \n    }, TMP_Module_module_function_49.$$arity = -1);\n    \n    Opal.defn(self, '$name', TMP_Module_name_50 = function $$name() {\n      var self = this;\n\n      \n      if (self.$$full_name) {\n        return self.$$full_name;\n      }\n\n      var result = [], base = self;\n\n      while (base) {\n        // Give up if any of the ancestors is unnamed\n        if (base.$$name === nil || base.$$name == null) return nil;\n\n        result.unshift(base.$$name);\n\n        base = base.$$base_module;\n\n        if (base === Opal.Object) {\n          break;\n        }\n      }\n\n      if (result.length === 0) {\n        return nil;\n      }\n\n      return self.$$full_name = result.join('::');\n    \n    }, TMP_Module_name_50.$$arity = 0);\n    \n    Opal.defn(self, '$remove_const', TMP_Module_remove_const_51 = function $$remove_const(name) {\n      var self = this;\n\n      return Opal.const_remove(self, name)\n    }, TMP_Module_remove_const_51.$$arity = 1);\n    \n    Opal.defn(self, '$to_s', TMP_Module_to_s_52 = function $$to_s() {\n      var $a, self = this;\n\n      return ($truthy($a = Opal.Module.$name.call(self)) ? $a : \"\" + \"#<\" + (self.$$is_module ? 'Module' : 'Class') + \":0x\" + (self.$__id__().$to_s(16)) + \">\")\n    }, TMP_Module_to_s_52.$$arity = 0);\n    \n    Opal.defn(self, '$undef_method', TMP_Module_undef_method_53 = function $$undef_method($a_rest) {\n      var self = this, names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = 0, length = names.length; i < length; i++) {\n        Opal.udef(self, \"$\" + names[i]);\n      }\n    ;\n      return self;\n    }, TMP_Module_undef_method_53.$$arity = -1);\n    \n    Opal.defn(self, '$instance_variables', TMP_Module_instance_variables_54 = function $$instance_variables() {\n      var self = this, consts = nil;\n\n      \n      consts = (Opal.Module.$$nesting = $nesting, self.$constants());\n      \n      var result = [];\n\n      for (var name in self) {\n        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {\n          result.push('@' + name);\n        }\n      }\n\n      return result;\n    ;\n    }, TMP_Module_instance_variables_54.$$arity = 0);\n    \n    Opal.defn(self, '$dup', TMP_Module_dup_55 = function $$dup() {\n      var self = this, $iter = TMP_Module_dup_55.$$p, $yield = $iter || nil, copy = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Module_dup_55.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      copy = $send(self, Opal.find_super_dispatcher(self, 'dup', TMP_Module_dup_55, false), $zuper, $iter);\n      copy.$copy_class_variables(self);\n      copy.$copy_constants(self);\n      return copy;\n    }, TMP_Module_dup_55.$$arity = 0);\n    \n    Opal.defn(self, '$copy_class_variables', TMP_Module_copy_class_variables_56 = function $$copy_class_variables(other) {\n      var self = this;\n\n      \n      for (var name in other.$$cvars) {\n        self.$$cvars[name] = other.$$cvars[name];\n      }\n    \n    }, TMP_Module_copy_class_variables_56.$$arity = 1);\n    return (Opal.defn(self, '$copy_constants', TMP_Module_copy_constants_57 = function $$copy_constants(other) {\n      var self = this;\n\n      \n      var name, other_constants = other.$$const;\n\n      for (name in other_constants) {\n        Opal.const_set(self, name, other_constants[name]);\n      }\n    \n    }, TMP_Module_copy_constants_57.$$arity = 1), nil) && 'copy_constants';\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/class\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$initialize_copy', '$allocate', '$name', '$to_s']);\n  \n  self.$require(\"corelib/module\");\n  return (function($base, $super, $parent_nesting) {\n    function $Class(){};\n    var self = $Class = $klass($base, $super, 'Class', $Class);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Class_new_1, TMP_Class_allocate_2, TMP_Class_inherited_3, TMP_Class_initialize_dup_4, TMP_Class_new_5, TMP_Class_superclass_6, TMP_Class_to_s_7;\n\n    \n    Opal.defs(self, '$new', TMP_Class_new_1 = function(superclass) {\n      var self = this, $iter = TMP_Class_new_1.$$p, block = $iter || nil;\n\n      if (superclass == null) {\n        superclass = Opal.const_get_relative($nesting, 'Object');\n      }\n      if ($iter) TMP_Class_new_1.$$p = null;\n      \n      if (!superclass.$$is_class) {\n        throw Opal.TypeError.$new(\"superclass must be a Class\");\n      }\n\n      var alloc = Opal.boot_class_alloc(null, function(){}, superclass);\n      var klass = Opal.setup_class_object(null, alloc, superclass.$$name, superclass.constructor);\n\n      klass.$$super  = superclass;\n      klass.$$parent = superclass;\n\n      superclass.$inherited(klass);\n      Opal.module_initialize(klass, block);\n\n      return klass;\n    \n    }, TMP_Class_new_1.$$arity = -1);\n    \n    Opal.defn(self, '$allocate', TMP_Class_allocate_2 = function $$allocate() {\n      var self = this;\n\n      \n      var obj = new self.$$alloc();\n      obj.$$id = Opal.uid();\n      return obj;\n    \n    }, TMP_Class_allocate_2.$$arity = 0);\n    \n    Opal.defn(self, '$inherited', TMP_Class_inherited_3 = function $$inherited(cls) {\n      var self = this;\n\n      return nil\n    }, TMP_Class_inherited_3.$$arity = 1);\n    \n    Opal.defn(self, '$initialize_dup', TMP_Class_initialize_dup_4 = function $$initialize_dup(original) {\n      var self = this;\n\n      \n      self.$initialize_copy(original);\n      \n      self.$$name = null;\n      self.$$full_name = null;\n    ;\n    }, TMP_Class_initialize_dup_4.$$arity = 1);\n    \n    Opal.defn(self, '$new', TMP_Class_new_5 = function($a_rest) {\n      var self = this, args, $iter = TMP_Class_new_5.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Class_new_5.$$p = null;\n      \n      var object = self.$allocate();\n      Opal.send(object, object.$initialize, args, block);\n      return object;\n    \n    }, TMP_Class_new_5.$$arity = -1);\n    \n    Opal.defn(self, '$superclass', TMP_Class_superclass_6 = function $$superclass() {\n      var self = this;\n\n      return self.$$super || nil\n    }, TMP_Class_superclass_6.$$arity = 0);\n    return (Opal.defn(self, '$to_s', TMP_Class_to_s_7 = function $$to_s() {\n      var self = this, $iter = TMP_Class_to_s_7.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_Class_to_s_7.$$p = null;\n      \n      var singleton_of = self.$$singleton_of;\n\n      if (singleton_of && (singleton_of.$$is_class || singleton_of.$$is_module)) {\n        return \"\" + \"#<Class:\" + ((singleton_of).$name()) + \">\";\n      }\n      else if (singleton_of) {\n        // a singleton class created from an object\n        return \"\" + \"#<Class:#<\" + ((singleton_of.$$class).$name()) + \":0x\" + ((Opal.id(singleton_of)).$to_s(16)) + \">>\";\n      }\n      return $send(self, Opal.find_super_dispatcher(self, 'to_s', TMP_Class_to_s_7, false), [], null);\n    \n    }, TMP_Class_to_s_7.$$arity = 0), nil) && 'to_s';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/basic_object\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$==', '$!', '$nil?', '$cover?', '$size', '$raise', '$merge', '$compile', '$proc', '$>', '$new', '$inspect']);\n  return (function($base, $super, $parent_nesting) {\n    function $BasicObject(){};\n    var self = $BasicObject = $klass($base, $super, 'BasicObject', $BasicObject);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BasicObject_initialize_1, TMP_BasicObject_$eq$eq_2, TMP_BasicObject_eql$q_3, TMP_BasicObject___id___4, TMP_BasicObject___send___5, TMP_BasicObject_$B_6, TMP_BasicObject_$B$eq_7, TMP_BasicObject_instance_eval_8, TMP_BasicObject_instance_exec_10, TMP_BasicObject_singleton_method_added_11, TMP_BasicObject_singleton_method_removed_12, TMP_BasicObject_singleton_method_undefined_13, TMP_BasicObject_method_missing_14;\n\n    \n    \n    Opal.defn(self, '$initialize', TMP_BasicObject_initialize_1 = function $$initialize($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_BasicObject_initialize_1.$$arity = -1);\n    \n    Opal.defn(self, '$==', TMP_BasicObject_$eq$eq_2 = function(other) {\n      var self = this;\n\n      return self === other\n    }, TMP_BasicObject_$eq$eq_2.$$arity = 1);\n    \n    Opal.defn(self, '$eql?', TMP_BasicObject_eql$q_3 = function(other) {\n      var self = this;\n\n      return self['$=='](other)\n    }, TMP_BasicObject_eql$q_3.$$arity = 1);\n    Opal.alias(self, \"equal?\", \"==\");\n    \n    Opal.defn(self, '$__id__', TMP_BasicObject___id___4 = function $$__id__() {\n      var self = this;\n\n      return self.$$id || (self.$$id = Opal.uid())\n    }, TMP_BasicObject___id___4.$$arity = 0);\n    \n    Opal.defn(self, '$__send__', TMP_BasicObject___send___5 = function $$__send__(symbol, $a_rest) {\n      var self = this, args, $iter = TMP_BasicObject___send___5.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_BasicObject___send___5.$$p = null;\n      \n      var func = self['$' + symbol]\n\n      if (func) {\n        if (block !== nil) {\n          func.$$p = block;\n        }\n\n        return func.apply(self, args);\n      }\n\n      if (block !== nil) {\n        self.$method_missing.$$p = block;\n      }\n\n      return self.$method_missing.apply(self, [symbol].concat(args));\n    \n    }, TMP_BasicObject___send___5.$$arity = -2);\n    \n    Opal.defn(self, '$!', TMP_BasicObject_$B_6 = function() {\n      var self = this;\n\n      return false\n    }, TMP_BasicObject_$B_6.$$arity = 0);\n    \n    Opal.defn(self, '$!=', TMP_BasicObject_$B$eq_7 = function(other) {\n      var self = this;\n\n      return self['$=='](other)['$!']()\n    }, TMP_BasicObject_$B$eq_7.$$arity = 1);\n    \n    Opal.defn(self, '$instance_eval', TMP_BasicObject_instance_eval_8 = function $$instance_eval($a_rest) {\n      var $b, TMP_9, self = this, args, $iter = TMP_BasicObject_instance_eval_8.$$p, block = $iter || nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_BasicObject_instance_eval_8.$$p = null;\n      \n      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {\n        \n        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {\n          } else {\n          Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_qualified('::', 'ArgumentError'), \"wrong number of arguments (0 for 1..3)\")\n        };\n        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;\n        default_eval_options = $hash2([\"file\", \"eval\"], {\"file\": ($truthy($b = file) ? $b : \"(eval)\"), \"eval\": true});\n        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);\n        compiled = Opal.const_get_qualified('::', 'Opal').$compile(string, compiling_options);\n        block = $send(Opal.const_get_qualified('::', 'Kernel'), 'proc', [], (TMP_9 = function(){var self = TMP_9.$$s || this;\n\n        \n          return (function(self) {\n            return eval(compiled);\n          })(self)\n        }, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9));\n      } else if ($truthy($rb_gt(args.$size(), 0))) {\n        Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_qualified('::', 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (args.$size()) + \" for 0)\")};\n      \n      var old = block.$$s,\n          result;\n\n      block.$$s = null;\n\n      // Need to pass $$eval so that method definitions know if this is\n      // being done on a class/module. Cannot be compiler driven since\n      // send(:instance_eval) needs to work.\n      if (self.$$is_class || self.$$is_module) {\n        self.$$eval = true;\n        try {\n          result = block.call(self, self);\n        }\n        finally {\n          self.$$eval = false;\n        }\n      }\n      else {\n        result = block.call(self, self);\n      }\n\n      block.$$s = old;\n\n      return result;\n    ;\n    }, TMP_BasicObject_instance_eval_8.$$arity = -1);\n    \n    Opal.defn(self, '$instance_exec', TMP_BasicObject_instance_exec_10 = function $$instance_exec($a_rest) {\n      var self = this, args, $iter = TMP_BasicObject_instance_exec_10.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_BasicObject_instance_exec_10.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_qualified('::', 'ArgumentError'), \"no block given\")\n      };\n      \n      var block_self = block.$$s,\n          result;\n\n      block.$$s = null;\n\n      if (self.$$is_class || self.$$is_module) {\n        self.$$eval = true;\n        try {\n          result = block.apply(self, args);\n        }\n        finally {\n          self.$$eval = false;\n        }\n      }\n      else {\n        result = block.apply(self, args);\n      }\n\n      block.$$s = block_self;\n\n      return result;\n    ;\n    }, TMP_BasicObject_instance_exec_10.$$arity = -1);\n    \n    Opal.defn(self, '$singleton_method_added', TMP_BasicObject_singleton_method_added_11 = function $$singleton_method_added($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_BasicObject_singleton_method_added_11.$$arity = -1);\n    \n    Opal.defn(self, '$singleton_method_removed', TMP_BasicObject_singleton_method_removed_12 = function $$singleton_method_removed($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_BasicObject_singleton_method_removed_12.$$arity = -1);\n    \n    Opal.defn(self, '$singleton_method_undefined', TMP_BasicObject_singleton_method_undefined_13 = function $$singleton_method_undefined($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_BasicObject_singleton_method_undefined_13.$$arity = -1);\n    return (Opal.defn(self, '$method_missing', TMP_BasicObject_method_missing_14 = function $$method_missing(symbol, $a_rest) {\n      var self = this, args, $iter = TMP_BasicObject_method_missing_14.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_BasicObject_method_missing_14.$$p = null;\n      return Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_qualified('::', 'NoMethodError').$new((function() {if ($truthy(self.$inspect && !self.$inspect.$$stub)) {\n        return \"\" + \"undefined method `\" + (symbol) + \"' for \" + (self.$inspect()) + \":\" + (self.$$class)\n        } else {\n        return \"\" + \"undefined method `\" + (symbol) + \"' for \" + (self.$$class)\n      }; return nil; })(), symbol))\n    }, TMP_BasicObject_method_missing_14.$$arity = -2), nil) && 'method_missing';\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/kernel\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $klass = Opal.klass;\n\n  Opal.add_stubs(['$raise', '$new', '$inspect', '$!', '$=~', '$==', '$object_id', '$class', '$coerce_to?', '$<<', '$allocate', '$copy_instance_variables', '$copy_singleton_methods', '$initialize_clone', '$initialize_copy', '$define_method', '$singleton_class', '$to_proc', '$initialize_dup', '$for', '$>', '$size', '$pop', '$call', '$append_features', '$extended', '$length', '$respond_to?', '$[]', '$nil?', '$to_a', '$to_int', '$fetch', '$Integer', '$Float', '$to_ary', '$to_str', '$coerce_to', '$to_s', '$__id__', '$instance_variable_name!', '$coerce_to!', '$===', '$enum_for', '$result', '$print', '$format', '$puts', '$each', '$<=', '$empty?', '$exception', '$kind_of?', '$rand', '$respond_to_missing?', '$try_convert!', '$expand_path', '$join', '$start_with?', '$srand', '$new_seed', '$sym', '$arg', '$open', '$include']);\n  \n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_method_missing_1, TMP_Kernel_$eq$_2, TMP_Kernel_$B$_3, TMP_Kernel_$eq$eq$eq_4, TMP_Kernel_$lt$eq$gt_5, TMP_Kernel_method_6, TMP_Kernel_methods_7, TMP_Kernel_Array_8, TMP_Kernel_at_exit_9, TMP_Kernel_caller_10, TMP_Kernel_class_11, TMP_Kernel_copy_instance_variables_12, TMP_Kernel_copy_singleton_methods_13, TMP_Kernel_clone_14, TMP_Kernel_initialize_clone_15, TMP_Kernel_define_singleton_method_16, TMP_Kernel_dup_17, TMP_Kernel_initialize_dup_18, TMP_Kernel_enum_for_19, TMP_Kernel_equal$q_20, TMP_Kernel_exit_21, TMP_Kernel_extend_22, TMP_Kernel_format_23, TMP_Kernel_hash_24, TMP_Kernel_initialize_copy_25, TMP_Kernel_inspect_26, TMP_Kernel_instance_of$q_27, TMP_Kernel_instance_variable_defined$q_28, TMP_Kernel_instance_variable_get_29, TMP_Kernel_instance_variable_set_30, TMP_Kernel_remove_instance_variable_31, TMP_Kernel_instance_variables_32, TMP_Kernel_Integer_33, TMP_Kernel_Float_34, TMP_Kernel_Hash_35, TMP_Kernel_is_a$q_36, TMP_Kernel_itself_37, TMP_Kernel_lambda_38, TMP_Kernel_load_39, TMP_Kernel_loop_40, TMP_Kernel_nil$q_42, TMP_Kernel_printf_43, TMP_Kernel_proc_44, TMP_Kernel_puts_45, TMP_Kernel_p_47, TMP_Kernel_print_48, TMP_Kernel_warn_49, TMP_Kernel_raise_50, TMP_Kernel_rand_51, TMP_Kernel_respond_to$q_52, TMP_Kernel_respond_to_missing$q_53, TMP_Kernel_require_54, TMP_Kernel_require_relative_55, TMP_Kernel_require_tree_56, TMP_Kernel_singleton_class_57, TMP_Kernel_sleep_58, TMP_Kernel_srand_59, TMP_Kernel_String_60, TMP_Kernel_tap_61, TMP_Kernel_to_proc_62, TMP_Kernel_to_s_63, TMP_Kernel_catch_64, TMP_Kernel_throw_65, TMP_Kernel_open_66;\n\n    \n    \n    Opal.defn(self, '$method_missing', TMP_Kernel_method_missing_1 = function $$method_missing(symbol, $a_rest) {\n      var self = this, args, $iter = TMP_Kernel_method_missing_1.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Kernel_method_missing_1.$$p = null;\n      return self.$raise(Opal.const_get_relative($nesting, 'NoMethodError').$new(\"\" + \"undefined method `\" + (symbol) + \"' for \" + (self.$inspect()), symbol, args))\n    }, TMP_Kernel_method_missing_1.$$arity = -2);\n    \n    Opal.defn(self, '$=~', TMP_Kernel_$eq$_2 = function(obj) {\n      var self = this;\n\n      return false\n    }, TMP_Kernel_$eq$_2.$$arity = 1);\n    \n    Opal.defn(self, '$!~', TMP_Kernel_$B$_3 = function(obj) {\n      var self = this;\n\n      return self['$=~'](obj)['$!']()\n    }, TMP_Kernel_$B$_3.$$arity = 1);\n    \n    Opal.defn(self, '$===', TMP_Kernel_$eq$eq$eq_4 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = self.$object_id()['$=='](other.$object_id())) ? $a : self['$=='](other))\n    }, TMP_Kernel_$eq$eq$eq_4.$$arity = 1);\n    \n    Opal.defn(self, '$<=>', TMP_Kernel_$lt$eq$gt_5 = function(other) {\n      var self = this;\n\n      \n      // set guard for infinite recursion\n      self.$$comparable = true;\n\n      var x = self['$=='](other);\n\n      if (x && x !== nil) {\n        return 0;\n      }\n\n      return nil;\n    \n    }, TMP_Kernel_$lt$eq$gt_5.$$arity = 1);\n    \n    Opal.defn(self, '$method', TMP_Kernel_method_6 = function $$method(name) {\n      var self = this;\n\n      \n      var meth = self['$' + name];\n\n      if (!meth || meth.$$stub) {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"undefined method `\" + (name) + \"' for class `\" + (self.$class()) + \"'\", name));\n      }\n\n      return Opal.const_get_relative($nesting, 'Method').$new(self, meth.$$owner || self.$class(), meth, name);\n    \n    }, TMP_Kernel_method_6.$$arity = 1);\n    \n    Opal.defn(self, '$methods', TMP_Kernel_methods_7 = function $$methods(all) {\n      var self = this;\n\n      if (all == null) {\n        all = true;\n      }\n      \n      var methods = [];\n\n      for (var key in self) {\n        if (key[0] == \"$\" && typeof(self[key]) === \"function\") {\n          if (all == false || all === nil) {\n            if (!Opal.hasOwnProperty.call(self, key)) {\n              continue;\n            }\n          }\n          if (self[key].$$stub === undefined) {\n            methods.push(key.substr(1));\n          }\n        }\n      }\n\n      return methods;\n    \n    }, TMP_Kernel_methods_7.$$arity = -1);\n    Opal.alias(self, \"public_methods\", \"methods\");\n    \n    Opal.defn(self, '$Array', TMP_Kernel_Array_8 = function $$Array(object) {\n      var self = this;\n\n      \n      var coerced;\n\n      if (object === nil) {\n        return [];\n      }\n\n      if (object.$$is_array) {\n        return object;\n      }\n\n      coerced = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](object, Opal.const_get_relative($nesting, 'Array'), \"to_ary\");\n      if (coerced !== nil) { return coerced; }\n\n      coerced = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](object, Opal.const_get_relative($nesting, 'Array'), \"to_a\");\n      if (coerced !== nil) { return coerced; }\n\n      return [object];\n    \n    }, TMP_Kernel_Array_8.$$arity = 1);\n    \n    Opal.defn(self, '$at_exit', TMP_Kernel_at_exit_9 = function $$at_exit() {\n      var $a, self = this, $iter = TMP_Kernel_at_exit_9.$$p, block = $iter || nil;\n      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;\n\n      if ($iter) TMP_Kernel_at_exit_9.$$p = null;\n      \n      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);\n      return $gvars.__at_exit__['$<<'](block);\n    }, TMP_Kernel_at_exit_9.$$arity = 0);\n    \n    Opal.defn(self, '$caller', TMP_Kernel_caller_10 = function $$caller($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return []\n    }, TMP_Kernel_caller_10.$$arity = -1);\n    \n    Opal.defn(self, '$class', TMP_Kernel_class_11 = function() {\n      var self = this;\n\n      return self.$$class\n    }, TMP_Kernel_class_11.$$arity = 0);\n    \n    Opal.defn(self, '$copy_instance_variables', TMP_Kernel_copy_instance_variables_12 = function $$copy_instance_variables(other) {\n      var self = this;\n\n      \n      var keys = Object.keys(other), i, ii, name;\n      for (i = 0, ii = keys.length; i < ii; i++) {\n        name = keys[i];\n        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {\n          self[name] = other[name];\n        }\n      }\n    \n    }, TMP_Kernel_copy_instance_variables_12.$$arity = 1);\n    \n    Opal.defn(self, '$copy_singleton_methods', TMP_Kernel_copy_singleton_methods_13 = function $$copy_singleton_methods(other) {\n      var self = this;\n\n      \n      var name;\n\n      if (other.hasOwnProperty('$$meta')) {\n        var other_singleton_class_proto = Opal.get_singleton_class(other).$$proto;\n        var self_singleton_class_proto = Opal.get_singleton_class(self).$$proto;\n\n        for (name in other_singleton_class_proto) {\n          if (name.charAt(0) === '$' && other_singleton_class_proto.hasOwnProperty(name)) {\n            self_singleton_class_proto[name] = other_singleton_class_proto[name];\n          }\n        }\n      }\n\n      for (name in other) {\n        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {\n          self[name] = other[name];\n        }\n      }\n    \n    }, TMP_Kernel_copy_singleton_methods_13.$$arity = 1);\n    \n    Opal.defn(self, '$clone', TMP_Kernel_clone_14 = function $$clone($kwargs) {\n      var self = this, freeze, copy = nil;\n\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      freeze = $kwargs.$$smap[\"freeze\"];\n      if (freeze == null) {\n        freeze = true\n      }\n      \n      copy = self.$class().$allocate();\n      copy.$copy_instance_variables(self);\n      copy.$copy_singleton_methods(self);\n      copy.$initialize_clone(self);\n      return copy;\n    }, TMP_Kernel_clone_14.$$arity = -1);\n    \n    Opal.defn(self, '$initialize_clone', TMP_Kernel_initialize_clone_15 = function $$initialize_clone(other) {\n      var self = this;\n\n      return self.$initialize_copy(other)\n    }, TMP_Kernel_initialize_clone_15.$$arity = 1);\n    \n    Opal.defn(self, '$define_singleton_method', TMP_Kernel_define_singleton_method_16 = function $$define_singleton_method(name, method) {\n      var self = this, $iter = TMP_Kernel_define_singleton_method_16.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Kernel_define_singleton_method_16.$$p = null;\n      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc())\n    }, TMP_Kernel_define_singleton_method_16.$$arity = -2);\n    \n    Opal.defn(self, '$dup', TMP_Kernel_dup_17 = function $$dup() {\n      var self = this, copy = nil;\n\n      \n      copy = self.$class().$allocate();\n      copy.$copy_instance_variables(self);\n      copy.$initialize_dup(self);\n      return copy;\n    }, TMP_Kernel_dup_17.$$arity = 0);\n    \n    Opal.defn(self, '$initialize_dup', TMP_Kernel_initialize_dup_18 = function $$initialize_dup(other) {\n      var self = this;\n\n      return self.$initialize_copy(other)\n    }, TMP_Kernel_initialize_dup_18.$$arity = 1);\n    \n    Opal.defn(self, '$enum_for', TMP_Kernel_enum_for_19 = function $$enum_for(method, $a_rest) {\n      var self = this, args, $iter = TMP_Kernel_enum_for_19.$$p, block = $iter || nil;\n\n      if (method == null) {\n        method = \"each\";\n      }\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Kernel_enum_for_19.$$p = null;\n      return $send(Opal.const_get_relative($nesting, 'Enumerator'), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc())\n    }, TMP_Kernel_enum_for_19.$$arity = -1);\n    Opal.alias(self, \"to_enum\", \"enum_for\");\n    \n    Opal.defn(self, '$equal?', TMP_Kernel_equal$q_20 = function(other) {\n      var self = this;\n\n      return self === other\n    }, TMP_Kernel_equal$q_20.$$arity = 1);\n    \n    Opal.defn(self, '$exit', TMP_Kernel_exit_21 = function $$exit(status) {\n      var $a, self = this, block = nil;\n      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;\n\n      if (status == null) {\n        status = true;\n      }\n      \n      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);\n      while ($truthy($rb_gt($gvars.__at_exit__.$size(), 0))) {\n        \n        block = $gvars.__at_exit__.$pop();\n        block.$call();\n      };\n      \n      if (status == null) {\n        status = 0\n      } else if (status.$$is_boolean) {\n        status = status ? 0 : 1;\n      } else if (status.$$is_numeric) {\n        status = status.$to_i();\n      } else {\n        status = 0\n      }\n\n      Opal.exit(status);\n    ;\n      return nil;\n    }, TMP_Kernel_exit_21.$$arity = -1);\n    \n    Opal.defn(self, '$extend', TMP_Kernel_extend_22 = function $$extend($a_rest) {\n      var self = this, mods;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      mods = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        mods[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      var singleton = self.$singleton_class();\n\n      for (var i = mods.length - 1; i >= 0; i--) {\n        var mod = mods[i];\n\n        if (!mod.$$is_module) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"wrong argument type \" + ((mod).$class()) + \" (expected Module)\");\n        }\n\n        (mod).$append_features(singleton);\n        (mod).$extended(self);\n      }\n    ;\n      return self;\n    }, TMP_Kernel_extend_22.$$arity = -1);\n    \n    Opal.defn(self, '$format', TMP_Kernel_format_23 = function $$format(format_string, $a_rest) {\n      var $b, self = this, args, ary = nil;\n      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      if ($truthy((($b = args.$length()['$=='](1)) ? args['$[]'](0)['$respond_to?'](\"to_ary\") : args.$length()['$=='](1)))) {\n        \n        ary = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](args['$[]'](0), Opal.const_get_relative($nesting, 'Array'), \"to_ary\");\n        if ($truthy(ary['$nil?']())) {\n          } else {\n          args = ary.$to_a()\n        };};\n      \n      var result = '',\n          //used for slicing:\n          begin_slice = 0,\n          end_slice,\n          //used for iterating over the format string:\n          i,\n          len = format_string.length,\n          //used for processing field values:\n          arg,\n          str,\n          //used for processing %g and %G fields:\n          exponent,\n          //used for keeping track of width and precision:\n          width,\n          precision,\n          //used for holding temporary values:\n          tmp_num,\n          //used for processing %{} and %<> fileds:\n          hash_parameter_key,\n          closing_brace_char,\n          //used for processing %b, %B, %o, %x, and %X fields:\n          base_number,\n          base_prefix,\n          base_neg_zero_regex,\n          base_neg_zero_digit,\n          //used for processing arguments:\n          next_arg,\n          seq_arg_num = 1,\n          pos_arg_num = 0,\n          //used for keeping track of flags:\n          flags,\n          FNONE  = 0,\n          FSHARP = 1,\n          FMINUS = 2,\n          FPLUS  = 4,\n          FZERO  = 8,\n          FSPACE = 16,\n          FWIDTH = 32,\n          FPREC  = 64,\n          FPREC0 = 128;\n\n      function CHECK_FOR_FLAGS() {\n        if (flags&FWIDTH) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"flag after width\") }\n        if (flags&FPREC0) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"flag after precision\") }\n      }\n\n      function CHECK_FOR_WIDTH() {\n        if (flags&FWIDTH) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"width given twice\") }\n        if (flags&FPREC0) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"width after precision\") }\n      }\n\n      function GET_NTH_ARG(num) {\n        if (num >= args.length) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"too few arguments\") }\n        return args[num];\n      }\n\n      function GET_NEXT_ARG() {\n        switch (pos_arg_num) {\n        case -1: self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"unnumbered(\" + (seq_arg_num) + \") mixed with numbered\")\n        case -2: self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"unnumbered(\" + (seq_arg_num) + \") mixed with named\")\n        }\n        pos_arg_num = seq_arg_num++;\n        return GET_NTH_ARG(pos_arg_num - 1);\n      }\n\n      function GET_POS_ARG(num) {\n        if (pos_arg_num > 0) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"numbered(\" + (num) + \") after unnumbered(\" + (pos_arg_num) + \")\")\n        }\n        if (pos_arg_num === -2) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"numbered(\" + (num) + \") after named\")\n        }\n        if (num < 1) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid index - \" + (num) + \"$\")\n        }\n        pos_arg_num = -1;\n        return GET_NTH_ARG(num - 1);\n      }\n\n      function GET_ARG() {\n        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);\n      }\n\n      function READ_NUM(label) {\n        var num, str = '';\n        for (;; i++) {\n          if (i === len) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"malformed format string - %*[0-9]\")\n          }\n          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {\n            i--;\n            num = parseInt(str, 10) || 0;\n            if (num > 2147483647) {\n              self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + (label) + \" too big\")\n            }\n            return num;\n          }\n          str += format_string.charAt(i);\n        }\n      }\n\n      function READ_NUM_AFTER_ASTER(label) {\n        var arg, num = READ_NUM(label);\n        if (format_string.charAt(i + 1) === '$') {\n          i++;\n          arg = GET_POS_ARG(num);\n        } else {\n          arg = GET_NEXT_ARG();\n        }\n        return (arg).$to_int();\n      }\n\n      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {\n        str = undefined;\n\n        flags = FNONE;\n        width = -1;\n        precision = -1;\n        next_arg = undefined;\n\n        end_slice = i;\n\n        i++;\n\n        switch (format_string.charAt(i)) {\n        case '%':\n          begin_slice = i;\n        case '':\n        case '\\n':\n        case '\\0':\n          i++;\n          continue;\n        }\n\n        format_sequence: for (; i < len; i++) {\n          switch (format_string.charAt(i)) {\n\n          case ' ':\n            CHECK_FOR_FLAGS();\n            flags |= FSPACE;\n            continue format_sequence;\n\n          case '#':\n            CHECK_FOR_FLAGS();\n            flags |= FSHARP;\n            continue format_sequence;\n\n          case '+':\n            CHECK_FOR_FLAGS();\n            flags |= FPLUS;\n            continue format_sequence;\n\n          case '-':\n            CHECK_FOR_FLAGS();\n            flags |= FMINUS;\n            continue format_sequence;\n\n          case '0':\n            CHECK_FOR_FLAGS();\n            flags |= FZERO;\n            continue format_sequence;\n\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            tmp_num = READ_NUM('width');\n            if (format_string.charAt(i + 1) === '$') {\n              if (i + 2 === len) {\n                str = '%';\n                i++;\n                break format_sequence;\n              }\n              if (next_arg !== undefined) {\n                self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"value given twice - %\" + (tmp_num) + \"$\")\n              }\n              next_arg = GET_POS_ARG(tmp_num);\n              i++;\n            } else {\n              CHECK_FOR_WIDTH();\n              flags |= FWIDTH;\n              width = tmp_num;\n            }\n            continue format_sequence;\n\n          case '<':\n          case '\\{':\n            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\\}');\n            hash_parameter_key = '';\n\n            i++;\n\n            for (;; i++) {\n              if (i === len) {\n                self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"malformed name - unmatched parenthesis\")\n              }\n              if (format_string.charAt(i) === closing_brace_char) {\n\n                if (pos_arg_num > 0) {\n                  self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"named \" + (hash_parameter_key) + \" after unnumbered(\" + (pos_arg_num) + \")\")\n                }\n                if (pos_arg_num === -1) {\n                  self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"named \" + (hash_parameter_key) + \" after numbered\")\n                }\n                pos_arg_num = -2;\n\n                if (args[0] === undefined || !args[0].$$is_hash) {\n                  self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"one hash required\")\n                }\n\n                next_arg = (args[0]).$fetch(hash_parameter_key);\n\n                if (closing_brace_char === '>') {\n                  continue format_sequence;\n                } else {\n                  str = next_arg.toString();\n                  if (precision !== -1) { str = str.slice(0, precision); }\n                  if (flags&FMINUS) {\n                    while (str.length < width) { str = str + ' '; }\n                  } else {\n                    while (str.length < width) { str = ' ' + str; }\n                  }\n                  break format_sequence;\n                }\n              }\n              hash_parameter_key += format_string.charAt(i);\n            }\n\n          case '*':\n            i++;\n            CHECK_FOR_WIDTH();\n            flags |= FWIDTH;\n            width = READ_NUM_AFTER_ASTER('width');\n            if (width < 0) {\n              flags |= FMINUS;\n              width = -width;\n            }\n            continue format_sequence;\n\n          case '.':\n            if (flags&FPREC0) {\n              self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"precision given twice\")\n            }\n            flags |= FPREC|FPREC0;\n            precision = 0;\n            i++;\n            if (format_string.charAt(i) === '*') {\n              i++;\n              precision = READ_NUM_AFTER_ASTER('precision');\n              if (precision < 0) {\n                flags &= ~FPREC;\n              }\n              continue format_sequence;\n            }\n            precision = READ_NUM('precision');\n            continue format_sequence;\n\n          case 'd':\n          case 'i':\n          case 'u':\n            arg = self.$Integer(GET_ARG());\n            if (arg >= 0) {\n              str = arg.toString();\n              while (str.length < precision) { str = '0' + str; }\n              if (flags&FMINUS) {\n                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                while (str.length < width) { str = str + ' '; }\n              } else {\n                if (flags&FZERO && precision === -1) {\n                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                } else {\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                  while (str.length < width) { str = ' ' + str; }\n                }\n              }\n            } else {\n              str = (-arg).toString();\n              while (str.length < precision) { str = '0' + str; }\n              if (flags&FMINUS) {\n                str = '-' + str;\n                while (str.length < width) { str = str + ' '; }\n              } else {\n                if (flags&FZERO && precision === -1) {\n                  while (str.length < width - 1) { str = '0' + str; }\n                  str = '-' + str;\n                } else {\n                  str = '-' + str;\n                  while (str.length < width) { str = ' ' + str; }\n                }\n              }\n            }\n            break format_sequence;\n\n          case 'b':\n          case 'B':\n          case 'o':\n          case 'x':\n          case 'X':\n            switch (format_string.charAt(i)) {\n            case 'b':\n            case 'B':\n              base_number = 2;\n              base_prefix = '0b';\n              base_neg_zero_regex = /^1+/;\n              base_neg_zero_digit = '1';\n              break;\n            case 'o':\n              base_number = 8;\n              base_prefix = '0';\n              base_neg_zero_regex = /^3?7+/;\n              base_neg_zero_digit = '7';\n              break;\n            case 'x':\n            case 'X':\n              base_number = 16;\n              base_prefix = '0x';\n              base_neg_zero_regex = /^f+/;\n              base_neg_zero_digit = 'f';\n              break;\n            }\n            arg = self.$Integer(GET_ARG());\n            if (arg >= 0) {\n              str = arg.toString(base_number);\n              while (str.length < precision) { str = '0' + str; }\n              if (flags&FMINUS) {\n                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }\n                while (str.length < width) { str = str + ' '; }\n              } else {\n                if (flags&FZERO && precision === -1) {\n                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }\n                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                } else {\n                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                  while (str.length < width) { str = ' ' + str; }\n                }\n              }\n            } else {\n              if (flags&FPLUS || flags&FSPACE) {\n                str = (-arg).toString(base_number);\n                while (str.length < precision) { str = '0' + str; }\n                if (flags&FMINUS) {\n                  if (flags&FSHARP) { str = base_prefix + str; }\n                  str = '-' + str;\n                  while (str.length < width) { str = str + ' '; }\n                } else {\n                  if (flags&FZERO && precision === -1) {\n                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }\n                    if (flags&FSHARP) { str = base_prefix + str; }\n                    str = '-' + str;\n                  } else {\n                    if (flags&FSHARP) { str = base_prefix + str; }\n                    str = '-' + str;\n                    while (str.length < width) { str = ' ' + str; }\n                  }\n                }\n              } else {\n                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);\n                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }\n                if (flags&FMINUS) {\n                  str = '..' + str;\n                  if (flags&FSHARP) { str = base_prefix + str; }\n                  while (str.length < width) { str = str + ' '; }\n                } else {\n                  if (flags&FZERO && precision === -1) {\n                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }\n                    str = '..' + str;\n                    if (flags&FSHARP) { str = base_prefix + str; }\n                  } else {\n                    str = '..' + str;\n                    if (flags&FSHARP) { str = base_prefix + str; }\n                    while (str.length < width) { str = ' ' + str; }\n                  }\n                }\n              }\n            }\n            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {\n              str = str.toUpperCase();\n            }\n            break format_sequence;\n\n          case 'f':\n          case 'e':\n          case 'E':\n          case 'g':\n          case 'G':\n            arg = self.$Float(GET_ARG());\n            if (arg >= 0 || isNaN(arg)) {\n              if (arg === Infinity) {\n                str = 'Inf';\n              } else {\n                switch (format_string.charAt(i)) {\n                case 'f':\n                  str = arg.toFixed(precision === -1 ? 6 : precision);\n                  break;\n                case 'e':\n                case 'E':\n                  str = arg.toExponential(precision === -1 ? 6 : precision);\n                  break;\n                case 'g':\n                case 'G':\n                  str = arg.toExponential();\n                  exponent = parseInt(str.split('e')[1], 10);\n                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {\n                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);\n                  }\n                  break;\n                }\n              }\n              if (flags&FMINUS) {\n                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                while (str.length < width) { str = str + ' '; }\n              } else {\n                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {\n                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                } else {\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                  while (str.length < width) { str = ' ' + str; }\n                }\n              }\n            } else {\n              if (arg === -Infinity) {\n                str = 'Inf';\n              } else {\n                switch (format_string.charAt(i)) {\n                case 'f':\n                  str = (-arg).toFixed(precision === -1 ? 6 : precision);\n                  break;\n                case 'e':\n                case 'E':\n                  str = (-arg).toExponential(precision === -1 ? 6 : precision);\n                  break;\n                case 'g':\n                case 'G':\n                  str = (-arg).toExponential();\n                  exponent = parseInt(str.split('e')[1], 10);\n                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {\n                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);\n                  }\n                  break;\n                }\n              }\n              if (flags&FMINUS) {\n                str = '-' + str;\n                while (str.length < width) { str = str + ' '; }\n              } else {\n                if (flags&FZERO && arg !== -Infinity) {\n                  while (str.length < width - 1) { str = '0' + str; }\n                  str = '-' + str;\n                } else {\n                  str = '-' + str;\n                  while (str.length < width) { str = ' ' + str; }\n                }\n              }\n            }\n            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {\n              str = str.toUpperCase();\n            }\n            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');\n            break format_sequence;\n\n          case 'a':\n          case 'A':\n            // Not implemented because there are no specs for this field type.\n            self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"`A` and `a` format field types are not implemented in Opal yet\")\n\n          case 'c':\n            arg = GET_ARG();\n            if ((arg)['$respond_to?'](\"to_ary\")) { arg = (arg).$to_ary()[0]; }\n            if ((arg)['$respond_to?'](\"to_str\")) {\n              str = (arg).$to_str();\n            } else {\n              str = String.fromCharCode(Opal.const_get_relative($nesting, 'Opal').$coerce_to(arg, Opal.const_get_relative($nesting, 'Integer'), \"to_int\"));\n            }\n            if (str.length !== 1) {\n              self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"%c requires a character\")\n            }\n            if (flags&FMINUS) {\n              while (str.length < width) { str = str + ' '; }\n            } else {\n              while (str.length < width) { str = ' ' + str; }\n            }\n            break format_sequence;\n\n          case 'p':\n            str = (GET_ARG()).$inspect();\n            if (precision !== -1) { str = str.slice(0, precision); }\n            if (flags&FMINUS) {\n              while (str.length < width) { str = str + ' '; }\n            } else {\n              while (str.length < width) { str = ' ' + str; }\n            }\n            break format_sequence;\n\n          case 's':\n            str = (GET_ARG()).$to_s();\n            if (precision !== -1) { str = str.slice(0, precision); }\n            if (flags&FMINUS) {\n              while (str.length < width) { str = str + ' '; }\n            } else {\n              while (str.length < width) { str = ' ' + str; }\n            }\n            break format_sequence;\n\n          default:\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"malformed format string - %\" + (format_string.charAt(i)))\n          }\n        }\n\n        if (str === undefined) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"malformed format string - %\")\n        }\n\n        result += format_string.slice(begin_slice, end_slice) + str;\n        begin_slice = i + 1;\n      }\n\n      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"too many arguments for format string\")\n      }\n\n      return result + format_string.slice(begin_slice);\n    ;\n    }, TMP_Kernel_format_23.$$arity = -2);\n    \n    Opal.defn(self, '$hash', TMP_Kernel_hash_24 = function $$hash() {\n      var self = this;\n\n      return self.$__id__()\n    }, TMP_Kernel_hash_24.$$arity = 0);\n    \n    Opal.defn(self, '$initialize_copy', TMP_Kernel_initialize_copy_25 = function $$initialize_copy(other) {\n      var self = this;\n\n      return nil\n    }, TMP_Kernel_initialize_copy_25.$$arity = 1);\n    \n    Opal.defn(self, '$inspect', TMP_Kernel_inspect_26 = function $$inspect() {\n      var self = this;\n\n      return self.$to_s()\n    }, TMP_Kernel_inspect_26.$$arity = 0);\n    \n    Opal.defn(self, '$instance_of?', TMP_Kernel_instance_of$q_27 = function(klass) {\n      var self = this;\n\n      \n      if (!klass.$$is_class && !klass.$$is_module) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"class or module required\");\n      }\n\n      return self.$$class === klass;\n    \n    }, TMP_Kernel_instance_of$q_27.$$arity = 1);\n    \n    Opal.defn(self, '$instance_variable_defined?', TMP_Kernel_instance_variable_defined$q_28 = function(name) {\n      var self = this;\n\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$instance_variable_name!'](name);\n      return Opal.hasOwnProperty.call(self, name.substr(1));\n    }, TMP_Kernel_instance_variable_defined$q_28.$$arity = 1);\n    \n    Opal.defn(self, '$instance_variable_get', TMP_Kernel_instance_variable_get_29 = function $$instance_variable_get(name) {\n      var self = this;\n\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$instance_variable_name!'](name);\n      \n      var ivar = self[Opal.ivar(name.substr(1))];\n\n      return ivar == null ? nil : ivar;\n    ;\n    }, TMP_Kernel_instance_variable_get_29.$$arity = 1);\n    \n    Opal.defn(self, '$instance_variable_set', TMP_Kernel_instance_variable_set_30 = function $$instance_variable_set(name, value) {\n      var self = this;\n\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$instance_variable_name!'](name);\n      return self[Opal.ivar(name.substr(1))] = value;\n    }, TMP_Kernel_instance_variable_set_30.$$arity = 2);\n    \n    Opal.defn(self, '$remove_instance_variable', TMP_Kernel_remove_instance_variable_31 = function $$remove_instance_variable(name) {\n      var self = this;\n\n      \n      name = Opal.const_get_relative($nesting, 'Opal')['$instance_variable_name!'](name);\n      \n      var key = Opal.ivar(name.substr(1)),\n          val;\n      if (self.hasOwnProperty(key)) {\n        val = self[key];\n        delete self[key];\n        return val;\n      }\n    ;\n      return self.$raise(Opal.const_get_relative($nesting, 'NameError'), \"\" + \"instance variable \" + (name) + \" not defined\");\n    }, TMP_Kernel_remove_instance_variable_31.$$arity = 1);\n    \n    Opal.defn(self, '$instance_variables', TMP_Kernel_instance_variables_32 = function $$instance_variables() {\n      var self = this;\n\n      \n      var result = [], ivar;\n\n      for (var name in self) {\n        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {\n          if (name.substr(-1) === '$') {\n            ivar = name.slice(0, name.length - 1);\n          } else {\n            ivar = name;\n          }\n          result.push('@' + ivar);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Kernel_instance_variables_32.$$arity = 0);\n    \n    Opal.defn(self, '$Integer', TMP_Kernel_Integer_33 = function $$Integer(value, base) {\n      var self = this;\n\n      \n      var i, str, base_digits;\n\n      if (!value.$$is_string) {\n        if (base !== undefined) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"base specified for non string value\")\n        }\n        if (value === nil) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"can't convert nil into Integer\")\n        }\n        if (value.$$is_number) {\n          if (value === Infinity || value === -Infinity || isNaN(value)) {\n            self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), value)\n          }\n          return Math.floor(value);\n        }\n        if (value['$respond_to?'](\"to_int\")) {\n          i = value.$to_int();\n          if (i !== nil) {\n            return i;\n          }\n        }\n        return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](value, Opal.const_get_relative($nesting, 'Integer'), \"to_i\");\n      }\n\n      if (value === \"0\") {\n        return 0;\n      }\n\n      if (base === undefined) {\n        base = 0;\n      } else {\n        base = Opal.const_get_relative($nesting, 'Opal').$coerce_to(base, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if (base === 1 || base < 0 || base > 36) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid radix \" + (base))\n        }\n      }\n\n      str = value.toLowerCase();\n\n      str = str.replace(/(\\d)_(?=\\d)/g, '$1');\n\n      str = str.replace(/^(\\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {\n        switch (flag) {\n        case '0b':\n          if (base === 0 || base === 2) {\n            base = 2;\n            return head;\n          }\n        case '0':\n        case '0o':\n          if (base === 0 || base === 8) {\n            base = 8;\n            return head;\n          }\n        case '0d':\n          if (base === 0 || base === 10) {\n            base = 10;\n            return head;\n          }\n        case '0x':\n          if (base === 0 || base === 16) {\n            base = 16;\n            return head;\n          }\n        }\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid value for Integer(): \\\"\" + (value) + \"\\\"\")\n      });\n\n      base = (base === 0 ? 10 : base);\n\n      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));\n\n      if (!(new RegExp('^\\\\s*[+-]?[' + base_digits + ']+\\\\s*$')).test(str)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid value for Integer(): \\\"\" + (value) + \"\\\"\")\n      }\n\n      i = parseInt(str, base);\n\n      if (isNaN(i)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid value for Integer(): \\\"\" + (value) + \"\\\"\")\n      }\n\n      return i;\n    \n    }, TMP_Kernel_Integer_33.$$arity = -2);\n    \n    Opal.defn(self, '$Float', TMP_Kernel_Float_34 = function $$Float(value) {\n      var self = this;\n\n      \n      var str;\n\n      if (value === nil) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"can't convert nil into Float\")\n      }\n\n      if (value.$$is_string) {\n        str = value.toString();\n\n        str = str.replace(/(\\d)_(?=\\d)/g, '$1');\n\n        //Special case for hex strings only:\n        if (/^\\s*[-+]?0[xX][0-9a-fA-F]+\\s*$/.test(str)) {\n          return self.$Integer(str);\n        }\n\n        if (!/^\\s*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?\\s*$/.test(str)) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid value for Float(): \\\"\" + (value) + \"\\\"\")\n        }\n\n        return parseFloat(str);\n      }\n\n      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](value, Opal.const_get_relative($nesting, 'Float'), \"to_f\");\n    \n    }, TMP_Kernel_Float_34.$$arity = 1);\n    \n    Opal.defn(self, '$Hash', TMP_Kernel_Hash_35 = function $$Hash(arg) {\n      var $a, self = this;\n\n      \n      if ($truthy(($truthy($a = arg['$nil?']()) ? $a : arg['$==']([])))) {\n        return $hash2([], {})};\n      if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](arg))) {\n        return arg};\n      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](arg, Opal.const_get_relative($nesting, 'Hash'), \"to_hash\");\n    }, TMP_Kernel_Hash_35.$$arity = 1);\n    \n    Opal.defn(self, '$is_a?', TMP_Kernel_is_a$q_36 = function(klass) {\n      var self = this;\n\n      \n      if (!klass.$$is_class && !klass.$$is_module) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"class or module required\");\n      }\n\n      return Opal.is_a(self, klass);\n    \n    }, TMP_Kernel_is_a$q_36.$$arity = 1);\n    \n    Opal.defn(self, '$itself', TMP_Kernel_itself_37 = function $$itself() {\n      var self = this;\n\n      return self\n    }, TMP_Kernel_itself_37.$$arity = 0);\n    Opal.alias(self, \"kind_of?\", \"is_a?\");\n    \n    Opal.defn(self, '$lambda', TMP_Kernel_lambda_38 = function $$lambda() {\n      var self = this, $iter = TMP_Kernel_lambda_38.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Kernel_lambda_38.$$p = null;\n      \n      block.$$is_lambda = true;\n      return block;\n    }, TMP_Kernel_lambda_38.$$arity = 0);\n    \n    Opal.defn(self, '$load', TMP_Kernel_load_39 = function $$load(file) {\n      var self = this;\n\n      \n      file = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](file, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      return Opal.load(file);\n    }, TMP_Kernel_load_39.$$arity = 1);\n    \n    Opal.defn(self, '$loop', TMP_Kernel_loop_40 = function $$loop() {\n      var TMP_41, $a, self = this, $iter = TMP_Kernel_loop_40.$$p, $yield = $iter || nil, e = nil;\n\n      if ($iter) TMP_Kernel_loop_40.$$p = null;\n      \n      if (($yield !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"loop\"], (TMP_41 = function(){var self = TMP_41.$$s || this;\n\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY')}, TMP_41.$$s = self, TMP_41.$$arity = 0, TMP_41))\n      };\n      while ($truthy(true)) {\n        \n        try {\n          Opal.yieldX($yield, [])\n        } catch ($err) {\n          if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StopIteration')])) {e = $err;\n            try {\n              return e.$result()\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        };\n      };\n      return self;\n    }, TMP_Kernel_loop_40.$$arity = 0);\n    \n    Opal.defn(self, '$nil?', TMP_Kernel_nil$q_42 = function() {\n      var self = this;\n\n      return false\n    }, TMP_Kernel_nil$q_42.$$arity = 0);\n    Opal.alias(self, \"object_id\", \"__id__\");\n    \n    Opal.defn(self, '$printf', TMP_Kernel_printf_43 = function $$printf($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if ($truthy($rb_gt(args.$length(), 0))) {\n        self.$print($send(self, 'format', Opal.to_a(args)))};\n      return nil;\n    }, TMP_Kernel_printf_43.$$arity = -1);\n    \n    Opal.defn(self, '$proc', TMP_Kernel_proc_44 = function $$proc() {\n      var self = this, $iter = TMP_Kernel_proc_44.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Kernel_proc_44.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"tried to create Proc object without a block\")\n      };\n      block.$$is_lambda = false;\n      return block;\n    }, TMP_Kernel_proc_44.$$arity = 0);\n    \n    Opal.defn(self, '$puts', TMP_Kernel_puts_45 = function $$puts($a_rest) {\n      var self = this, strs;\n      if ($gvars.stdout == null) $gvars.stdout = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      strs = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        strs[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return $send($gvars.stdout, 'puts', Opal.to_a(strs))\n    }, TMP_Kernel_puts_45.$$arity = -1);\n    \n    Opal.defn(self, '$p', TMP_Kernel_p_47 = function $$p($a_rest) {\n      var TMP_46, self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      $send(args, 'each', [], (TMP_46 = function(obj){var self = TMP_46.$$s || this;\n        if ($gvars.stdout == null) $gvars.stdout = nil;\nif (obj == null) obj = nil;\n      return $gvars.stdout.$puts(obj.$inspect())}, TMP_46.$$s = self, TMP_46.$$arity = 1, TMP_46));\n      if ($truthy($rb_le(args.$length(), 1))) {\n        return args['$[]'](0)\n        } else {\n        return args\n      };\n    }, TMP_Kernel_p_47.$$arity = -1);\n    \n    Opal.defn(self, '$print', TMP_Kernel_print_48 = function $$print($a_rest) {\n      var self = this, strs;\n      if ($gvars.stdout == null) $gvars.stdout = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      strs = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        strs[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return $send($gvars.stdout, 'print', Opal.to_a(strs))\n    }, TMP_Kernel_print_48.$$arity = -1);\n    \n    Opal.defn(self, '$warn', TMP_Kernel_warn_49 = function $$warn($a_rest) {\n      var $b, self = this, strs;\n      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;\n      if ($gvars.stderr == null) $gvars.stderr = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      strs = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        strs[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($truthy(($truthy($b = $gvars.VERBOSE['$nil?']()) ? $b : strs['$empty?']()))) {\n        return nil\n        } else {\n        return $send($gvars.stderr, 'puts', Opal.to_a(strs))\n      }\n    }, TMP_Kernel_warn_49.$$arity = -1);\n    \n    Opal.defn(self, '$raise', TMP_Kernel_raise_50 = function $$raise(exception, string, _backtrace) {\n      var self = this;\n      if ($gvars[\"!\"] == null) $gvars[\"!\"] = nil;\n\n      if (string == null) {\n        string = nil;\n      }\n      if (_backtrace == null) {\n        _backtrace = nil;\n      }\n      \n      if (exception == null && $gvars[\"!\"] !== nil) {\n        throw $gvars[\"!\"];\n      }\n      if (exception == null) {\n        exception = Opal.const_get_relative($nesting, 'RuntimeError').$new();\n      }\n      else if (exception.$$is_string) {\n        exception = Opal.const_get_relative($nesting, 'RuntimeError').$new(exception);\n      }\n      // using respond_to? and not an undefined check to avoid method_missing matching as true\n      else if (exception.$$is_class && exception['$respond_to?'](\"exception\")) {\n        exception = exception.$exception(string);\n      }\n      else if (exception['$kind_of?'](Opal.const_get_relative($nesting, 'Exception'))) {\n        // exception is fine\n      }\n      else {\n        exception = Opal.const_get_relative($nesting, 'TypeError').$new(\"exception class/object expected\");\n      }\n\n      if ($gvars[\"!\"] !== nil) {\n        Opal.exceptions.push($gvars[\"!\"]);\n      }\n\n      $gvars[\"!\"] = exception;\n\n      throw exception;\n    \n    }, TMP_Kernel_raise_50.$$arity = -1);\n    Opal.alias(self, \"fail\", \"raise\");\n    \n    Opal.defn(self, '$rand', TMP_Kernel_rand_51 = function $$rand(max) {\n      var self = this;\n\n      \n      \n      if (max === undefined) {\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Random'), 'DEFAULT').$rand();\n      }\n\n      if (max.$$is_number) {\n        if (max < 0) {\n          max = Math.abs(max);\n        }\n\n        if (max % 1 !== 0) {\n          max = max.$to_i();\n        }\n\n        if (max === 0) {\n          max = undefined;\n        }\n      }\n    ;\n      return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Random'), 'DEFAULT').$rand(max);\n    }, TMP_Kernel_rand_51.$$arity = -1);\n    \n    Opal.defn(self, '$respond_to?', TMP_Kernel_respond_to$q_52 = function(name, include_all) {\n      var self = this;\n\n      if (include_all == null) {\n        include_all = false;\n      }\n      \n      if ($truthy(self['$respond_to_missing?'](name, include_all))) {\n        return true};\n      \n      var body = self['$' + name];\n\n      if (typeof(body) === \"function\" && !body.$$stub) {\n        return true;\n      }\n    ;\n      return false;\n    }, TMP_Kernel_respond_to$q_52.$$arity = -2);\n    \n    Opal.defn(self, '$respond_to_missing?', TMP_Kernel_respond_to_missing$q_53 = function(method_name, include_all) {\n      var self = this;\n\n      if (include_all == null) {\n        include_all = false;\n      }\n      return false\n    }, TMP_Kernel_respond_to_missing$q_53.$$arity = -2);\n    \n    Opal.defn(self, '$require', TMP_Kernel_require_54 = function $$require(file) {\n      var self = this;\n\n      \n      file = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](file, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      return Opal.require(file);\n    }, TMP_Kernel_require_54.$$arity = 1);\n    \n    Opal.defn(self, '$require_relative', TMP_Kernel_require_relative_55 = function $$require_relative(file) {\n      var self = this;\n\n      \n      Opal.const_get_relative($nesting, 'Opal')['$try_convert!'](file, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      file = Opal.const_get_relative($nesting, 'File').$expand_path(Opal.const_get_relative($nesting, 'File').$join(Opal.current_file, \"..\", file));\n      return Opal.require(file);\n    }, TMP_Kernel_require_relative_55.$$arity = 1);\n    \n    Opal.defn(self, '$require_tree', TMP_Kernel_require_tree_56 = function $$require_tree(path) {\n      var self = this;\n\n      \n      var result = [];\n\n      path = Opal.const_get_relative($nesting, 'File').$expand_path(path)\n      path = Opal.normalize(path);\n      if (path === '.') path = '';\n      for (var name in Opal.modules) {\n        if ((name)['$start_with?'](path)) {\n          result.push([name, Opal.require(name)]);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Kernel_require_tree_56.$$arity = 1);\n    Opal.alias(self, \"send\", \"__send__\");\n    Opal.alias(self, \"public_send\", \"__send__\");\n    \n    Opal.defn(self, '$singleton_class', TMP_Kernel_singleton_class_57 = function $$singleton_class() {\n      var self = this;\n\n      return Opal.get_singleton_class(self)\n    }, TMP_Kernel_singleton_class_57.$$arity = 0);\n    \n    Opal.defn(self, '$sleep', TMP_Kernel_sleep_58 = function $$sleep(seconds) {\n      var self = this;\n\n      if (seconds == null) {\n        seconds = nil;\n      }\n      \n      if (seconds === nil) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"can't convert NilClass into time interval\")\n      }\n      if (!seconds.$$is_number) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"can't convert \" + (seconds.$class()) + \" into time interval\")\n      }\n      if (seconds < 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"time interval must be positive\")\n      }\n      var get_time = Opal.global.performance ?\n        function() {return performance.now()} :\n        function() {return new Date()}\n\n      var t = get_time();\n      while (get_time() - t <= seconds * 1000);\n      return seconds;\n    \n    }, TMP_Kernel_sleep_58.$$arity = -1);\n    Opal.alias(self, \"sprintf\", \"format\");\n    \n    Opal.defn(self, '$srand', TMP_Kernel_srand_59 = function $$srand(seed) {\n      var self = this;\n\n      if (seed == null) {\n        seed = Opal.const_get_relative($nesting, 'Random').$new_seed();\n      }\n      return Opal.const_get_relative($nesting, 'Random').$srand(seed)\n    }, TMP_Kernel_srand_59.$$arity = -1);\n    \n    Opal.defn(self, '$String', TMP_Kernel_String_60 = function $$String(str) {\n      var $a, self = this;\n\n      return ($truthy($a = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](str, Opal.const_get_relative($nesting, 'String'), \"to_str\")) ? $a : Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](str, Opal.const_get_relative($nesting, 'String'), \"to_s\"))\n    }, TMP_Kernel_String_60.$$arity = 1);\n    \n    Opal.defn(self, '$tap', TMP_Kernel_tap_61 = function $$tap() {\n      var self = this, $iter = TMP_Kernel_tap_61.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Kernel_tap_61.$$p = null;\n      \n      Opal.yield1(block, self);\n      return self;\n    }, TMP_Kernel_tap_61.$$arity = 0);\n    \n    Opal.defn(self, '$to_proc', TMP_Kernel_to_proc_62 = function $$to_proc() {\n      var self = this;\n\n      return self\n    }, TMP_Kernel_to_proc_62.$$arity = 0);\n    \n    Opal.defn(self, '$to_s', TMP_Kernel_to_s_63 = function $$to_s() {\n      var self = this;\n\n      return \"\" + \"#<\" + (self.$class()) + \":0x\" + (self.$__id__().$to_s(16)) + \">\"\n    }, TMP_Kernel_to_s_63.$$arity = 0);\n    \n    Opal.defn(self, '$catch', TMP_Kernel_catch_64 = function(sym) {\n      var self = this, $iter = TMP_Kernel_catch_64.$$p, $yield = $iter || nil, e = nil;\n\n      if ($iter) TMP_Kernel_catch_64.$$p = null;\n      try {\n        return Opal.yieldX($yield, []);\n      } catch ($err) {\n        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'UncaughtThrowError')])) {e = $err;\n          try {\n            \n            if (e.$sym()['$=='](sym)) {\n              return e.$arg()};\n            return self.$raise();\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      }\n    }, TMP_Kernel_catch_64.$$arity = 1);\n    \n    Opal.defn(self, '$throw', TMP_Kernel_throw_65 = function($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return self.$raise(Opal.const_get_relative($nesting, 'UncaughtThrowError').$new(args))\n    }, TMP_Kernel_throw_65.$$arity = -1);\n    \n    Opal.defn(self, '$open', TMP_Kernel_open_66 = function $$open($a_rest) {\n      var self = this, args, $iter = TMP_Kernel_open_66.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Kernel_open_66.$$p = null;\n      return $send(Opal.const_get_relative($nesting, 'File'), 'open', Opal.to_a(args), block.$to_proc())\n    }, TMP_Kernel_open_66.$$arity = -1);\n  })($nesting[0], $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $Object(){};\n    var self = $Object = $klass($base, $super, 'Object', $Object);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return self.$include(Opal.const_get_relative($nesting, 'Kernel'))\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/error\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $module = Opal.module;\n\n  Opal.add_stubs(['$new', '$clone', '$to_s', '$empty?', '$class', '$+', '$attr_reader', '$[]', '$>', '$length', '$inspect']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Exception(){};\n    var self = $Exception = $klass($base, $super, 'Exception', $Exception);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Exception_new_1, TMP_Exception_exception_2, TMP_Exception_initialize_3, TMP_Exception_backtrace_4, TMP_Exception_exception_5, TMP_Exception_message_6, TMP_Exception_inspect_7, TMP_Exception_to_s_8;\n\n    def.message = nil;\n    \n    var Kernel$raise = Opal.const_get_relative($nesting, 'Kernel').$raise;\n    Opal.defs(self, '$new', TMP_Exception_new_1 = function($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      var message   = (args.length > 0) ? args[0] : nil;\n      var error     = new self.$$alloc(message);\n      error.name    = self.$$name;\n      error.message = message;\n      Opal.send(error, error.$initialize, args);\n\n      // Error.captureStackTrace() will use .name and .toString to build the\n      // first line of the stack trace so it must be called after the error\n      // has been initialized.\n      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html\n      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {\n        // Passing Kernel.raise will cut the stack trace from that point above\n        Error.captureStackTrace(error, Kernel$raise);\n      }\n\n      return error;\n    \n    }, TMP_Exception_new_1.$$arity = -1);\n    Opal.defs(self, '$exception', TMP_Exception_exception_2 = function $$exception($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return $send(self, 'new', Opal.to_a(args))\n    }, TMP_Exception_exception_2.$$arity = -1);\n    \n    Opal.defn(self, '$initialize', TMP_Exception_initialize_3 = function $$initialize($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return self.message = (args.length > 0) ? args[0] : nil\n    }, TMP_Exception_initialize_3.$$arity = -1);\n    \n    Opal.defn(self, '$backtrace', TMP_Exception_backtrace_4 = function $$backtrace() {\n      var self = this;\n\n      \n      var backtrace = self.stack;\n\n      if (typeof(backtrace) === 'string') {\n        return backtrace.split(\"\\n\").slice(0, 15);\n      }\n      else if (backtrace) {\n        return backtrace.slice(0, 15);\n      }\n\n      return [];\n    \n    }, TMP_Exception_backtrace_4.$$arity = 0);\n    \n    Opal.defn(self, '$exception', TMP_Exception_exception_5 = function $$exception(str) {\n      var self = this;\n\n      if (str == null) {\n        str = nil;\n      }\n      \n      if (str === nil || self === str) {\n        return self;\n      }\n\n      var cloned = self.$clone();\n      cloned.message = str;\n      return cloned;\n    \n    }, TMP_Exception_exception_5.$$arity = -1);\n    \n    Opal.defn(self, '$message', TMP_Exception_message_6 = function $$message() {\n      var self = this;\n\n      return self.$to_s()\n    }, TMP_Exception_message_6.$$arity = 0);\n    \n    Opal.defn(self, '$inspect', TMP_Exception_inspect_7 = function $$inspect() {\n      var self = this, as_str = nil;\n\n      \n      as_str = self.$to_s();\n      if ($truthy(as_str['$empty?']())) {\n        return self.$class().$to_s()\n        } else {\n        return \"\" + \"#<\" + (self.$class().$to_s()) + \": \" + (self.$to_s()) + \">\"\n      };\n    }, TMP_Exception_inspect_7.$$arity = 0);\n    return (Opal.defn(self, '$to_s', TMP_Exception_to_s_8 = function $$to_s() {\n      var $a, $b, self = this;\n\n      return ($truthy($a = ($truthy($b = self.message) ? self.message.$to_s() : $b)) ? $a : self.$class().$to_s())\n    }, TMP_Exception_to_s_8.$$arity = 0), nil) && 'to_s';\n  })($nesting[0], Error, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $ScriptError(){};\n    var self = $ScriptError = $klass($base, $super, 'ScriptError', $ScriptError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $SyntaxError(){};\n    var self = $SyntaxError = $klass($base, $super, 'SyntaxError', $SyntaxError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'ScriptError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $LoadError(){};\n    var self = $LoadError = $klass($base, $super, 'LoadError', $LoadError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'ScriptError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NotImplementedError(){};\n    var self = $NotImplementedError = $klass($base, $super, 'NotImplementedError', $NotImplementedError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'ScriptError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $SystemExit(){};\n    var self = $SystemExit = $klass($base, $super, 'SystemExit', $SystemExit);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NoMemoryError(){};\n    var self = $NoMemoryError = $klass($base, $super, 'NoMemoryError', $NoMemoryError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $SignalException(){};\n    var self = $SignalException = $klass($base, $super, 'SignalException', $SignalException);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Interrupt(){};\n    var self = $Interrupt = $klass($base, $super, 'Interrupt', $Interrupt);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $SecurityError(){};\n    var self = $SecurityError = $klass($base, $super, 'SecurityError', $SecurityError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $StandardError(){};\n    var self = $StandardError = $klass($base, $super, 'StandardError', $StandardError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $ZeroDivisionError(){};\n    var self = $ZeroDivisionError = $klass($base, $super, 'ZeroDivisionError', $ZeroDivisionError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NameError(){};\n    var self = $NameError = $klass($base, $super, 'NameError', $NameError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NoMethodError(){};\n    var self = $NoMethodError = $klass($base, $super, 'NoMethodError', $NoMethodError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'NameError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $RuntimeError(){};\n    var self = $RuntimeError = $klass($base, $super, 'RuntimeError', $RuntimeError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $LocalJumpError(){};\n    var self = $LocalJumpError = $klass($base, $super, 'LocalJumpError', $LocalJumpError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $TypeError(){};\n    var self = $TypeError = $klass($base, $super, 'TypeError', $TypeError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $ArgumentError(){};\n    var self = $ArgumentError = $klass($base, $super, 'ArgumentError', $ArgumentError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $IndexError(){};\n    var self = $IndexError = $klass($base, $super, 'IndexError', $IndexError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $StopIteration(){};\n    var self = $StopIteration = $klass($base, $super, 'StopIteration', $StopIteration);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'IndexError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $KeyError(){};\n    var self = $KeyError = $klass($base, $super, 'KeyError', $KeyError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'IndexError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $RangeError(){};\n    var self = $RangeError = $klass($base, $super, 'RangeError', $RangeError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $FloatDomainError(){};\n    var self = $FloatDomainError = $klass($base, $super, 'FloatDomainError', $FloatDomainError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'RangeError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $IOError(){};\n    var self = $IOError = $klass($base, $super, 'IOError', $IOError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $SystemCallError(){};\n    var self = $SystemCallError = $klass($base, $super, 'SystemCallError', $SystemCallError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n  (function($base, $parent_nesting) {\n    var $Errno, self = $Errno = $module($base, 'Errno');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $EINVAL(){};\n      var self = $EINVAL = $klass($base, $super, 'EINVAL', $EINVAL);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_EINVAL_new_9;\n\n      return Opal.defs(self, '$new', TMP_EINVAL_new_9 = function(name) {\n        var self = this, $iter = TMP_EINVAL_new_9.$$p, $yield = $iter || nil, message = nil;\n\n        if (name == null) {\n          name = nil;\n        }\n        if ($iter) TMP_EINVAL_new_9.$$p = null;\n        \n        message = \"Invalid argument\";\n        if ($truthy(name)) {\n          message = $rb_plus(message, \"\" + \" - \" + (name))};\n        return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_EINVAL_new_9, false, $EINVAL), [message], null);\n      }, TMP_EINVAL_new_9.$$arity = -1)\n    })($nesting[0], Opal.const_get_relative($nesting, 'SystemCallError'), $nesting)\n  })($nesting[0], $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $UncaughtThrowError(){};\n    var self = $UncaughtThrowError = $klass($base, $super, 'UncaughtThrowError', $UncaughtThrowError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_UncaughtThrowError_initialize_10;\n\n    def.sym = nil;\n    \n    self.$attr_reader(\"sym\", \"arg\");\n    return (Opal.defn(self, '$initialize', TMP_UncaughtThrowError_initialize_10 = function $$initialize(args) {\n      var self = this, $iter = TMP_UncaughtThrowError_initialize_10.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_UncaughtThrowError_initialize_10.$$p = null;\n      \n      self.sym = args['$[]'](0);\n      if ($truthy($rb_gt(args.$length(), 1))) {\n        self.arg = args['$[]'](1)};\n      return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_UncaughtThrowError_initialize_10, false), [\"\" + \"uncaught throw \" + (self.sym.$inspect())], null);\n    }, TMP_UncaughtThrowError_initialize_10.$$arity = 1), nil) && 'initialize';\n  })($nesting[0], Opal.const_get_relative($nesting, 'ArgumentError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NameError(){};\n    var self = $NameError = $klass($base, $super, 'NameError', $NameError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NameError_initialize_11;\n\n    \n    self.$attr_reader(\"name\");\n    return (Opal.defn(self, '$initialize', TMP_NameError_initialize_11 = function $$initialize(message, name) {\n      var self = this, $iter = TMP_NameError_initialize_11.$$p, $yield = $iter || nil;\n\n      if (name == null) {\n        name = nil;\n      }\n      if ($iter) TMP_NameError_initialize_11.$$p = null;\n      \n      $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_NameError_initialize_11, false), [message], null);\n      return (self.name = name);\n    }, TMP_NameError_initialize_11.$$arity = -2), nil) && 'initialize';\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NoMethodError(){};\n    var self = $NoMethodError = $klass($base, $super, 'NoMethodError', $NoMethodError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NoMethodError_initialize_12;\n\n    \n    self.$attr_reader(\"args\");\n    return (Opal.defn(self, '$initialize', TMP_NoMethodError_initialize_12 = function $$initialize(message, name, args) {\n      var self = this, $iter = TMP_NoMethodError_initialize_12.$$p, $yield = $iter || nil;\n\n      if (name == null) {\n        name = nil;\n      }\n      if (args == null) {\n        args = [];\n      }\n      if ($iter) TMP_NoMethodError_initialize_12.$$p = null;\n      \n      $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_NoMethodError_initialize_12, false), [message, name], null);\n      return (self.args = args);\n    }, TMP_NoMethodError_initialize_12.$$arity = -2), nil) && 'initialize';\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $StopIteration(){};\n    var self = $StopIteration = $klass($base, $super, 'StopIteration', $StopIteration);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return self.$attr_reader(\"result\")\n  })($nesting[0], null, $nesting);\n  return (function($base, $parent_nesting) {\n    var $JS, self = $JS = $module($base, 'JS');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Error(){};\n      var self = $Error = $klass($base, $super, 'Error', $Error);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return nil\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/constants\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  \n  Opal.const_set($nesting[0], 'RUBY_PLATFORM', \"opal\");\n  Opal.const_set($nesting[0], 'RUBY_ENGINE', \"opal\");\n  Opal.const_set($nesting[0], 'RUBY_VERSION', \"2.4.0\");\n  Opal.const_set($nesting[0], 'RUBY_ENGINE_VERSION', \"0.11.3\");\n  Opal.const_set($nesting[0], 'RUBY_RELEASE_DATE', \"2018-08-28\");\n  Opal.const_set($nesting[0], 'RUBY_PATCHLEVEL', 0);\n  Opal.const_set($nesting[0], 'RUBY_REVISION', 0);\n  Opal.const_set($nesting[0], 'RUBY_COPYRIGHT', \"opal - Copyright (C) 2013-2015 Adam Beynon\");\n  return Opal.const_set($nesting[0], 'RUBY_DESCRIPTION', \"\" + \"opal \" + (Opal.const_get_relative($nesting, 'RUBY_ENGINE_VERSION')) + \" (\" + (Opal.const_get_relative($nesting, 'RUBY_RELEASE_DATE')) + \" revision \" + (Opal.const_get_relative($nesting, 'RUBY_REVISION')) + \")\");\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/base\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"corelib/runtime\");\n  self.$require(\"corelib/helpers\");\n  self.$require(\"corelib/module\");\n  self.$require(\"corelib/class\");\n  self.$require(\"corelib/basic_object\");\n  self.$require(\"corelib/kernel\");\n  self.$require(\"corelib/error\");\n  return self.$require(\"corelib/constants\");\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/nil\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$raise', '$name', '$new', '$>', '$length', '$Rational']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $NilClass(){};\n    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NilClass_$B_2, TMP_NilClass_$_3, TMP_NilClass_$_4, TMP_NilClass_$_5, TMP_NilClass_$eq$eq_6, TMP_NilClass_dup_7, TMP_NilClass_clone_8, TMP_NilClass_inspect_9, TMP_NilClass_nil$q_10, TMP_NilClass_singleton_class_11, TMP_NilClass_to_a_12, TMP_NilClass_to_h_13, TMP_NilClass_to_i_14, TMP_NilClass_to_s_15, TMP_NilClass_to_c_16, TMP_NilClass_rationalize_17, TMP_NilClass_to_r_18, TMP_NilClass_instance_variables_19;\n\n    \n    def.$$meta = self;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1;\n\n      \n      \n      Opal.defn(self, '$allocate', TMP_allocate_1 = function $$allocate() {\n        var self = this;\n\n        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"allocator undefined for \" + (self.$name()))\n      }, TMP_allocate_1.$$arity = 0);\n      \n      \n      Opal.udef(self, '$' + \"new\");;\n      return nil;;\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    Opal.defn(self, '$!', TMP_NilClass_$B_2 = function() {\n      var self = this;\n\n      return true\n    }, TMP_NilClass_$B_2.$$arity = 0);\n    \n    Opal.defn(self, '$&', TMP_NilClass_$_3 = function(other) {\n      var self = this;\n\n      return false\n    }, TMP_NilClass_$_3.$$arity = 1);\n    \n    Opal.defn(self, '$|', TMP_NilClass_$_4 = function(other) {\n      var self = this;\n\n      return other !== false && other !== nil\n    }, TMP_NilClass_$_4.$$arity = 1);\n    \n    Opal.defn(self, '$^', TMP_NilClass_$_5 = function(other) {\n      var self = this;\n\n      return other !== false && other !== nil\n    }, TMP_NilClass_$_5.$$arity = 1);\n    \n    Opal.defn(self, '$==', TMP_NilClass_$eq$eq_6 = function(other) {\n      var self = this;\n\n      return other === nil\n    }, TMP_NilClass_$eq$eq_6.$$arity = 1);\n    \n    Opal.defn(self, '$dup', TMP_NilClass_dup_7 = function $$dup() {\n      var self = this;\n\n      return nil\n    }, TMP_NilClass_dup_7.$$arity = 0);\n    \n    Opal.defn(self, '$clone', TMP_NilClass_clone_8 = function $$clone($kwargs) {\n      var self = this, freeze;\n\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      freeze = $kwargs.$$smap[\"freeze\"];\n      if (freeze == null) {\n        freeze = true\n      }\n      return nil\n    }, TMP_NilClass_clone_8.$$arity = -1);\n    \n    Opal.defn(self, '$inspect', TMP_NilClass_inspect_9 = function $$inspect() {\n      var self = this;\n\n      return \"nil\"\n    }, TMP_NilClass_inspect_9.$$arity = 0);\n    \n    Opal.defn(self, '$nil?', TMP_NilClass_nil$q_10 = function() {\n      var self = this;\n\n      return true\n    }, TMP_NilClass_nil$q_10.$$arity = 0);\n    \n    Opal.defn(self, '$singleton_class', TMP_NilClass_singleton_class_11 = function $$singleton_class() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'NilClass')\n    }, TMP_NilClass_singleton_class_11.$$arity = 0);\n    \n    Opal.defn(self, '$to_a', TMP_NilClass_to_a_12 = function $$to_a() {\n      var self = this;\n\n      return []\n    }, TMP_NilClass_to_a_12.$$arity = 0);\n    \n    Opal.defn(self, '$to_h', TMP_NilClass_to_h_13 = function $$to_h() {\n      var self = this;\n\n      return Opal.hash()\n    }, TMP_NilClass_to_h_13.$$arity = 0);\n    \n    Opal.defn(self, '$to_i', TMP_NilClass_to_i_14 = function $$to_i() {\n      var self = this;\n\n      return 0\n    }, TMP_NilClass_to_i_14.$$arity = 0);\n    Opal.alias(self, \"to_f\", \"to_i\");\n    \n    Opal.defn(self, '$to_s', TMP_NilClass_to_s_15 = function $$to_s() {\n      var self = this;\n\n      return \"\"\n    }, TMP_NilClass_to_s_15.$$arity = 0);\n    \n    Opal.defn(self, '$to_c', TMP_NilClass_to_c_16 = function $$to_c() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Complex').$new(0, 0)\n    }, TMP_NilClass_to_c_16.$$arity = 0);\n    \n    Opal.defn(self, '$rationalize', TMP_NilClass_rationalize_17 = function $$rationalize($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if ($truthy($rb_gt(args.$length(), 1))) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'))};\n      return self.$Rational(0, 1);\n    }, TMP_NilClass_rationalize_17.$$arity = -1);\n    \n    Opal.defn(self, '$to_r', TMP_NilClass_to_r_18 = function $$to_r() {\n      var self = this;\n\n      return self.$Rational(0, 1)\n    }, TMP_NilClass_to_r_18.$$arity = 0);\n    return (Opal.defn(self, '$instance_variables', TMP_NilClass_instance_variables_19 = function $$instance_variables() {\n      var self = this;\n\n      return []\n    }, TMP_NilClass_instance_variables_19.$$arity = 0), nil) && 'instance_variables';\n  })($nesting[0], null, $nesting);\n  return Opal.const_set($nesting[0], 'NIL', nil);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/boolean\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$raise', '$name']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Boolean(){};\n    var self = $Boolean = $klass($base, $super, 'Boolean', $Boolean);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Boolean___id___2, TMP_Boolean_$B_3, TMP_Boolean_$_4, TMP_Boolean_$_5, TMP_Boolean_$_6, TMP_Boolean_$eq$eq_7, TMP_Boolean_singleton_class_8, TMP_Boolean_to_s_9, TMP_Boolean_dup_10, TMP_Boolean_clone_11;\n\n    \n    def.$$is_boolean = true;\n    def.$$meta = self;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1;\n\n      \n      \n      Opal.defn(self, '$allocate', TMP_allocate_1 = function $$allocate() {\n        var self = this;\n\n        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"allocator undefined for \" + (self.$name()))\n      }, TMP_allocate_1.$$arity = 0);\n      \n      \n      Opal.udef(self, '$' + \"new\");;\n      return nil;;\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    Opal.defn(self, '$__id__', TMP_Boolean___id___2 = function $$__id__() {\n      var self = this;\n\n      return self.valueOf() ? 2 : 0\n    }, TMP_Boolean___id___2.$$arity = 0);\n    Opal.alias(self, \"object_id\", \"__id__\");\n    \n    Opal.defn(self, '$!', TMP_Boolean_$B_3 = function() {\n      var self = this;\n\n      return self != true\n    }, TMP_Boolean_$B_3.$$arity = 0);\n    \n    Opal.defn(self, '$&', TMP_Boolean_$_4 = function(other) {\n      var self = this;\n\n      return (self == true) ? (other !== false && other !== nil) : false\n    }, TMP_Boolean_$_4.$$arity = 1);\n    \n    Opal.defn(self, '$|', TMP_Boolean_$_5 = function(other) {\n      var self = this;\n\n      return (self == true) ? true : (other !== false && other !== nil)\n    }, TMP_Boolean_$_5.$$arity = 1);\n    \n    Opal.defn(self, '$^', TMP_Boolean_$_6 = function(other) {\n      var self = this;\n\n      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil)\n    }, TMP_Boolean_$_6.$$arity = 1);\n    \n    Opal.defn(self, '$==', TMP_Boolean_$eq$eq_7 = function(other) {\n      var self = this;\n\n      return (self == true) === other.valueOf()\n    }, TMP_Boolean_$eq$eq_7.$$arity = 1);\n    Opal.alias(self, \"equal?\", \"==\");\n    Opal.alias(self, \"eql?\", \"==\");\n    \n    Opal.defn(self, '$singleton_class', TMP_Boolean_singleton_class_8 = function $$singleton_class() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Boolean')\n    }, TMP_Boolean_singleton_class_8.$$arity = 0);\n    \n    Opal.defn(self, '$to_s', TMP_Boolean_to_s_9 = function $$to_s() {\n      var self = this;\n\n      return (self == true) ? 'true' : 'false'\n    }, TMP_Boolean_to_s_9.$$arity = 0);\n    \n    Opal.defn(self, '$dup', TMP_Boolean_dup_10 = function $$dup() {\n      var self = this;\n\n      return self\n    }, TMP_Boolean_dup_10.$$arity = 0);\n    return (Opal.defn(self, '$clone', TMP_Boolean_clone_11 = function $$clone($kwargs) {\n      var self = this, freeze;\n\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      freeze = $kwargs.$$smap[\"freeze\"];\n      if (freeze == null) {\n        freeze = true\n      }\n      return self\n    }, TMP_Boolean_clone_11.$$arity = -1), nil) && 'clone';\n  })($nesting[0], Boolean, $nesting);\n  Opal.const_set($nesting[0], 'TrueClass', Opal.const_get_relative($nesting, 'Boolean'));\n  Opal.const_set($nesting[0], 'FalseClass', Opal.const_get_relative($nesting, 'Boolean'));\n  Opal.const_set($nesting[0], 'TRUE', true);\n  return Opal.const_set($nesting[0], 'FALSE', false);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/comparable\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$===', '$>', '$<', '$equal?', '$<=>', '$normalize', '$raise', '$class']);\n  return (function($base, $parent_nesting) {\n    var $Comparable, self = $Comparable = $module($base, 'Comparable');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Comparable_normalize_1, TMP_Comparable_$eq$eq_2, TMP_Comparable_$gt_3, TMP_Comparable_$gt$eq_4, TMP_Comparable_$lt_5, TMP_Comparable_$lt$eq_6, TMP_Comparable_between$q_7, TMP_Comparable_clamp_8;\n\n    \n    Opal.defs(self, '$normalize', TMP_Comparable_normalize_1 = function $$normalize(what) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](what))) {\n        return what};\n      if ($truthy($rb_gt(what, 0))) {\n        return 1};\n      if ($truthy($rb_lt(what, 0))) {\n        return -1};\n      return 0;\n    }, TMP_Comparable_normalize_1.$$arity = 1);\n    \n    Opal.defn(self, '$==', TMP_Comparable_$eq$eq_2 = function(other) {\n      var self = this, cmp = nil;\n\n      try {\n        \n        if ($truthy(self['$equal?'](other))) {\n          return true};\n        \n      if (self[\"$<=>\"] == Opal.Kernel[\"$<=>\"]) {\n        return false;\n      }\n\n      // check for infinite recursion\n      if (self.$$comparable) {\n        delete self.$$comparable;\n        return false;\n      }\n    ;\n        if ($truthy((cmp = self['$<=>'](other)))) {\n          } else {\n          return false\n        };\n        return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) == 0;\n      } catch ($err) {\n        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {\n          try {\n            return false\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      }\n    }, TMP_Comparable_$eq$eq_2.$$arity = 1);\n    \n    Opal.defn(self, '$>', TMP_Comparable_$gt_3 = function(other) {\n      var self = this, cmp = nil;\n\n      \n      if ($truthy((cmp = self['$<=>'](other)))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (other.$class()) + \" failed\")\n      };\n      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) > 0;\n    }, TMP_Comparable_$gt_3.$$arity = 1);\n    \n    Opal.defn(self, '$>=', TMP_Comparable_$gt$eq_4 = function(other) {\n      var self = this, cmp = nil;\n\n      \n      if ($truthy((cmp = self['$<=>'](other)))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (other.$class()) + \" failed\")\n      };\n      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) >= 0;\n    }, TMP_Comparable_$gt$eq_4.$$arity = 1);\n    \n    Opal.defn(self, '$<', TMP_Comparable_$lt_5 = function(other) {\n      var self = this, cmp = nil;\n\n      \n      if ($truthy((cmp = self['$<=>'](other)))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (other.$class()) + \" failed\")\n      };\n      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) < 0;\n    }, TMP_Comparable_$lt_5.$$arity = 1);\n    \n    Opal.defn(self, '$<=', TMP_Comparable_$lt$eq_6 = function(other) {\n      var self = this, cmp = nil;\n\n      \n      if ($truthy((cmp = self['$<=>'](other)))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (other.$class()) + \" failed\")\n      };\n      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) <= 0;\n    }, TMP_Comparable_$lt$eq_6.$$arity = 1);\n    \n    Opal.defn(self, '$between?', TMP_Comparable_between$q_7 = function(min, max) {\n      var self = this;\n\n      \n      if ($rb_lt(self, min)) {\n        return false};\n      if ($rb_gt(self, max)) {\n        return false};\n      return true;\n    }, TMP_Comparable_between$q_7.$$arity = 2);\n    \n    Opal.defn(self, '$clamp', TMP_Comparable_clamp_8 = function $$clamp(min, max) {\n      var self = this, cmp = nil;\n\n      \n      cmp = min['$<=>'](max);\n      if ($truthy(cmp)) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (min.$class()) + \" with \" + (max.$class()) + \" failed\")\n      };\n      if ($truthy($rb_gt(Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp), 0))) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"min argument must be smaller than max argument\")};\n      if ($truthy($rb_lt(Opal.const_get_relative($nesting, 'Comparable').$normalize(self['$<=>'](min)), 0))) {\n        return min};\n      if ($truthy($rb_gt(Opal.const_get_relative($nesting, 'Comparable').$normalize(self['$<=>'](max)), 0))) {\n        return max};\n      return self;\n    }, TMP_Comparable_clamp_8.$$arity = 2);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/regexp\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$nil?', '$[]', '$raise', '$escape', '$options', '$to_str', '$new', '$join', '$coerce_to!', '$!', '$match', '$coerce_to?', '$begin', '$coerce_to', '$call', '$=~', '$attr_reader', '$===', '$inspect', '$to_a']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $RegexpError(){};\n    var self = $RegexpError = $klass($base, $super, 'RegexpError', $RegexpError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Regexp(){};\n    var self = $Regexp = $klass($base, $super, 'Regexp', $Regexp);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Regexp_$eq$eq_6, TMP_Regexp_$eq$eq$eq_7, TMP_Regexp_$eq$_8, TMP_Regexp_inspect_9, TMP_Regexp_match_10, TMP_Regexp_match$q_11, TMP_Regexp_$_12, TMP_Regexp_source_13, TMP_Regexp_options_14, TMP_Regexp_casefold$q_15;\n\n    \n    Opal.const_set($nesting[0], 'IGNORECASE', 1);\n    Opal.const_set($nesting[0], 'MULTILINE', 4);\n    def.$$is_regexp = true;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1, TMP_escape_2, TMP_last_match_3, TMP_union_4, TMP_new_5;\n\n      \n      \n      Opal.defn(self, '$allocate', TMP_allocate_1 = function $$allocate() {\n        var self = this, $iter = TMP_allocate_1.$$p, $yield = $iter || nil, allocated = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_allocate_1.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        \n        allocated = $send(self, Opal.find_super_dispatcher(self, 'allocate', TMP_allocate_1, false), $zuper, $iter);\n        allocated.uninitialized = true;\n        return allocated;\n      }, TMP_allocate_1.$$arity = 0);\n      \n      Opal.defn(self, '$escape', TMP_escape_2 = function $$escape(string) {\n        var self = this;\n\n        return Opal.escape_regexp(string)\n      }, TMP_escape_2.$$arity = 1);\n      \n      Opal.defn(self, '$last_match', TMP_last_match_3 = function $$last_match(n) {\n        var self = this;\n        if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n        if (n == null) {\n          n = nil;\n        }\n        if ($truthy(n['$nil?']())) {\n          return $gvars[\"~\"]\n          } else {\n          return $gvars[\"~\"]['$[]'](n)\n        }\n      }, TMP_last_match_3.$$arity = -1);\n      Opal.alias(self, \"quote\", \"escape\");\n      \n      Opal.defn(self, '$union', TMP_union_4 = function $$union($a_rest) {\n        var self = this, parts;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        parts = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          parts[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        \n        var is_first_part_array, quoted_validated, part, options, each_part_options;\n        if (parts.length == 0) {\n          return /(?!)/;\n        }\n        // cover the 2 arrays passed as arguments case\n        is_first_part_array = parts[0].$$is_array;\n        if (parts.length > 1 && is_first_part_array) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"no implicit conversion of Array into String\")\n        }\n        // deal with splat issues (related to https://github.com/opal/opal/issues/858)\n        if (is_first_part_array) {\n          parts = parts[0];\n        }\n        options = undefined;\n        quoted_validated = [];\n        for (var i=0; i < parts.length; i++) {\n          part = parts[i];\n          if (part.$$is_string) {\n            quoted_validated.push(self.$escape(part));\n          }\n          else if (part.$$is_regexp) {\n            each_part_options = (part).$options();\n            if (options != undefined && options != each_part_options) {\n              self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"All expressions must use the same options\")\n            }\n            options = each_part_options;\n            quoted_validated.push('('+part.source+')');\n          }\n          else {\n            quoted_validated.push(self.$escape((part).$to_str()));\n          }\n        }\n      ;\n        return self.$new((quoted_validated).$join(\"|\"), options);\n      }, TMP_union_4.$$arity = -1);\n      return (Opal.defn(self, '$new', TMP_new_5 = function(regexp, options) {\n        var self = this;\n\n        \n        if (regexp.$$is_regexp) {\n          return new RegExp(regexp);\n        }\n\n        regexp = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](regexp, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n\n        if (regexp.charAt(regexp.length - 1) === '\\\\' && regexp.charAt(regexp.length - 2) !== '\\\\') {\n          self.$raise(Opal.const_get_relative($nesting, 'RegexpError'), \"\" + \"too short escape sequence: /\" + (regexp) + \"/\")\n        }\n\n        if (options === undefined || options['$!']()) {\n          return new RegExp(regexp);\n        }\n\n        if (options.$$is_number) {\n          var temp = '';\n          if (Opal.const_get_relative($nesting, 'IGNORECASE') & options) { temp += 'i'; }\n          if (Opal.const_get_relative($nesting, 'MULTILINE')  & options) { temp += 'm'; }\n          options = temp;\n        }\n        else {\n          options = 'i';\n        }\n\n        return new RegExp(regexp, options);\n      \n      }, TMP_new_5.$$arity = -2), nil) && 'new';\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    Opal.defn(self, '$==', TMP_Regexp_$eq$eq_6 = function(other) {\n      var self = this;\n\n      return other.constructor == RegExp && self.toString() === other.toString()\n    }, TMP_Regexp_$eq$eq_6.$$arity = 1);\n    \n    Opal.defn(self, '$===', TMP_Regexp_$eq$eq$eq_7 = function(string) {\n      var self = this;\n\n      return self.$match(Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](string, Opal.const_get_relative($nesting, 'String'), \"to_str\")) !== nil\n    }, TMP_Regexp_$eq$eq$eq_7.$$arity = 1);\n    \n    Opal.defn(self, '$=~', TMP_Regexp_$eq$_8 = function(string) {\n      var $a, self = this;\n      if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n      return ($truthy($a = self.$match(string)) ? $gvars[\"~\"].$begin(0) : $a)\n    }, TMP_Regexp_$eq$_8.$$arity = 1);\n    Opal.alias(self, \"eql?\", \"==\");\n    \n    Opal.defn(self, '$inspect', TMP_Regexp_inspect_9 = function $$inspect() {\n      var self = this;\n\n      \n      var regexp_format = /^\\/(.*)\\/([^\\/]*)$/;\n      var value = self.toString();\n      var matches = regexp_format.exec(value);\n      if (matches) {\n        var regexp_pattern = matches[1];\n        var regexp_flags = matches[2];\n        var chars = regexp_pattern.split('');\n        var chars_length = chars.length;\n        var char_escaped = false;\n        var regexp_pattern_escaped = '';\n        for (var i = 0; i < chars_length; i++) {\n          var current_char = chars[i];\n          if (!char_escaped && current_char == '/') {\n            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\\\');\n          }\n          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);\n          if (current_char == '\\\\') {\n            if (char_escaped) {\n              // does not over escape\n              char_escaped = false;\n            } else {\n              char_escaped = true;\n            }\n          } else {\n            char_escaped = false;\n          }\n        }\n        return '/' + regexp_pattern_escaped + '/' + regexp_flags;\n      } else {\n        return value;\n      }\n    \n    }, TMP_Regexp_inspect_9.$$arity = 0);\n    \n    Opal.defn(self, '$match', TMP_Regexp_match_10 = function $$match(string, pos) {\n      var self = this, $iter = TMP_Regexp_match_10.$$p, block = $iter || nil;\n      if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n      if ($iter) TMP_Regexp_match_10.$$p = null;\n      \n      if (self.uninitialized) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"uninitialized Regexp\")\n      }\n\n      if (pos === undefined) {\n        pos = 0;\n      } else {\n        pos = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pos, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (string === nil) {\n        return ($gvars[\"~\"] = nil);\n      }\n\n      string = Opal.const_get_relative($nesting, 'Opal').$coerce_to(string, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n\n      if (pos < 0) {\n        pos += string.length;\n        if (pos < 0) {\n          return ($gvars[\"~\"] = nil);\n        }\n      }\n\n      var source = self.source;\n      var flags = 'g';\n      // m flag + a . in Ruby will match white space, but in JS, it only matches beginning/ending of lines, so we get the equivalent here\n      if (self.multiline) {\n        source = source.replace('.', \"[\\\\s\\\\S]\");\n        flags += 'm';\n      }\n\n      // global RegExp maintains state, so not using self/this\n      var md, re = new RegExp(source, flags + (self.ignoreCase ? 'i' : ''));\n\n      while (true) {\n        md = re.exec(string);\n        if (md === null) {\n          return ($gvars[\"~\"] = nil);\n        }\n        if (md.index >= pos) {\n          ($gvars[\"~\"] = Opal.const_get_relative($nesting, 'MatchData').$new(re, md))\n          return block === nil ? $gvars[\"~\"] : block.$call($gvars[\"~\"]);\n        }\n        re.lastIndex = md.index + 1;\n      }\n    \n    }, TMP_Regexp_match_10.$$arity = -2);\n    \n    Opal.defn(self, '$match?', TMP_Regexp_match$q_11 = function(string, pos) {\n      var self = this;\n\n      \n      if (self.uninitialized) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"uninitialized Regexp\")\n      }\n\n      if (pos === undefined) {\n        pos = 0;\n      } else {\n        pos = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pos, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (string === nil) {\n        return false;\n      }\n\n      string = Opal.const_get_relative($nesting, 'Opal').$coerce_to(string, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n\n      if (pos < 0) {\n        pos += string.length;\n        if (pos < 0) {\n          return false;\n        }\n      }\n\n      var source = self.source;\n      var flags = 'g';\n      // m flag + a . in Ruby will match white space, but in JS, it only matches beginning/ending of lines, so we get the equivalent here\n      if (self.multiline) {\n        source = source.replace('.', \"[\\\\s\\\\S]\");\n        flags += 'm';\n      }\n\n      // global RegExp maintains state, so not using self/this\n      var md, re = new RegExp(source, flags + (self.ignoreCase ? 'i' : ''));\n\n      md = re.exec(string);\n      if (md === null || md.index < pos) {\n        return false;\n      } else {\n        return true;\n      }\n    \n    }, TMP_Regexp_match$q_11.$$arity = -2);\n    \n    Opal.defn(self, '$~', TMP_Regexp_$_12 = function() {\n      var self = this;\n      if ($gvars._ == null) $gvars._ = nil;\n\n      return self['$=~']($gvars._)\n    }, TMP_Regexp_$_12.$$arity = 0);\n    \n    Opal.defn(self, '$source', TMP_Regexp_source_13 = function $$source() {\n      var self = this;\n\n      return self.source\n    }, TMP_Regexp_source_13.$$arity = 0);\n    \n    Opal.defn(self, '$options', TMP_Regexp_options_14 = function $$options() {\n      var self = this;\n\n      \n      if (self.uninitialized) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"uninitialized Regexp\")\n      }\n      var result = 0;\n      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx\n      if (self.multiline) {\n        result |= Opal.const_get_relative($nesting, 'MULTILINE');\n      }\n      if (self.ignoreCase) {\n        result |= Opal.const_get_relative($nesting, 'IGNORECASE');\n      }\n      return result;\n    \n    }, TMP_Regexp_options_14.$$arity = 0);\n    \n    Opal.defn(self, '$casefold?', TMP_Regexp_casefold$q_15 = function() {\n      var self = this;\n\n      return self.ignoreCase\n    }, TMP_Regexp_casefold$q_15.$$arity = 0);\n    return Opal.alias(self, \"to_s\", \"source\");\n  })($nesting[0], RegExp, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $MatchData(){};\n    var self = $MatchData = $klass($base, $super, 'MatchData', $MatchData);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MatchData_initialize_16, TMP_MatchData_$$_17, TMP_MatchData_offset_18, TMP_MatchData_$eq$eq_19, TMP_MatchData_begin_20, TMP_MatchData_end_21, TMP_MatchData_captures_22, TMP_MatchData_inspect_23, TMP_MatchData_length_24, TMP_MatchData_to_a_25, TMP_MatchData_to_s_26, TMP_MatchData_values_at_27;\n\n    def.matches = nil;\n    \n    self.$attr_reader(\"post_match\", \"pre_match\", \"regexp\", \"string\");\n    \n    Opal.defn(self, '$initialize', TMP_MatchData_initialize_16 = function $$initialize(regexp, match_groups) {\n      var self = this;\n\n      \n      $gvars[\"~\"] = self;\n      self.regexp = regexp;\n      self.begin = match_groups.index;\n      self.string = match_groups.input;\n      self.pre_match = match_groups.input.slice(0, match_groups.index);\n      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);\n      self.matches = [];\n      \n      for (var i = 0, length = match_groups.length; i < length; i++) {\n        var group = match_groups[i];\n\n        if (group == null) {\n          self.matches.push(nil);\n        }\n        else {\n          self.matches.push(group);\n        }\n      }\n    ;\n    }, TMP_MatchData_initialize_16.$$arity = 2);\n    \n    Opal.defn(self, '$[]', TMP_MatchData_$$_17 = function($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return $send(self.matches, '[]', Opal.to_a(args))\n    }, TMP_MatchData_$$_17.$$arity = -1);\n    \n    Opal.defn(self, '$offset', TMP_MatchData_offset_18 = function $$offset(n) {\n      var self = this;\n\n      \n      if (n !== 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"MatchData#offset only supports 0th element\")\n      }\n      return [self.begin, self.begin + self.matches[n].length];\n    \n    }, TMP_MatchData_offset_18.$$arity = 1);\n    \n    Opal.defn(self, '$==', TMP_MatchData_$eq$eq_19 = function(other) {\n      var $a, $b, $c, $d, self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'MatchData')['$==='](other))) {\n        } else {\n        return false\n      };\n      return ($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = self.string == other.string) ? self.regexp.toString() == other.regexp.toString() : $d)) ? self.pre_match == other.pre_match : $c)) ? self.post_match == other.post_match : $b)) ? self.begin == other.begin : $a);\n    }, TMP_MatchData_$eq$eq_19.$$arity = 1);\n    Opal.alias(self, \"eql?\", \"==\");\n    \n    Opal.defn(self, '$begin', TMP_MatchData_begin_20 = function $$begin(n) {\n      var self = this;\n\n      \n      if (n !== 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"MatchData#begin only supports 0th element\")\n      }\n      return self.begin;\n    \n    }, TMP_MatchData_begin_20.$$arity = 1);\n    \n    Opal.defn(self, '$end', TMP_MatchData_end_21 = function $$end(n) {\n      var self = this;\n\n      \n      if (n !== 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"MatchData#end only supports 0th element\")\n      }\n      return self.begin + self.matches[n].length;\n    \n    }, TMP_MatchData_end_21.$$arity = 1);\n    \n    Opal.defn(self, '$captures', TMP_MatchData_captures_22 = function $$captures() {\n      var self = this;\n\n      return self.matches.slice(1)\n    }, TMP_MatchData_captures_22.$$arity = 0);\n    \n    Opal.defn(self, '$inspect', TMP_MatchData_inspect_23 = function $$inspect() {\n      var self = this;\n\n      \n      var str = \"#<MatchData \" + (self.matches[0]).$inspect();\n\n      for (var i = 1, length = self.matches.length; i < length; i++) {\n        str += \" \" + i + \":\" + (self.matches[i]).$inspect();\n      }\n\n      return str + \">\";\n    \n    }, TMP_MatchData_inspect_23.$$arity = 0);\n    \n    Opal.defn(self, '$length', TMP_MatchData_length_24 = function $$length() {\n      var self = this;\n\n      return self.matches.length\n    }, TMP_MatchData_length_24.$$arity = 0);\n    Opal.alias(self, \"size\", \"length\");\n    \n    Opal.defn(self, '$to_a', TMP_MatchData_to_a_25 = function $$to_a() {\n      var self = this;\n\n      return self.matches\n    }, TMP_MatchData_to_a_25.$$arity = 0);\n    \n    Opal.defn(self, '$to_s', TMP_MatchData_to_s_26 = function $$to_s() {\n      var self = this;\n\n      return self.matches[0]\n    }, TMP_MatchData_to_s_26.$$arity = 0);\n    return (Opal.defn(self, '$values_at', TMP_MatchData_values_at_27 = function $$values_at($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      var i, a, index, values = [];\n\n      for (i = 0; i < args.length; i++) {\n\n        if (args[i].$$is_range) {\n          a = (args[i]).$to_a();\n          a.unshift(i, 1);\n          Array.prototype.splice.apply(args, a);\n        }\n\n        index = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](args[i], Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n        if (index < 0) {\n          index += self.matches.length;\n          if (index < 0) {\n            values.push(nil);\n            continue;\n          }\n        }\n\n        values.push(self.matches[index]);\n      }\n\n      return values;\n    \n    }, TMP_MatchData_values_at_27.$$arity = -1), nil) && 'values_at';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/string\"] = function(Opal) {\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$coerce_to', '$raise', '$===', '$format', '$to_s', '$respond_to?', '$to_str', '$<=>', '$==', '$=~', '$new', '$empty?', '$ljust', '$ceil', '$/', '$+', '$rjust', '$floor', '$to_a', '$each_char', '$to_proc', '$coerce_to!', '$copy_singleton_methods', '$initialize_clone', '$initialize_dup', '$enum_for', '$size', '$chomp', '$[]', '$to_i', '$each_line', '$class', '$match', '$captures', '$proc', '$succ', '$escape']);\n  \n  self.$require(\"corelib/comparable\");\n  self.$require(\"corelib/regexp\");\n  (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String___id___1, TMP_String_try_convert_2, TMP_String_new_3, TMP_String_initialize_4, TMP_String_$_5, TMP_String_$_6, TMP_String_$_7, TMP_String_$lt$eq$gt_8, TMP_String_$eq$eq_9, TMP_String_$eq$_10, TMP_String_$$_11, TMP_String_capitalize_12, TMP_String_casecmp_13, TMP_String_center_14, TMP_String_chars_15, TMP_String_chomp_16, TMP_String_chop_17, TMP_String_chr_18, TMP_String_clone_19, TMP_String_dup_20, TMP_String_count_21, TMP_String_delete_22, TMP_String_downcase_23, TMP_String_each_char_24, TMP_String_each_line_26, TMP_String_empty$q_27, TMP_String_end_with$q_28, TMP_String_gsub_29, TMP_String_hash_30, TMP_String_hex_31, TMP_String_include$q_32, TMP_String_index_33, TMP_String_inspect_34, TMP_String_intern_35, TMP_String_lines_36, TMP_String_length_37, TMP_String_ljust_38, TMP_String_lstrip_39, TMP_String_ascii_only$q_40, TMP_String_match_41, TMP_String_next_42, TMP_String_oct_43, TMP_String_ord_44, TMP_String_partition_45, TMP_String_reverse_46, TMP_String_rindex_47, TMP_String_rjust_48, TMP_String_rpartition_49, TMP_String_rstrip_50, TMP_String_scan_51, TMP_String_split_52, TMP_String_squeeze_53, TMP_String_start_with$q_54, TMP_String_strip_55, TMP_String_sub_56, TMP_String_sum_57, TMP_String_swapcase_58, TMP_String_to_f_59, TMP_String_to_i_60, TMP_String_to_proc_62, TMP_String_to_s_63, TMP_String_tr_64, TMP_String_tr_s_65, TMP_String_upcase_66, TMP_String_upto_67, TMP_String_instance_variables_68, TMP_String__load_69, TMP_String_unpack_70;\n\n    def.length = nil;\n    \n    self.$include(Opal.const_get_relative($nesting, 'Comparable'));\n    def.$$is_string = true;\n    \n    Opal.defn(self, '$__id__', TMP_String___id___1 = function $$__id__() {\n      var self = this;\n\n      return self.toString()\n    }, TMP_String___id___1.$$arity = 0);\n    Opal.alias(self, \"object_id\", \"__id__\");\n    Opal.defs(self, '$try_convert', TMP_String_try_convert_2 = function $$try_convert(what) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](what, Opal.const_get_relative($nesting, 'String'), \"to_str\")\n    }, TMP_String_try_convert_2.$$arity = 1);\n    Opal.defs(self, '$new', TMP_String_new_3 = function(str) {\n      var self = this;\n\n      if (str == null) {\n        str = \"\";\n      }\n      \n      str = Opal.const_get_relative($nesting, 'Opal').$coerce_to(str, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      return new String(str);\n    }, TMP_String_new_3.$$arity = -1);\n    \n    Opal.defn(self, '$initialize', TMP_String_initialize_4 = function $$initialize(str) {\n      var self = this;\n\n      \n      \n      if (str === undefined) {\n        return self;\n      }\n    ;\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"Mutable strings are not supported in Opal.\");\n    }, TMP_String_initialize_4.$$arity = -1);\n    \n    Opal.defn(self, '$%', TMP_String_$_5 = function(data) {\n      var self = this;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](data))) {\n        return $send(self, 'format', [self].concat(Opal.to_a(data)))\n        } else {\n        return self.$format(self, data)\n      }\n    }, TMP_String_$_5.$$arity = 1);\n    \n    Opal.defn(self, '$*', TMP_String_$_6 = function(count) {\n      var self = this;\n\n      \n      count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n      if (count < 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"negative argument\")\n      }\n\n      if (count === 0) {\n        return '';\n      }\n\n      var result = '',\n          string = self.toString();\n\n      // All credit for the bit-twiddling magic code below goes to Mozilla\n      // polyfill implementation of String.prototype.repeat() posted here:\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\n\n      if (string.length * count >= 1 << 28) {\n        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"multiply count must not overflow maximum string size\")\n      }\n\n      for (;;) {\n        if ((count & 1) === 1) {\n          result += string;\n        }\n        count >>>= 1;\n        if (count === 0) {\n          break;\n        }\n        string += string;\n      }\n\n      return result;\n    \n    }, TMP_String_$_6.$$arity = 1);\n    \n    Opal.defn(self, '$+', TMP_String_$_7 = function(other) {\n      var self = this;\n\n      \n      other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      return self + other.$to_s();\n    }, TMP_String_$_7.$$arity = 1);\n    \n    Opal.defn(self, '$<=>', TMP_String_$lt$eq$gt_8 = function(other) {\n      var self = this;\n\n      if ($truthy(other['$respond_to?'](\"to_str\"))) {\n        \n        other = other.$to_str().$to_s();\n        return self > other ? 1 : (self < other ? -1 : 0);\n        } else {\n        \n        var cmp = other['$<=>'](self);\n\n        if (cmp === nil) {\n          return nil;\n        }\n        else {\n          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);\n        }\n      \n      }\n    }, TMP_String_$lt$eq$gt_8.$$arity = 1);\n    \n    Opal.defn(self, '$==', TMP_String_$eq$eq_9 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_string) {\n        return self.toString() === other.toString();\n      }\n      if (Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](other, \"to_str\")) {\n        return other['$=='](self);\n      }\n      return false;\n    \n    }, TMP_String_$eq$eq_9.$$arity = 1);\n    Opal.alias(self, \"eql?\", \"==\");\n    Opal.alias(self, \"===\", \"==\");\n    \n    Opal.defn(self, '$=~', TMP_String_$eq$_10 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_string) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"type mismatch: String given\");\n      }\n\n      return other['$=~'](self);\n    \n    }, TMP_String_$eq$_10.$$arity = 1);\n    \n    Opal.defn(self, '$[]', TMP_String_$$_11 = function(index, length) {\n      var self = this;\n\n      \n      var size = self.length, exclude;\n\n      if (index.$$is_range) {\n        exclude = index.excl;\n        length  = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index.end, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        index   = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index.begin, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n        if (Math.abs(index) > size) {\n          return nil;\n        }\n\n        if (index < 0) {\n          index += size;\n        }\n\n        if (length < 0) {\n          length += size;\n        }\n\n        if (!exclude) {\n          length += 1;\n        }\n\n        length = length - index;\n\n        if (length < 0) {\n          length = 0;\n        }\n\n        return self.substr(index, length);\n      }\n\n\n      if (index.$$is_string) {\n        if (length != null) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'))\n        }\n        return self.indexOf(index) !== -1 ? index : nil;\n      }\n\n\n      if (index.$$is_regexp) {\n        var match = self.match(index);\n\n        if (match === null) {\n          ($gvars[\"~\"] = nil)\n          return nil;\n        }\n\n        ($gvars[\"~\"] = Opal.const_get_relative($nesting, 'MatchData').$new(index, match))\n\n        if (length == null) {\n          return match[0];\n        }\n\n        length = Opal.const_get_relative($nesting, 'Opal').$coerce_to(length, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n        if (length < 0 && -length < match.length) {\n          return match[length += match.length];\n        }\n\n        if (length >= 0 && length < match.length) {\n          return match[length];\n        }\n\n        return nil;\n      }\n\n\n      index = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n      if (index < 0) {\n        index += size;\n      }\n\n      if (length == null) {\n        if (index >= size || index < 0) {\n          return nil;\n        }\n        return self.substr(index, 1);\n      }\n\n      length = Opal.const_get_relative($nesting, 'Opal').$coerce_to(length, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n      if (length < 0) {\n        return nil;\n      }\n\n      if (index > size || index < 0) {\n        return nil;\n      }\n\n      return self.substr(index, length);\n    \n    }, TMP_String_$$_11.$$arity = -2);\n    Opal.alias(self, \"byteslice\", \"[]\");\n    \n    Opal.defn(self, '$capitalize', TMP_String_capitalize_12 = function $$capitalize() {\n      var self = this;\n\n      return self.charAt(0).toUpperCase() + self.substr(1).toLowerCase()\n    }, TMP_String_capitalize_12.$$arity = 0);\n    \n    Opal.defn(self, '$casecmp', TMP_String_casecmp_13 = function $$casecmp(other) {\n      var self = this;\n\n      \n      other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n      \n      var ascii_only = /^[\\x00-\\x7F]*$/;\n      if (ascii_only.test(self) && ascii_only.test(other)) {\n        self = self.toLowerCase();\n        other = other.toLowerCase();\n      }\n    ;\n      return self['$<=>'](other);\n    }, TMP_String_casecmp_13.$$arity = 1);\n    \n    Opal.defn(self, '$center', TMP_String_center_14 = function $$center(width, padstr) {\n      var self = this;\n\n      if (padstr == null) {\n        padstr = \" \";\n      }\n      \n      width = Opal.const_get_relative($nesting, 'Opal').$coerce_to(width, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      padstr = Opal.const_get_relative($nesting, 'Opal').$coerce_to(padstr, Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n      if ($truthy(padstr['$empty?']())) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"zero width padding\")};\n      if ($truthy(width <= self.length)) {\n        return self};\n      \n      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),\n          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);\n\n      return rjustified + ljustified.slice(self.length);\n    ;\n    }, TMP_String_center_14.$$arity = -2);\n    \n    Opal.defn(self, '$chars', TMP_String_chars_15 = function $$chars() {\n      var self = this, $iter = TMP_String_chars_15.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_chars_15.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return self.$each_char().$to_a()\n      };\n      return $send(self, 'each_char', [], block.$to_proc());\n    }, TMP_String_chars_15.$$arity = 0);\n    \n    Opal.defn(self, '$chomp', TMP_String_chomp_16 = function $$chomp(separator) {\n      var self = this;\n      if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n      if (separator == null) {\n        separator = $gvars[\"/\"];\n      }\n      \n      if ($truthy(separator === nil || self.length === 0)) {\n        return self};\n      separator = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](separator, Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n      \n      if (separator === \"\\n\") {\n        return self.replace(/\\r?\\n?$/, '');\n      }\n      else if (separator === \"\") {\n        return self.replace(/(\\r?\\n)+$/, '');\n      }\n      else if (self.length > separator.length) {\n        var tail = self.substr(self.length - separator.length, separator.length);\n\n        if (tail === separator) {\n          return self.substr(0, self.length - separator.length);\n        }\n      }\n    ;\n      return self;\n    }, TMP_String_chomp_16.$$arity = -1);\n    \n    Opal.defn(self, '$chop', TMP_String_chop_17 = function $$chop() {\n      var self = this;\n\n      \n      var length = self.length;\n\n      if (length <= 1) {\n        return \"\";\n      }\n\n      if (self.charAt(length - 1) === \"\\n\" && self.charAt(length - 2) === \"\\r\") {\n        return self.substr(0, length - 2);\n      }\n      else {\n        return self.substr(0, length - 1);\n      }\n    \n    }, TMP_String_chop_17.$$arity = 0);\n    \n    Opal.defn(self, '$chr', TMP_String_chr_18 = function $$chr() {\n      var self = this;\n\n      return self.charAt(0)\n    }, TMP_String_chr_18.$$arity = 0);\n    \n    Opal.defn(self, '$clone', TMP_String_clone_19 = function $$clone() {\n      var self = this, copy = nil;\n\n      \n      copy = self.slice();\n      copy.$copy_singleton_methods(self);\n      copy.$initialize_clone(self);\n      return copy;\n    }, TMP_String_clone_19.$$arity = 0);\n    \n    Opal.defn(self, '$dup', TMP_String_dup_20 = function $$dup() {\n      var self = this, copy = nil;\n\n      \n      copy = self.slice();\n      copy.$initialize_dup(self);\n      return copy;\n    }, TMP_String_dup_20.$$arity = 0);\n    \n    Opal.defn(self, '$count', TMP_String_count_21 = function $$count($a_rest) {\n      var self = this, sets;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      sets = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        sets[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if (sets.length === 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"ArgumentError: wrong number of arguments (0 for 1+)\")\n      }\n      var char_class = char_class_from_char_sets(sets);\n      if (char_class === null) {\n        return 0;\n      }\n      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;\n    \n    }, TMP_String_count_21.$$arity = -1);\n    \n    Opal.defn(self, '$delete', TMP_String_delete_22 = function($a_rest) {\n      var self = this, sets;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      sets = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        sets[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if (sets.length === 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"ArgumentError: wrong number of arguments (0 for 1+)\")\n      }\n      var char_class = char_class_from_char_sets(sets);\n      if (char_class === null) {\n        return self;\n      }\n      return self.replace(new RegExp(char_class, 'g'), '');\n    \n    }, TMP_String_delete_22.$$arity = -1);\n    \n    Opal.defn(self, '$downcase', TMP_String_downcase_23 = function $$downcase() {\n      var self = this;\n\n      return self.toLowerCase()\n    }, TMP_String_downcase_23.$$arity = 0);\n    \n    Opal.defn(self, '$each_char', TMP_String_each_char_24 = function $$each_char() {\n      var TMP_25, self = this, $iter = TMP_String_each_char_24.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_each_char_24.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"each_char\"], (TMP_25 = function(){var self = TMP_25.$$s || this;\n\n        return self.$size()}, TMP_25.$$s = self, TMP_25.$$arity = 0, TMP_25))\n      };\n      \n      for (var i = 0, length = self.length; i < length; i++) {\n        Opal.yield1(block, self.charAt(i));\n      }\n    ;\n      return self;\n    }, TMP_String_each_char_24.$$arity = 0);\n    \n    Opal.defn(self, '$each_line', TMP_String_each_line_26 = function $$each_line(separator) {\n      var self = this, $iter = TMP_String_each_line_26.$$p, block = $iter || nil;\n      if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n      if (separator == null) {\n        separator = $gvars[\"/\"];\n      }\n      if ($iter) TMP_String_each_line_26.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"each_line\", separator)\n      };\n      \n      if (separator === nil) {\n        Opal.yield1(block, self);\n\n        return self;\n      }\n\n      separator = Opal.const_get_relative($nesting, 'Opal').$coerce_to(separator, Opal.const_get_relative($nesting, 'String'), \"to_str\")\n\n      var a, i, n, length, chomped, trailing, splitted;\n\n      if (separator.length === 0) {\n        for (a = self.split(/(\\n{2,})/), i = 0, n = a.length; i < n; i += 2) {\n          if (a[i] || a[i + 1]) {\n            Opal.yield1(block, (a[i] || \"\") + (a[i + 1] || \"\"));\n          }\n        }\n\n        return self;\n      }\n\n      chomped  = self.$chomp(separator);\n      trailing = self.length != chomped.length;\n      splitted = chomped.split(separator);\n\n      for (i = 0, length = splitted.length; i < length; i++) {\n        if (i < length - 1 || trailing) {\n          Opal.yield1(block, splitted[i] + separator);\n        }\n        else {\n          Opal.yield1(block, splitted[i]);\n        }\n      }\n    ;\n      return self;\n    }, TMP_String_each_line_26.$$arity = -1);\n    \n    Opal.defn(self, '$empty?', TMP_String_empty$q_27 = function() {\n      var self = this;\n\n      return self.length === 0\n    }, TMP_String_empty$q_27.$$arity = 0);\n    \n    Opal.defn(self, '$end_with?', TMP_String_end_with$q_28 = function($a_rest) {\n      var self = this, suffixes;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      suffixes = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        suffixes[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = 0, length = suffixes.length; i < length; i++) {\n        var suffix = Opal.const_get_relative($nesting, 'Opal').$coerce_to(suffixes[i], Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n\n        if (self.length >= suffix.length &&\n            self.substr(self.length - suffix.length, suffix.length) == suffix) {\n          return true;\n        }\n      }\n    ;\n      return false;\n    }, TMP_String_end_with$q_28.$$arity = -1);\n    Opal.alias(self, \"eql?\", \"==\");\n    Opal.alias(self, \"equal?\", \"===\");\n    \n    Opal.defn(self, '$gsub', TMP_String_gsub_29 = function $$gsub(pattern, replacement) {\n      var self = this, $iter = TMP_String_gsub_29.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_gsub_29.$$p = null;\n      \n      if (replacement === undefined && block === nil) {\n        return self.$enum_for(\"gsub\", pattern);\n      }\n\n      var result = '', match_data = nil, index = 0, match, _replacement;\n\n      if (pattern.$$is_regexp) {\n        pattern = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));\n      } else {\n        pattern = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pattern, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gm');\n      }\n\n      while (true) {\n        match = pattern.exec(self);\n\n        if (match === null) {\n          ($gvars[\"~\"] = nil)\n          result += self.slice(index);\n          break;\n        }\n\n        match_data = Opal.const_get_relative($nesting, 'MatchData').$new(pattern, match);\n\n        if (replacement === undefined) {\n          _replacement = block(match[0]);\n        }\n        else if (replacement.$$is_hash) {\n          _replacement = (replacement)['$[]'](match[0]).$to_s();\n        }\n        else {\n          if (!replacement.$$is_string) {\n            replacement = Opal.const_get_relative($nesting, 'Opal').$coerce_to(replacement, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n          }\n          _replacement = replacement.replace(/([\\\\]+)([0-9+&`'])/g, function (original, slashes, command) {\n            if (slashes.length % 2 === 0) {\n              return original;\n            }\n            switch (command) {\n            case \"+\":\n              for (var i = match.length - 1; i > 0; i--) {\n                if (match[i] !== undefined) {\n                  return slashes.slice(1) + match[i];\n                }\n              }\n              return '';\n            case \"&\": return slashes.slice(1) + match[0];\n            case \"`\": return slashes.slice(1) + self.slice(0, match.index);\n            case \"'\": return slashes.slice(1) + self.slice(match.index + match[0].length);\n            default:  return slashes.slice(1) + (match[command] || '');\n            }\n          }).replace(/\\\\\\\\/g, '\\\\');\n        }\n\n        if (pattern.lastIndex === match.index) {\n          result += (_replacement + self.slice(index, match.index + 1))\n          pattern.lastIndex += 1;\n        }\n        else {\n          result += (self.slice(index, match.index) + _replacement)\n        }\n        index = pattern.lastIndex;\n      }\n\n      ($gvars[\"~\"] = match_data)\n      return result;\n    \n    }, TMP_String_gsub_29.$$arity = -2);\n    \n    Opal.defn(self, '$hash', TMP_String_hash_30 = function $$hash() {\n      var self = this;\n\n      return self.toString()\n    }, TMP_String_hash_30.$$arity = 0);\n    \n    Opal.defn(self, '$hex', TMP_String_hex_31 = function $$hex() {\n      var self = this;\n\n      return self.$to_i(16)\n    }, TMP_String_hex_31.$$arity = 0);\n    \n    Opal.defn(self, '$include?', TMP_String_include$q_32 = function(other) {\n      var self = this;\n\n      \n      if (!other.$$is_string) {\n        (other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'String'), \"to_str\"))\n      }\n      return self.indexOf(other) !== -1;\n    \n    }, TMP_String_include$q_32.$$arity = 1);\n    \n    Opal.defn(self, '$index', TMP_String_index_33 = function $$index(search, offset) {\n      var self = this;\n\n      \n      var index,\n          match,\n          regex;\n\n      if (offset === undefined) {\n        offset = 0;\n      } else {\n        offset = Opal.const_get_relative($nesting, 'Opal').$coerce_to(offset, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if (offset < 0) {\n          offset += self.length;\n          if (offset < 0) {\n            return nil;\n          }\n        }\n      }\n\n      if (search.$$is_regexp) {\n        regex = new RegExp(search.source, 'gm' + (search.ignoreCase ? 'i' : ''));\n        while (true) {\n          match = regex.exec(self);\n          if (match === null) {\n            ($gvars[\"~\"] = nil);\n            index = -1;\n            break;\n          }\n          if (match.index >= offset) {\n            ($gvars[\"~\"] = Opal.const_get_relative($nesting, 'MatchData').$new(regex, match))\n            index = match.index;\n            break;\n          }\n          regex.lastIndex = match.index + 1;\n        }\n      } else {\n        search = Opal.const_get_relative($nesting, 'Opal').$coerce_to(search, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n        if (search.length === 0 && offset > self.length) {\n          index = -1;\n        } else {\n          index = self.indexOf(search, offset);\n        }\n      }\n\n      return index === -1 ? nil : index;\n    \n    }, TMP_String_index_33.$$arity = -2);\n    \n    Opal.defn(self, '$inspect', TMP_String_inspect_34 = function $$inspect() {\n      var self = this;\n\n      \n      var escapable = /[\\\\\\\"\\x00-\\x1f\\u007F-\\u009F\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n          meta = {\n            '\\u0007': '\\\\a',\n            '\\u001b': '\\\\e',\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\v': '\\\\v',\n            '\"' : '\\\\\"',\n            '\\\\': '\\\\\\\\'\n          },\n          escaped = self.replace(escapable, function (chr) {\n            return meta[chr] || '\\\\u' + ('0000' + chr.charCodeAt(0).toString(16).toUpperCase()).slice(-4);\n          });\n      return '\"' + escaped.replace(/\\#[\\$\\@\\{]/g, '\\\\$&') + '\"';\n    \n    }, TMP_String_inspect_34.$$arity = 0);\n    \n    Opal.defn(self, '$intern', TMP_String_intern_35 = function $$intern() {\n      var self = this;\n\n      return self\n    }, TMP_String_intern_35.$$arity = 0);\n    \n    Opal.defn(self, '$lines', TMP_String_lines_36 = function $$lines(separator) {\n      var self = this, $iter = TMP_String_lines_36.$$p, block = $iter || nil, e = nil;\n      if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n      if (separator == null) {\n        separator = $gvars[\"/\"];\n      }\n      if ($iter) TMP_String_lines_36.$$p = null;\n      \n      e = $send(self, 'each_line', [separator], block.$to_proc());\n      if ($truthy(block)) {\n        return self\n        } else {\n        return e.$to_a()\n      };\n    }, TMP_String_lines_36.$$arity = -1);\n    \n    Opal.defn(self, '$length', TMP_String_length_37 = function $$length() {\n      var self = this;\n\n      return self.length\n    }, TMP_String_length_37.$$arity = 0);\n    \n    Opal.defn(self, '$ljust', TMP_String_ljust_38 = function $$ljust(width, padstr) {\n      var self = this;\n\n      if (padstr == null) {\n        padstr = \" \";\n      }\n      \n      width = Opal.const_get_relative($nesting, 'Opal').$coerce_to(width, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      padstr = Opal.const_get_relative($nesting, 'Opal').$coerce_to(padstr, Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n      if ($truthy(padstr['$empty?']())) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"zero width padding\")};\n      if ($truthy(width <= self.length)) {\n        return self};\n      \n      var index  = -1,\n          result = \"\";\n\n      width -= self.length;\n\n      while (++index < width) {\n        result += padstr;\n      }\n\n      return self + result.slice(0, width);\n    ;\n    }, TMP_String_ljust_38.$$arity = -2);\n    \n    Opal.defn(self, '$lstrip', TMP_String_lstrip_39 = function $$lstrip() {\n      var self = this;\n\n      return self.replace(/^\\s*/, '')\n    }, TMP_String_lstrip_39.$$arity = 0);\n    \n    Opal.defn(self, '$ascii_only?', TMP_String_ascii_only$q_40 = function() {\n      var self = this;\n\n      return self.match(/[ -~\\n]*/)[0] === self\n    }, TMP_String_ascii_only$q_40.$$arity = 0);\n    \n    Opal.defn(self, '$match', TMP_String_match_41 = function $$match(pattern, pos) {\n      var $a, self = this, $iter = TMP_String_match_41.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_match_41.$$p = null;\n      \n      if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'String')['$==='](pattern)) ? $a : pattern['$respond_to?'](\"to_str\")))) {\n        pattern = Opal.const_get_relative($nesting, 'Regexp').$new(pattern.$to_str())};\n      if ($truthy(Opal.const_get_relative($nesting, 'Regexp')['$==='](pattern))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"wrong argument type \" + (pattern.$class()) + \" (expected Regexp)\")\n      };\n      return $send(pattern, 'match', [self, pos], block.$to_proc());\n    }, TMP_String_match_41.$$arity = -2);\n    \n    Opal.defn(self, '$next', TMP_String_next_42 = function $$next() {\n      var self = this;\n\n      \n      var i = self.length;\n      if (i === 0) {\n        return '';\n      }\n      var result = self;\n      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);\n      var carry = false;\n      var code;\n      while (i--) {\n        code = self.charCodeAt(i);\n        if ((code >= 48 && code <= 57) ||\n          (code >= 65 && code <= 90) ||\n          (code >= 97 && code <= 122)) {\n          switch (code) {\n          case 57:\n            carry = true;\n            code = 48;\n            break;\n          case 90:\n            carry = true;\n            code = 65;\n            break;\n          case 122:\n            carry = true;\n            code = 97;\n            break;\n          default:\n            carry = false;\n            code += 1;\n          }\n        } else {\n          if (first_alphanum_char_index === -1) {\n            if (code === 255) {\n              carry = true;\n              code = 0;\n            } else {\n              carry = false;\n              code += 1;\n            }\n          } else {\n            carry = true;\n          }\n        }\n        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);\n        if (carry && (i === 0 || i === first_alphanum_char_index)) {\n          switch (code) {\n          case 65:\n            break;\n          case 97:\n            break;\n          default:\n            code += 1;\n          }\n          if (i === 0) {\n            result = String.fromCharCode(code) + result;\n          } else {\n            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);\n          }\n          carry = false;\n        }\n        if (!carry) {\n          break;\n        }\n      }\n      return result;\n    \n    }, TMP_String_next_42.$$arity = 0);\n    \n    Opal.defn(self, '$oct', TMP_String_oct_43 = function $$oct() {\n      var self = this;\n\n      \n      var result,\n          string = self,\n          radix = 8;\n\n      if (/^\\s*_/.test(string)) {\n        return 0;\n      }\n\n      string = string.replace(/^(\\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {\n        switch (tail.charAt(0)) {\n        case '+':\n        case '-':\n          return original;\n        case '0':\n          if (tail.charAt(1) === 'x' && flag === '0x') {\n            return original;\n          }\n        }\n        switch (flag) {\n        case '0b':\n          radix = 2;\n          break;\n        case '0':\n        case '0o':\n          radix = 8;\n          break;\n        case '0d':\n          radix = 10;\n          break;\n        case '0x':\n          radix = 16;\n          break;\n        }\n        return head + tail;\n      });\n\n      result = parseInt(string.replace(/_(?!_)/g, ''), radix);\n      return isNaN(result) ? 0 : result;\n    \n    }, TMP_String_oct_43.$$arity = 0);\n    \n    Opal.defn(self, '$ord', TMP_String_ord_44 = function $$ord() {\n      var self = this;\n\n      return self.charCodeAt(0)\n    }, TMP_String_ord_44.$$arity = 0);\n    \n    Opal.defn(self, '$partition', TMP_String_partition_45 = function $$partition(sep) {\n      var self = this;\n\n      \n      var i, m;\n\n      if (sep.$$is_regexp) {\n        m = sep.exec(self);\n        if (m === null) {\n          i = -1;\n        } else {\n          Opal.const_get_relative($nesting, 'MatchData').$new(sep, m);\n          sep = m[0];\n          i = m.index;\n        }\n      } else {\n        sep = Opal.const_get_relative($nesting, 'Opal').$coerce_to(sep, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n        i = self.indexOf(sep);\n      }\n\n      if (i === -1) {\n        return [self, '', ''];\n      }\n\n      return [\n        self.slice(0, i),\n        self.slice(i, i + sep.length),\n        self.slice(i + sep.length)\n      ];\n    \n    }, TMP_String_partition_45.$$arity = 1);\n    \n    Opal.defn(self, '$reverse', TMP_String_reverse_46 = function $$reverse() {\n      var self = this;\n\n      return self.split('').reverse().join('')\n    }, TMP_String_reverse_46.$$arity = 0);\n    \n    Opal.defn(self, '$rindex', TMP_String_rindex_47 = function $$rindex(search, offset) {\n      var self = this;\n\n      \n      var i, m, r, _m;\n\n      if (offset === undefined) {\n        offset = self.length;\n      } else {\n        offset = Opal.const_get_relative($nesting, 'Opal').$coerce_to(offset, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if (offset < 0) {\n          offset += self.length;\n          if (offset < 0) {\n            return nil;\n          }\n        }\n      }\n\n      if (search.$$is_regexp) {\n        m = null;\n        r = new RegExp(search.source, 'gm' + (search.ignoreCase ? 'i' : ''));\n        while (true) {\n          _m = r.exec(self);\n          if (_m === null || _m.index > offset) {\n            break;\n          }\n          m = _m;\n          r.lastIndex = m.index + 1;\n        }\n        if (m === null) {\n          ($gvars[\"~\"] = nil)\n          i = -1;\n        } else {\n          Opal.const_get_relative($nesting, 'MatchData').$new(r, m);\n          i = m.index;\n        }\n      } else {\n        search = Opal.const_get_relative($nesting, 'Opal').$coerce_to(search, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n        i = self.lastIndexOf(search, offset);\n      }\n\n      return i === -1 ? nil : i;\n    \n    }, TMP_String_rindex_47.$$arity = -2);\n    \n    Opal.defn(self, '$rjust', TMP_String_rjust_48 = function $$rjust(width, padstr) {\n      var self = this;\n\n      if (padstr == null) {\n        padstr = \" \";\n      }\n      \n      width = Opal.const_get_relative($nesting, 'Opal').$coerce_to(width, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      padstr = Opal.const_get_relative($nesting, 'Opal').$coerce_to(padstr, Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n      if ($truthy(padstr['$empty?']())) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"zero width padding\")};\n      if ($truthy(width <= self.length)) {\n        return self};\n      \n      var chars     = Math.floor(width - self.length),\n          patterns  = Math.floor(chars / padstr.length),\n          result    = Array(patterns + 1).join(padstr),\n          remaining = chars - result.length;\n\n      return result + padstr.slice(0, remaining) + self;\n    ;\n    }, TMP_String_rjust_48.$$arity = -2);\n    \n    Opal.defn(self, '$rpartition', TMP_String_rpartition_49 = function $$rpartition(sep) {\n      var self = this;\n\n      \n      var i, m, r, _m;\n\n      if (sep.$$is_regexp) {\n        m = null;\n        r = new RegExp(sep.source, 'gm' + (sep.ignoreCase ? 'i' : ''));\n\n        while (true) {\n          _m = r.exec(self);\n          if (_m === null) {\n            break;\n          }\n          m = _m;\n          r.lastIndex = m.index + 1;\n        }\n\n        if (m === null) {\n          i = -1;\n        } else {\n          Opal.const_get_relative($nesting, 'MatchData').$new(r, m);\n          sep = m[0];\n          i = m.index;\n        }\n\n      } else {\n        sep = Opal.const_get_relative($nesting, 'Opal').$coerce_to(sep, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n        i = self.lastIndexOf(sep);\n      }\n\n      if (i === -1) {\n        return ['', '', self];\n      }\n\n      return [\n        self.slice(0, i),\n        self.slice(i, i + sep.length),\n        self.slice(i + sep.length)\n      ];\n    \n    }, TMP_String_rpartition_49.$$arity = 1);\n    \n    Opal.defn(self, '$rstrip', TMP_String_rstrip_50 = function $$rstrip() {\n      var self = this;\n\n      return self.replace(/[\\s\\u0000]*$/, '')\n    }, TMP_String_rstrip_50.$$arity = 0);\n    \n    Opal.defn(self, '$scan', TMP_String_scan_51 = function $$scan(pattern) {\n      var self = this, $iter = TMP_String_scan_51.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_scan_51.$$p = null;\n      \n      var result = [],\n          match_data = nil,\n          match;\n\n      if (pattern.$$is_regexp) {\n        pattern = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));\n      } else {\n        pattern = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pattern, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gm');\n      }\n\n      while ((match = pattern.exec(self)) != null) {\n        match_data = Opal.const_get_relative($nesting, 'MatchData').$new(pattern, match);\n        if (block === nil) {\n          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());\n        } else {\n          match.length == 1 ? block(match[0]) : block.call(self, (match_data).$captures());\n        }\n        if (pattern.lastIndex === match.index) {\n          pattern.lastIndex += 1;\n        }\n      }\n\n      ($gvars[\"~\"] = match_data)\n\n      return (block !== nil ? self : result);\n    \n    }, TMP_String_scan_51.$$arity = 1);\n    Opal.alias(self, \"size\", \"length\");\n    Opal.alias(self, \"slice\", \"[]\");\n    \n    Opal.defn(self, '$split', TMP_String_split_52 = function $$split(pattern, limit) {\n      var $a, self = this;\n      if ($gvars[\";\"] == null) $gvars[\";\"] = nil;\n\n      \n      if (self.length === 0) {\n        return [];\n      }\n\n      if (limit === undefined) {\n        limit = 0;\n      } else {\n        limit = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](limit, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if (limit === 1) {\n          return [self];\n        }\n      }\n\n      if (pattern === undefined || pattern === nil) {\n        pattern = ($truthy($a = $gvars[\";\"]) ? $a : \" \");\n      }\n\n      var result = [],\n          string = self.toString(),\n          index = 0,\n          match,\n          i, ii;\n\n      if (pattern.$$is_regexp) {\n        pattern = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));\n      } else {\n        pattern = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pattern, Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n        if (pattern === ' ') {\n          pattern = /\\s+/gm;\n          string = string.replace(/^\\s+/, '');\n        } else {\n          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gm');\n        }\n      }\n\n      result = string.split(pattern);\n\n      if (result.length === 1 && result[0] === string) {\n        return result;\n      }\n\n      while ((i = result.indexOf(undefined)) !== -1) {\n        result.splice(i, 1);\n      }\n\n      if (limit === 0) {\n        while (result[result.length - 1] === '') {\n          result.length -= 1;\n        }\n        return result;\n      }\n\n      match = pattern.exec(string);\n\n      if (limit < 0) {\n        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {\n          for (i = 0, ii = match.length; i < ii; i++) {\n            result.push('');\n          }\n        }\n        return result;\n      }\n\n      if (match !== null && match[0] === '') {\n        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));\n        return result;\n      }\n\n      if (limit >= result.length) {\n        return result;\n      }\n\n      i = 0;\n      while (match !== null) {\n        i++;\n        index = pattern.lastIndex;\n        if (i + 1 === limit) {\n          break;\n        }\n        match = pattern.exec(string);\n      }\n      result.splice(limit - 1, result.length - 1, string.slice(index));\n      return result;\n    \n    }, TMP_String_split_52.$$arity = -1);\n    \n    Opal.defn(self, '$squeeze', TMP_String_squeeze_53 = function $$squeeze($a_rest) {\n      var self = this, sets;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      sets = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        sets[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if (sets.length === 0) {\n        return self.replace(/(.)\\1+/g, '$1');\n      }\n      var char_class = char_class_from_char_sets(sets);\n      if (char_class === null) {\n        return self;\n      }\n      return self.replace(new RegExp('(' + char_class + ')\\\\1+', 'g'), '$1');\n    \n    }, TMP_String_squeeze_53.$$arity = -1);\n    \n    Opal.defn(self, '$start_with?', TMP_String_start_with$q_54 = function($a_rest) {\n      var self = this, prefixes;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      prefixes = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        prefixes[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      for (var i = 0, length = prefixes.length; i < length; i++) {\n        var prefix = Opal.const_get_relative($nesting, 'Opal').$coerce_to(prefixes[i], Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n\n        if (self.indexOf(prefix) === 0) {\n          return true;\n        }\n      }\n\n      return false;\n    \n    }, TMP_String_start_with$q_54.$$arity = -1);\n    \n    Opal.defn(self, '$strip', TMP_String_strip_55 = function $$strip() {\n      var self = this;\n\n      return self.replace(/^\\s*/, '').replace(/[\\s\\u0000]*$/, '')\n    }, TMP_String_strip_55.$$arity = 0);\n    \n    Opal.defn(self, '$sub', TMP_String_sub_56 = function $$sub(pattern, replacement) {\n      var self = this, $iter = TMP_String_sub_56.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_sub_56.$$p = null;\n      \n      if (!pattern.$$is_regexp) {\n        pattern = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pattern, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'));\n      }\n\n      var result = pattern.exec(self);\n\n      if (result === null) {\n        ($gvars[\"~\"] = nil)\n        return self.toString();\n      }\n\n      Opal.const_get_relative($nesting, 'MatchData').$new(pattern, result)\n\n      if (replacement === undefined) {\n        if (block === nil) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"wrong number of arguments (1 for 2)\")\n        }\n        return self.slice(0, result.index) + block(result[0]) + self.slice(result.index + result[0].length);\n      }\n\n      if (replacement.$$is_hash) {\n        return self.slice(0, result.index) + (replacement)['$[]'](result[0]).$to_s() + self.slice(result.index + result[0].length);\n      }\n\n      replacement = Opal.const_get_relative($nesting, 'Opal').$coerce_to(replacement, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n\n      replacement = replacement.replace(/([\\\\]+)([0-9+&`'])/g, function (original, slashes, command) {\n        if (slashes.length % 2 === 0) {\n          return original;\n        }\n        switch (command) {\n        case \"+\":\n          for (var i = result.length - 1; i > 0; i--) {\n            if (result[i] !== undefined) {\n              return slashes.slice(1) + result[i];\n            }\n          }\n          return '';\n        case \"&\": return slashes.slice(1) + result[0];\n        case \"`\": return slashes.slice(1) + self.slice(0, result.index);\n        case \"'\": return slashes.slice(1) + self.slice(result.index + result[0].length);\n        default:  return slashes.slice(1) + (result[command] || '');\n        }\n      }).replace(/\\\\\\\\/g, '\\\\');\n\n      return self.slice(0, result.index) + replacement + self.slice(result.index + result[0].length);\n    \n    }, TMP_String_sub_56.$$arity = -2);\n    Opal.alias(self, \"succ\", \"next\");\n    \n    Opal.defn(self, '$sum', TMP_String_sum_57 = function $$sum(n) {\n      var self = this;\n\n      if (n == null) {\n        n = 16;\n      }\n      \n      n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n      var result = 0,\n          length = self.length,\n          i = 0;\n\n      for (; i < length; i++) {\n        result += self.charCodeAt(i);\n      }\n\n      if (n <= 0) {\n        return result;\n      }\n\n      return result & (Math.pow(2, n) - 1);\n    \n    }, TMP_String_sum_57.$$arity = -1);\n    \n    Opal.defn(self, '$swapcase', TMP_String_swapcase_58 = function $$swapcase() {\n      var self = this;\n\n      \n      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {\n        return $1 ? $0.toUpperCase() : $0.toLowerCase();\n      });\n\n      if (self.constructor === String) {\n        return str;\n      }\n\n      return self.$class().$new(str);\n    \n    }, TMP_String_swapcase_58.$$arity = 0);\n    \n    Opal.defn(self, '$to_f', TMP_String_to_f_59 = function $$to_f() {\n      var self = this;\n\n      \n      if (self.charAt(0) === '_') {\n        return 0;\n      }\n\n      var result = parseFloat(self.replace(/_/g, ''));\n\n      if (isNaN(result) || result == Infinity || result == -Infinity) {\n        return 0;\n      }\n      else {\n        return result;\n      }\n    \n    }, TMP_String_to_f_59.$$arity = 0);\n    \n    Opal.defn(self, '$to_i', TMP_String_to_i_60 = function $$to_i(base) {\n      var self = this;\n\n      if (base == null) {\n        base = 10;\n      }\n      \n      var result,\n          string = self.toLowerCase(),\n          radix = Opal.const_get_relative($nesting, 'Opal').$coerce_to(base, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n      if (radix === 1 || radix < 0 || radix > 36) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid radix \" + (radix))\n      }\n\n      if (/^\\s*_/.test(string)) {\n        return 0;\n      }\n\n      string = string.replace(/^(\\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {\n        switch (tail.charAt(0)) {\n        case '+':\n        case '-':\n          return original;\n        case '0':\n          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {\n            return original;\n          }\n        }\n        switch (flag) {\n        case '0b':\n          if (radix === 0 || radix === 2) {\n            radix = 2;\n            return head + tail;\n          }\n          break;\n        case '0':\n        case '0o':\n          if (radix === 0 || radix === 8) {\n            radix = 8;\n            return head + tail;\n          }\n          break;\n        case '0d':\n          if (radix === 0 || radix === 10) {\n            radix = 10;\n            return head + tail;\n          }\n          break;\n        case '0x':\n          if (radix === 0 || radix === 16) {\n            radix = 16;\n            return head + tail;\n          }\n          break;\n        }\n        return original\n      });\n\n      result = parseInt(string.replace(/_(?!_)/g, ''), radix);\n      return isNaN(result) ? 0 : result;\n    \n    }, TMP_String_to_i_60.$$arity = -1);\n    \n    Opal.defn(self, '$to_proc', TMP_String_to_proc_62 = function $$to_proc() {\n      var TMP_61, self = this, sym = nil;\n\n      \n      sym = self.valueOf();\n      return $send(self, 'proc', [], (TMP_61 = function($a_rest){var self = TMP_61.$$s || this, block, args;\n\n        block = TMP_61.$$p || nil;\n        if (block) TMP_61.$$p = null;\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        if (args.length === 0) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"no receiver given\")\n        }\n        var obj = args.shift();\n        if (obj == null) obj = nil;\n        return Opal.send(obj, sym, args, block);\n      }, TMP_61.$$s = self, TMP_61.$$arity = -1, TMP_61));\n    }, TMP_String_to_proc_62.$$arity = 0);\n    \n    Opal.defn(self, '$to_s', TMP_String_to_s_63 = function $$to_s() {\n      var self = this;\n\n      return self.toString()\n    }, TMP_String_to_s_63.$$arity = 0);\n    Opal.alias(self, \"to_str\", \"to_s\");\n    Opal.alias(self, \"to_sym\", \"intern\");\n    \n    Opal.defn(self, '$tr', TMP_String_tr_64 = function $$tr(from, to) {\n      var self = this;\n\n      \n      from = Opal.const_get_relative($nesting, 'Opal').$coerce_to(from, Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n      to = Opal.const_get_relative($nesting, 'Opal').$coerce_to(to, Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n      \n      if (from.length == 0 || from === to) {\n        return self;\n      }\n\n      var i, in_range, c, ch, start, end, length;\n      var subs = {};\n      var from_chars = from.split('');\n      var from_length = from_chars.length;\n      var to_chars = to.split('');\n      var to_length = to_chars.length;\n\n      var inverse = false;\n      var global_sub = null;\n      if (from_chars[0] === '^' && from_chars.length > 1) {\n        inverse = true;\n        from_chars.shift();\n        global_sub = to_chars[to_length - 1]\n        from_length -= 1;\n      }\n\n      var from_chars_expanded = [];\n      var last_from = null;\n      in_range = false;\n      for (i = 0; i < from_length; i++) {\n        ch = from_chars[i];\n        if (last_from == null) {\n          last_from = ch;\n          from_chars_expanded.push(ch);\n        }\n        else if (ch === '-') {\n          if (last_from === '-') {\n            from_chars_expanded.push('-');\n            from_chars_expanded.push('-');\n          }\n          else if (i == from_length - 1) {\n            from_chars_expanded.push('-');\n          }\n          else {\n            in_range = true;\n          }\n        }\n        else if (in_range) {\n          start = last_from.charCodeAt(0);\n          end = ch.charCodeAt(0);\n          if (start > end) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid range \\\"\" + (String.fromCharCode(start)) + \"-\" + (String.fromCharCode(end)) + \"\\\" in string transliteration\")\n          }\n          for (c = start + 1; c < end; c++) {\n            from_chars_expanded.push(String.fromCharCode(c));\n          }\n          from_chars_expanded.push(ch);\n          in_range = null;\n          last_from = null;\n        }\n        else {\n          from_chars_expanded.push(ch);\n        }\n      }\n\n      from_chars = from_chars_expanded;\n      from_length = from_chars.length;\n\n      if (inverse) {\n        for (i = 0; i < from_length; i++) {\n          subs[from_chars[i]] = true;\n        }\n      }\n      else {\n        if (to_length > 0) {\n          var to_chars_expanded = [];\n          var last_to = null;\n          in_range = false;\n          for (i = 0; i < to_length; i++) {\n            ch = to_chars[i];\n            if (last_to == null) {\n              last_to = ch;\n              to_chars_expanded.push(ch);\n            }\n            else if (ch === '-') {\n              if (last_to === '-') {\n                to_chars_expanded.push('-');\n                to_chars_expanded.push('-');\n              }\n              else if (i == to_length - 1) {\n                to_chars_expanded.push('-');\n              }\n              else {\n                in_range = true;\n              }\n            }\n            else if (in_range) {\n              start = last_to.charCodeAt(0);\n              end = ch.charCodeAt(0);\n              if (start > end) {\n                self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid range \\\"\" + (String.fromCharCode(start)) + \"-\" + (String.fromCharCode(end)) + \"\\\" in string transliteration\")\n              }\n              for (c = start + 1; c < end; c++) {\n                to_chars_expanded.push(String.fromCharCode(c));\n              }\n              to_chars_expanded.push(ch);\n              in_range = null;\n              last_to = null;\n            }\n            else {\n              to_chars_expanded.push(ch);\n            }\n          }\n\n          to_chars = to_chars_expanded;\n          to_length = to_chars.length;\n        }\n\n        var length_diff = from_length - to_length;\n        if (length_diff > 0) {\n          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');\n          for (i = 0; i < length_diff; i++) {\n            to_chars.push(pad_char);\n          }\n        }\n\n        for (i = 0; i < from_length; i++) {\n          subs[from_chars[i]] = to_chars[i];\n        }\n      }\n\n      var new_str = ''\n      for (i = 0, length = self.length; i < length; i++) {\n        ch = self.charAt(i);\n        var sub = subs[ch];\n        if (inverse) {\n          new_str += (sub == null ? global_sub : ch);\n        }\n        else {\n          new_str += (sub != null ? sub : ch);\n        }\n      }\n      return new_str;\n    ;\n    }, TMP_String_tr_64.$$arity = 2);\n    \n    Opal.defn(self, '$tr_s', TMP_String_tr_s_65 = function $$tr_s(from, to) {\n      var self = this;\n\n      \n      from = Opal.const_get_relative($nesting, 'Opal').$coerce_to(from, Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n      to = Opal.const_get_relative($nesting, 'Opal').$coerce_to(to, Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s();\n      \n      if (from.length == 0) {\n        return self;\n      }\n\n      var i, in_range, c, ch, start, end, length;\n      var subs = {};\n      var from_chars = from.split('');\n      var from_length = from_chars.length;\n      var to_chars = to.split('');\n      var to_length = to_chars.length;\n\n      var inverse = false;\n      var global_sub = null;\n      if (from_chars[0] === '^' && from_chars.length > 1) {\n        inverse = true;\n        from_chars.shift();\n        global_sub = to_chars[to_length - 1]\n        from_length -= 1;\n      }\n\n      var from_chars_expanded = [];\n      var last_from = null;\n      in_range = false;\n      for (i = 0; i < from_length; i++) {\n        ch = from_chars[i];\n        if (last_from == null) {\n          last_from = ch;\n          from_chars_expanded.push(ch);\n        }\n        else if (ch === '-') {\n          if (last_from === '-') {\n            from_chars_expanded.push('-');\n            from_chars_expanded.push('-');\n          }\n          else if (i == from_length - 1) {\n            from_chars_expanded.push('-');\n          }\n          else {\n            in_range = true;\n          }\n        }\n        else if (in_range) {\n          start = last_from.charCodeAt(0);\n          end = ch.charCodeAt(0);\n          if (start > end) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid range \\\"\" + (String.fromCharCode(start)) + \"-\" + (String.fromCharCode(end)) + \"\\\" in string transliteration\")\n          }\n          for (c = start + 1; c < end; c++) {\n            from_chars_expanded.push(String.fromCharCode(c));\n          }\n          from_chars_expanded.push(ch);\n          in_range = null;\n          last_from = null;\n        }\n        else {\n          from_chars_expanded.push(ch);\n        }\n      }\n\n      from_chars = from_chars_expanded;\n      from_length = from_chars.length;\n\n      if (inverse) {\n        for (i = 0; i < from_length; i++) {\n          subs[from_chars[i]] = true;\n        }\n      }\n      else {\n        if (to_length > 0) {\n          var to_chars_expanded = [];\n          var last_to = null;\n          in_range = false;\n          for (i = 0; i < to_length; i++) {\n            ch = to_chars[i];\n            if (last_from == null) {\n              last_from = ch;\n              to_chars_expanded.push(ch);\n            }\n            else if (ch === '-') {\n              if (last_to === '-') {\n                to_chars_expanded.push('-');\n                to_chars_expanded.push('-');\n              }\n              else if (i == to_length - 1) {\n                to_chars_expanded.push('-');\n              }\n              else {\n                in_range = true;\n              }\n            }\n            else if (in_range) {\n              start = last_from.charCodeAt(0);\n              end = ch.charCodeAt(0);\n              if (start > end) {\n                self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid range \\\"\" + (String.fromCharCode(start)) + \"-\" + (String.fromCharCode(end)) + \"\\\" in string transliteration\")\n              }\n              for (c = start + 1; c < end; c++) {\n                to_chars_expanded.push(String.fromCharCode(c));\n              }\n              to_chars_expanded.push(ch);\n              in_range = null;\n              last_from = null;\n            }\n            else {\n              to_chars_expanded.push(ch);\n            }\n          }\n\n          to_chars = to_chars_expanded;\n          to_length = to_chars.length;\n        }\n\n        var length_diff = from_length - to_length;\n        if (length_diff > 0) {\n          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');\n          for (i = 0; i < length_diff; i++) {\n            to_chars.push(pad_char);\n          }\n        }\n\n        for (i = 0; i < from_length; i++) {\n          subs[from_chars[i]] = to_chars[i];\n        }\n      }\n      var new_str = ''\n      var last_substitute = null\n      for (i = 0, length = self.length; i < length; i++) {\n        ch = self.charAt(i);\n        var sub = subs[ch]\n        if (inverse) {\n          if (sub == null) {\n            if (last_substitute == null) {\n              new_str += global_sub;\n              last_substitute = true;\n            }\n          }\n          else {\n            new_str += ch;\n            last_substitute = null;\n          }\n        }\n        else {\n          if (sub != null) {\n            if (last_substitute == null || last_substitute !== sub) {\n              new_str += sub;\n              last_substitute = sub;\n            }\n          }\n          else {\n            new_str += ch;\n            last_substitute = null;\n          }\n        }\n      }\n      return new_str;\n    ;\n    }, TMP_String_tr_s_65.$$arity = 2);\n    \n    Opal.defn(self, '$upcase', TMP_String_upcase_66 = function $$upcase() {\n      var self = this;\n\n      return self.toUpperCase()\n    }, TMP_String_upcase_66.$$arity = 0);\n    \n    Opal.defn(self, '$upto', TMP_String_upto_67 = function $$upto(stop, excl) {\n      var self = this, $iter = TMP_String_upto_67.$$p, block = $iter || nil;\n\n      if (excl == null) {\n        excl = false;\n      }\n      if ($iter) TMP_String_upto_67.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"upto\", stop, excl)\n      };\n      stop = Opal.const_get_relative($nesting, 'Opal').$coerce_to(stop, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      \n      var a, b, s = self.toString();\n\n      if (s.length === 1 && stop.length === 1) {\n\n        a = s.charCodeAt(0);\n        b = stop.charCodeAt(0);\n\n        while (a <= b) {\n          if (excl && a === b) {\n            break;\n          }\n\n          block(String.fromCharCode(a));\n\n          a += 1;\n        }\n\n      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {\n\n        a = parseInt(s, 10);\n        b = parseInt(stop, 10);\n\n        while (a <= b) {\n          if (excl && a === b) {\n            break;\n          }\n\n          block(a.toString());\n\n          a += 1;\n        }\n\n      } else {\n\n        while (s.length <= stop.length && s <= stop) {\n          if (excl && s === stop) {\n            break;\n          }\n\n          block(s);\n\n          s = (s).$succ();\n        }\n\n      }\n      return self;\n    ;\n    }, TMP_String_upto_67.$$arity = -2);\n    \n    function char_class_from_char_sets(sets) {\n      function explode_sequences_in_character_set(set) {\n        var result = '',\n            i, len = set.length,\n            curr_char,\n            skip_next_dash,\n            char_code_from,\n            char_code_upto,\n            char_code;\n        for (i = 0; i < len; i++) {\n          curr_char = set.charAt(i);\n          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {\n            char_code_from = set.charCodeAt(i - 1);\n            char_code_upto = set.charCodeAt(i + 1);\n            if (char_code_from > char_code_upto) {\n              self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid range \\\"\" + (char_code_from) + \"-\" + (char_code_upto) + \"\\\" in string transliteration\")\n            }\n            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {\n              result += String.fromCharCode(char_code);\n            }\n            skip_next_dash = true;\n            i++;\n          } else {\n            skip_next_dash = (curr_char === '\\\\');\n            result += curr_char;\n          }\n        }\n        return result;\n      }\n\n      function intersection(setA, setB) {\n        if (setA.length === 0) {\n          return setB;\n        }\n        var result = '',\n            i, len = setA.length,\n            chr;\n        for (i = 0; i < len; i++) {\n          chr = setA.charAt(i);\n          if (setB.indexOf(chr) !== -1) {\n            result += chr;\n          }\n        }\n        return result;\n      }\n\n      var i, len, set, neg, chr, tmp,\n          pos_intersection = '',\n          neg_intersection = '';\n\n      for (i = 0, len = sets.length; i < len; i++) {\n        set = Opal.const_get_relative($nesting, 'Opal').$coerce_to(sets[i], Opal.const_get_relative($nesting, 'String'), \"to_str\");\n        neg = (set.charAt(0) === '^' && set.length > 1);\n        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);\n        if (neg) {\n          neg_intersection = intersection(neg_intersection, set);\n        } else {\n          pos_intersection = intersection(pos_intersection, set);\n        }\n      }\n\n      if (pos_intersection.length > 0 && neg_intersection.length > 0) {\n        tmp = '';\n        for (i = 0, len = pos_intersection.length; i < len; i++) {\n          chr = pos_intersection.charAt(i);\n          if (neg_intersection.indexOf(chr) === -1) {\n            tmp += chr;\n          }\n        }\n        pos_intersection = tmp;\n        neg_intersection = '';\n      }\n\n      if (pos_intersection.length > 0) {\n        return '[' + Opal.const_get_relative($nesting, 'Regexp').$escape(pos_intersection) + ']';\n      }\n\n      if (neg_intersection.length > 0) {\n        return '[^' + Opal.const_get_relative($nesting, 'Regexp').$escape(neg_intersection) + ']';\n      }\n\n      return null;\n    }\n  ;\n    \n    Opal.defn(self, '$instance_variables', TMP_String_instance_variables_68 = function $$instance_variables() {\n      var self = this;\n\n      return []\n    }, TMP_String_instance_variables_68.$$arity = 0);\n    Opal.defs(self, '$_load', TMP_String__load_69 = function $$_load($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return $send(self, 'new', Opal.to_a(args))\n    }, TMP_String__load_69.$$arity = -1);\n    return (Opal.defn(self, '$unpack', TMP_String_unpack_70 = function $$unpack(pattern) {\n      var self = this, $case = nil;\n\n      \n      \n      function stringToBytes(string) {\n        var i,\n            singleByte,\n            l = string.length,\n            result = [];\n\n        for (i = 0; i < l; i++) {\n          singleByte = string.charCodeAt(i);\n          result.push(singleByte);\n        }\n        return result;\n      }\n    ;\n      return (function() {$case = pattern;\n      if (\"U*\"['$===']($case) || \"C*\"['$===']($case)) {return stringToBytes(self);}\n      else {return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))}})();\n    }, TMP_String_unpack_70.$$arity = 1), nil) && 'unpack';\n  })($nesting[0], String, $nesting);\n  return Opal.const_set($nesting[0], 'Symbol', Opal.const_get_relative($nesting, 'String'));\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/enumerable\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy, $falsy = Opal.falsy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$each', '$destructure', '$to_enum', '$enumerator_size', '$new', '$yield', '$raise', '$slice_when', '$!', '$enum_for', '$flatten', '$map', '$warn', '$proc', '$==', '$nil?', '$respond_to?', '$coerce_to!', '$>', '$*', '$coerce_to', '$try_convert', '$<', '$+', '$-', '$ceil', '$/', '$size', '$===', '$<<', '$[]', '$[]=', '$inspect', '$__send__', '$<=>', '$first', '$reverse', '$sort', '$to_proc', '$compare', '$call', '$dup', '$to_a', '$lambda', '$sort!', '$map!', '$has_key?', '$values', '$zip']);\n  return (function($base, $parent_nesting) {\n    var $Enumerable, self = $Enumerable = $module($base, 'Enumerable');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Enumerable_all$q_1, TMP_Enumerable_any$q_4, TMP_Enumerable_chunk_7, TMP_Enumerable_chunk_while_10, TMP_Enumerable_collect_12, TMP_Enumerable_collect_concat_14, TMP_Enumerable_count_17, TMP_Enumerable_cycle_21, TMP_Enumerable_detect_23, TMP_Enumerable_drop_25, TMP_Enumerable_drop_while_26, TMP_Enumerable_each_cons_27, TMP_Enumerable_each_entry_29, TMP_Enumerable_each_slice_31, TMP_Enumerable_each_with_index_33, TMP_Enumerable_each_with_object_35, TMP_Enumerable_entries_37, TMP_Enumerable_find_all_38, TMP_Enumerable_find_index_40, TMP_Enumerable_first_45, TMP_Enumerable_grep_46, TMP_Enumerable_grep_v_47, TMP_Enumerable_group_by_48, TMP_Enumerable_include$q_51, TMP_Enumerable_inject_52, TMP_Enumerable_lazy_54, TMP_Enumerable_enumerator_size_55, TMP_Enumerable_max_56, TMP_Enumerable_max_by_57, TMP_Enumerable_min_59, TMP_Enumerable_min_by_60, TMP_Enumerable_minmax_62, TMP_Enumerable_minmax_by_64, TMP_Enumerable_none$q_65, TMP_Enumerable_one$q_68, TMP_Enumerable_partition_71, TMP_Enumerable_reject_73, TMP_Enumerable_reverse_each_75, TMP_Enumerable_slice_before_77, TMP_Enumerable_slice_after_79, TMP_Enumerable_slice_when_82, TMP_Enumerable_sort_84, TMP_Enumerable_sort_by_86, TMP_Enumerable_sum_91, TMP_Enumerable_take_93, TMP_Enumerable_take_while_94, TMP_Enumerable_uniq_96, TMP_Enumerable_zip_98;\n\n    \n    \n    Opal.defn(self, '$all?', TMP_Enumerable_all$q_1 = function() {try {\n\n      var TMP_2, TMP_3, self = this, $iter = TMP_Enumerable_all$q_1.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_all$q_1.$$p = null;\n      \n      if ((block !== nil)) {\n        $send(self, 'each', [], (TMP_2 = function($a_rest){var self = TMP_2.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {\n            return nil\n            } else {\n            Opal.ret(false)\n          }}, TMP_2.$$s = self, TMP_2.$$arity = -1, TMP_2))\n        } else {\n        $send(self, 'each', [], (TMP_3 = function($a_rest){var self = TMP_3.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy(Opal.const_get_relative($nesting, 'Opal').$destructure(value))) {\n            return nil\n            } else {\n            Opal.ret(false)\n          }}, TMP_3.$$s = self, TMP_3.$$arity = -1, TMP_3))\n      };\n      return true;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_all$q_1.$$arity = 0);\n    \n    Opal.defn(self, '$any?', TMP_Enumerable_any$q_4 = function() {try {\n\n      var TMP_5, TMP_6, self = this, $iter = TMP_Enumerable_any$q_4.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_any$q_4.$$p = null;\n      \n      if ((block !== nil)) {\n        $send(self, 'each', [], (TMP_5 = function($a_rest){var self = TMP_5.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {\n            Opal.ret(true)\n            } else {\n            return nil\n          }}, TMP_5.$$s = self, TMP_5.$$arity = -1, TMP_5))\n        } else {\n        $send(self, 'each', [], (TMP_6 = function($a_rest){var self = TMP_6.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy(Opal.const_get_relative($nesting, 'Opal').$destructure(value))) {\n            Opal.ret(true)\n            } else {\n            return nil\n          }}, TMP_6.$$s = self, TMP_6.$$arity = -1, TMP_6))\n      };\n      return false;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_any$q_4.$$arity = 0);\n    \n    Opal.defn(self, '$chunk', TMP_Enumerable_chunk_7 = function $$chunk() {\n      var TMP_8, TMP_9, self = this, $iter = TMP_Enumerable_chunk_7.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_chunk_7.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'to_enum', [\"chunk\"], (TMP_8 = function(){var self = TMP_8.$$s || this;\n\n        return self.$enumerator_size()}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8))\n      };\n      return $send(Opal.const_get_qualified('::', 'Enumerator'), 'new', [], (TMP_9 = function(yielder){var self = TMP_9.$$s || this;\nif (yielder == null) yielder = nil;\n      \n        var previous = nil, accumulate = [];\n\n        function releaseAccumulate() {\n          if (accumulate.length > 0) {\n            yielder.$yield(previous, accumulate)\n          }\n        }\n\n        self.$each.$$p = function(value) {\n          var key = Opal.yield1(block, value);\n\n          if (key === nil) {\n            releaseAccumulate();\n            accumulate = [];\n            previous = nil;\n          } else {\n            if (previous === nil || previous === key) {\n              accumulate.push(value);\n            } else {\n              releaseAccumulate();\n              accumulate = [value];\n            }\n\n            previous = key;\n          }\n        }\n\n        self.$each();\n\n        releaseAccumulate();\n      }, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9));\n    }, TMP_Enumerable_chunk_7.$$arity = 0);\n    \n    Opal.defn(self, '$chunk_while', TMP_Enumerable_chunk_while_10 = function $$chunk_while() {\n      var TMP_11, self = this, $iter = TMP_Enumerable_chunk_while_10.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_chunk_while_10.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"no block given\")\n      };\n      return $send(self, 'slice_when', [], (TMP_11 = function(before, after){var self = TMP_11.$$s || this;\nif (before == null) before = nil;if (after == null) after = nil;\n      return Opal.yieldX(block, [before, after])['$!']()}, TMP_11.$$s = self, TMP_11.$$arity = 2, TMP_11));\n    }, TMP_Enumerable_chunk_while_10.$$arity = 0);\n    \n    Opal.defn(self, '$collect', TMP_Enumerable_collect_12 = function $$collect() {\n      var TMP_13, self = this, $iter = TMP_Enumerable_collect_12.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_collect_12.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"collect\"], (TMP_13 = function(){var self = TMP_13.$$s || this;\n\n        return self.$enumerator_size()}, TMP_13.$$s = self, TMP_13.$$arity = 0, TMP_13))\n      };\n      \n      var result = [];\n\n      self.$each.$$p = function() {\n        var value = Opal.yieldX(block, arguments);\n\n        result.push(value);\n      };\n\n      self.$each();\n\n      return result;\n    ;\n    }, TMP_Enumerable_collect_12.$$arity = 0);\n    \n    Opal.defn(self, '$collect_concat', TMP_Enumerable_collect_concat_14 = function $$collect_concat() {\n      var TMP_15, TMP_16, self = this, $iter = TMP_Enumerable_collect_concat_14.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_collect_concat_14.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"collect_concat\"], (TMP_15 = function(){var self = TMP_15.$$s || this;\n\n        return self.$enumerator_size()}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15))\n      };\n      return $send(self, 'map', [], (TMP_16 = function(item){var self = TMP_16.$$s || this;\nif (item == null) item = nil;\n      return Opal.yield1(block, item);}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16)).$flatten(1);\n    }, TMP_Enumerable_collect_concat_14.$$arity = 0);\n    \n    Opal.defn(self, '$count', TMP_Enumerable_count_17 = function $$count(object) {\n      var TMP_18, TMP_19, TMP_20, self = this, $iter = TMP_Enumerable_count_17.$$p, block = $iter || nil, result = nil;\n\n      if ($iter) TMP_Enumerable_count_17.$$p = null;\n      \n      result = 0;\n      \n      if (object != null && block !== nil) {\n        self.$warn(\"warning: given block not used\")\n      }\n    ;\n      if ($truthy(object != null)) {\n        block = $send(self, 'proc', [], (TMP_18 = function($a_rest){var self = TMP_18.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        return Opal.const_get_relative($nesting, 'Opal').$destructure(args)['$=='](object)}, TMP_18.$$s = self, TMP_18.$$arity = -1, TMP_18))\n      } else if ($truthy(block['$nil?']())) {\n        block = $send(self, 'proc', [], (TMP_19 = function(){var self = TMP_19.$$s || this;\n\n        return true}, TMP_19.$$s = self, TMP_19.$$arity = 0, TMP_19))};\n      $send(self, 'each', [], (TMP_20 = function($a_rest){var self = TMP_20.$$s || this, args;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      if ($truthy(Opal.yieldX(block, args))) {\n          return result++\n          } else {\n          return nil\n        }}, TMP_20.$$s = self, TMP_20.$$arity = -1, TMP_20));\n      return result;\n    }, TMP_Enumerable_count_17.$$arity = -1);\n    \n    Opal.defn(self, '$cycle', TMP_Enumerable_cycle_21 = function $$cycle(n) {\n      var TMP_22, self = this, $iter = TMP_Enumerable_cycle_21.$$p, block = $iter || nil;\n\n      if (n == null) {\n        n = nil;\n      }\n      if ($iter) TMP_Enumerable_cycle_21.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"cycle\", n], (TMP_22 = function(){var self = TMP_22.$$s || this;\n\n        if (n['$=='](nil)) {\n            if ($truthy(self['$respond_to?'](\"size\"))) {\n              return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY')\n              } else {\n              return nil\n            }\n            } else {\n            \n            n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n            if ($truthy($rb_gt(n, 0))) {\n              return $rb_times(self.$enumerator_size(), n)\n              } else {\n              return 0\n            };\n          }}, TMP_22.$$s = self, TMP_22.$$arity = 0, TMP_22))\n      };\n      if ($truthy(n['$nil?']())) {\n        } else {\n        \n        n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if ($truthy(n <= 0)) {\n          return nil};\n      };\n      \n      var result,\n          all = [], i, length, value;\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        all.push(param);\n      }\n\n      self.$each();\n\n      if (result !== undefined) {\n        return result;\n      }\n\n      if (all.length === 0) {\n        return nil;\n      }\n\n      if (n === nil) {\n        while (true) {\n          for (i = 0, length = all.length; i < length; i++) {\n            value = Opal.yield1(block, all[i]);\n          }\n        }\n      }\n      else {\n        while (n > 1) {\n          for (i = 0, length = all.length; i < length; i++) {\n            value = Opal.yield1(block, all[i]);\n          }\n\n          n--;\n        }\n      }\n    ;\n    }, TMP_Enumerable_cycle_21.$$arity = -1);\n    \n    Opal.defn(self, '$detect', TMP_Enumerable_detect_23 = function $$detect(ifnone) {try {\n\n      var TMP_24, self = this, $iter = TMP_Enumerable_detect_23.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_detect_23.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"detect\", ifnone)\n      };\n      $send(self, 'each', [], (TMP_24 = function($a_rest){var self = TMP_24.$$s || this, args, value = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        value = Opal.const_get_relative($nesting, 'Opal').$destructure(args);\n        if ($truthy(Opal.yield1(block, value))) {\n          Opal.ret(value)\n          } else {\n          return nil\n        };}, TMP_24.$$s = self, TMP_24.$$arity = -1, TMP_24));\n      \n      if (ifnone !== undefined) {\n        if (typeof(ifnone) === 'function') {\n          return ifnone();\n        } else {\n          return ifnone;\n        }\n      }\n    ;\n      return nil;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_detect_23.$$arity = -1);\n    \n    Opal.defn(self, '$drop', TMP_Enumerable_drop_25 = function $$drop(number) {\n      var self = this;\n\n      \n      number = Opal.const_get_relative($nesting, 'Opal').$coerce_to(number, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      if ($truthy(number < 0)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"attempt to drop negative size\")};\n      \n      var result  = [],\n          current = 0;\n\n      self.$each.$$p = function() {\n        if (number <= current) {\n          result.push(Opal.const_get_relative($nesting, 'Opal').$destructure(arguments));\n        }\n\n        current++;\n      };\n\n      self.$each()\n\n      return result;\n    ;\n    }, TMP_Enumerable_drop_25.$$arity = 1);\n    \n    Opal.defn(self, '$drop_while', TMP_Enumerable_drop_while_26 = function $$drop_while() {\n      var self = this, $iter = TMP_Enumerable_drop_while_26.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_drop_while_26.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"drop_while\")\n      };\n      \n      var result   = [],\n          dropping = true;\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n\n        if (dropping) {\n          var value = Opal.yield1(block, param);\n\n          if ($falsy(value)) {\n            dropping = false;\n            result.push(param);\n          }\n        }\n        else {\n          result.push(param);\n        }\n      };\n\n      self.$each();\n\n      return result;\n    ;\n    }, TMP_Enumerable_drop_while_26.$$arity = 0);\n    \n    Opal.defn(self, '$each_cons', TMP_Enumerable_each_cons_27 = function $$each_cons(n) {\n      var TMP_28, self = this, $iter = TMP_Enumerable_each_cons_27.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_each_cons_27.$$p = null;\n      \n      if ($truthy(arguments.length != 1)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" for 1)\")};\n      n = Opal.const_get_relative($nesting, 'Opal').$try_convert(n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      if ($truthy(n <= 0)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"invalid size\")};\n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"each_cons\", n], (TMP_28 = function(){var self = TMP_28.$$s || this, $a, enum_size = nil;\n\n        \n          enum_size = self.$enumerator_size();\n          if ($truthy(enum_size['$nil?']())) {\n            return nil\n          } else if ($truthy(($truthy($a = enum_size['$=='](0)) ? $a : $rb_lt(enum_size, n)))) {\n            return 0\n            } else {\n            return $rb_plus($rb_minus(enum_size, n), 1)\n          };}, TMP_28.$$s = self, TMP_28.$$arity = 0, TMP_28))\n      };\n      \n      var buffer = [], result = nil;\n\n      self.$each.$$p = function() {\n        var element = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n        buffer.push(element);\n        if (buffer.length > n) {\n          buffer.shift();\n        }\n        if (buffer.length == n) {\n          Opal.yield1(block, buffer.slice(0, n));\n        }\n      }\n\n      self.$each();\n\n      return result;\n    ;\n    }, TMP_Enumerable_each_cons_27.$$arity = 1);\n    \n    Opal.defn(self, '$each_entry', TMP_Enumerable_each_entry_29 = function $$each_entry($a_rest) {\n      var TMP_30, self = this, data, $iter = TMP_Enumerable_each_entry_29.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      data = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        data[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerable_each_entry_29.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'to_enum', [\"each_entry\"].concat(Opal.to_a(data)), (TMP_30 = function(){var self = TMP_30.$$s || this;\n\n        return self.$enumerator_size()}, TMP_30.$$s = self, TMP_30.$$arity = 0, TMP_30))\n      };\n      \n      self.$each.$$p = function() {\n        var item = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n\n        Opal.yield1(block, item);\n      }\n\n      self.$each.apply(self, data);\n\n      return self;\n    ;\n    }, TMP_Enumerable_each_entry_29.$$arity = -1);\n    \n    Opal.defn(self, '$each_slice', TMP_Enumerable_each_slice_31 = function $$each_slice(n) {\n      var TMP_32, self = this, $iter = TMP_Enumerable_each_slice_31.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_each_slice_31.$$p = null;\n      \n      n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      if ($truthy(n <= 0)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"invalid slice size\")};\n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"each_slice\", n], (TMP_32 = function(){var self = TMP_32.$$s || this;\n\n        if ($truthy(self['$respond_to?'](\"size\"))) {\n            return $rb_divide(self.$size(), n).$ceil()\n            } else {\n            return nil\n          }}, TMP_32.$$s = self, TMP_32.$$arity = 0, TMP_32))\n      };\n      \n      var result,\n          slice = []\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n\n        slice.push(param);\n\n        if (slice.length === n) {\n          Opal.yield1(block, slice);\n          slice = [];\n        }\n      };\n\n      self.$each();\n\n      if (result !== undefined) {\n        return result;\n      }\n\n      // our \"last\" group, if smaller than n then won't have been yielded\n      if (slice.length > 0) {\n        Opal.yield1(block, slice);\n      }\n    ;\n      return nil;\n    }, TMP_Enumerable_each_slice_31.$$arity = 1);\n    \n    Opal.defn(self, '$each_with_index', TMP_Enumerable_each_with_index_33 = function $$each_with_index($a_rest) {\n      var TMP_34, self = this, args, $iter = TMP_Enumerable_each_with_index_33.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerable_each_with_index_33.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"each_with_index\"].concat(Opal.to_a(args)), (TMP_34 = function(){var self = TMP_34.$$s || this;\n\n        return self.$enumerator_size()}, TMP_34.$$s = self, TMP_34.$$arity = 0, TMP_34))\n      };\n      \n      var result,\n          index = 0;\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n\n        block(param, index);\n\n        index++;\n      };\n\n      self.$each.apply(self, args);\n\n      if (result !== undefined) {\n        return result;\n      }\n    ;\n      return self;\n    }, TMP_Enumerable_each_with_index_33.$$arity = -1);\n    \n    Opal.defn(self, '$each_with_object', TMP_Enumerable_each_with_object_35 = function $$each_with_object(object) {\n      var TMP_36, self = this, $iter = TMP_Enumerable_each_with_object_35.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_each_with_object_35.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"each_with_object\", object], (TMP_36 = function(){var self = TMP_36.$$s || this;\n\n        return self.$enumerator_size()}, TMP_36.$$s = self, TMP_36.$$arity = 0, TMP_36))\n      };\n      \n      var result;\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n\n        block(param, object);\n      };\n\n      self.$each();\n\n      if (result !== undefined) {\n        return result;\n      }\n    ;\n      return object;\n    }, TMP_Enumerable_each_with_object_35.$$arity = 1);\n    \n    Opal.defn(self, '$entries', TMP_Enumerable_entries_37 = function $$entries($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      var result = [];\n\n      self.$each.$$p = function() {\n        result.push(Opal.const_get_relative($nesting, 'Opal').$destructure(arguments));\n      };\n\n      self.$each.apply(self, args);\n\n      return result;\n    \n    }, TMP_Enumerable_entries_37.$$arity = -1);\n    Opal.alias(self, \"find\", \"detect\");\n    \n    Opal.defn(self, '$find_all', TMP_Enumerable_find_all_38 = function $$find_all() {\n      var TMP_39, self = this, $iter = TMP_Enumerable_find_all_38.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_find_all_38.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"find_all\"], (TMP_39 = function(){var self = TMP_39.$$s || this;\n\n        return self.$enumerator_size()}, TMP_39.$$s = self, TMP_39.$$arity = 0, TMP_39))\n      };\n      \n      var result = [];\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        if ($truthy(value)) {\n          result.push(param);\n        }\n      };\n\n      self.$each();\n\n      return result;\n    ;\n    }, TMP_Enumerable_find_all_38.$$arity = 0);\n    \n    Opal.defn(self, '$find_index', TMP_Enumerable_find_index_40 = function $$find_index(object) {try {\n\n      var TMP_41, TMP_42, self = this, $iter = TMP_Enumerable_find_index_40.$$p, block = $iter || nil, index = nil;\n\n      if ($iter) TMP_Enumerable_find_index_40.$$p = null;\n      \n      if ($truthy(object === undefined && block === nil)) {\n        return self.$enum_for(\"find_index\")};\n      \n      if (object != null && block !== nil) {\n        self.$warn(\"warning: given block not used\")\n      }\n    ;\n      index = 0;\n      if ($truthy(object != null)) {\n        $send(self, 'each', [], (TMP_41 = function($a_rest){var self = TMP_41.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          if (Opal.const_get_relative($nesting, 'Opal').$destructure(value)['$=='](object)) {\n            Opal.ret(index)};\n          return index += 1;}, TMP_41.$$s = self, TMP_41.$$arity = -1, TMP_41))\n        } else {\n        $send(self, 'each', [], (TMP_42 = function($a_rest){var self = TMP_42.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {\n            Opal.ret(index)};\n          return index += 1;}, TMP_42.$$s = self, TMP_42.$$arity = -1, TMP_42))\n      };\n      return nil;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_find_index_40.$$arity = -1);\n    \n    Opal.defn(self, '$first', TMP_Enumerable_first_45 = function $$first(number) {try {\n\n      var TMP_43, TMP_44, self = this, result = nil, current = nil;\n\n      if ($truthy(number === undefined)) {\n        return $send(self, 'each', [], (TMP_43 = function(value){var self = TMP_43.$$s || this;\nif (value == null) value = nil;\n        Opal.ret(value)}, TMP_43.$$s = self, TMP_43.$$arity = 1, TMP_43))\n        } else {\n        \n        result = [];\n        number = Opal.const_get_relative($nesting, 'Opal').$coerce_to(number, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if ($truthy(number < 0)) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"attempt to take negative size\")};\n        if ($truthy(number == 0)) {\n          return []};\n        current = 0;\n        $send(self, 'each', [], (TMP_44 = function($a_rest){var self = TMP_44.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          result.push(Opal.const_get_relative($nesting, 'Opal').$destructure(args));\n          if ($truthy(number <= ++current)) {\n            Opal.ret(result)\n            } else {\n            return nil\n          };}, TMP_44.$$s = self, TMP_44.$$arity = -1, TMP_44));\n        return result;\n      }\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_first_45.$$arity = -1);\n    Opal.alias(self, \"flat_map\", \"collect_concat\");\n    \n    Opal.defn(self, '$grep', TMP_Enumerable_grep_46 = function $$grep(pattern) {\n      var self = this, $iter = TMP_Enumerable_grep_46.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_grep_46.$$p = null;\n      \n      var result = [];\n\n      if (block !== nil) {\n        self.$each.$$p = function() {\n          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n              value = pattern['$==='](param);\n\n          if ($truthy(value)) {\n            value = Opal.yield1(block, param);\n\n            result.push(value);\n          }\n        };\n      }\n      else {\n        self.$each.$$p = function() {\n          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n              value = pattern['$==='](param);\n\n          if ($truthy(value)) {\n            result.push(param);\n          }\n        };\n      }\n\n      self.$each();\n\n      return result;\n    \n    }, TMP_Enumerable_grep_46.$$arity = 1);\n    \n    Opal.defn(self, '$grep_v', TMP_Enumerable_grep_v_47 = function $$grep_v(pattern) {\n      var self = this, $iter = TMP_Enumerable_grep_v_47.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_grep_v_47.$$p = null;\n      \n      var result = [];\n\n      if (block !== nil) {\n        self.$each.$$p = function() {\n          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n              value = pattern['$==='](param);\n\n          if ($falsy(value)) {\n            value = Opal.yield1(block, param);\n\n            result.push(value);\n          }\n        };\n      }\n      else {\n        self.$each.$$p = function() {\n          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n              value = pattern['$==='](param);\n\n          if ($falsy(value)) {\n            result.push(param);\n          }\n        };\n      }\n\n      self.$each();\n\n      return result;\n    \n    }, TMP_Enumerable_grep_v_47.$$arity = 1);\n    \n    Opal.defn(self, '$group_by', TMP_Enumerable_group_by_48 = function $$group_by() {\n      var TMP_49, $a, self = this, $iter = TMP_Enumerable_group_by_48.$$p, block = $iter || nil, hash = nil, $writer = nil;\n\n      if ($iter) TMP_Enumerable_group_by_48.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"group_by\"], (TMP_49 = function(){var self = TMP_49.$$s || this;\n\n        return self.$enumerator_size()}, TMP_49.$$s = self, TMP_49.$$arity = 0, TMP_49))\n      };\n      hash = Opal.const_get_relative($nesting, 'Hash').$new();\n      \n      var result;\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        ($truthy($a = hash['$[]'](value)) ? $a : (($writer = [value, []]), $send(hash, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))['$<<'](param);\n      }\n\n      self.$each();\n\n      if (result !== undefined) {\n        return result;\n      }\n    ;\n      return hash;\n    }, TMP_Enumerable_group_by_48.$$arity = 0);\n    \n    Opal.defn(self, '$include?', TMP_Enumerable_include$q_51 = function(obj) {try {\n\n      var TMP_50, self = this;\n\n      \n      $send(self, 'each', [], (TMP_50 = function($a_rest){var self = TMP_50.$$s || this, args;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      if (Opal.const_get_relative($nesting, 'Opal').$destructure(args)['$=='](obj)) {\n          Opal.ret(true)\n          } else {\n          return nil\n        }}, TMP_50.$$s = self, TMP_50.$$arity = -1, TMP_50));\n      return false;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_include$q_51.$$arity = 1);\n    \n    Opal.defn(self, '$inject', TMP_Enumerable_inject_52 = function $$inject(object, sym) {\n      var self = this, $iter = TMP_Enumerable_inject_52.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_inject_52.$$p = null;\n      \n      var result = object;\n\n      if (block !== nil && sym === undefined) {\n        self.$each.$$p = function() {\n          var value = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n\n          if (result === undefined) {\n            result = value;\n            return;\n          }\n\n          value = Opal.yieldX(block, [result, value]);\n\n          result = value;\n        };\n      }\n      else {\n        if (sym === undefined) {\n          if (!Opal.const_get_relative($nesting, 'Symbol')['$==='](object)) {\n            self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + (object.$inspect()) + \" is not a Symbol\");\n          }\n\n          sym    = object;\n          result = undefined;\n        }\n\n        self.$each.$$p = function() {\n          var value = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n\n          if (result === undefined) {\n            result = value;\n            return;\n          }\n\n          result = (result).$__send__(sym, value);\n        };\n      }\n\n      self.$each();\n\n      return result == undefined ? nil : result;\n    \n    }, TMP_Enumerable_inject_52.$$arity = -1);\n    \n    Opal.defn(self, '$lazy', TMP_Enumerable_lazy_54 = function $$lazy() {\n      var TMP_53, self = this;\n\n      return $send(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], (TMP_53 = function(enum$, $a_rest){var self = TMP_53.$$s || this, args;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 1] = arguments[$arg_idx];\n        }if (enum$ == null) enum$ = nil;\n      return $send(enum$, 'yield', Opal.to_a(args))}, TMP_53.$$s = self, TMP_53.$$arity = -2, TMP_53))\n    }, TMP_Enumerable_lazy_54.$$arity = 0);\n    \n    Opal.defn(self, '$enumerator_size', TMP_Enumerable_enumerator_size_55 = function $$enumerator_size() {\n      var self = this;\n\n      if ($truthy(self['$respond_to?'](\"size\"))) {\n        return self.$size()\n        } else {\n        return nil\n      }\n    }, TMP_Enumerable_enumerator_size_55.$$arity = 0);\n    Opal.alias(self, \"map\", \"collect\");\n    \n    Opal.defn(self, '$max', TMP_Enumerable_max_56 = function $$max(n) {\n      var self = this, $iter = TMP_Enumerable_max_56.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_max_56.$$p = null;\n      \n      \n      if (n === undefined || n === nil) {\n        var result, value;\n\n        self.$each.$$p = function() {\n          var item = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n\n          if (result === undefined) {\n            result = item;\n            return;\n          }\n\n          if (block !== nil) {\n            value = Opal.yieldX(block, [item, result]);\n          } else {\n            value = (item)['$<=>'](result);\n          }\n\n          if (value === nil) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"comparison failed\");\n          }\n\n          if (value > 0) {\n            result = item;\n          }\n        }\n\n        self.$each();\n\n        if (result === undefined) {\n          return nil;\n        } else {\n          return result;\n        }\n      }\n    ;\n      n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);\n    }, TMP_Enumerable_max_56.$$arity = -1);\n    \n    Opal.defn(self, '$max_by', TMP_Enumerable_max_by_57 = function $$max_by() {\n      var TMP_58, self = this, $iter = TMP_Enumerable_max_by_57.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_max_by_57.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"max_by\"], (TMP_58 = function(){var self = TMP_58.$$s || this;\n\n        return self.$enumerator_size()}, TMP_58.$$s = self, TMP_58.$$arity = 0, TMP_58))\n      };\n      \n      var result,\n          by;\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        if (result === undefined) {\n          result = param;\n          by     = value;\n          return;\n        }\n\n        if ((value)['$<=>'](by) > 0) {\n          result = param\n          by     = value;\n        }\n      };\n\n      self.$each();\n\n      return result === undefined ? nil : result;\n    ;\n    }, TMP_Enumerable_max_by_57.$$arity = 0);\n    Opal.alias(self, \"member?\", \"include?\");\n    \n    Opal.defn(self, '$min', TMP_Enumerable_min_59 = function $$min() {\n      var self = this, $iter = TMP_Enumerable_min_59.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_min_59.$$p = null;\n      \n      var result;\n\n      if (block !== nil) {\n        self.$each.$$p = function() {\n          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n\n          if (result === undefined) {\n            result = param;\n            return;\n          }\n\n          var value = block(param, result);\n\n          if (value === nil) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"comparison failed\");\n          }\n\n          if (value < 0) {\n            result = param;\n          }\n        };\n      }\n      else {\n        self.$each.$$p = function() {\n          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n\n          if (result === undefined) {\n            result = param;\n            return;\n          }\n\n          if (Opal.const_get_relative($nesting, 'Opal').$compare(param, result) < 0) {\n            result = param;\n          }\n        };\n      }\n\n      self.$each();\n\n      return result === undefined ? nil : result;\n    \n    }, TMP_Enumerable_min_59.$$arity = 0);\n    \n    Opal.defn(self, '$min_by', TMP_Enumerable_min_by_60 = function $$min_by() {\n      var TMP_61, self = this, $iter = TMP_Enumerable_min_by_60.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_min_by_60.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"min_by\"], (TMP_61 = function(){var self = TMP_61.$$s || this;\n\n        return self.$enumerator_size()}, TMP_61.$$s = self, TMP_61.$$arity = 0, TMP_61))\n      };\n      \n      var result,\n          by;\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        if (result === undefined) {\n          result = param;\n          by     = value;\n          return;\n        }\n\n        if ((value)['$<=>'](by) < 0) {\n          result = param\n          by     = value;\n        }\n      };\n\n      self.$each();\n\n      return result === undefined ? nil : result;\n    ;\n    }, TMP_Enumerable_min_by_60.$$arity = 0);\n    \n    Opal.defn(self, '$minmax', TMP_Enumerable_minmax_62 = function $$minmax() {\n      var $a, TMP_63, self = this, $iter = TMP_Enumerable_minmax_62.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_minmax_62.$$p = null;\n      \n      block = ($truthy($a = block) ? $a : $send(self, 'proc', [], (TMP_63 = function(a, b){var self = TMP_63.$$s || this;\nif (a == null) a = nil;if (b == null) b = nil;\n      return a['$<=>'](b)}, TMP_63.$$s = self, TMP_63.$$arity = 2, TMP_63)));\n      \n      var min = nil, max = nil, first_time = true;\n\n      self.$each.$$p = function() {\n        var element = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n        if (first_time) {\n          min = max = element;\n          first_time = false;\n        } else {\n          var min_cmp = block.$call(min, element);\n\n          if (min_cmp === nil) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"comparison failed\")\n          } else if (min_cmp > 0) {\n            min = element;\n          }\n\n          var max_cmp = block.$call(max, element);\n\n          if (max_cmp === nil) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"comparison failed\")\n          } else if (max_cmp < 0) {\n            max = element;\n          }\n        }\n      }\n\n      self.$each();\n\n      return [min, max];\n    ;\n    }, TMP_Enumerable_minmax_62.$$arity = 0);\n    \n    Opal.defn(self, '$minmax_by', TMP_Enumerable_minmax_by_64 = function $$minmax_by() {\n      var self = this, $iter = TMP_Enumerable_minmax_by_64.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_minmax_by_64.$$p = null;\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n    }, TMP_Enumerable_minmax_by_64.$$arity = 0);\n    \n    Opal.defn(self, '$none?', TMP_Enumerable_none$q_65 = function() {try {\n\n      var TMP_66, TMP_67, self = this, $iter = TMP_Enumerable_none$q_65.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_none$q_65.$$p = null;\n      \n      if ((block !== nil)) {\n        $send(self, 'each', [], (TMP_66 = function($a_rest){var self = TMP_66.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {\n            Opal.ret(false)\n            } else {\n            return nil\n          }}, TMP_66.$$s = self, TMP_66.$$arity = -1, TMP_66))\n        } else {\n        $send(self, 'each', [], (TMP_67 = function($a_rest){var self = TMP_67.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy(Opal.const_get_relative($nesting, 'Opal').$destructure(value))) {\n            Opal.ret(false)\n            } else {\n            return nil\n          }}, TMP_67.$$s = self, TMP_67.$$arity = -1, TMP_67))\n      };\n      return true;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_none$q_65.$$arity = 0);\n    \n    Opal.defn(self, '$one?', TMP_Enumerable_one$q_68 = function() {try {\n\n      var TMP_69, TMP_70, self = this, $iter = TMP_Enumerable_one$q_68.$$p, block = $iter || nil, count = nil;\n\n      if ($iter) TMP_Enumerable_one$q_68.$$p = null;\n      \n      count = 0;\n      if ((block !== nil)) {\n        $send(self, 'each', [], (TMP_69 = function($a_rest){var self = TMP_69.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {\n            \n            count = $rb_plus(count, 1);\n            if ($truthy($rb_gt(count, 1))) {\n              Opal.ret(false)\n              } else {\n              return nil\n            };\n            } else {\n            return nil\n          }}, TMP_69.$$s = self, TMP_69.$$arity = -1, TMP_69))\n        } else {\n        $send(self, 'each', [], (TMP_70 = function($a_rest){var self = TMP_70.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy(Opal.const_get_relative($nesting, 'Opal').$destructure(value))) {\n            \n            count = $rb_plus(count, 1);\n            if ($truthy($rb_gt(count, 1))) {\n              Opal.ret(false)\n              } else {\n              return nil\n            };\n            } else {\n            return nil\n          }}, TMP_70.$$s = self, TMP_70.$$arity = -1, TMP_70))\n      };\n      return count['$=='](1);\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_one$q_68.$$arity = 0);\n    \n    Opal.defn(self, '$partition', TMP_Enumerable_partition_71 = function $$partition() {\n      var TMP_72, self = this, $iter = TMP_Enumerable_partition_71.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_partition_71.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"partition\"], (TMP_72 = function(){var self = TMP_72.$$s || this;\n\n        return self.$enumerator_size()}, TMP_72.$$s = self, TMP_72.$$arity = 0, TMP_72))\n      };\n      \n      var truthy = [], falsy = [], result;\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        if ($truthy(value)) {\n          truthy.push(param);\n        }\n        else {\n          falsy.push(param);\n        }\n      };\n\n      self.$each();\n\n      return [truthy, falsy];\n    ;\n    }, TMP_Enumerable_partition_71.$$arity = 0);\n    Opal.alias(self, \"reduce\", \"inject\");\n    \n    Opal.defn(self, '$reject', TMP_Enumerable_reject_73 = function $$reject() {\n      var TMP_74, self = this, $iter = TMP_Enumerable_reject_73.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_reject_73.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"reject\"], (TMP_74 = function(){var self = TMP_74.$$s || this;\n\n        return self.$enumerator_size()}, TMP_74.$$s = self, TMP_74.$$arity = 0, TMP_74))\n      };\n      \n      var result = [];\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        if ($falsy(value)) {\n          result.push(param);\n        }\n      };\n\n      self.$each();\n\n      return result;\n    ;\n    }, TMP_Enumerable_reject_73.$$arity = 0);\n    \n    Opal.defn(self, '$reverse_each', TMP_Enumerable_reverse_each_75 = function $$reverse_each() {\n      var TMP_76, self = this, $iter = TMP_Enumerable_reverse_each_75.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_reverse_each_75.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"reverse_each\"], (TMP_76 = function(){var self = TMP_76.$$s || this;\n\n        return self.$enumerator_size()}, TMP_76.$$s = self, TMP_76.$$arity = 0, TMP_76))\n      };\n      \n      var result = [];\n\n      self.$each.$$p = function() {\n        result.push(arguments);\n      };\n\n      self.$each();\n\n      for (var i = result.length - 1; i >= 0; i--) {\n        Opal.yieldX(block, result[i]);\n      }\n\n      return result;\n    ;\n    }, TMP_Enumerable_reverse_each_75.$$arity = 0);\n    Opal.alias(self, \"select\", \"find_all\");\n    \n    Opal.defn(self, '$slice_before', TMP_Enumerable_slice_before_77 = function $$slice_before(pattern) {\n      var TMP_78, self = this, $iter = TMP_Enumerable_slice_before_77.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_slice_before_77.$$p = null;\n      \n      if ($truthy(pattern === undefined && block === nil)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"both pattern and block are given\")};\n      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" expected 1)\")};\n      return $send(Opal.const_get_relative($nesting, 'Enumerator'), 'new', [], (TMP_78 = function(e){var self = TMP_78.$$s || this;\nif (e == null) e = nil;\n      \n        var slice = [];\n\n        if (block !== nil) {\n          if (pattern === undefined) {\n            self.$each.$$p = function() {\n              var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n                  value = Opal.yield1(block, param);\n\n              if ($truthy(value) && slice.length > 0) {\n                e['$<<'](slice);\n                slice = [];\n              }\n\n              slice.push(param);\n            };\n          }\n          else {\n            self.$each.$$p = function() {\n              var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n                  value = block(param, pattern.$dup());\n\n              if ($truthy(value) && slice.length > 0) {\n                e['$<<'](slice);\n                slice = [];\n              }\n\n              slice.push(param);\n            };\n          }\n        }\n        else {\n          self.$each.$$p = function() {\n            var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n                value = pattern['$==='](param);\n\n            if ($truthy(value) && slice.length > 0) {\n              e['$<<'](slice);\n              slice = [];\n            }\n\n            slice.push(param);\n          };\n        }\n\n        self.$each();\n\n        if (slice.length > 0) {\n          e['$<<'](slice);\n        }\n      }, TMP_78.$$s = self, TMP_78.$$arity = 1, TMP_78));\n    }, TMP_Enumerable_slice_before_77.$$arity = -1);\n    \n    Opal.defn(self, '$slice_after', TMP_Enumerable_slice_after_79 = function $$slice_after(pattern) {\n      var TMP_80, TMP_81, self = this, $iter = TMP_Enumerable_slice_after_79.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_slice_after_79.$$p = null;\n      \n      if ($truthy(pattern === undefined && block === nil)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"both pattern and block are given\")};\n      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" expected 1)\")};\n      if ($truthy(pattern !== undefined)) {\n        block = $send(self, 'proc', [], (TMP_80 = function(e){var self = TMP_80.$$s || this;\nif (e == null) e = nil;\n        return pattern['$==='](e)}, TMP_80.$$s = self, TMP_80.$$arity = 1, TMP_80))};\n      return $send(Opal.const_get_relative($nesting, 'Enumerator'), 'new', [], (TMP_81 = function(yielder){var self = TMP_81.$$s || this;\nif (yielder == null) yielder = nil;\n      \n        var accumulate;\n\n        self.$each.$$p = function() {\n          var element = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n              end_chunk = Opal.yield1(block, element);\n\n          if (accumulate == null) {\n            accumulate = [];\n          }\n\n          if ($truthy(end_chunk)) {\n            accumulate.push(element);\n            yielder.$yield(accumulate);\n            accumulate = null;\n          } else {\n            accumulate.push(element)\n          }\n        }\n\n        self.$each();\n\n        if (accumulate != null) {\n          yielder.$yield(accumulate);\n        }\n      }, TMP_81.$$s = self, TMP_81.$$arity = 1, TMP_81));\n    }, TMP_Enumerable_slice_after_79.$$arity = -1);\n    \n    Opal.defn(self, '$slice_when', TMP_Enumerable_slice_when_82 = function $$slice_when() {\n      var TMP_83, self = this, $iter = TMP_Enumerable_slice_when_82.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_slice_when_82.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"wrong number of arguments (0 for 1)\")\n      };\n      return $send(Opal.const_get_relative($nesting, 'Enumerator'), 'new', [], (TMP_83 = function(yielder){var self = TMP_83.$$s || this;\nif (yielder == null) yielder = nil;\n      \n        var slice = nil, last_after = nil;\n\n        self.$each_cons.$$p = function() {\n          var params = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n              before = params[0],\n              after = params[1],\n              match = Opal.yieldX(block, [before, after]);\n\n          last_after = after;\n\n          if (slice === nil) {\n            slice = [];\n          }\n\n          if ($truthy(match)) {\n            slice.push(before);\n            yielder.$yield(slice);\n            slice = [];\n          } else {\n            slice.push(before);\n          }\n        }\n\n        self.$each_cons(2);\n\n        if (slice !== nil) {\n          slice.push(last_after);\n          yielder.$yield(slice);\n        }\n      }, TMP_83.$$s = self, TMP_83.$$arity = 1, TMP_83));\n    }, TMP_Enumerable_slice_when_82.$$arity = 0);\n    \n    Opal.defn(self, '$sort', TMP_Enumerable_sort_84 = function $$sort() {\n      var TMP_85, self = this, $iter = TMP_Enumerable_sort_84.$$p, block = $iter || nil, ary = nil;\n\n      if ($iter) TMP_Enumerable_sort_84.$$p = null;\n      \n      ary = self.$to_a();\n      if ((block !== nil)) {\n        } else {\n        block = $send(self, 'lambda', [], (TMP_85 = function(a, b){var self = TMP_85.$$s || this;\nif (a == null) a = nil;if (b == null) b = nil;\n        return a['$<=>'](b)}, TMP_85.$$s = self, TMP_85.$$arity = 2, TMP_85))\n      };\n      return $send(ary, 'sort', [], block.$to_proc());\n    }, TMP_Enumerable_sort_84.$$arity = 0);\n    \n    Opal.defn(self, '$sort_by', TMP_Enumerable_sort_by_86 = function $$sort_by() {\n      var TMP_87, TMP_88, TMP_89, TMP_90, self = this, $iter = TMP_Enumerable_sort_by_86.$$p, block = $iter || nil, dup = nil;\n\n      if ($iter) TMP_Enumerable_sort_by_86.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"sort_by\"], (TMP_87 = function(){var self = TMP_87.$$s || this;\n\n        return self.$enumerator_size()}, TMP_87.$$s = self, TMP_87.$$arity = 0, TMP_87))\n      };\n      dup = $send(self, 'map', [], (TMP_88 = function(){var self = TMP_88.$$s || this, arg = nil;\n\n      \n        arg = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);\n        return [Opal.yield1(block, arg), arg];}, TMP_88.$$s = self, TMP_88.$$arity = 0, TMP_88));\n      $send(dup, 'sort!', [], (TMP_89 = function(a, b){var self = TMP_89.$$s || this;\nif (a == null) a = nil;if (b == null) b = nil;\n      return (a[0])['$<=>'](b[0])}, TMP_89.$$s = self, TMP_89.$$arity = 2, TMP_89));\n      return $send(dup, 'map!', [], (TMP_90 = function(i){var self = TMP_90.$$s || this;\nif (i == null) i = nil;\n      return i[1]}, TMP_90.$$s = self, TMP_90.$$arity = 1, TMP_90));\n    }, TMP_Enumerable_sort_by_86.$$arity = 0);\n    \n    Opal.defn(self, '$sum', TMP_Enumerable_sum_91 = function $$sum(initial) {\n      var TMP_92, self = this, $iter = TMP_Enumerable_sum_91.$$p, block = $iter || nil, result = nil;\n\n      if (initial == null) {\n        initial = 0;\n      }\n      if ($iter) TMP_Enumerable_sum_91.$$p = null;\n      \n      result = initial;\n      $send(self, 'each', [], (TMP_92 = function($a_rest){var self = TMP_92.$$s || this, args, item = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        if ((block !== nil)) {\n          item = $send(block, 'call', Opal.to_a(args))\n          } else {\n          item = Opal.const_get_relative($nesting, 'Opal').$destructure(args)\n        };\n        return (result = $rb_plus(result, item));}, TMP_92.$$s = self, TMP_92.$$arity = -1, TMP_92));\n      return result;\n    }, TMP_Enumerable_sum_91.$$arity = -1);\n    \n    Opal.defn(self, '$take', TMP_Enumerable_take_93 = function $$take(num) {\n      var self = this;\n\n      return self.$first(num)\n    }, TMP_Enumerable_take_93.$$arity = 1);\n    \n    Opal.defn(self, '$take_while', TMP_Enumerable_take_while_94 = function $$take_while() {try {\n\n      var TMP_95, self = this, $iter = TMP_Enumerable_take_while_94.$$p, block = $iter || nil, result = nil;\n\n      if ($iter) TMP_Enumerable_take_while_94.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return self.$enum_for(\"take_while\")\n      };\n      result = [];\n      return $send(self, 'each', [], (TMP_95 = function($a_rest){var self = TMP_95.$$s || this, args, value = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        value = Opal.const_get_relative($nesting, 'Opal').$destructure(args);\n        if ($truthy(Opal.yield1(block, value))) {\n          } else {\n          Opal.ret(result)\n        };\n        return result.push(value);}, TMP_95.$$s = self, TMP_95.$$arity = -1, TMP_95));\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_take_while_94.$$arity = 0);\n    \n    Opal.defn(self, '$uniq', TMP_Enumerable_uniq_96 = function $$uniq() {\n      var TMP_97, self = this, $iter = TMP_Enumerable_uniq_96.$$p, block = $iter || nil, hash = nil;\n\n      if ($iter) TMP_Enumerable_uniq_96.$$p = null;\n      \n      hash = $hash2([], {});\n      $send(self, 'each', [], (TMP_97 = function($a_rest){var self = TMP_97.$$s || this, args, value = nil, produced = nil, $writer = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        value = Opal.const_get_relative($nesting, 'Opal').$destructure(args);\n        produced = (function() {if ((block !== nil)) {\n          return block.$call(value)\n          } else {\n          return value\n        }; return nil; })();\n        if ($truthy(hash['$has_key?'](produced))) {\n          return nil\n          } else {\n          \n          $writer = [produced, value];\n          $send(hash, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        };}, TMP_97.$$s = self, TMP_97.$$arity = -1, TMP_97));\n      return hash.$values();\n    }, TMP_Enumerable_uniq_96.$$arity = 0);\n    Opal.alias(self, \"to_a\", \"entries\");\n    \n    Opal.defn(self, '$zip', TMP_Enumerable_zip_98 = function $$zip($a_rest) {\n      var self = this, others, $iter = TMP_Enumerable_zip_98.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      others = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        others[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerable_zip_98.$$p = null;\n      return $send(self.$to_a(), 'zip', Opal.to_a(others))\n    }, TMP_Enumerable_zip_98.$$arity = -1);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/enumerator\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $falsy = Opal.falsy;\n\n  Opal.add_stubs(['$require', '$include', '$allocate', '$new', '$to_proc', '$coerce_to', '$nil?', '$empty?', '$+', '$class', '$__send__', '$===', '$call', '$enum_for', '$size', '$destructure', '$inspect', '$[]', '$raise', '$yield', '$each', '$enumerator_size', '$respond_to?', '$try_convert', '$<', '$for']);\n  \n  self.$require(\"corelib/enumerable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Enumerator(){};\n    var self = $Enumerator = $klass($base, $super, 'Enumerator', $Enumerator);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Enumerator_for_1, TMP_Enumerator_initialize_2, TMP_Enumerator_each_3, TMP_Enumerator_size_4, TMP_Enumerator_with_index_5, TMP_Enumerator_inspect_7;\n\n    def.size = def.args = def.object = def.method = nil;\n    \n    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n    def.$$is_enumerator = true;\n    Opal.defs(self, '$for', TMP_Enumerator_for_1 = function(object, method, $a_rest) {\n      var self = this, args, $iter = TMP_Enumerator_for_1.$$p, block = $iter || nil;\n\n      if (method == null) {\n        method = \"each\";\n      }\n      var $args_len = arguments.length, $rest_len = $args_len - 2;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 2; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 2] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerator_for_1.$$p = null;\n      \n      var obj = self.$allocate();\n\n      obj.object = object;\n      obj.size   = block;\n      obj.method = method;\n      obj.args   = args;\n\n      return obj;\n    \n    }, TMP_Enumerator_for_1.$$arity = -2);\n    \n    Opal.defn(self, '$initialize', TMP_Enumerator_initialize_2 = function $$initialize($a_rest) {\n      var self = this, $iter = TMP_Enumerator_initialize_2.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerator_initialize_2.$$p = null;\n      if ($truthy(block)) {\n        \n        self.object = $send(Opal.const_get_relative($nesting, 'Generator'), 'new', [], block.$to_proc());\n        self.method = \"each\";\n        self.args = [];\n        self.size = arguments[0] || nil;\n        if ($truthy(self.size)) {\n          return (self.size = Opal.const_get_relative($nesting, 'Opal').$coerce_to(self.size, Opal.const_get_relative($nesting, 'Integer'), \"to_int\"))\n          } else {\n          return nil\n        };\n        } else {\n        \n        self.object = arguments[0];\n        self.method = arguments[1] || \"each\";\n        self.args = $slice.call(arguments, 2);\n        return (self.size = nil);\n      }\n    }, TMP_Enumerator_initialize_2.$$arity = -1);\n    \n    Opal.defn(self, '$each', TMP_Enumerator_each_3 = function $$each($a_rest) {\n      var $b, self = this, args, $iter = TMP_Enumerator_each_3.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerator_each_3.$$p = null;\n      \n      if ($truthy(($truthy($b = block['$nil?']()) ? args['$empty?']() : $b))) {\n        return self};\n      args = $rb_plus(self.args, args);\n      if ($truthy(block['$nil?']())) {\n        return $send(self.$class(), 'new', [self.object, self.method].concat(Opal.to_a(args)))};\n      return $send(self.object, '__send__', [self.method].concat(Opal.to_a(args)), block.$to_proc());\n    }, TMP_Enumerator_each_3.$$arity = -1);\n    \n    Opal.defn(self, '$size', TMP_Enumerator_size_4 = function $$size() {\n      var self = this;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Proc')['$==='](self.size))) {\n        return $send(self.size, 'call', Opal.to_a(self.args))\n        } else {\n        return self.size\n      }\n    }, TMP_Enumerator_size_4.$$arity = 0);\n    \n    Opal.defn(self, '$with_index', TMP_Enumerator_with_index_5 = function $$with_index(offset) {\n      var TMP_6, self = this, $iter = TMP_Enumerator_with_index_5.$$p, block = $iter || nil;\n\n      if (offset == null) {\n        offset = 0;\n      }\n      if ($iter) TMP_Enumerator_with_index_5.$$p = null;\n      \n      if ($truthy(offset)) {\n        offset = Opal.const_get_relative($nesting, 'Opal').$coerce_to(offset, Opal.const_get_relative($nesting, 'Integer'), \"to_int\")\n        } else {\n        offset = 0\n      };\n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"with_index\", offset], (TMP_6 = function(){var self = TMP_6.$$s || this;\n\n        return self.$size()}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6))\n      };\n      \n      var result, index = offset;\n\n      self.$each.$$p = function() {\n        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),\n            value = block(param, index);\n\n        index++;\n\n        return value;\n      }\n\n      return self.$each();\n    ;\n    }, TMP_Enumerator_with_index_5.$$arity = -1);\n    Opal.alias(self, \"with_object\", \"each_with_object\");\n    \n    Opal.defn(self, '$inspect', TMP_Enumerator_inspect_7 = function $$inspect() {\n      var self = this, result = nil;\n\n      \n      result = \"\" + \"#<\" + (self.$class()) + \": \" + (self.object.$inspect()) + \":\" + (self.method);\n      if ($truthy(self.args['$empty?']())) {\n        } else {\n        result = $rb_plus(result, \"\" + \"(\" + (self.args.$inspect()['$[]'](Opal.const_get_relative($nesting, 'Range').$new(1, -2))) + \")\")\n      };\n      return $rb_plus(result, \">\");\n    }, TMP_Enumerator_inspect_7.$$arity = 0);\n    (function($base, $super, $parent_nesting) {\n      function $Generator(){};\n      var self = $Generator = $klass($base, $super, 'Generator', $Generator);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Generator_initialize_8, TMP_Generator_each_9;\n\n      def.block = nil;\n      \n      self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n      \n      Opal.defn(self, '$initialize', TMP_Generator_initialize_8 = function $$initialize() {\n        var self = this, $iter = TMP_Generator_initialize_8.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Generator_initialize_8.$$p = null;\n        \n        if ($truthy(block)) {\n          } else {\n          self.$raise(Opal.const_get_relative($nesting, 'LocalJumpError'), \"no block given\")\n        };\n        return (self.block = block);\n      }, TMP_Generator_initialize_8.$$arity = 0);\n      return (Opal.defn(self, '$each', TMP_Generator_each_9 = function $$each($a_rest) {\n        var self = this, args, $iter = TMP_Generator_each_9.$$p, block = $iter || nil, yielder = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        if ($iter) TMP_Generator_each_9.$$p = null;\n        \n        yielder = $send(Opal.const_get_relative($nesting, 'Yielder'), 'new', [], block.$to_proc());\n        \n        try {\n          args.unshift(yielder);\n\n          Opal.yieldX(self.block, args);\n        }\n        catch (e) {\n          if (e === $breaker) {\n            return $breaker.$v;\n          }\n          else {\n            throw e;\n          }\n        }\n      ;\n        return self;\n      }, TMP_Generator_each_9.$$arity = -1), nil) && 'each';\n    })($nesting[0], null, $nesting);\n    (function($base, $super, $parent_nesting) {\n      function $Yielder(){};\n      var self = $Yielder = $klass($base, $super, 'Yielder', $Yielder);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Yielder_initialize_10, TMP_Yielder_yield_11, TMP_Yielder_$lt$lt_12;\n\n      def.block = nil;\n      \n      \n      Opal.defn(self, '$initialize', TMP_Yielder_initialize_10 = function $$initialize() {\n        var self = this, $iter = TMP_Yielder_initialize_10.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Yielder_initialize_10.$$p = null;\n        return (self.block = block)\n      }, TMP_Yielder_initialize_10.$$arity = 0);\n      \n      Opal.defn(self, '$yield', TMP_Yielder_yield_11 = function($a_rest) {\n        var self = this, values;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        values = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          values[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        var value = Opal.yieldX(self.block, values);\n\n        if (value === $breaker) {\n          throw $breaker;\n        }\n\n        return value;\n      \n      }, TMP_Yielder_yield_11.$$arity = -1);\n      return (Opal.defn(self, '$<<', TMP_Yielder_$lt$lt_12 = function($a_rest) {\n        var self = this, values;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        values = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          values[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        $send(self, 'yield', Opal.to_a(values));\n        return self;\n      }, TMP_Yielder_$lt$lt_12.$$arity = -1), nil) && '<<';\n    })($nesting[0], null, $nesting);\n    return (function($base, $super, $parent_nesting) {\n      function $Lazy(){};\n      var self = $Lazy = $klass($base, $super, 'Lazy', $Lazy);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Lazy_initialize_13, TMP_Lazy_lazy_16, TMP_Lazy_collect_17, TMP_Lazy_collect_concat_19, TMP_Lazy_drop_24, TMP_Lazy_drop_while_25, TMP_Lazy_enum_for_27, TMP_Lazy_find_all_28, TMP_Lazy_grep_30, TMP_Lazy_reject_33, TMP_Lazy_take_36, TMP_Lazy_take_while_37, TMP_Lazy_inspect_39;\n\n      def.enumerator = nil;\n      \n      (function($base, $super, $parent_nesting) {\n        function $StopLazyError(){};\n        var self = $StopLazyError = $klass($base, $super, 'StopLazyError', $StopLazyError);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return nil\n      })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);\n      \n      Opal.defn(self, '$initialize', TMP_Lazy_initialize_13 = function $$initialize(object, size) {\n        var TMP_14, self = this, $iter = TMP_Lazy_initialize_13.$$p, block = $iter || nil;\n\n        if (size == null) {\n          size = nil;\n        }\n        if ($iter) TMP_Lazy_initialize_13.$$p = null;\n        \n        if ((block !== nil)) {\n          } else {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"tried to call lazy new without a block\")\n        };\n        self.enumerator = object;\n        return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Lazy_initialize_13, false), [size], (TMP_14 = function(yielder, $a_rest){var self = TMP_14.$$s || this, each_args, TMP_15;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          each_args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            each_args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (yielder == null) yielder = nil;\n        \n          try {\n            return $send(object, 'each', Opal.to_a(each_args), (TMP_15 = function($a_rest){var self = TMP_15.$$s || this, args;\n\n              var $args_len = arguments.length, $rest_len = $args_len - 0;\n              if ($rest_len < 0) { $rest_len = 0; }\n              args = new Array($rest_len);\n              for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n                args[$arg_idx - 0] = arguments[$arg_idx];\n              }\n            \n              args.unshift(yielder);\n\n              Opal.yieldX(block, args);\n            }, TMP_15.$$s = self, TMP_15.$$arity = -1, TMP_15))\n          } catch ($err) {\n            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {\n              try {\n                return nil\n              } finally { Opal.pop_exception() }\n            } else { throw $err; }\n          };}, TMP_14.$$s = self, TMP_14.$$arity = -2, TMP_14));\n      }, TMP_Lazy_initialize_13.$$arity = -2);\n      Opal.alias(self, \"force\", \"to_a\");\n      \n      Opal.defn(self, '$lazy', TMP_Lazy_lazy_16 = function $$lazy() {\n        var self = this;\n\n        return self\n      }, TMP_Lazy_lazy_16.$$arity = 0);\n      \n      Opal.defn(self, '$collect', TMP_Lazy_collect_17 = function $$collect() {\n        var TMP_18, self = this, $iter = TMP_Lazy_collect_17.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_collect_17.$$p = null;\n        \n        if ($truthy(block)) {\n          } else {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"tried to call lazy map without a block\")\n        };\n        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, self.$enumerator_size()], (TMP_18 = function(enum$, $a_rest){var self = TMP_18.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        \n          var value = Opal.yieldX(block, args);\n\n          enum$.$yield(value);\n        }, TMP_18.$$s = self, TMP_18.$$arity = -2, TMP_18));\n      }, TMP_Lazy_collect_17.$$arity = 0);\n      \n      Opal.defn(self, '$collect_concat', TMP_Lazy_collect_concat_19 = function $$collect_concat() {\n        var TMP_20, self = this, $iter = TMP_Lazy_collect_concat_19.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_collect_concat_19.$$p = null;\n        \n        if ($truthy(block)) {\n          } else {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"tried to call lazy map without a block\")\n        };\n        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_20 = function(enum$, $a_rest){var self = TMP_20.$$s || this, args, TMP_21, TMP_22;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        \n          var value = Opal.yieldX(block, args);\n\n          if ((value)['$respond_to?'](\"force\") && (value)['$respond_to?'](\"each\")) {\n            $send((value), 'each', [], (TMP_21 = function(v){var self = TMP_21.$$s || this;\nif (v == null) v = nil;\n          return enum$.$yield(v)}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21))\n          }\n          else {\n            var array = Opal.const_get_relative($nesting, 'Opal').$try_convert(value, Opal.const_get_relative($nesting, 'Array'), \"to_ary\");\n\n            if (array === nil) {\n              enum$.$yield(value);\n            }\n            else {\n              $send((value), 'each', [], (TMP_22 = function(v){var self = TMP_22.$$s || this;\nif (v == null) v = nil;\n          return enum$.$yield(v)}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22));\n            }\n          }\n        }, TMP_20.$$s = self, TMP_20.$$arity = -2, TMP_20));\n      }, TMP_Lazy_collect_concat_19.$$arity = 0);\n      \n      Opal.defn(self, '$drop', TMP_Lazy_drop_24 = function $$drop(n) {\n        var TMP_23, self = this, current_size = nil, set_size = nil, dropped = nil;\n\n        \n        n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if ($truthy($rb_lt(n, 0))) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"attempt to drop negative size\")};\n        current_size = self.$enumerator_size();\n        set_size = (function() {if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](current_size))) {\n          if ($truthy($rb_lt(n, current_size))) {\n            return n\n            } else {\n            return current_size\n          }\n          } else {\n          return current_size\n        }; return nil; })();\n        dropped = 0;\n        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, set_size], (TMP_23 = function(enum$, $a_rest){var self = TMP_23.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        if ($truthy($rb_lt(dropped, n))) {\n            return (dropped = $rb_plus(dropped, 1))\n            } else {\n            return $send(enum$, 'yield', Opal.to_a(args))\n          }}, TMP_23.$$s = self, TMP_23.$$arity = -2, TMP_23));\n      }, TMP_Lazy_drop_24.$$arity = 1);\n      \n      Opal.defn(self, '$drop_while', TMP_Lazy_drop_while_25 = function $$drop_while() {\n        var TMP_26, self = this, $iter = TMP_Lazy_drop_while_25.$$p, block = $iter || nil, succeeding = nil;\n\n        if ($iter) TMP_Lazy_drop_while_25.$$p = null;\n        \n        if ($truthy(block)) {\n          } else {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"tried to call lazy drop_while without a block\")\n        };\n        succeeding = true;\n        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_26 = function(enum$, $a_rest){var self = TMP_26.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        if ($truthy(succeeding)) {\n            \n            var value = Opal.yieldX(block, args);\n\n            if ($falsy(value)) {\n              succeeding = false;\n\n              $send(enum$, 'yield', Opal.to_a(args));\n            }\n          \n            } else {\n            return $send(enum$, 'yield', Opal.to_a(args))\n          }}, TMP_26.$$s = self, TMP_26.$$arity = -2, TMP_26));\n      }, TMP_Lazy_drop_while_25.$$arity = 0);\n      \n      Opal.defn(self, '$enum_for', TMP_Lazy_enum_for_27 = function $$enum_for(method, $a_rest) {\n        var self = this, args, $iter = TMP_Lazy_enum_for_27.$$p, block = $iter || nil;\n\n        if (method == null) {\n          method = \"each\";\n        }\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 1] = arguments[$arg_idx];\n        }\n        if ($iter) TMP_Lazy_enum_for_27.$$p = null;\n        return $send(self.$class(), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc())\n      }, TMP_Lazy_enum_for_27.$$arity = -1);\n      \n      Opal.defn(self, '$find_all', TMP_Lazy_find_all_28 = function $$find_all() {\n        var TMP_29, self = this, $iter = TMP_Lazy_find_all_28.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_find_all_28.$$p = null;\n        \n        if ($truthy(block)) {\n          } else {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"tried to call lazy select without a block\")\n        };\n        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_29 = function(enum$, $a_rest){var self = TMP_29.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        \n          var value = Opal.yieldX(block, args);\n\n          if ($truthy(value)) {\n            $send(enum$, 'yield', Opal.to_a(args));\n          }\n        }, TMP_29.$$s = self, TMP_29.$$arity = -2, TMP_29));\n      }, TMP_Lazy_find_all_28.$$arity = 0);\n      Opal.alias(self, \"flat_map\", \"collect_concat\");\n      \n      Opal.defn(self, '$grep', TMP_Lazy_grep_30 = function $$grep(pattern) {\n        var TMP_31, TMP_32, self = this, $iter = TMP_Lazy_grep_30.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_grep_30.$$p = null;\n        if ($truthy(block)) {\n          return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_31 = function(enum$, $a_rest){var self = TMP_31.$$s || this, args;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 1;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 1] = arguments[$arg_idx];\n            }if (enum$ == null) enum$ = nil;\n          \n            var param = Opal.const_get_relative($nesting, 'Opal').$destructure(args),\n                value = pattern['$==='](param);\n\n            if ($truthy(value)) {\n              value = Opal.yield1(block, param);\n\n              enum$.$yield(Opal.yield1(block, param));\n            }\n          }, TMP_31.$$s = self, TMP_31.$$arity = -2, TMP_31))\n          } else {\n          return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_32 = function(enum$, $a_rest){var self = TMP_32.$$s || this, args;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 1;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 1] = arguments[$arg_idx];\n            }if (enum$ == null) enum$ = nil;\n          \n            var param = Opal.const_get_relative($nesting, 'Opal').$destructure(args),\n                value = pattern['$==='](param);\n\n            if ($truthy(value)) {\n              enum$.$yield(param);\n            }\n          }, TMP_32.$$s = self, TMP_32.$$arity = -2, TMP_32))\n        }\n      }, TMP_Lazy_grep_30.$$arity = 1);\n      Opal.alias(self, \"map\", \"collect\");\n      Opal.alias(self, \"select\", \"find_all\");\n      \n      Opal.defn(self, '$reject', TMP_Lazy_reject_33 = function $$reject() {\n        var TMP_34, self = this, $iter = TMP_Lazy_reject_33.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_reject_33.$$p = null;\n        \n        if ($truthy(block)) {\n          } else {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"tried to call lazy reject without a block\")\n        };\n        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_34 = function(enum$, $a_rest){var self = TMP_34.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        \n          var value = Opal.yieldX(block, args);\n\n          if ($falsy(value)) {\n            $send(enum$, 'yield', Opal.to_a(args));\n          }\n        }, TMP_34.$$s = self, TMP_34.$$arity = -2, TMP_34));\n      }, TMP_Lazy_reject_33.$$arity = 0);\n      \n      Opal.defn(self, '$take', TMP_Lazy_take_36 = function $$take(n) {\n        var TMP_35, self = this, current_size = nil, set_size = nil, taken = nil;\n\n        \n        n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if ($truthy($rb_lt(n, 0))) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"attempt to take negative size\")};\n        current_size = self.$enumerator_size();\n        set_size = (function() {if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](current_size))) {\n          if ($truthy($rb_lt(n, current_size))) {\n            return n\n            } else {\n            return current_size\n          }\n          } else {\n          return current_size\n        }; return nil; })();\n        taken = 0;\n        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, set_size], (TMP_35 = function(enum$, $a_rest){var self = TMP_35.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        if ($truthy($rb_lt(taken, n))) {\n            \n            $send(enum$, 'yield', Opal.to_a(args));\n            return (taken = $rb_plus(taken, 1));\n            } else {\n            return self.$raise(Opal.const_get_relative($nesting, 'StopLazyError'))\n          }}, TMP_35.$$s = self, TMP_35.$$arity = -2, TMP_35));\n      }, TMP_Lazy_take_36.$$arity = 1);\n      \n      Opal.defn(self, '$take_while', TMP_Lazy_take_while_37 = function $$take_while() {\n        var TMP_38, self = this, $iter = TMP_Lazy_take_while_37.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_take_while_37.$$p = null;\n        \n        if ($truthy(block)) {\n          } else {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"tried to call lazy take_while without a block\")\n        };\n        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_38 = function(enum$, $a_rest){var self = TMP_38.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        \n          var value = Opal.yieldX(block, args);\n\n          if ($truthy(value)) {\n            $send(enum$, 'yield', Opal.to_a(args));\n          }\n          else {\n            self.$raise(Opal.const_get_relative($nesting, 'StopLazyError'));\n          }\n        }, TMP_38.$$s = self, TMP_38.$$arity = -2, TMP_38));\n      }, TMP_Lazy_take_while_37.$$arity = 0);\n      Opal.alias(self, \"to_enum\", \"enum_for\");\n      return (Opal.defn(self, '$inspect', TMP_Lazy_inspect_39 = function $$inspect() {\n        var self = this;\n\n        return \"\" + \"#<\" + (self.$class()) + \": \" + (self.enumerator.$inspect()) + \">\"\n      }, TMP_Lazy_inspect_39.$$arity = 0), nil) && 'inspect';\n    })($nesting[0], self, $nesting);\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/numeric\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$include', '$instance_of?', '$class', '$Float', '$coerce', '$===', '$raise', '$__send__', '$equal?', '$-', '$*', '$div', '$<', '$-@', '$ceil', '$to_f', '$denominator', '$to_r', '$==', '$floor', '$/', '$%', '$Complex', '$zero?', '$numerator', '$abs', '$arg', '$coerce_to!', '$round', '$to_i', '$truncate', '$>']);\n  \n  self.$require(\"corelib/comparable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Numeric(){};\n    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Numeric_coerce_1, TMP_Numeric___coerced___2, TMP_Numeric_$lt$eq$gt_3, TMP_Numeric_$$_4, TMP_Numeric_$$_5, TMP_Numeric_$_6, TMP_Numeric_abs_7, TMP_Numeric_abs2_8, TMP_Numeric_angle_9, TMP_Numeric_ceil_10, TMP_Numeric_conj_11, TMP_Numeric_denominator_12, TMP_Numeric_div_13, TMP_Numeric_divmod_14, TMP_Numeric_fdiv_15, TMP_Numeric_floor_16, TMP_Numeric_i_17, TMP_Numeric_imag_18, TMP_Numeric_integer$q_19, TMP_Numeric_nonzero$q_20, TMP_Numeric_numerator_21, TMP_Numeric_polar_22, TMP_Numeric_quo_23, TMP_Numeric_real_24, TMP_Numeric_real$q_25, TMP_Numeric_rect_26, TMP_Numeric_round_27, TMP_Numeric_to_c_28, TMP_Numeric_to_int_29, TMP_Numeric_truncate_30, TMP_Numeric_zero$q_31, TMP_Numeric_positive$q_32, TMP_Numeric_negative$q_33, TMP_Numeric_dup_34, TMP_Numeric_clone_35;\n\n    \n    self.$include(Opal.const_get_relative($nesting, 'Comparable'));\n    \n    Opal.defn(self, '$coerce', TMP_Numeric_coerce_1 = function $$coerce(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$instance_of?'](self.$class()))) {\n        return [other, self]};\n      return [self.$Float(other), self.$Float(self)];\n    }, TMP_Numeric_coerce_1.$$arity = 1);\n    \n    Opal.defn(self, '$__coerced__', TMP_Numeric___coerced___2 = function $$__coerced__(method, other) {\n      var $a, $b, self = this, a = nil, b = nil, $case = nil;\n\n      \n      \n      try {\n        $b = other.$coerce(self), $a = Opal.to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b\n      } catch ($err) {\n        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {\n          try {\n            $case = method;\n            if (\"+\"['$===']($case) || \"-\"['$===']($case) || \"*\"['$===']($case) || \"/\"['$===']($case) || \"%\"['$===']($case) || \"&\"['$===']($case) || \"|\"['$===']($case) || \"^\"['$===']($case) || \"**\"['$===']($case)) {self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + (other.$class()) + \" can't be coerce into Numeric\")}\n            else if (\">\"['$===']($case) || \">=\"['$===']($case) || \"<\"['$===']($case) || \"<=\"['$===']($case) || \"<=>\"['$===']($case)) {self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (other.$class()) + \" failed\")}\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      };;\n      return a.$__send__(method, b);\n    }, TMP_Numeric___coerced___2.$$arity = 2);\n    \n    Opal.defn(self, '$<=>', TMP_Numeric_$lt$eq$gt_3 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(self['$equal?'](other))) {\n        return 0};\n      return nil;\n    }, TMP_Numeric_$lt$eq$gt_3.$$arity = 1);\n    \n    Opal.defn(self, '$+@', TMP_Numeric_$$_4 = function() {\n      var self = this;\n\n      return self\n    }, TMP_Numeric_$$_4.$$arity = 0);\n    \n    Opal.defn(self, '$-@', TMP_Numeric_$$_5 = function() {\n      var self = this;\n\n      return $rb_minus(0, self)\n    }, TMP_Numeric_$$_5.$$arity = 0);\n    \n    Opal.defn(self, '$%', TMP_Numeric_$_6 = function(other) {\n      var self = this;\n\n      return $rb_minus(self, $rb_times(other, self.$div(other)))\n    }, TMP_Numeric_$_6.$$arity = 1);\n    \n    Opal.defn(self, '$abs', TMP_Numeric_abs_7 = function $$abs() {\n      var self = this;\n\n      if ($rb_lt(self, 0)) {\n        return self['$-@']()\n        } else {\n        return self\n      }\n    }, TMP_Numeric_abs_7.$$arity = 0);\n    \n    Opal.defn(self, '$abs2', TMP_Numeric_abs2_8 = function $$abs2() {\n      var self = this;\n\n      return $rb_times(self, self)\n    }, TMP_Numeric_abs2_8.$$arity = 0);\n    \n    Opal.defn(self, '$angle', TMP_Numeric_angle_9 = function $$angle() {\n      var self = this;\n\n      if ($rb_lt(self, 0)) {\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Math'), 'PI')\n        } else {\n        return 0\n      }\n    }, TMP_Numeric_angle_9.$$arity = 0);\n    Opal.alias(self, \"arg\", \"angle\");\n    \n    Opal.defn(self, '$ceil', TMP_Numeric_ceil_10 = function $$ceil() {\n      var self = this;\n\n      return self.$to_f().$ceil()\n    }, TMP_Numeric_ceil_10.$$arity = 0);\n    \n    Opal.defn(self, '$conj', TMP_Numeric_conj_11 = function $$conj() {\n      var self = this;\n\n      return self\n    }, TMP_Numeric_conj_11.$$arity = 0);\n    Opal.alias(self, \"conjugate\", \"conj\");\n    \n    Opal.defn(self, '$denominator', TMP_Numeric_denominator_12 = function $$denominator() {\n      var self = this;\n\n      return self.$to_r().$denominator()\n    }, TMP_Numeric_denominator_12.$$arity = 0);\n    \n    Opal.defn(self, '$div', TMP_Numeric_div_13 = function $$div(other) {\n      var self = this;\n\n      \n      if (other['$=='](0)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ZeroDivisionError'), \"divided by o\")};\n      return $rb_divide(self, other).$floor();\n    }, TMP_Numeric_div_13.$$arity = 1);\n    \n    Opal.defn(self, '$divmod', TMP_Numeric_divmod_14 = function $$divmod(other) {\n      var self = this;\n\n      return [self.$div(other), self['$%'](other)]\n    }, TMP_Numeric_divmod_14.$$arity = 1);\n    \n    Opal.defn(self, '$fdiv', TMP_Numeric_fdiv_15 = function $$fdiv(other) {\n      var self = this;\n\n      return $rb_divide(self.$to_f(), other)\n    }, TMP_Numeric_fdiv_15.$$arity = 1);\n    \n    Opal.defn(self, '$floor', TMP_Numeric_floor_16 = function $$floor() {\n      var self = this;\n\n      return self.$to_f().$floor()\n    }, TMP_Numeric_floor_16.$$arity = 0);\n    \n    Opal.defn(self, '$i', TMP_Numeric_i_17 = function $$i() {\n      var self = this;\n\n      return self.$Complex(0, self)\n    }, TMP_Numeric_i_17.$$arity = 0);\n    \n    Opal.defn(self, '$imag', TMP_Numeric_imag_18 = function $$imag() {\n      var self = this;\n\n      return 0\n    }, TMP_Numeric_imag_18.$$arity = 0);\n    Opal.alias(self, \"imaginary\", \"imag\");\n    \n    Opal.defn(self, '$integer?', TMP_Numeric_integer$q_19 = function() {\n      var self = this;\n\n      return false\n    }, TMP_Numeric_integer$q_19.$$arity = 0);\n    Opal.alias(self, \"magnitude\", \"abs\");\n    Opal.alias(self, \"modulo\", \"%\");\n    \n    Opal.defn(self, '$nonzero?', TMP_Numeric_nonzero$q_20 = function() {\n      var self = this;\n\n      if ($truthy(self['$zero?']())) {\n        return nil\n        } else {\n        return self\n      }\n    }, TMP_Numeric_nonzero$q_20.$$arity = 0);\n    \n    Opal.defn(self, '$numerator', TMP_Numeric_numerator_21 = function $$numerator() {\n      var self = this;\n\n      return self.$to_r().$numerator()\n    }, TMP_Numeric_numerator_21.$$arity = 0);\n    Opal.alias(self, \"phase\", \"arg\");\n    \n    Opal.defn(self, '$polar', TMP_Numeric_polar_22 = function $$polar() {\n      var self = this;\n\n      return [self.$abs(), self.$arg()]\n    }, TMP_Numeric_polar_22.$$arity = 0);\n    \n    Opal.defn(self, '$quo', TMP_Numeric_quo_23 = function $$quo(other) {\n      var self = this;\n\n      return $rb_divide(Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](self, Opal.const_get_relative($nesting, 'Rational'), \"to_r\"), other)\n    }, TMP_Numeric_quo_23.$$arity = 1);\n    \n    Opal.defn(self, '$real', TMP_Numeric_real_24 = function $$real() {\n      var self = this;\n\n      return self\n    }, TMP_Numeric_real_24.$$arity = 0);\n    \n    Opal.defn(self, '$real?', TMP_Numeric_real$q_25 = function() {\n      var self = this;\n\n      return true\n    }, TMP_Numeric_real$q_25.$$arity = 0);\n    \n    Opal.defn(self, '$rect', TMP_Numeric_rect_26 = function $$rect() {\n      var self = this;\n\n      return [self, 0]\n    }, TMP_Numeric_rect_26.$$arity = 0);\n    Opal.alias(self, \"rectangular\", \"rect\");\n    \n    Opal.defn(self, '$round', TMP_Numeric_round_27 = function $$round(digits) {\n      var self = this;\n\n      return self.$to_f().$round(digits)\n    }, TMP_Numeric_round_27.$$arity = -1);\n    \n    Opal.defn(self, '$to_c', TMP_Numeric_to_c_28 = function $$to_c() {\n      var self = this;\n\n      return self.$Complex(self, 0)\n    }, TMP_Numeric_to_c_28.$$arity = 0);\n    \n    Opal.defn(self, '$to_int', TMP_Numeric_to_int_29 = function $$to_int() {\n      var self = this;\n\n      return self.$to_i()\n    }, TMP_Numeric_to_int_29.$$arity = 0);\n    \n    Opal.defn(self, '$truncate', TMP_Numeric_truncate_30 = function $$truncate() {\n      var self = this;\n\n      return self.$to_f().$truncate()\n    }, TMP_Numeric_truncate_30.$$arity = 0);\n    \n    Opal.defn(self, '$zero?', TMP_Numeric_zero$q_31 = function() {\n      var self = this;\n\n      return self['$=='](0)\n    }, TMP_Numeric_zero$q_31.$$arity = 0);\n    \n    Opal.defn(self, '$positive?', TMP_Numeric_positive$q_32 = function() {\n      var self = this;\n\n      return $rb_gt(self, 0)\n    }, TMP_Numeric_positive$q_32.$$arity = 0);\n    \n    Opal.defn(self, '$negative?', TMP_Numeric_negative$q_33 = function() {\n      var self = this;\n\n      return $rb_lt(self, 0)\n    }, TMP_Numeric_negative$q_33.$$arity = 0);\n    \n    Opal.defn(self, '$dup', TMP_Numeric_dup_34 = function $$dup() {\n      var self = this;\n\n      return self\n    }, TMP_Numeric_dup_34.$$arity = 0);\n    return (Opal.defn(self, '$clone', TMP_Numeric_clone_35 = function $$clone($kwargs) {\n      var self = this, freeze;\n\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      freeze = $kwargs.$$smap[\"freeze\"];\n      if (freeze == null) {\n        freeze = true\n      }\n      return self\n    }, TMP_Numeric_clone_35.$$arity = -1), nil) && 'clone';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/array\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$require', '$include', '$to_a', '$warn', '$raise', '$replace', '$respond_to?', '$to_ary', '$coerce_to', '$coerce_to?', '$===', '$join', '$to_str', '$class', '$hash', '$<=>', '$==', '$object_id', '$inspect', '$enum_for', '$bsearch_index', '$to_proc', '$coerce_to!', '$>', '$*', '$enumerator_size', '$empty?', '$size', '$map', '$equal?', '$dup', '$each', '$[]', '$dig', '$eql?', '$length', '$begin', '$end', '$exclude_end?', '$flatten', '$__id__', '$to_s', '$new', '$!', '$>=', '$**', '$delete_if', '$reverse', '$rotate', '$rand', '$at', '$keep_if', '$shuffle!', '$<', '$sort', '$sort_by', '$!=', '$times', '$[]=', '$-', '$<<', '$values', '$kind_of?', '$last', '$first', '$upto', '$reject', '$pristine']);\n  \n  self.$require(\"corelib/enumerable\");\n  self.$require(\"corelib/numeric\");\n  return (function($base, $super, $parent_nesting) {\n    function $Array(){};\n    var self = $Array = $klass($base, $super, 'Array', $Array);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_$$_1, TMP_Array_initialize_2, TMP_Array_try_convert_3, TMP_Array_$_4, TMP_Array_$_5, TMP_Array_$_6, TMP_Array_$_7, TMP_Array_$_8, TMP_Array_$lt$lt_9, TMP_Array_$lt$eq$gt_10, TMP_Array_$eq$eq_11, TMP_Array_$$_12, TMP_Array_$$$eq_13, TMP_Array_any$q_14, TMP_Array_assoc_15, TMP_Array_at_16, TMP_Array_bsearch_index_17, TMP_Array_bsearch_18, TMP_Array_cycle_19, TMP_Array_clear_21, TMP_Array_count_22, TMP_Array_initialize_copy_23, TMP_Array_collect_24, TMP_Array_collect$B_26, TMP_Array_combination_28, TMP_Array_repeated_combination_30, TMP_Array_compact_32, TMP_Array_compact$B_33, TMP_Array_concat_36, TMP_Array_delete_37, TMP_Array_delete_at_38, TMP_Array_delete_if_39, TMP_Array_dig_41, TMP_Array_drop_42, TMP_Array_dup_43, TMP_Array_each_44, TMP_Array_each_index_46, TMP_Array_empty$q_48, TMP_Array_eql$q_49, TMP_Array_fetch_50, TMP_Array_fill_51, TMP_Array_first_52, TMP_Array_flatten_53, TMP_Array_flatten$B_54, TMP_Array_hash_55, TMP_Array_include$q_56, TMP_Array_index_57, TMP_Array_insert_58, TMP_Array_inspect_59, TMP_Array_join_60, TMP_Array_keep_if_61, TMP_Array_last_63, TMP_Array_length_64, TMP_Array_permutation_65, TMP_Array_repeated_permutation_67, TMP_Array_pop_69, TMP_Array_product_70, TMP_Array_push_71, TMP_Array_rassoc_72, TMP_Array_reject_73, TMP_Array_reject$B_75, TMP_Array_replace_77, TMP_Array_reverse_78, TMP_Array_reverse$B_79, TMP_Array_reverse_each_80, TMP_Array_rindex_82, TMP_Array_rotate_83, TMP_Array_rotate$B_84, TMP_Array_sample_87, TMP_Array_select_88, TMP_Array_select$B_90, TMP_Array_shift_92, TMP_Array_shuffle_93, TMP_Array_shuffle$B_94, TMP_Array_slice$B_95, TMP_Array_sort_96, TMP_Array_sort$B_97, TMP_Array_sort_by$B_98, TMP_Array_take_100, TMP_Array_take_while_101, TMP_Array_to_a_102, TMP_Array_to_h_103, TMP_Array_transpose_106, TMP_Array_uniq_107, TMP_Array_uniq$B_108, TMP_Array_unshift_109, TMP_Array_values_at_112, TMP_Array_zip_113, TMP_Array_inherited_114, TMP_Array_instance_variables_115;\n\n    \n    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n    def.$$is_array = true;\n    \n    function toArraySubclass(obj, klass) {\n      if (klass.$$name === Opal.Array) {\n        return obj;\n      } else {\n        return klass.$allocate().$replace((obj).$to_a());\n      }\n    }\n  ;\n    Opal.defs(self, '$[]', TMP_Array_$$_1 = function($a_rest) {\n      var self = this, objects;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      objects = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        objects[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return toArraySubclass(objects, self)\n    }, TMP_Array_$$_1.$$arity = -1);\n    \n    Opal.defn(self, '$initialize', TMP_Array_initialize_2 = function $$initialize(size, obj) {\n      var self = this, $iter = TMP_Array_initialize_2.$$p, block = $iter || nil;\n\n      if (size == null) {\n        size = nil;\n      }\n      if (obj == null) {\n        obj = nil;\n      }\n      if ($iter) TMP_Array_initialize_2.$$p = null;\n      \n      if (obj !== nil && block !== nil) {\n        self.$warn(\"warning: block supersedes default value argument\")\n      }\n\n      if (size > Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Integer'), 'MAX')) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"array size too big\")\n      }\n\n      if (arguments.length > 2) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" for 0..2)\")\n      }\n\n      if (arguments.length === 0) {\n        self.splice(0, self.length);\n        return self;\n      }\n\n      if (arguments.length === 1) {\n        if (size.$$is_array) {\n          self.$replace(size.$to_a())\n          return self;\n        } else if (size['$respond_to?'](\"to_ary\")) {\n          self.$replace(size.$to_ary())\n          return self;\n        }\n      }\n\n      size = Opal.const_get_relative($nesting, 'Opal').$coerce_to(size, Opal.const_get_relative($nesting, 'Integer'), \"to_int\")\n\n      if (size < 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"negative array size\")\n      }\n\n      self.splice(0, self.length);\n      var i, value;\n\n      if (block === nil) {\n        for (i = 0; i < size; i++) {\n          self.push(obj);\n        }\n      }\n      else {\n        for (i = 0, value; i < size; i++) {\n          value = block(i);\n          self[i] = value;\n        }\n      }\n\n      return self;\n    \n    }, TMP_Array_initialize_2.$$arity = -1);\n    Opal.defs(self, '$try_convert', TMP_Array_try_convert_3 = function $$try_convert(obj) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](obj, Opal.const_get_relative($nesting, 'Array'), \"to_ary\")\n    }, TMP_Array_try_convert_3.$$arity = 1);\n    \n    Opal.defn(self, '$&', TMP_Array_$_4 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {\n        other = other.$to_a()\n        } else {\n        other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), \"to_ary\").$to_a()\n      };\n      \n      var result = [], hash = $hash2([], {}), i, length, item;\n\n      for (i = 0, length = other.length; i < length; i++) {\n        Opal.hash_put(hash, other[i], true);\n      }\n\n      for (i = 0, length = self.length; i < length; i++) {\n        item = self[i];\n        if (Opal.hash_delete(hash, item) !== undefined) {\n          result.push(item);\n        }\n      }\n\n      return result;\n    ;\n    }, TMP_Array_$_4.$$arity = 1);\n    \n    Opal.defn(self, '$|', TMP_Array_$_5 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {\n        other = other.$to_a()\n        } else {\n        other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), \"to_ary\").$to_a()\n      };\n      \n      var hash = $hash2([], {}), i, length, item;\n\n      for (i = 0, length = self.length; i < length; i++) {\n        Opal.hash_put(hash, self[i], true);\n      }\n\n      for (i = 0, length = other.length; i < length; i++) {\n        Opal.hash_put(hash, other[i], true);\n      }\n\n      return hash.$keys();\n    ;\n    }, TMP_Array_$_5.$$arity = 1);\n    \n    Opal.defn(self, '$*', TMP_Array_$_6 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$respond_to?'](\"to_str\"))) {\n        return self.$join(other.$to_str())};\n      other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      if ($truthy(other < 0)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"negative argument\")};\n      \n      var result = [],\n          converted = self.$to_a();\n\n      for (var i = 0; i < other; i++) {\n        result = result.concat(converted);\n      }\n\n      return toArraySubclass(result, self.$class());\n    ;\n    }, TMP_Array_$_6.$$arity = 1);\n    \n    Opal.defn(self, '$+', TMP_Array_$_7 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {\n        other = other.$to_a()\n        } else {\n        other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), \"to_ary\").$to_a()\n      };\n      return self.concat(other);\n    }, TMP_Array_$_7.$$arity = 1);\n    \n    Opal.defn(self, '$-', TMP_Array_$_8 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {\n        other = other.$to_a()\n        } else {\n        other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), \"to_ary\").$to_a()\n      };\n      if ($truthy(self.length === 0)) {\n        return []};\n      if ($truthy(other.length === 0)) {\n        return self.slice()};\n      \n      var result = [], hash = $hash2([], {}), i, length, item;\n\n      for (i = 0, length = other.length; i < length; i++) {\n        Opal.hash_put(hash, other[i], true);\n      }\n\n      for (i = 0, length = self.length; i < length; i++) {\n        item = self[i];\n        if (Opal.hash_get(hash, item) === undefined) {\n          result.push(item);\n        }\n      }\n\n      return result;\n    ;\n    }, TMP_Array_$_8.$$arity = 1);\n    \n    Opal.defn(self, '$<<', TMP_Array_$lt$lt_9 = function(object) {\n      var self = this;\n\n      \n      self.push(object);;\n      return self;\n    }, TMP_Array_$lt$lt_9.$$arity = 1);\n    \n    Opal.defn(self, '$<=>', TMP_Array_$lt$eq$gt_10 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {\n        other = other.$to_a()\n      } else if ($truthy(other['$respond_to?'](\"to_ary\"))) {\n        other = other.$to_ary().$to_a()\n        } else {\n        return nil\n      };\n      \n      if (self.$hash() === other.$hash()) {\n        return 0;\n      }\n\n      var count = Math.min(self.length, other.length);\n\n      for (var i = 0; i < count; i++) {\n        var tmp = (self[i])['$<=>'](other[i]);\n\n        if (tmp !== 0) {\n          return tmp;\n        }\n      }\n\n      return (self.length)['$<=>'](other.length);\n    ;\n    }, TMP_Array_$lt$eq$gt_10.$$arity = 1);\n    \n    Opal.defn(self, '$==', TMP_Array_$eq$eq_11 = function(other) {\n      var self = this;\n\n      \n      var recursed = {};\n\n      function _eqeq(array, other) {\n        var i, length, a, b;\n\n        if (array === other)\n          return true;\n\n        if (!other.$$is_array) {\n          if (Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](other, \"to_ary\")) {\n            return (other)['$=='](array);\n          } else {\n            return false;\n          }\n        }\n\n        if (array.constructor !== Array)\n          array = (array).$to_a();\n        if (other.constructor !== Array)\n          other = (other).$to_a();\n\n        if (array.length !== other.length) {\n          return false;\n        }\n\n        recursed[(array).$object_id()] = true;\n\n        for (i = 0, length = array.length; i < length; i++) {\n          a = array[i];\n          b = other[i];\n          if (a.$$is_array) {\n            if (b.$$is_array && b.length !== a.length) {\n              return false;\n            }\n            if (!recursed.hasOwnProperty((a).$object_id())) {\n              if (!_eqeq(a, b)) {\n                return false;\n              }\n            }\n          } else {\n            if (!(a)['$=='](b)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n\n      return _eqeq(self, other);\n    \n    }, TMP_Array_$eq$eq_11.$$arity = 1);\n    \n    function $array_slice_range(self, index) {\n      var size = self.length,\n          exclude, from, to, result;\n\n      exclude = index.excl;\n      from    = Opal.Opal.$coerce_to(index.begin, Opal.Integer, 'to_int');\n      to      = Opal.Opal.$coerce_to(index.end, Opal.Integer, 'to_int');\n\n      if (from < 0) {\n        from += size;\n\n        if (from < 0) {\n          return nil;\n        }\n      }\n\n      if (from > size) {\n        return nil;\n      }\n\n      if (to < 0) {\n        to += size;\n\n        if (to < 0) {\n          return [];\n        }\n      }\n\n      if (!exclude) {\n        to += 1;\n      }\n\n      result = self.slice(from, to);\n      return toArraySubclass(result, self.$class());\n    }\n\n    function $array_slice_index_length(self, index, length) {\n      var size = self.length,\n          exclude, from, to, result;\n\n      index = Opal.Opal.$coerce_to(index, Opal.Integer, 'to_int');\n\n      if (index < 0) {\n        index += size;\n\n        if (index < 0) {\n          return nil;\n        }\n      }\n\n      if (length === undefined) {\n        if (index >= size || index < 0) {\n          return nil;\n        }\n\n        return self[index];\n      }\n      else {\n        length = Opal.Opal.$coerce_to(length, Opal.Integer, 'to_int');\n\n        if (length < 0 || index > size || index < 0) {\n          return nil;\n        }\n\n        result = self.slice(index, index + length);\n      }\n      return toArraySubclass(result, self.$class());\n    }\n  ;\n    \n    Opal.defn(self, '$[]', TMP_Array_$$_12 = function(index, length) {\n      var self = this;\n\n      \n      if (index.$$is_range) {\n        return $array_slice_range(self, index);\n      }\n      else {\n        return $array_slice_index_length(self, index, length);\n      }\n    \n    }, TMP_Array_$$_12.$$arity = -2);\n    \n    Opal.defn(self, '$[]=', TMP_Array_$$$eq_13 = function(index, value, extra) {\n      var self = this, data = nil, length = nil;\n\n      \n      \n      var i, size = self.length;\n    ;\n      if ($truthy(Opal.const_get_relative($nesting, 'Range')['$==='](index))) {\n        \n        if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](value))) {\n          data = value.$to_a()\n        } else if ($truthy(value['$respond_to?'](\"to_ary\"))) {\n          data = value.$to_ary().$to_a()\n          } else {\n          data = [value]\n        };\n        \n        var exclude = index.excl,\n            from    = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index.begin, Opal.const_get_relative($nesting, 'Integer'), \"to_int\"),\n            to      = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index.end, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n        if (from < 0) {\n          from += size;\n\n          if (from < 0) {\n            self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"\" + (index.$inspect()) + \" out of range\");\n          }\n        }\n\n        if (to < 0) {\n          to += size;\n        }\n\n        if (!exclude) {\n          to += 1;\n        }\n\n        if (from > size) {\n          for (i = size; i < from; i++) {\n            self[i] = nil;\n          }\n        }\n\n        if (to < 0) {\n          self.splice.apply(self, [from, 0].concat(data));\n        }\n        else {\n          self.splice.apply(self, [from, to - from].concat(data));\n        }\n\n        return value;\n      ;\n        } else {\n        \n        if ($truthy(extra === undefined)) {\n          length = 1\n          } else {\n          \n          length = value;\n          value = extra;\n          if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](value))) {\n            data = value.$to_a()\n          } else if ($truthy(value['$respond_to?'](\"to_ary\"))) {\n            data = value.$to_ary().$to_a()\n            } else {\n            data = [value]\n          };\n        };\n        \n        var old;\n\n        index  = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        length = Opal.const_get_relative($nesting, 'Opal').$coerce_to(length, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n        if (index < 0) {\n          old    = index;\n          index += size;\n\n          if (index < 0) {\n            self.$raise(Opal.const_get_relative($nesting, 'IndexError'), \"\" + \"index \" + (old) + \" too small for array; minimum \" + (-self.length));\n          }\n        }\n\n        if (length < 0) {\n          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), \"\" + \"negative length (\" + (length) + \")\")\n        }\n\n        if (index > size) {\n          for (i = size; i < index; i++) {\n            self[i] = nil;\n          }\n        }\n\n        if (extra === undefined) {\n          self[index] = value;\n        }\n        else {\n          self.splice.apply(self, [index, length].concat(data));\n        }\n\n        return value;\n      ;\n      };\n    }, TMP_Array_$$$eq_13.$$arity = -3);\n    \n    Opal.defn(self, '$any?', TMP_Array_any$q_14 = function() {\n      var self = this, $iter = TMP_Array_any$q_14.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Array_any$q_14.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      if (self.length === 0) return false;;\n      return $send(self, Opal.find_super_dispatcher(self, 'any?', TMP_Array_any$q_14, false), $zuper, $iter);\n    }, TMP_Array_any$q_14.$$arity = 0);\n    \n    Opal.defn(self, '$assoc', TMP_Array_assoc_15 = function $$assoc(object) {\n      var self = this;\n\n      \n      for (var i = 0, length = self.length, item; i < length; i++) {\n        if (item = self[i], item.length && (item[0])['$=='](object)) {\n          return item;\n        }\n      }\n\n      return nil;\n    \n    }, TMP_Array_assoc_15.$$arity = 1);\n    \n    Opal.defn(self, '$at', TMP_Array_at_16 = function $$at(index) {\n      var self = this;\n\n      \n      index = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      \n      if (index < 0) {\n        index += self.length;\n      }\n\n      if (index < 0 || index >= self.length) {\n        return nil;\n      }\n\n      return self[index];\n    ;\n    }, TMP_Array_at_16.$$arity = 1);\n    \n    Opal.defn(self, '$bsearch_index', TMP_Array_bsearch_index_17 = function $$bsearch_index() {\n      var self = this, $iter = TMP_Array_bsearch_index_17.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_bsearch_index_17.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"bsearch_index\")\n      };\n      \n      var min = 0,\n          max = self.length,\n          mid,\n          val,\n          ret,\n          smaller = false,\n          satisfied = nil;\n\n      while (min < max) {\n        mid = min + Math.floor((max - min) / 2);\n        val = self[mid];\n        ret = Opal.yield1(block, val);\n\n        if (ret === true) {\n          satisfied = mid;\n          smaller = true;\n        }\n        else if (ret === false || ret === nil) {\n          smaller = false;\n        }\n        else if (ret.$$is_number) {\n          if (ret === 0) { return mid; }\n          smaller = (ret < 0);\n        }\n        else {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"wrong argument type \" + ((ret).$class()) + \" (must be numeric, true, false or nil)\")\n        }\n\n        if (smaller) { max = mid; } else { min = mid + 1; }\n      }\n\n      return satisfied;\n    ;\n    }, TMP_Array_bsearch_index_17.$$arity = 0);\n    \n    Opal.defn(self, '$bsearch', TMP_Array_bsearch_18 = function $$bsearch() {\n      var self = this, $iter = TMP_Array_bsearch_18.$$p, block = $iter || nil, index = nil;\n\n      if ($iter) TMP_Array_bsearch_18.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"bsearch\")\n      };\n      index = $send(self, 'bsearch_index', [], block.$to_proc());\n      \n      if (index != null && index.$$is_number) {\n        return self[index];\n      } else {\n        return index;\n      }\n    ;\n    }, TMP_Array_bsearch_18.$$arity = 0);\n    \n    Opal.defn(self, '$cycle', TMP_Array_cycle_19 = function $$cycle(n) {\n      var TMP_20, $a, self = this, $iter = TMP_Array_cycle_19.$$p, block = $iter || nil;\n\n      if (n == null) {\n        n = nil;\n      }\n      if ($iter) TMP_Array_cycle_19.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"cycle\", n], (TMP_20 = function(){var self = TMP_20.$$s || this;\n\n        if (n['$=='](nil)) {\n            return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY')\n            } else {\n            \n            n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n            if ($truthy($rb_gt(n, 0))) {\n              return $rb_times(self.$enumerator_size(), n)\n              } else {\n              return 0\n            };\n          }}, TMP_20.$$s = self, TMP_20.$$arity = 0, TMP_20))\n      };\n      if ($truthy(($truthy($a = self['$empty?']()) ? $a : n['$=='](0)))) {\n        return nil};\n      \n      var i, length, value;\n\n      if (n === nil) {\n        while (true) {\n          for (i = 0, length = self.length; i < length; i++) {\n            value = Opal.yield1(block, self[i]);\n          }\n        }\n      }\n      else {\n        n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if (n <= 0) {\n          return self;\n        }\n\n        while (n > 0) {\n          for (i = 0, length = self.length; i < length; i++) {\n            value = Opal.yield1(block, self[i]);\n          }\n\n          n--;\n        }\n      }\n    ;\n      return self;\n    }, TMP_Array_cycle_19.$$arity = -1);\n    \n    Opal.defn(self, '$clear', TMP_Array_clear_21 = function $$clear() {\n      var self = this;\n\n      \n      self.splice(0, self.length);\n      return self;\n    }, TMP_Array_clear_21.$$arity = 0);\n    \n    Opal.defn(self, '$count', TMP_Array_count_22 = function $$count(object) {\n      var $a, self = this, $iter = TMP_Array_count_22.$$p, block = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if (object == null) {\n        object = nil;\n      }\n      if ($iter) TMP_Array_count_22.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if ($truthy(($truthy($a = object) ? $a : block))) {\n        return $send(self, Opal.find_super_dispatcher(self, 'count', TMP_Array_count_22, false), $zuper, $iter)\n        } else {\n        return self.$size()\n      }\n    }, TMP_Array_count_22.$$arity = -1);\n    \n    Opal.defn(self, '$initialize_copy', TMP_Array_initialize_copy_23 = function $$initialize_copy(other) {\n      var self = this;\n\n      return self.$replace(other)\n    }, TMP_Array_initialize_copy_23.$$arity = 1);\n    \n    Opal.defn(self, '$collect', TMP_Array_collect_24 = function $$collect() {\n      var TMP_25, self = this, $iter = TMP_Array_collect_24.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_collect_24.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"collect\"], (TMP_25 = function(){var self = TMP_25.$$s || this;\n\n        return self.$size()}, TMP_25.$$s = self, TMP_25.$$arity = 0, TMP_25))\n      };\n      \n      var result = [];\n\n      for (var i = 0, length = self.length; i < length; i++) {\n        var value = Opal.yield1(block, self[i]);\n        result.push(value);\n      }\n\n      return result;\n    ;\n    }, TMP_Array_collect_24.$$arity = 0);\n    \n    Opal.defn(self, '$collect!', TMP_Array_collect$B_26 = function() {\n      var TMP_27, self = this, $iter = TMP_Array_collect$B_26.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_collect$B_26.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"collect!\"], (TMP_27 = function(){var self = TMP_27.$$s || this;\n\n        return self.$size()}, TMP_27.$$s = self, TMP_27.$$arity = 0, TMP_27))\n      };\n      \n      for (var i = 0, length = self.length; i < length; i++) {\n        var value = Opal.yield1(block, self[i]);\n        self[i] = value;\n      }\n    ;\n      return self;\n    }, TMP_Array_collect$B_26.$$arity = 0);\n    \n    function binomial_coefficient(n, k) {\n      if (n === k || k === 0) {\n        return 1;\n      }\n\n      if (k > 0 && n > k) {\n        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);\n      }\n\n      return 0;\n    }\n  ;\n    \n    Opal.defn(self, '$combination', TMP_Array_combination_28 = function $$combination(n) {\n      var TMP_29, self = this, $iter = TMP_Array_combination_28.$$p, $yield = $iter || nil, num = nil;\n\n      if ($iter) TMP_Array_combination_28.$$p = null;\n      \n      num = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      if (($yield !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"combination\", num], (TMP_29 = function(){var self = TMP_29.$$s || this;\n\n        return binomial_coefficient(self.length, num)}, TMP_29.$$s = self, TMP_29.$$arity = 0, TMP_29))\n      };\n      \n      var i, length, stack, chosen, lev, done, next;\n\n      if (num === 0) {\n        Opal.yield1($yield, [])\n      } else if (num === 1) {\n        for (i = 0, length = self.length; i < length; i++) {\n          Opal.yield1($yield, [self[i]])\n        }\n      }\n      else if (num === self.length) {\n        Opal.yield1($yield, self.slice())\n      }\n      else if (num >= 0 && num < self.length) {\n        stack = [];\n        for (i = 0; i <= num + 1; i++) {\n          stack.push(0);\n        }\n\n        chosen = [];\n        lev = 0;\n        done = false;\n        stack[0] = -1;\n\n        while (!done) {\n          chosen[lev] = self[stack[lev+1]];\n          while (lev < num - 1) {\n            lev++;\n            next = stack[lev+1] = stack[lev] + 1;\n            chosen[lev] = self[next];\n          }\n          Opal.yield1($yield, chosen.slice())\n          lev++;\n          do {\n            done = (lev === 0);\n            stack[lev]++;\n            lev--;\n          } while ( stack[lev+1] + num === self.length + lev + 1 );\n        }\n      }\n    ;\n      return self;\n    }, TMP_Array_combination_28.$$arity = 1);\n    \n    Opal.defn(self, '$repeated_combination', TMP_Array_repeated_combination_30 = function $$repeated_combination(n) {\n      var TMP_31, self = this, $iter = TMP_Array_repeated_combination_30.$$p, $yield = $iter || nil, num = nil;\n\n      if ($iter) TMP_Array_repeated_combination_30.$$p = null;\n      \n      num = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      if (($yield !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"repeated_combination\", num], (TMP_31 = function(){var self = TMP_31.$$s || this;\n\n        return binomial_coefficient(self.length + num - 1, num)}, TMP_31.$$s = self, TMP_31.$$arity = 0, TMP_31))\n      };\n      \n      function iterate(max, from, buffer, self) {\n        if (buffer.length == max) {\n          var copy = buffer.slice();\n          Opal.yield1($yield, copy)\n          return;\n        }\n        for (var i = from; i < self.length; i++) {\n          buffer.push(self[i]);\n          iterate(max, i, buffer, self);\n          buffer.pop();\n        }\n      }\n\n      if (num >= 0) {\n        iterate(num, 0, [], self);\n      }\n    ;\n      return self;\n    }, TMP_Array_repeated_combination_30.$$arity = 1);\n    \n    Opal.defn(self, '$compact', TMP_Array_compact_32 = function $$compact() {\n      var self = this;\n\n      \n      var result = [];\n\n      for (var i = 0, length = self.length, item; i < length; i++) {\n        if ((item = self[i]) !== nil) {\n          result.push(item);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Array_compact_32.$$arity = 0);\n    \n    Opal.defn(self, '$compact!', TMP_Array_compact$B_33 = function() {\n      var self = this;\n\n      \n      var original = self.length;\n\n      for (var i = 0, length = self.length; i < length; i++) {\n        if (self[i] === nil) {\n          self.splice(i, 1);\n\n          length--;\n          i--;\n        }\n      }\n\n      return self.length === original ? nil : self;\n    \n    }, TMP_Array_compact$B_33.$$arity = 0);\n    \n    Opal.defn(self, '$concat', TMP_Array_concat_36 = function $$concat($a_rest) {\n      var TMP_34, TMP_35, self = this, others;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      others = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        others[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      others = $send(others, 'map', [], (TMP_34 = function(other){var self = TMP_34.$$s || this;\nif (other == null) other = nil;\n      \n        if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {\n          other = other.$to_a()\n          } else {\n          other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), \"to_ary\").$to_a()\n        };\n        if ($truthy(other['$equal?'](self))) {\n          other = other.$dup()};\n        return other;}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34));\n      $send(others, 'each', [], (TMP_35 = function(other){var self = TMP_35.$$s || this;\nif (other == null) other = nil;\n      \n        for (var i = 0, length = other.length; i < length; i++) {\n          self.push(other[i]);\n        }\n      }, TMP_35.$$s = self, TMP_35.$$arity = 1, TMP_35));\n      return self;\n    }, TMP_Array_concat_36.$$arity = -1);\n    \n    Opal.defn(self, '$delete', TMP_Array_delete_37 = function(object) {\n      var self = this, $iter = TMP_Array_delete_37.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_Array_delete_37.$$p = null;\n      \n      var original = self.length;\n\n      for (var i = 0, length = original; i < length; i++) {\n        if ((self[i])['$=='](object)) {\n          self.splice(i, 1);\n\n          length--;\n          i--;\n        }\n      }\n\n      if (self.length === original) {\n        if (($yield !== nil)) {\n          return Opal.yieldX($yield, []);\n        }\n        return nil;\n      }\n      return object;\n    \n    }, TMP_Array_delete_37.$$arity = 1);\n    \n    Opal.defn(self, '$delete_at', TMP_Array_delete_at_38 = function $$delete_at(index) {\n      var self = this;\n\n      \n      index = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n      if (index < 0) {\n        index += self.length;\n      }\n\n      if (index < 0 || index >= self.length) {\n        return nil;\n      }\n\n      var result = self[index];\n\n      self.splice(index, 1);\n\n      return result;\n    \n    }, TMP_Array_delete_at_38.$$arity = 1);\n    \n    Opal.defn(self, '$delete_if', TMP_Array_delete_if_39 = function $$delete_if() {\n      var TMP_40, self = this, $iter = TMP_Array_delete_if_39.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_delete_if_39.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"delete_if\"], (TMP_40 = function(){var self = TMP_40.$$s || this;\n\n        return self.$size()}, TMP_40.$$s = self, TMP_40.$$arity = 0, TMP_40))\n      };\n      \n      for (var i = 0, length = self.length, value; i < length; i++) {\n        value = block(self[i]);\n\n        if (value !== false && value !== nil) {\n          self.splice(i, 1);\n\n          length--;\n          i--;\n        }\n      }\n    ;\n      return self;\n    }, TMP_Array_delete_if_39.$$arity = 0);\n    \n    Opal.defn(self, '$dig', TMP_Array_dig_41 = function $$dig(idx, $a_rest) {\n      var self = this, idxs, item = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      idxs = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        idxs[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      item = self['$[]'](idx);\n      \n      if (item === nil || idxs.length === 0) {\n        return item;\n      }\n    ;\n      if ($truthy(item['$respond_to?'](\"dig\"))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + (item.$class()) + \" does not have #dig method\")\n      };\n      return $send(item, 'dig', Opal.to_a(idxs));\n    }, TMP_Array_dig_41.$$arity = -2);\n    \n    Opal.defn(self, '$drop', TMP_Array_drop_42 = function $$drop(number) {\n      var self = this;\n\n      \n      if (number < 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'))\n      }\n\n      return self.slice(number);\n    \n    }, TMP_Array_drop_42.$$arity = 1);\n    \n    Opal.defn(self, '$dup', TMP_Array_dup_43 = function $$dup() {\n      var self = this, $iter = TMP_Array_dup_43.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Array_dup_43.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      \n      if (\n        self.$$class === Opal.Array &&\n        self.$$class.$allocate.$$pristine &&\n        self.$copy_instance_variables.$$pristine &&\n        self.$initialize_dup.$$pristine\n      ) return self.slice(0);\n    ;\n      return $send(self, Opal.find_super_dispatcher(self, 'dup', TMP_Array_dup_43, false), $zuper, $iter);\n    }, TMP_Array_dup_43.$$arity = 0);\n    \n    Opal.defn(self, '$each', TMP_Array_each_44 = function $$each() {\n      var TMP_45, self = this, $iter = TMP_Array_each_44.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_each_44.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"each\"], (TMP_45 = function(){var self = TMP_45.$$s || this;\n\n        return self.$size()}, TMP_45.$$s = self, TMP_45.$$arity = 0, TMP_45))\n      };\n      \n      for (var i = 0, length = self.length; i < length; i++) {\n        var value = Opal.yield1(block, self[i]);\n      }\n    ;\n      return self;\n    }, TMP_Array_each_44.$$arity = 0);\n    \n    Opal.defn(self, '$each_index', TMP_Array_each_index_46 = function $$each_index() {\n      var TMP_47, self = this, $iter = TMP_Array_each_index_46.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_each_index_46.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"each_index\"], (TMP_47 = function(){var self = TMP_47.$$s || this;\n\n        return self.$size()}, TMP_47.$$s = self, TMP_47.$$arity = 0, TMP_47))\n      };\n      \n      for (var i = 0, length = self.length; i < length; i++) {\n        var value = Opal.yield1(block, i);\n      }\n    ;\n      return self;\n    }, TMP_Array_each_index_46.$$arity = 0);\n    \n    Opal.defn(self, '$empty?', TMP_Array_empty$q_48 = function() {\n      var self = this;\n\n      return self.length === 0\n    }, TMP_Array_empty$q_48.$$arity = 0);\n    \n    Opal.defn(self, '$eql?', TMP_Array_eql$q_49 = function(other) {\n      var self = this;\n\n      \n      var recursed = {};\n\n      function _eql(array, other) {\n        var i, length, a, b;\n\n        if (!other.$$is_array) {\n          return false;\n        }\n\n        other = other.$to_a();\n\n        if (array.length !== other.length) {\n          return false;\n        }\n\n        recursed[(array).$object_id()] = true;\n\n        for (i = 0, length = array.length; i < length; i++) {\n          a = array[i];\n          b = other[i];\n          if (a.$$is_array) {\n            if (b.$$is_array && b.length !== a.length) {\n              return false;\n            }\n            if (!recursed.hasOwnProperty((a).$object_id())) {\n              if (!_eql(a, b)) {\n                return false;\n              }\n            }\n          } else {\n            if (!(a)['$eql?'](b)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n\n      return _eql(self, other);\n    \n    }, TMP_Array_eql$q_49.$$arity = 1);\n    \n    Opal.defn(self, '$fetch', TMP_Array_fetch_50 = function $$fetch(index, defaults) {\n      var self = this, $iter = TMP_Array_fetch_50.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_fetch_50.$$p = null;\n      \n      var original = index;\n\n      index = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n      if (index < 0) {\n        index += self.length;\n      }\n\n      if (index >= 0 && index < self.length) {\n        return self[index];\n      }\n\n      if (block !== nil && defaults != null) {\n        self.$warn(\"warning: block supersedes default value argument\")\n      }\n\n      if (block !== nil) {\n        return block(original);\n      }\n\n      if (defaults != null) {\n        return defaults;\n      }\n\n      if (self.length === 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'IndexError'), \"\" + \"index \" + (original) + \" outside of array bounds: 0...0\")\n      }\n      else {\n        self.$raise(Opal.const_get_relative($nesting, 'IndexError'), \"\" + \"index \" + (original) + \" outside of array bounds: -\" + (self.length) + \"...\" + (self.length));\n      }\n    \n    }, TMP_Array_fetch_50.$$arity = -2);\n    \n    Opal.defn(self, '$fill', TMP_Array_fill_51 = function $$fill($a_rest) {\n      var $b, $c, self = this, args, $iter = TMP_Array_fill_51.$$p, block = $iter || nil, one = nil, two = nil, obj = nil, left = nil, right = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Array_fill_51.$$p = null;\n      \n      \n      var i, length, value;\n    ;\n      if ($truthy(block)) {\n        \n        if ($truthy(args.length > 2)) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (args.$length()) + \" for 0..2)\")};\n        $c = args, $b = Opal.to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;\n        } else {\n        \n        if ($truthy(args.length == 0)) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"wrong number of arguments (0 for 1..3)\")\n        } else if ($truthy(args.length > 3)) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (args.$length()) + \" for 1..3)\")};\n        $c = args, $b = Opal.to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;\n      };\n      if ($truthy(Opal.const_get_relative($nesting, 'Range')['$==='](one))) {\n        \n        if ($truthy(two)) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"length invalid with range\")};\n        left = Opal.const_get_relative($nesting, 'Opal').$coerce_to(one.$begin(), Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if ($truthy(left < 0)) {\n          left += this.length};\n        if ($truthy(left < 0)) {\n          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"\" + (one.$inspect()) + \" out of range\")};\n        right = Opal.const_get_relative($nesting, 'Opal').$coerce_to(one.$end(), Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if ($truthy(right < 0)) {\n          right += this.length};\n        if ($truthy(one['$exclude_end?']())) {\n          } else {\n          right += 1\n        };\n        if ($truthy(right <= left)) {\n          return self};\n      } else if ($truthy(one)) {\n        \n        left = Opal.const_get_relative($nesting, 'Opal').$coerce_to(one, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if ($truthy(left < 0)) {\n          left += this.length};\n        if ($truthy(left < 0)) {\n          left = 0};\n        if ($truthy(two)) {\n          \n          right = Opal.const_get_relative($nesting, 'Opal').$coerce_to(two, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n          if ($truthy(right == 0)) {\n            return self};\n          right += left;\n          } else {\n          right = this.length\n        };\n        } else {\n        \n        left = 0;\n        right = this.length;\n      };\n      if ($truthy(left > this.length)) {\n        \n        for (i = this.length; i < right; i++) {\n          self[i] = nil;\n        }\n      };\n      if ($truthy(right > this.length)) {\n        this.length = right};\n      if ($truthy(block)) {\n        \n        for (length = this.length; left < right; left++) {\n          value = block(left);\n          self[left] = value;\n        }\n      \n        } else {\n        \n        for (length = this.length; left < right; left++) {\n          self[left] = obj;\n        }\n      \n      };\n      return self;\n    }, TMP_Array_fill_51.$$arity = -1);\n    \n    Opal.defn(self, '$first', TMP_Array_first_52 = function $$first(count) {\n      var self = this;\n\n      \n      if (count == null) {\n        return self.length === 0 ? nil : self[0];\n      }\n\n      count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n      if (count < 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"negative array size\");\n      }\n\n      return self.slice(0, count);\n    \n    }, TMP_Array_first_52.$$arity = -1);\n    \n    Opal.defn(self, '$flatten', TMP_Array_flatten_53 = function $$flatten(level) {\n      var self = this;\n\n      \n      function _flatten(array, level) {\n        var result = [],\n            i, length,\n            item, ary;\n\n        array = (array).$to_a();\n\n        for (i = 0, length = array.length; i < length; i++) {\n          item = array[i];\n\n          if (!Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](item, \"to_ary\")) {\n            result.push(item);\n            continue;\n          }\n\n          ary = (item).$to_ary();\n\n          if (ary === nil) {\n            result.push(item);\n            continue;\n          }\n\n          if (!ary.$$is_array) {\n            self.$raise(Opal.const_get_relative($nesting, 'TypeError'));\n          }\n\n          if (ary === self) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'));\n          }\n\n          switch (level) {\n          case undefined:\n            result = result.concat(_flatten(ary));\n            break;\n          case 0:\n            result.push(ary);\n            break;\n          default:\n            result.push.apply(result, _flatten(ary, level - 1));\n          }\n        }\n        return result;\n      }\n\n      if (level !== undefined) {\n        level = Opal.const_get_relative($nesting, 'Opal').$coerce_to(level, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      }\n\n      return toArraySubclass(_flatten(self, level), self.$class());\n    \n    }, TMP_Array_flatten_53.$$arity = -1);\n    \n    Opal.defn(self, '$flatten!', TMP_Array_flatten$B_54 = function(level) {\n      var self = this;\n\n      \n      \n      var flattened = self.$flatten(level);\n\n      if (self.length == flattened.length) {\n        for (var i = 0, length = self.length; i < length; i++) {\n          if (self[i] !== flattened[i]) {\n            break;\n          }\n        }\n\n        if (i == length) {\n          return nil;\n        }\n      }\n\n      self.$replace(flattened);\n    ;\n      return self;\n    }, TMP_Array_flatten$B_54.$$arity = -1);\n    \n    Opal.defn(self, '$hash', TMP_Array_hash_55 = function $$hash() {\n      var self = this;\n\n      \n      var top = (Opal.hash_ids === undefined),\n          result = ['A'],\n          hash_id = self.$object_id(),\n          item, i, key;\n\n      try {\n        if (top) {\n          Opal.hash_ids = Object.create(null);\n        }\n\n        // return early for recursive structures\n        if (Opal.hash_ids[hash_id]) {\n          return 'self';\n        }\n\n        for (key in Opal.hash_ids) {\n          item = Opal.hash_ids[key];\n          if (self['$eql?'](item)) {\n            return 'self';\n          }\n        }\n\n        Opal.hash_ids[hash_id] = self;\n\n        for (i = 0; i < self.length; i++) {\n          item = self[i];\n          result.push(item.$hash());\n        }\n\n        return result.join(',');\n      } finally {\n        if (top) {\n          Opal.hash_ids = undefined;\n        }\n      }\n    \n    }, TMP_Array_hash_55.$$arity = 0);\n    \n    Opal.defn(self, '$include?', TMP_Array_include$q_56 = function(member) {\n      var self = this;\n\n      \n      for (var i = 0, length = self.length; i < length; i++) {\n        if ((self[i])['$=='](member)) {\n          return true;\n        }\n      }\n\n      return false;\n    \n    }, TMP_Array_include$q_56.$$arity = 1);\n    \n    Opal.defn(self, '$index', TMP_Array_index_57 = function $$index(object) {\n      var self = this, $iter = TMP_Array_index_57.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_index_57.$$p = null;\n      \n      var i, length, value;\n\n      if (object != null && block !== nil) {\n        self.$warn(\"warning: given block not used\")\n      }\n\n      if (object != null) {\n        for (i = 0, length = self.length; i < length; i++) {\n          if ((self[i])['$=='](object)) {\n            return i;\n          }\n        }\n      }\n      else if (block !== nil) {\n        for (i = 0, length = self.length; i < length; i++) {\n          value = block(self[i]);\n\n          if (value !== false && value !== nil) {\n            return i;\n          }\n        }\n      }\n      else {\n        return self.$enum_for(\"index\");\n      }\n\n      return nil;\n    \n    }, TMP_Array_index_57.$$arity = -1);\n    \n    Opal.defn(self, '$insert', TMP_Array_insert_58 = function $$insert(index, $a_rest) {\n      var self = this, objects;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      objects = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        objects[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      \n      index = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n      if (objects.length > 0) {\n        if (index < 0) {\n          index += self.length + 1;\n\n          if (index < 0) {\n            self.$raise(Opal.const_get_relative($nesting, 'IndexError'), \"\" + (index) + \" is out of bounds\");\n          }\n        }\n        if (index > self.length) {\n          for (var i = self.length; i < index; i++) {\n            self.push(nil);\n          }\n        }\n\n        self.splice.apply(self, [index, 0].concat(objects));\n      }\n    ;\n      return self;\n    }, TMP_Array_insert_58.$$arity = -2);\n    \n    Opal.defn(self, '$inspect', TMP_Array_inspect_59 = function $$inspect() {\n      var self = this;\n\n      \n      var result = [],\n          id     = self.$__id__();\n\n      for (var i = 0, length = self.length; i < length; i++) {\n        var item = self['$[]'](i);\n\n        if ((item).$__id__() === id) {\n          result.push('[...]');\n        }\n        else {\n          result.push((item).$inspect());\n        }\n      }\n\n      return '[' + result.join(', ') + ']';\n    \n    }, TMP_Array_inspect_59.$$arity = 0);\n    \n    Opal.defn(self, '$join', TMP_Array_join_60 = function $$join(sep) {\n      var self = this;\n      if ($gvars[\",\"] == null) $gvars[\",\"] = nil;\n\n      if (sep == null) {\n        sep = nil;\n      }\n      \n      if ($truthy(self.length === 0)) {\n        return \"\"};\n      if ($truthy(sep === nil)) {\n        sep = $gvars[\",\"]};\n      \n      var result = [];\n      var i, length, item, tmp;\n\n      for (i = 0, length = self.length; i < length; i++) {\n        item = self[i];\n\n        if (Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](item, \"to_str\")) {\n          tmp = (item).$to_str();\n\n          if (tmp !== nil) {\n            result.push((tmp).$to_s());\n\n            continue;\n          }\n        }\n\n        if (Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](item, \"to_ary\")) {\n          tmp = (item).$to_ary();\n\n          if (tmp === self) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'));\n          }\n\n          if (tmp !== nil) {\n            result.push((tmp).$join(sep));\n\n            continue;\n          }\n        }\n\n        if (Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](item, \"to_s\")) {\n          tmp = (item).$to_s();\n\n          if (tmp !== nil) {\n            result.push(tmp);\n\n            continue;\n          }\n        }\n\n        self.$raise(Opal.const_get_relative($nesting, 'NoMethodError').$new(\"\" + (Opal.inspect(item)) + \" doesn't respond to #to_str, #to_ary or #to_s\", \"to_str\"));\n      }\n\n      if (sep === nil) {\n        return result.join('');\n      }\n      else {\n        return result.join(Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](sep, Opal.const_get_relative($nesting, 'String'), \"to_str\").$to_s());\n      }\n    ;\n    }, TMP_Array_join_60.$$arity = -1);\n    \n    Opal.defn(self, '$keep_if', TMP_Array_keep_if_61 = function $$keep_if() {\n      var TMP_62, self = this, $iter = TMP_Array_keep_if_61.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_keep_if_61.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"keep_if\"], (TMP_62 = function(){var self = TMP_62.$$s || this;\n\n        return self.$size()}, TMP_62.$$s = self, TMP_62.$$arity = 0, TMP_62))\n      };\n      \n      for (var i = 0, length = self.length, value; i < length; i++) {\n        value = block(self[i]);\n\n        if (value === false || value === nil) {\n          self.splice(i, 1);\n\n          length--;\n          i--;\n        }\n      }\n    ;\n      return self;\n    }, TMP_Array_keep_if_61.$$arity = 0);\n    \n    Opal.defn(self, '$last', TMP_Array_last_63 = function $$last(count) {\n      var self = this;\n\n      \n      if (count == null) {\n        return self.length === 0 ? nil : self[self.length - 1];\n      }\n\n      count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n      if (count < 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"negative array size\");\n      }\n\n      if (count > self.length) {\n        count = self.length;\n      }\n\n      return self.slice(self.length - count, self.length);\n    \n    }, TMP_Array_last_63.$$arity = -1);\n    \n    Opal.defn(self, '$length', TMP_Array_length_64 = function $$length() {\n      var self = this;\n\n      return self.length\n    }, TMP_Array_length_64.$$arity = 0);\n    Opal.alias(self, \"map\", \"collect\");\n    Opal.alias(self, \"map!\", \"collect!\");\n    \n    // Returns the product of from, from-1, ..., from - how_many + 1.\n    function descending_factorial(from, how_many) {\n      var count = how_many >= 0 ? 1 : 0;\n      while (how_many) {\n        count *= from;\n        from--;\n        how_many--;\n      }\n      return count;\n    }\n  ;\n    \n    Opal.defn(self, '$permutation', TMP_Array_permutation_65 = function $$permutation(num) {\n      var TMP_66, self = this, $iter = TMP_Array_permutation_65.$$p, block = $iter || nil, perm = nil, used = nil;\n\n      if ($iter) TMP_Array_permutation_65.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"permutation\", num], (TMP_66 = function(){var self = TMP_66.$$s || this;\n\n        return descending_factorial(self.length, num === undefined ? self.length : num)}, TMP_66.$$s = self, TMP_66.$$arity = 0, TMP_66))\n      };\n      \n      var permute, offensive, output;\n\n      if (num === undefined) {\n        num = self.length;\n      }\n      else {\n        num = Opal.const_get_relative($nesting, 'Opal').$coerce_to(num, Opal.const_get_relative($nesting, 'Integer'), \"to_int\")\n      }\n\n      if (num < 0 || self.length < num) {\n        // no permutations, yield nothing\n      }\n      else if (num === 0) {\n        // exactly one permutation: the zero-length array\n        Opal.yield1(block, [])\n      }\n      else if (num === 1) {\n        // this is a special, easy case\n        for (var i = 0; i < self.length; i++) {\n          Opal.yield1(block, [self[i]])\n        }\n      }\n      else {\n        // this is the general case\n        (perm = Opal.const_get_relative($nesting, 'Array').$new(num));\n        (used = Opal.const_get_relative($nesting, 'Array').$new(self.length, false));\n\n        permute = function(num, perm, index, used, blk) {\n          self = this;\n          for(var i = 0; i < self.length; i++){\n            if(used['$[]'](i)['$!']()) {\n              perm[index] = i;\n              if(index < num - 1) {\n                used[i] = true;\n                permute.call(self, num, perm, index + 1, used, blk);\n                used[i] = false;\n              }\n              else {\n                output = [];\n                for (var j = 0; j < perm.length; j++) {\n                  output.push(self[perm[j]]);\n                }\n                Opal.yield1(blk, output);\n              }\n            }\n          }\n        }\n\n        if ((block !== nil)) {\n          // offensive (both definitions) copy.\n          offensive = self.slice();\n          permute.call(offensive, num, perm, 0, used, block);\n        }\n        else {\n          permute.call(self, num, perm, 0, used, block);\n        }\n      }\n    ;\n      return self;\n    }, TMP_Array_permutation_65.$$arity = -1);\n    \n    Opal.defn(self, '$repeated_permutation', TMP_Array_repeated_permutation_67 = function $$repeated_permutation(n) {\n      var TMP_68, self = this, $iter = TMP_Array_repeated_permutation_67.$$p, $yield = $iter || nil, num = nil;\n\n      if ($iter) TMP_Array_repeated_permutation_67.$$p = null;\n      \n      num = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      if (($yield !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"repeated_permutation\", num], (TMP_68 = function(){var self = TMP_68.$$s || this;\n\n        if ($truthy($rb_ge(num, 0))) {\n            return self.$size()['$**'](num)\n            } else {\n            return 0\n          }}, TMP_68.$$s = self, TMP_68.$$arity = 0, TMP_68))\n      };\n      \n      function iterate(max, buffer, self) {\n        if (buffer.length == max) {\n          var copy = buffer.slice();\n          Opal.yield1($yield, copy)\n          return;\n        }\n        for (var i = 0; i < self.length; i++) {\n          buffer.push(self[i]);\n          iterate(max, buffer, self);\n          buffer.pop();\n        }\n      }\n\n      iterate(num, [], self.slice());\n    ;\n      return self;\n    }, TMP_Array_repeated_permutation_67.$$arity = 1);\n    \n    Opal.defn(self, '$pop', TMP_Array_pop_69 = function $$pop(count) {\n      var self = this;\n\n      \n      if ($truthy(count === undefined)) {\n        \n        if ($truthy(self.length === 0)) {\n          return nil};\n        return self.pop();};\n      count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      if ($truthy(count < 0)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"negative array size\")};\n      if ($truthy(self.length === 0)) {\n        return []};\n      if ($truthy(count > self.length)) {\n        return self.splice(0, self.length)\n        } else {\n        return self.splice(self.length - count, self.length)\n      };\n    }, TMP_Array_pop_69.$$arity = -1);\n    \n    Opal.defn(self, '$product', TMP_Array_product_70 = function $$product($a_rest) {\n      var self = this, args, $iter = TMP_Array_product_70.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Array_product_70.$$p = null;\n      \n      var result = (block !== nil) ? null : [],\n          n = args.length + 1,\n          counters = new Array(n),\n          lengths  = new Array(n),\n          arrays   = new Array(n),\n          i, m, subarray, len, resultlen = 1;\n\n      arrays[0] = self;\n      for (i = 1; i < n; i++) {\n        arrays[i] = Opal.const_get_relative($nesting, 'Opal').$coerce_to(args[i - 1], Opal.const_get_relative($nesting, 'Array'), \"to_ary\");\n      }\n\n      for (i = 0; i < n; i++) {\n        len = arrays[i].length;\n        if (len === 0) {\n          return result || self;\n        }\n        resultlen *= len;\n        if (resultlen > 2147483647) {\n          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"too big to product\")\n        }\n        lengths[i] = len;\n        counters[i] = 0;\n      }\n\n      outer_loop: for (;;) {\n        subarray = [];\n        for (i = 0; i < n; i++) {\n          subarray.push(arrays[i][counters[i]]);\n        }\n        if (result) {\n          result.push(subarray);\n        } else {\n          Opal.yield1(block, subarray)\n        }\n        m = n - 1;\n        counters[m]++;\n        while (counters[m] === lengths[m]) {\n          counters[m] = 0;\n          if (--m < 0) break outer_loop;\n          counters[m]++;\n        }\n      }\n\n      return result || self;\n    \n    }, TMP_Array_product_70.$$arity = -1);\n    \n    Opal.defn(self, '$push', TMP_Array_push_71 = function $$push($a_rest) {\n      var self = this, objects;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      objects = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        objects[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = 0, length = objects.length; i < length; i++) {\n        self.push(objects[i]);\n      }\n    ;\n      return self;\n    }, TMP_Array_push_71.$$arity = -1);\n    \n    Opal.defn(self, '$rassoc', TMP_Array_rassoc_72 = function $$rassoc(object) {\n      var self = this;\n\n      \n      for (var i = 0, length = self.length, item; i < length; i++) {\n        item = self[i];\n\n        if (item.length && item[1] !== undefined) {\n          if ((item[1])['$=='](object)) {\n            return item;\n          }\n        }\n      }\n\n      return nil;\n    \n    }, TMP_Array_rassoc_72.$$arity = 1);\n    \n    Opal.defn(self, '$reject', TMP_Array_reject_73 = function $$reject() {\n      var TMP_74, self = this, $iter = TMP_Array_reject_73.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_reject_73.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"reject\"], (TMP_74 = function(){var self = TMP_74.$$s || this;\n\n        return self.$size()}, TMP_74.$$s = self, TMP_74.$$arity = 0, TMP_74))\n      };\n      \n      var result = [];\n\n      for (var i = 0, length = self.length, value; i < length; i++) {\n        value = block(self[i]);\n\n        if (value === false || value === nil) {\n          result.push(self[i]);\n        }\n      }\n      return result;\n    ;\n    }, TMP_Array_reject_73.$$arity = 0);\n    \n    Opal.defn(self, '$reject!', TMP_Array_reject$B_75 = function() {\n      var TMP_76, self = this, $iter = TMP_Array_reject$B_75.$$p, block = $iter || nil, original = nil;\n\n      if ($iter) TMP_Array_reject$B_75.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"reject!\"], (TMP_76 = function(){var self = TMP_76.$$s || this;\n\n        return self.$size()}, TMP_76.$$s = self, TMP_76.$$arity = 0, TMP_76))\n      };\n      original = self.$length();\n      $send(self, 'delete_if', [], block.$to_proc());\n      if (self.$length()['$=='](original)) {\n        return nil\n        } else {\n        return self\n      };\n    }, TMP_Array_reject$B_75.$$arity = 0);\n    \n    Opal.defn(self, '$replace', TMP_Array_replace_77 = function $$replace(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {\n        other = other.$to_a()\n        } else {\n        other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), \"to_ary\").$to_a()\n      };\n      \n      self.splice(0, self.length);\n      self.push.apply(self, other);\n    ;\n      return self;\n    }, TMP_Array_replace_77.$$arity = 1);\n    \n    Opal.defn(self, '$reverse', TMP_Array_reverse_78 = function $$reverse() {\n      var self = this;\n\n      return self.slice(0).reverse()\n    }, TMP_Array_reverse_78.$$arity = 0);\n    \n    Opal.defn(self, '$reverse!', TMP_Array_reverse$B_79 = function() {\n      var self = this;\n\n      return self.reverse()\n    }, TMP_Array_reverse$B_79.$$arity = 0);\n    \n    Opal.defn(self, '$reverse_each', TMP_Array_reverse_each_80 = function $$reverse_each() {\n      var TMP_81, self = this, $iter = TMP_Array_reverse_each_80.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_reverse_each_80.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"reverse_each\"], (TMP_81 = function(){var self = TMP_81.$$s || this;\n\n        return self.$size()}, TMP_81.$$s = self, TMP_81.$$arity = 0, TMP_81))\n      };\n      $send(self.$reverse(), 'each', [], block.$to_proc());\n      return self;\n    }, TMP_Array_reverse_each_80.$$arity = 0);\n    \n    Opal.defn(self, '$rindex', TMP_Array_rindex_82 = function $$rindex(object) {\n      var self = this, $iter = TMP_Array_rindex_82.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_rindex_82.$$p = null;\n      \n      var i, value;\n\n      if (object != null && block !== nil) {\n        self.$warn(\"warning: given block not used\")\n      }\n\n      if (object != null) {\n        for (i = self.length - 1; i >= 0; i--) {\n          if (i >= self.length) {\n            break;\n          }\n          if ((self[i])['$=='](object)) {\n            return i;\n          }\n        }\n      }\n      else if (block !== nil) {\n        for (i = self.length - 1; i >= 0; i--) {\n          if (i >= self.length) {\n            break;\n          }\n\n          value = block(self[i]);\n\n          if (value !== false && value !== nil) {\n            return i;\n          }\n        }\n      }\n      else if (object == null) {\n        return self.$enum_for(\"rindex\");\n      }\n\n      return nil;\n    \n    }, TMP_Array_rindex_82.$$arity = -1);\n    \n    Opal.defn(self, '$rotate', TMP_Array_rotate_83 = function $$rotate(n) {\n      var self = this;\n\n      if (n == null) {\n        n = 1;\n      }\n      \n      n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      \n      var ary, idx, firstPart, lastPart;\n\n      if (self.length === 1) {\n        return self.slice();\n      }\n      if (self.length === 0) {\n        return [];\n      }\n\n      ary = self.slice();\n      idx = n % ary.length;\n\n      firstPart = ary.slice(idx);\n      lastPart = ary.slice(0, idx);\n      return firstPart.concat(lastPart);\n    ;\n    }, TMP_Array_rotate_83.$$arity = -1);\n    \n    Opal.defn(self, '$rotate!', TMP_Array_rotate$B_84 = function(cnt) {\n      var self = this, ary = nil;\n\n      if (cnt == null) {\n        cnt = 1;\n      }\n      \n      \n      if (self.length === 0 || self.length === 1) {\n        return self;\n      }\n    ;\n      cnt = Opal.const_get_relative($nesting, 'Opal').$coerce_to(cnt, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      ary = self.$rotate(cnt);\n      return self.$replace(ary);\n    }, TMP_Array_rotate$B_84.$$arity = -1);\n    (function($base, $super, $parent_nesting) {\n      function $SampleRandom(){};\n      var self = $SampleRandom = $klass($base, $super, 'SampleRandom', $SampleRandom);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SampleRandom_initialize_85, TMP_SampleRandom_rand_86;\n\n      def.rng = nil;\n      \n      \n      Opal.defn(self, '$initialize', TMP_SampleRandom_initialize_85 = function $$initialize(rng) {\n        var self = this;\n\n        return (self.rng = rng)\n      }, TMP_SampleRandom_initialize_85.$$arity = 1);\n      return (Opal.defn(self, '$rand', TMP_SampleRandom_rand_86 = function $$rand(size) {\n        var self = this, random = nil;\n\n        \n        random = Opal.const_get_relative($nesting, 'Opal').$coerce_to(self.rng.$rand(size), Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if ($truthy(random < 0)) {\n          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"random value must be >= 0\")};\n        if ($truthy(random < size)) {\n          } else {\n          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"random value must be less than Array size\")\n        };\n        return random;\n      }, TMP_SampleRandom_rand_86.$$arity = 1), nil) && 'rand';\n    })($nesting[0], null, $nesting);\n    \n    Opal.defn(self, '$sample', TMP_Array_sample_87 = function $$sample(count, options) {\n      var $a, self = this, o = nil, rng = nil;\n\n      \n      if ($truthy(count === undefined)) {\n        return self.$at(Opal.const_get_relative($nesting, 'Kernel').$rand(self.length))};\n      if ($truthy(options === undefined)) {\n        if ($truthy((o = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](count, Opal.const_get_relative($nesting, 'Hash'), \"to_hash\")))) {\n          \n          options = o;\n          count = nil;\n          } else {\n          \n          options = nil;\n          count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        }\n        } else {\n        \n        count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        options = Opal.const_get_relative($nesting, 'Opal').$coerce_to(options, Opal.const_get_relative($nesting, 'Hash'), \"to_hash\");\n      };\n      if ($truthy(($truthy($a = count) ? count < 0 : $a))) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"count must be greater than 0\")};\n      if ($truthy(options)) {\n        rng = options['$[]'](\"random\")};\n      if ($truthy(($truthy($a = rng) ? rng['$respond_to?'](\"rand\") : $a))) {\n        rng = Opal.const_get_relative($nesting, 'SampleRandom').$new(rng)\n        } else {\n        rng = Opal.const_get_relative($nesting, 'Kernel')\n      };\n      if ($truthy(count)) {\n        } else {\n        return self[rng.$rand(self.length)]\n      };\n      \n\n      var abandon, spin, result, i, j, k, targetIndex, oldValue;\n\n      if (count > self.length) {\n        count = self.length;\n      }\n\n      switch (count) {\n        case 0:\n          return [];\n          break;\n        case 1:\n          return [self[rng.$rand(self.length)]];\n          break;\n        case 2:\n          i = rng.$rand(self.length);\n          j = rng.$rand(self.length);\n          if (i === j) {\n            j = i === 0 ? i + 1 : i - 1;\n          }\n          return [self[i], self[j]];\n          break;\n        default:\n          if (self.length / count > 3) {\n            abandon = false;\n            spin = 0;\n\n            result = Opal.const_get_relative($nesting, 'Array').$new(count);\n            i = 1;\n\n            result[0] = rng.$rand(self.length);\n            while (i < count) {\n              k = rng.$rand(self.length);\n              j = 0;\n\n              while (j < i) {\n                while (k === result[j]) {\n                  spin++;\n                  if (spin > 100) {\n                    abandon = true;\n                    break;\n                  }\n                  k = rng.$rand(self.length);\n                }\n                if (abandon) { break; }\n\n                j++;\n              }\n\n              if (abandon) { break; }\n\n              result[i] = k;\n\n              i++;\n            }\n\n            if (!abandon) {\n              i = 0;\n              while (i < count) {\n                result[i] = self[result[i]];\n                i++;\n              }\n\n              return result;\n            }\n          }\n\n          result = self.slice();\n\n          for (var c = 0; c < count; c++) {\n            targetIndex = rng.$rand(self.length);\n            oldValue = result[c];\n            result[c] = result[targetIndex];\n            result[targetIndex] = oldValue;\n          }\n\n          return count === self.length ? result : (result)['$[]'](0, count);\n      }\n    ;\n    }, TMP_Array_sample_87.$$arity = -1);\n    \n    Opal.defn(self, '$select', TMP_Array_select_88 = function $$select() {\n      var TMP_89, self = this, $iter = TMP_Array_select_88.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_select_88.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"select\"], (TMP_89 = function(){var self = TMP_89.$$s || this;\n\n        return self.$size()}, TMP_89.$$s = self, TMP_89.$$arity = 0, TMP_89))\n      };\n      \n      var result = [];\n\n      for (var i = 0, length = self.length, item, value; i < length; i++) {\n        item = self[i];\n\n        value = Opal.yield1(block, item);\n\n        if (value !== false && value !== nil) {\n          result.push(item);\n        }\n      }\n\n      return result;\n    ;\n    }, TMP_Array_select_88.$$arity = 0);\n    \n    Opal.defn(self, '$select!', TMP_Array_select$B_90 = function() {\n      var TMP_91, self = this, $iter = TMP_Array_select$B_90.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_select$B_90.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"select!\"], (TMP_91 = function(){var self = TMP_91.$$s || this;\n\n        return self.$size()}, TMP_91.$$s = self, TMP_91.$$arity = 0, TMP_91))\n      };\n      \n      var original = self.length;\n      $send(self, 'keep_if', [], block.$to_proc());\n      return self.length === original ? nil : self;\n    ;\n    }, TMP_Array_select$B_90.$$arity = 0);\n    \n    Opal.defn(self, '$shift', TMP_Array_shift_92 = function $$shift(count) {\n      var self = this;\n\n      \n      if ($truthy(count === undefined)) {\n        \n        if ($truthy(self.length === 0)) {\n          return nil};\n        return self.shift();};\n      count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      if ($truthy(count < 0)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"negative array size\")};\n      if ($truthy(self.length === 0)) {\n        return []};\n      return self.splice(0, count);\n    }, TMP_Array_shift_92.$$arity = -1);\n    Opal.alias(self, \"size\", \"length\");\n    \n    Opal.defn(self, '$shuffle', TMP_Array_shuffle_93 = function $$shuffle(rng) {\n      var self = this;\n\n      return self.$dup().$to_a()['$shuffle!'](rng)\n    }, TMP_Array_shuffle_93.$$arity = -1);\n    \n    Opal.defn(self, '$shuffle!', TMP_Array_shuffle$B_94 = function(rng) {\n      var self = this;\n\n      \n      var randgen, i = self.length, j, tmp;\n\n      if (rng !== undefined) {\n        rng = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](rng, Opal.const_get_relative($nesting, 'Hash'), \"to_hash\");\n\n        if (rng !== nil) {\n          rng = rng['$[]'](\"random\");\n\n          if (rng !== nil && rng['$respond_to?'](\"rand\")) {\n            randgen = rng;\n          }\n        }\n      }\n\n      while (i) {\n        if (randgen) {\n          j = randgen.$rand(i).$to_int();\n\n          if (j < 0) {\n            self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"\" + \"random number too small \" + (j))\n          }\n\n          if (j >= i) {\n            self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"\" + \"random number too big \" + (j))\n          }\n        }\n        else {\n          j = self.$rand(i);\n        }\n\n        tmp = self[--i];\n        self[i] = self[j];\n        self[j] = tmp;\n      }\n\n      return self;\n    \n    }, TMP_Array_shuffle$B_94.$$arity = -1);\n    Opal.alias(self, \"slice\", \"[]\");\n    \n    Opal.defn(self, '$slice!', TMP_Array_slice$B_95 = function(index, length) {\n      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;\n\n      \n      result = nil;\n      if ($truthy(length === undefined)) {\n        if ($truthy(Opal.const_get_relative($nesting, 'Range')['$==='](index))) {\n          \n          range = index;\n          result = self['$[]'](range);\n          range_start = Opal.const_get_relative($nesting, 'Opal').$coerce_to(range.$begin(), Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n          range_end = Opal.const_get_relative($nesting, 'Opal').$coerce_to(range.$end(), Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n          \n          if (range_start < 0) {\n            range_start += self.length;\n          }\n\n          if (range_end < 0) {\n            range_end += self.length;\n          } else if (range_end >= self.length) {\n            range_end = self.length - 1;\n            if (range.excl) {\n              range_end += 1;\n            }\n          }\n\n          var range_length = range_end - range_start;\n          if (range.excl) {\n            range_end -= 1;\n          } else {\n            range_length += 1;\n          }\n\n          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {\n            self.splice(range_start, range_length);\n          }\n        ;\n          } else {\n          \n          start = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n          \n          if (start < 0) {\n            start += self.length;\n          }\n\n          if (start < 0 || start >= self.length) {\n            return nil;\n          }\n\n          result = self[start];\n\n          if (start === 0) {\n            self.shift();\n          } else {\n            self.splice(start, 1);\n          }\n        ;\n        }\n        } else {\n        \n        start = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        length = Opal.const_get_relative($nesting, 'Opal').$coerce_to(length, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        \n        if (length < 0) {\n          return nil;\n        }\n\n        var end = start + length;\n\n        result = self['$[]'](start, length);\n\n        if (start < 0) {\n          start += self.length;\n        }\n\n        if (start + length > self.length) {\n          length = self.length - start;\n        }\n\n        if (start < self.length && start >= 0) {\n          self.splice(start, length);\n        }\n      ;\n      };\n      return result;\n    }, TMP_Array_slice$B_95.$$arity = -2);\n    \n    Opal.defn(self, '$sort', TMP_Array_sort_96 = function $$sort() {\n      var self = this, $iter = TMP_Array_sort_96.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_sort_96.$$p = null;\n      \n      if ($truthy(self.length > 1)) {\n        } else {\n        return self\n      };\n      \n      if (block === nil) {\n        block = function(a, b) {\n          return (a)['$<=>'](b);\n        };\n      }\n\n      return self.slice().sort(function(x, y) {\n        var ret = block(x, y);\n\n        if (ret === nil) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + ((x).$inspect()) + \" with \" + ((y).$inspect()) + \" failed\");\n        }\n\n        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);\n      });\n    ;\n    }, TMP_Array_sort_96.$$arity = 0);\n    \n    Opal.defn(self, '$sort!', TMP_Array_sort$B_97 = function() {\n      var self = this, $iter = TMP_Array_sort$B_97.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_sort$B_97.$$p = null;\n      \n      var result;\n\n      if ((block !== nil)) {\n        result = $send((self.slice()), 'sort', [], block.$to_proc());\n      }\n      else {\n        result = (self.slice()).$sort();\n      }\n\n      self.length = 0;\n      for(var i = 0, length = result.length; i < length; i++) {\n        self.push(result[i]);\n      }\n\n      return self;\n    \n    }, TMP_Array_sort$B_97.$$arity = 0);\n    \n    Opal.defn(self, '$sort_by!', TMP_Array_sort_by$B_98 = function() {\n      var TMP_99, self = this, $iter = TMP_Array_sort_by$B_98.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_sort_by$B_98.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"sort_by!\"], (TMP_99 = function(){var self = TMP_99.$$s || this;\n\n        return self.$size()}, TMP_99.$$s = self, TMP_99.$$arity = 0, TMP_99))\n      };\n      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));\n    }, TMP_Array_sort_by$B_98.$$arity = 0);\n    \n    Opal.defn(self, '$take', TMP_Array_take_100 = function $$take(count) {\n      var self = this;\n\n      \n      if (count < 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'));\n      }\n\n      return self.slice(0, count);\n    \n    }, TMP_Array_take_100.$$arity = 1);\n    \n    Opal.defn(self, '$take_while', TMP_Array_take_while_101 = function $$take_while() {\n      var self = this, $iter = TMP_Array_take_while_101.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_take_while_101.$$p = null;\n      \n      var result = [];\n\n      for (var i = 0, length = self.length, item, value; i < length; i++) {\n        item = self[i];\n\n        value = block(item);\n\n        if (value === false || value === nil) {\n          return result;\n        }\n\n        result.push(item);\n      }\n\n      return result;\n    \n    }, TMP_Array_take_while_101.$$arity = 0);\n    \n    Opal.defn(self, '$to_a', TMP_Array_to_a_102 = function $$to_a() {\n      var self = this;\n\n      return self\n    }, TMP_Array_to_a_102.$$arity = 0);\n    Opal.alias(self, \"to_ary\", \"to_a\");\n    \n    Opal.defn(self, '$to_h', TMP_Array_to_h_103 = function $$to_h() {\n      var self = this;\n\n      \n      var i, len = self.length, ary, key, val, hash = $hash2([], {});\n\n      for (i = 0; i < len; i++) {\n        ary = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](self[i], Opal.const_get_relative($nesting, 'Array'), \"to_ary\");\n        if (!ary.$$is_array) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"wrong element type \" + ((ary).$class()) + \" at \" + (i) + \" (expected array)\")\n        }\n        if (ary.length !== 2) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong array length at \" + (i) + \" (expected 2, was \" + ((ary).$length()) + \")\")\n        }\n        key = ary[0];\n        val = ary[1];\n        Opal.hash_put(hash, key, val);\n      }\n\n      return hash;\n    \n    }, TMP_Array_to_h_103.$$arity = 0);\n    Opal.alias(self, \"to_s\", \"inspect\");\n    \n    Opal.defn(self, '$transpose', TMP_Array_transpose_106 = function $$transpose() {\n      var TMP_104, self = this, result = nil, max = nil;\n\n      \n      if ($truthy(self['$empty?']())) {\n        return []};\n      result = [];\n      max = nil;\n      $send(self, 'each', [], (TMP_104 = function(row){var self = TMP_104.$$s || this, $a, TMP_105;\nif (row == null) row = nil;\n      \n        if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](row))) {\n          row = row.$to_a()\n          } else {\n          row = Opal.const_get_relative($nesting, 'Opal').$coerce_to(row, Opal.const_get_relative($nesting, 'Array'), \"to_ary\").$to_a()\n        };\n        max = ($truthy($a = max) ? $a : row.length);\n        if ($truthy((row.length)['$!='](max))) {\n          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), \"\" + \"element size differs (\" + (row.length) + \" should be \" + (max) + \")\")};\n        return $send((row.length), 'times', [], (TMP_105 = function(i){var self = TMP_105.$$s || this, $b, entry = nil, $writer = nil;\nif (i == null) i = nil;\n        \n          entry = ($truthy($b = result['$[]'](i)) ? $b : (($writer = [i, []]), $send(result, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          return entry['$<<'](row.$at(i));}, TMP_105.$$s = self, TMP_105.$$arity = 1, TMP_105));}, TMP_104.$$s = self, TMP_104.$$arity = 1, TMP_104));\n      return result;\n    }, TMP_Array_transpose_106.$$arity = 0);\n    \n    Opal.defn(self, '$uniq', TMP_Array_uniq_107 = function $$uniq() {\n      var self = this, $iter = TMP_Array_uniq_107.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_uniq_107.$$p = null;\n      \n      var hash = $hash2([], {}), i, length, item, key;\n\n      if (block === nil) {\n        for (i = 0, length = self.length; i < length; i++) {\n          item = self[i];\n          if (Opal.hash_get(hash, item) === undefined) {\n            Opal.hash_put(hash, item, item);\n          }\n        }\n      }\n      else {\n        for (i = 0, length = self.length; i < length; i++) {\n          item = self[i];\n          key = Opal.yield1(block, item);\n          if (Opal.hash_get(hash, key) === undefined) {\n            Opal.hash_put(hash, key, item);\n          }\n        }\n      }\n\n      return toArraySubclass((hash).$values(), self.$class());\n    \n    }, TMP_Array_uniq_107.$$arity = 0);\n    \n    Opal.defn(self, '$uniq!', TMP_Array_uniq$B_108 = function() {\n      var self = this, $iter = TMP_Array_uniq$B_108.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_uniq$B_108.$$p = null;\n      \n      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;\n\n      for (i = 0, length = original_length; i < length; i++) {\n        item = self[i];\n        key = (block === nil ? item : Opal.yield1(block, item));\n\n        if (Opal.hash_get(hash, key) === undefined) {\n          Opal.hash_put(hash, key, item);\n          continue;\n        }\n\n        self.splice(i, 1);\n        length--;\n        i--;\n      }\n\n      return self.length === original_length ? nil : self;\n    \n    }, TMP_Array_uniq$B_108.$$arity = 0);\n    \n    Opal.defn(self, '$unshift', TMP_Array_unshift_109 = function $$unshift($a_rest) {\n      var self = this, objects;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      objects = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        objects[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = objects.length - 1; i >= 0; i--) {\n        self.unshift(objects[i]);\n      }\n    ;\n      return self;\n    }, TMP_Array_unshift_109.$$arity = -1);\n    \n    Opal.defn(self, '$values_at', TMP_Array_values_at_112 = function $$values_at($a_rest) {\n      var TMP_110, self = this, args, out = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      out = [];\n      $send(args, 'each', [], (TMP_110 = function(elem){var self = TMP_110.$$s || this, TMP_111, finish = nil, start = nil, i = nil;\nif (elem == null) elem = nil;\n      if ($truthy(elem['$kind_of?'](Opal.const_get_relative($nesting, 'Range')))) {\n          \n          finish = Opal.const_get_relative($nesting, 'Opal').$coerce_to(elem.$last(), Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n          start = Opal.const_get_relative($nesting, 'Opal').$coerce_to(elem.$first(), Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n          \n          if (start < 0) {\n            start = start + self.length;\n            return nil;;\n          }\n        ;\n          \n          if (finish < 0) {\n            finish = finish + self.length;\n          }\n          if (elem['$exclude_end?']()) {\n            finish--;\n          }\n          if (finish < start) {\n            return nil;;\n          }\n        ;\n          return $send(start, 'upto', [finish], (TMP_111 = function(i){var self = TMP_111.$$s || this;\nif (i == null) i = nil;\n          return out['$<<'](self.$at(i))}, TMP_111.$$s = self, TMP_111.$$arity = 1, TMP_111));\n          } else {\n          \n          i = Opal.const_get_relative($nesting, 'Opal').$coerce_to(elem, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n          return out['$<<'](self.$at(i));\n        }}, TMP_110.$$s = self, TMP_110.$$arity = 1, TMP_110));\n      return out;\n    }, TMP_Array_values_at_112.$$arity = -1);\n    \n    Opal.defn(self, '$zip', TMP_Array_zip_113 = function $$zip($a_rest) {\n      var $b, self = this, others, $iter = TMP_Array_zip_113.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      others = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        others[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Array_zip_113.$$p = null;\n      \n      var result = [], size = self.length, part, o, i, j, jj;\n\n      for (j = 0, jj = others.length; j < jj; j++) {\n        o = others[j];\n        if (o.$$is_array) {\n          continue;\n        }\n        if (o.$$is_enumerator) {\n          if (o.$size() === Infinity) {\n            others[j] = o.$take(size);\n          } else {\n            others[j] = o.$to_a();\n          }\n          continue;\n        }\n        others[j] = ($truthy($b = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](o, Opal.const_get_relative($nesting, 'Array'), \"to_ary\")) ? $b : Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](o, Opal.const_get_relative($nesting, 'Enumerator'), \"each\")).$to_a();\n      }\n\n      for (i = 0; i < size; i++) {\n        part = [self[i]];\n\n        for (j = 0, jj = others.length; j < jj; j++) {\n          o = others[j][i];\n\n          if (o == null) {\n            o = nil;\n          }\n\n          part[j + 1] = o;\n        }\n\n        result[i] = part;\n      }\n\n      if (block !== nil) {\n        for (i = 0; i < size; i++) {\n          block(result[i]);\n        }\n\n        return nil;\n      }\n\n      return result;\n    \n    }, TMP_Array_zip_113.$$arity = -1);\n    Opal.defs(self, '$inherited', TMP_Array_inherited_114 = function $$inherited(klass) {\n      var self = this;\n\n      \n      klass.$$proto.$to_a = function() {\n        return this.slice(0, this.length);\n      }\n    \n    }, TMP_Array_inherited_114.$$arity = 1);\n    \n    Opal.defn(self, '$instance_variables', TMP_Array_instance_variables_115 = function $$instance_variables() {\n      var TMP_116, self = this, $iter = TMP_Array_instance_variables_115.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Array_instance_variables_115.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      return $send($send(self, Opal.find_super_dispatcher(self, 'instance_variables', TMP_Array_instance_variables_115, false), $zuper, $iter), 'reject', [], (TMP_116 = function(ivar){var self = TMP_116.$$s || this, $a;\nif (ivar == null) ivar = nil;\n      return ($truthy($a = /^@\\d+$/.test(ivar)) ? $a : ivar['$=='](\"@length\"))}, TMP_116.$$s = self, TMP_116.$$arity = 1, TMP_116))\n    }, TMP_Array_instance_variables_115.$$arity = 0);\n    return Opal.const_get_relative($nesting, 'Opal').$pristine(self, \"allocate\", \"copy_instance_variables\", \"initialize_dup\");\n  })($nesting[0], Array, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/hash\"] = function(Opal) {\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$[]', '$merge!', '$allocate', '$raise', '$coerce_to!', '$each', '$fetch', '$>=', '$>', '$==', '$compare_by_identity', '$lambda?', '$abs', '$arity', '$call', '$enum_for', '$size', '$respond_to?', '$class', '$dig', '$inspect', '$map', '$to_proc', '$flatten', '$eql?', '$default', '$dup', '$default_proc', '$default_proc=', '$-', '$default=', '$alias_method', '$proc']);\n  \n  self.$require(\"corelib/enumerable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Hash(){};\n    var self = $Hash = $klass($base, $super, 'Hash', $Hash);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hash_$$_1, TMP_Hash_allocate_2, TMP_Hash_try_convert_3, TMP_Hash_initialize_4, TMP_Hash_$eq$eq_5, TMP_Hash_$gt$eq_7, TMP_Hash_$gt_8, TMP_Hash_$lt_9, TMP_Hash_$lt$eq_10, TMP_Hash_$$_11, TMP_Hash_$$$eq_12, TMP_Hash_assoc_13, TMP_Hash_clear_14, TMP_Hash_clone_15, TMP_Hash_compact_16, TMP_Hash_compact$B_17, TMP_Hash_compare_by_identity_18, TMP_Hash_compare_by_identity$q_19, TMP_Hash_default_20, TMP_Hash_default$eq_21, TMP_Hash_default_proc_22, TMP_Hash_default_proc$eq_23, TMP_Hash_delete_24, TMP_Hash_delete_if_25, TMP_Hash_dig_27, TMP_Hash_each_28, TMP_Hash_each_key_30, TMP_Hash_each_value_32, TMP_Hash_empty$q_34, TMP_Hash_fetch_35, TMP_Hash_fetch_values_36, TMP_Hash_flatten_38, TMP_Hash_has_key$q_39, TMP_Hash_has_value$q_40, TMP_Hash_hash_41, TMP_Hash_index_42, TMP_Hash_indexes_43, TMP_Hash_inspect_44, TMP_Hash_invert_45, TMP_Hash_keep_if_46, TMP_Hash_keys_48, TMP_Hash_length_49, TMP_Hash_merge_50, TMP_Hash_merge$B_51, TMP_Hash_rassoc_52, TMP_Hash_rehash_53, TMP_Hash_reject_54, TMP_Hash_reject$B_56, TMP_Hash_replace_58, TMP_Hash_select_59, TMP_Hash_select$B_61, TMP_Hash_shift_63, TMP_Hash_to_a_64, TMP_Hash_to_h_65, TMP_Hash_to_hash_66, TMP_Hash_to_proc_68, TMP_Hash_transform_values_69, TMP_Hash_transform_values$B_71, TMP_Hash_values_73;\n\n    \n    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n    def.$$is_hash = true;\n    Opal.defs(self, '$[]', TMP_Hash_$$_1 = function($a_rest) {\n      var self = this, argv;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      argv = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        argv[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      var hash, argc = argv.length, i;\n\n      if (argc === 1) {\n        hash = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), Opal.const_get_relative($nesting, 'Hash'), \"to_hash\");\n        if (hash !== nil) {\n          return self.$allocate()['$merge!'](hash);\n        }\n\n        argv = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), Opal.const_get_relative($nesting, 'Array'), \"to_ary\");\n        if (argv === nil) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"odd number of arguments for Hash\")\n        }\n\n        argc = argv.length;\n        hash = self.$allocate();\n\n        for (i = 0; i < argc; i++) {\n          if (!argv[i].$$is_array) continue;\n          switch(argv[i].length) {\n          case 1:\n            hash.$store(argv[i][0], nil);\n            break;\n          case 2:\n            hash.$store(argv[i][0], argv[i][1]);\n            break;\n          default:\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid number of elements (\" + (argv[i].length) + \" for 1..2)\")\n          }\n        }\n\n        return hash;\n      }\n\n      if (argc % 2 !== 0) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"odd number of arguments for Hash\")\n      }\n\n      hash = self.$allocate();\n\n      for (i = 0; i < argc; i += 2) {\n        hash.$store(argv[i], argv[i + 1]);\n      }\n\n      return hash;\n    \n    }, TMP_Hash_$$_1.$$arity = -1);\n    Opal.defs(self, '$allocate', TMP_Hash_allocate_2 = function $$allocate() {\n      var self = this;\n\n      \n      var hash = new self.$$alloc();\n\n      Opal.hash_init(hash);\n\n      hash.$$none = nil;\n      hash.$$proc = nil;\n\n      return hash;\n    \n    }, TMP_Hash_allocate_2.$$arity = 0);\n    Opal.defs(self, '$try_convert', TMP_Hash_try_convert_3 = function $$try_convert(obj) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](obj, Opal.const_get_relative($nesting, 'Hash'), \"to_hash\")\n    }, TMP_Hash_try_convert_3.$$arity = 1);\n    \n    Opal.defn(self, '$initialize', TMP_Hash_initialize_4 = function $$initialize(defaults) {\n      var self = this, $iter = TMP_Hash_initialize_4.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_initialize_4.$$p = null;\n      \n      \n      if (defaults !== undefined && block !== nil) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"wrong number of arguments (1 for 0)\")\n      }\n      self.$$none = (defaults === undefined ? nil : defaults);\n      self.$$proc = block;\n    ;\n      return self;\n    }, TMP_Hash_initialize_4.$$arity = -1);\n    \n    Opal.defn(self, '$==', TMP_Hash_$eq$eq_5 = function(other) {\n      var self = this;\n\n      \n      if (self === other) {\n        return true;\n      }\n\n      if (!other.$$is_hash) {\n        return false;\n      }\n\n      if (self.$$keys.length !== other.$$keys.length) {\n        return false;\n      }\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n          other_value = other.$$smap[key];\n        } else {\n          value = key.value;\n          other_value = Opal.hash_get(other, key.key);\n        }\n\n        if (other_value === undefined || !value['$eql?'](other_value)) {\n          return false;\n        }\n      }\n\n      return true;\n    \n    }, TMP_Hash_$eq$eq_5.$$arity = 1);\n    \n    Opal.defn(self, '$>=', TMP_Hash_$gt$eq_7 = function(other) {\n      var TMP_6, self = this, result = nil;\n\n      \n      other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), \"to_hash\");\n      \n      if (self.$$keys.length < other.$$keys.length) {\n        return false\n      }\n    ;\n      result = true;\n      $send(other, 'each', [], (TMP_6 = function(other_key, other_val){var self = TMP_6.$$s || this, val = nil;\nif (other_key == null) other_key = nil;if (other_val == null) other_val = nil;\n      \n        val = self.$fetch(other_key, null);\n        \n        if (val == null || val !== other_val) {\n          result = false;\n          return;\n        }\n      ;}, TMP_6.$$s = self, TMP_6.$$arity = 2, TMP_6));\n      return result;\n    }, TMP_Hash_$gt$eq_7.$$arity = 1);\n    \n    Opal.defn(self, '$>', TMP_Hash_$gt_8 = function(other) {\n      var self = this;\n\n      \n      other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), \"to_hash\");\n      \n      if (self.$$keys.length <= other.$$keys.length) {\n        return false\n      }\n    ;\n      return $rb_ge(self, other);\n    }, TMP_Hash_$gt_8.$$arity = 1);\n    \n    Opal.defn(self, '$<', TMP_Hash_$lt_9 = function(other) {\n      var self = this;\n\n      \n      other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), \"to_hash\");\n      return $rb_gt(other, self);\n    }, TMP_Hash_$lt_9.$$arity = 1);\n    \n    Opal.defn(self, '$<=', TMP_Hash_$lt$eq_10 = function(other) {\n      var self = this;\n\n      \n      other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), \"to_hash\");\n      return $rb_ge(other, self);\n    }, TMP_Hash_$lt$eq_10.$$arity = 1);\n    \n    Opal.defn(self, '$[]', TMP_Hash_$$_11 = function(key) {\n      var self = this;\n\n      \n      var value = Opal.hash_get(self, key);\n\n      if (value !== undefined) {\n        return value;\n      }\n\n      return self.$default(key);\n    \n    }, TMP_Hash_$$_11.$$arity = 1);\n    \n    Opal.defn(self, '$[]=', TMP_Hash_$$$eq_12 = function(key, value) {\n      var self = this;\n\n      \n      Opal.hash_put(self, key, value);\n      return value;\n    \n    }, TMP_Hash_$$$eq_12.$$arity = 2);\n    \n    Opal.defn(self, '$assoc', TMP_Hash_assoc_13 = function $$assoc(object) {\n      var self = this;\n\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          if ((key)['$=='](object)) {\n            return [key, self.$$smap[key]];\n          }\n        } else {\n          if ((key.key)['$=='](object)) {\n            return [key.key, key.value];\n          }\n        }\n      }\n\n      return nil;\n    \n    }, TMP_Hash_assoc_13.$$arity = 1);\n    \n    Opal.defn(self, '$clear', TMP_Hash_clear_14 = function $$clear() {\n      var self = this;\n\n      \n      Opal.hash_init(self);\n      return self;\n    \n    }, TMP_Hash_clear_14.$$arity = 0);\n    \n    Opal.defn(self, '$clone', TMP_Hash_clone_15 = function $$clone() {\n      var self = this;\n\n      \n      var hash = new self.$$class.$$alloc();\n\n      Opal.hash_init(hash);\n      Opal.hash_clone(self, hash);\n\n      return hash;\n    \n    }, TMP_Hash_clone_15.$$arity = 0);\n    \n    Opal.defn(self, '$compact', TMP_Hash_compact_16 = function $$compact() {\n      var self = this;\n\n      \n      var hash = Opal.hash();\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        if (value !== nil) {\n          Opal.hash_put(hash, key, value);\n        }\n      }\n\n      return hash;\n    \n    }, TMP_Hash_compact_16.$$arity = 0);\n    \n    Opal.defn(self, '$compact!', TMP_Hash_compact$B_17 = function() {\n      var self = this;\n\n      \n      var changes_were_made = false;\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        if (value === nil) {\n          if (Opal.hash_delete(self, key) !== undefined) {\n            changes_were_made = true;\n            length--;\n            i--;\n          }\n        }\n      }\n\n      return changes_were_made ? self : nil;\n    \n    }, TMP_Hash_compact$B_17.$$arity = 0);\n    \n    Opal.defn(self, '$compare_by_identity', TMP_Hash_compare_by_identity_18 = function $$compare_by_identity() {\n      var self = this;\n\n      \n      var i, ii, key, keys = self.$$keys, identity_hash;\n\n      if (self.$$by_identity) return self;\n      if (self.$$keys.length === 0) {\n        self.$$by_identity = true\n        return self;\n      }\n\n      identity_hash = $hash2([], {}).$compare_by_identity();\n      for(i = 0, ii = keys.length; i < ii; i++) {\n        key = keys[i];\n        if (!key.$$is_string) key = key.key;\n        Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));\n      }\n\n      self.$$by_identity = true;\n      self.$$map = identity_hash.$$map;\n      self.$$smap = identity_hash.$$smap;\n      return self;\n    \n    }, TMP_Hash_compare_by_identity_18.$$arity = 0);\n    \n    Opal.defn(self, '$compare_by_identity?', TMP_Hash_compare_by_identity$q_19 = function() {\n      var self = this;\n\n      return self.$$by_identity === true\n    }, TMP_Hash_compare_by_identity$q_19.$$arity = 0);\n    \n    Opal.defn(self, '$default', TMP_Hash_default_20 = function(key) {\n      var self = this;\n\n      \n      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {\n        return self.$$proc.$call(self, key);\n      }\n      if (self.$$none === undefined) {\n        return nil;\n      }\n      return self.$$none;\n    \n    }, TMP_Hash_default_20.$$arity = -1);\n    \n    Opal.defn(self, '$default=', TMP_Hash_default$eq_21 = function(object) {\n      var self = this;\n\n      \n      self.$$proc = nil;\n      self.$$none = object;\n\n      return object;\n    \n    }, TMP_Hash_default$eq_21.$$arity = 1);\n    \n    Opal.defn(self, '$default_proc', TMP_Hash_default_proc_22 = function $$default_proc() {\n      var self = this;\n\n      \n      if (self.$$proc !== undefined) {\n        return self.$$proc;\n      }\n      return nil;\n    \n    }, TMP_Hash_default_proc_22.$$arity = 0);\n    \n    Opal.defn(self, '$default_proc=', TMP_Hash_default_proc$eq_23 = function(default_proc) {\n      var self = this;\n\n      \n      var proc = default_proc;\n\n      if (proc !== nil) {\n        proc = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](proc, Opal.const_get_relative($nesting, 'Proc'), \"to_proc\");\n\n        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"default_proc takes two arguments\");\n        }\n      }\n\n      self.$$none = nil;\n      self.$$proc = proc;\n\n      return default_proc;\n    \n    }, TMP_Hash_default_proc$eq_23.$$arity = 1);\n    \n    Opal.defn(self, '$delete', TMP_Hash_delete_24 = function(key) {\n      var self = this, $iter = TMP_Hash_delete_24.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_delete_24.$$p = null;\n      \n      var value = Opal.hash_delete(self, key);\n\n      if (value !== undefined) {\n        return value;\n      }\n\n      if (block !== nil) {\n        return block.$call(key);\n      }\n\n      return nil;\n    \n    }, TMP_Hash_delete_24.$$arity = 1);\n    \n    Opal.defn(self, '$delete_if', TMP_Hash_delete_if_25 = function $$delete_if() {\n      var TMP_26, self = this, $iter = TMP_Hash_delete_if_25.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_delete_if_25.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"delete_if\"], (TMP_26 = function(){var self = TMP_26.$$s || this;\n\n        return self.$size()}, TMP_26.$$s = self, TMP_26.$$arity = 0, TMP_26))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj !== false && obj !== nil) {\n          if (Opal.hash_delete(self, key) !== undefined) {\n            length--;\n            i--;\n          }\n        }\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_delete_if_25.$$arity = 0);\n    Opal.alias(self, \"dup\", \"clone\");\n    \n    Opal.defn(self, '$dig', TMP_Hash_dig_27 = function $$dig(key, $a_rest) {\n      var self = this, keys, item = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      keys = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        keys[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      item = self['$[]'](key);\n      \n      if (item === nil || keys.length === 0) {\n        return item;\n      }\n    ;\n      if ($truthy(item['$respond_to?'](\"dig\"))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + (item.$class()) + \" does not have #dig method\")\n      };\n      return $send(item, 'dig', Opal.to_a(keys));\n    }, TMP_Hash_dig_27.$$arity = -2);\n    \n    Opal.defn(self, '$each', TMP_Hash_each_28 = function $$each() {\n      var TMP_29, self = this, $iter = TMP_Hash_each_28.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_each_28.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"each\"], (TMP_29 = function(){var self = TMP_29.$$s || this;\n\n        return self.$size()}, TMP_29.$$s = self, TMP_29.$$arity = 0, TMP_29))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        Opal.yield1(block, [key, value]);\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_each_28.$$arity = 0);\n    \n    Opal.defn(self, '$each_key', TMP_Hash_each_key_30 = function $$each_key() {\n      var TMP_31, self = this, $iter = TMP_Hash_each_key_30.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_each_key_30.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"each_key\"], (TMP_31 = function(){var self = TMP_31.$$s || this;\n\n        return self.$size()}, TMP_31.$$s = self, TMP_31.$$arity = 0, TMP_31))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        block(key.$$is_string ? key : key.key);\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_each_key_30.$$arity = 0);\n    Opal.alias(self, \"each_pair\", \"each\");\n    \n    Opal.defn(self, '$each_value', TMP_Hash_each_value_32 = function $$each_value() {\n      var TMP_33, self = this, $iter = TMP_Hash_each_value_32.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_each_value_32.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"each_value\"], (TMP_33 = function(){var self = TMP_33.$$s || this;\n\n        return self.$size()}, TMP_33.$$s = self, TMP_33.$$arity = 0, TMP_33))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        block(key.$$is_string ? self.$$smap[key] : key.value);\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_each_value_32.$$arity = 0);\n    \n    Opal.defn(self, '$empty?', TMP_Hash_empty$q_34 = function() {\n      var self = this;\n\n      return self.$$keys.length === 0\n    }, TMP_Hash_empty$q_34.$$arity = 0);\n    Opal.alias(self, \"eql?\", \"==\");\n    \n    Opal.defn(self, '$fetch', TMP_Hash_fetch_35 = function $$fetch(key, defaults) {\n      var self = this, $iter = TMP_Hash_fetch_35.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_fetch_35.$$p = null;\n      \n      \n      var value = Opal.hash_get(self, key);\n\n      if (value !== undefined) {\n        return value;\n      }\n\n      if (block !== nil) {\n        return block(key);\n      }\n\n      if (defaults !== undefined) {\n        return defaults;\n      }\n    ;\n      return self.$raise(Opal.const_get_relative($nesting, 'KeyError'), \"\" + \"key not found: \" + (key.$inspect()));\n    }, TMP_Hash_fetch_35.$$arity = -2);\n    \n    Opal.defn(self, '$fetch_values', TMP_Hash_fetch_values_36 = function $$fetch_values($a_rest) {\n      var TMP_37, self = this, keys, $iter = TMP_Hash_fetch_values_36.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      keys = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        keys[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Hash_fetch_values_36.$$p = null;\n      return $send(keys, 'map', [], (TMP_37 = function(key){var self = TMP_37.$$s || this;\nif (key == null) key = nil;\n      return $send(self, 'fetch', [key], block.$to_proc())}, TMP_37.$$s = self, TMP_37.$$arity = 1, TMP_37))\n    }, TMP_Hash_fetch_values_36.$$arity = -1);\n    \n    Opal.defn(self, '$flatten', TMP_Hash_flatten_38 = function $$flatten(level) {\n      var self = this;\n\n      if (level == null) {\n        level = 1;\n      }\n      \n      level = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](level, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      \n      var result = [];\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        result.push(key);\n\n        if (value.$$is_array) {\n          if (level === 1) {\n            result.push(value);\n            continue;\n          }\n\n          result = result.concat((value).$flatten(level - 2));\n          continue;\n        }\n\n        result.push(value);\n      }\n\n      return result;\n    ;\n    }, TMP_Hash_flatten_38.$$arity = -1);\n    \n    Opal.defn(self, '$has_key?', TMP_Hash_has_key$q_39 = function(key) {\n      var self = this;\n\n      return Opal.hash_get(self, key) !== undefined\n    }, TMP_Hash_has_key$q_39.$$arity = 1);\n    \n    Opal.defn(self, '$has_value?', TMP_Hash_has_value$q_40 = function(value) {\n      var self = this;\n\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {\n          return true;\n        }\n      }\n\n      return false;\n    \n    }, TMP_Hash_has_value$q_40.$$arity = 1);\n    \n    Opal.defn(self, '$hash', TMP_Hash_hash_41 = function $$hash() {\n      var self = this;\n\n      \n      var top = (Opal.hash_ids === undefined),\n          hash_id = self.$object_id(),\n          result = ['Hash'],\n          key, item;\n\n      try {\n        if (top) {\n          Opal.hash_ids = Object.create(null);\n        }\n\n        if (Opal[hash_id]) {\n          return 'self';\n        }\n\n        for (key in Opal.hash_ids) {\n          item = Opal.hash_ids[key];\n          if (self['$eql?'](item)) {\n            return 'self';\n          }\n        }\n\n        Opal.hash_ids[hash_id] = self;\n\n        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {\n          key = keys[i];\n\n          if (key.$$is_string) {\n            result.push([key, self.$$smap[key].$hash()]);\n          } else {\n            result.push([key.key_hash, key.value.$hash()]);\n          }\n        }\n\n        return result.sort().join();\n\n      } finally {\n        if (top) {\n          Opal.hash_ids = undefined;\n        }\n      }\n    \n    }, TMP_Hash_hash_41.$$arity = 0);\n    Opal.alias(self, \"include?\", \"has_key?\");\n    \n    Opal.defn(self, '$index', TMP_Hash_index_42 = function $$index(object) {\n      var self = this;\n\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        if ((value)['$=='](object)) {\n          return key;\n        }\n      }\n\n      return nil;\n    \n    }, TMP_Hash_index_42.$$arity = 1);\n    \n    Opal.defn(self, '$indexes', TMP_Hash_indexes_43 = function $$indexes($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      var result = [];\n\n      for (var i = 0, length = args.length, key, value; i < length; i++) {\n        key = args[i];\n        value = Opal.hash_get(self, key);\n\n        if (value === undefined) {\n          result.push(self.$default());\n          continue;\n        }\n\n        result.push(value);\n      }\n\n      return result;\n    \n    }, TMP_Hash_indexes_43.$$arity = -1);\n    Opal.alias(self, \"indices\", \"indexes\");\n    var inspect_ids;;\n    \n    Opal.defn(self, '$inspect', TMP_Hash_inspect_44 = function $$inspect() {\n      var self = this;\n\n      \n      var top = (inspect_ids === undefined),\n          hash_id = self.$object_id(),\n          result = [];\n\n      try {\n        if (top) {\n          inspect_ids = {};\n        }\n\n        if (inspect_ids.hasOwnProperty(hash_id)) {\n          return '{...}';\n        }\n\n        inspect_ids[hash_id] = true;\n\n        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n          key = keys[i];\n\n          if (key.$$is_string) {\n            value = self.$$smap[key];\n          } else {\n            value = key.value;\n            key = key.key;\n          }\n\n          result.push(key.$inspect() + '=>' + value.$inspect());\n        }\n\n        return '{' + result.join(', ') + '}';\n\n      } finally {\n        if (top) {\n          inspect_ids = undefined;\n        }\n      }\n    \n    }, TMP_Hash_inspect_44.$$arity = 0);\n    \n    Opal.defn(self, '$invert', TMP_Hash_invert_45 = function $$invert() {\n      var self = this;\n\n      \n      var hash = Opal.hash();\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        Opal.hash_put(hash, value, key);\n      }\n\n      return hash;\n    \n    }, TMP_Hash_invert_45.$$arity = 0);\n    \n    Opal.defn(self, '$keep_if', TMP_Hash_keep_if_46 = function $$keep_if() {\n      var TMP_47, self = this, $iter = TMP_Hash_keep_if_46.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_keep_if_46.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"keep_if\"], (TMP_47 = function(){var self = TMP_47.$$s || this;\n\n        return self.$size()}, TMP_47.$$s = self, TMP_47.$$arity = 0, TMP_47))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj === false || obj === nil) {\n          if (Opal.hash_delete(self, key) !== undefined) {\n            length--;\n            i--;\n          }\n        }\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_keep_if_46.$$arity = 0);\n    Opal.alias(self, \"key\", \"index\");\n    Opal.alias(self, \"key?\", \"has_key?\");\n    \n    Opal.defn(self, '$keys', TMP_Hash_keys_48 = function $$keys() {\n      var self = this;\n\n      \n      var result = [];\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          result.push(key);\n        } else {\n          result.push(key.key);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Hash_keys_48.$$arity = 0);\n    \n    Opal.defn(self, '$length', TMP_Hash_length_49 = function $$length() {\n      var self = this;\n\n      return self.$$keys.length\n    }, TMP_Hash_length_49.$$arity = 0);\n    Opal.alias(self, \"member?\", \"has_key?\");\n    \n    Opal.defn(self, '$merge', TMP_Hash_merge_50 = function $$merge(other) {\n      var self = this, $iter = TMP_Hash_merge_50.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_merge_50.$$p = null;\n      return $send(self.$dup(), 'merge!', [other], block.$to_proc())\n    }, TMP_Hash_merge_50.$$arity = 1);\n    \n    Opal.defn(self, '$merge!', TMP_Hash_merge$B_51 = function(other) {\n      var self = this, $iter = TMP_Hash_merge$B_51.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_merge$B_51.$$p = null;\n      \n      if (!other.$$is_hash) {\n        other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), \"to_hash\");\n      }\n\n      var i, other_keys = other.$$keys, length = other_keys.length, key, value, other_value;\n\n      if (block === nil) {\n        for (i = 0; i < length; i++) {\n          key = other_keys[i];\n\n          if (key.$$is_string) {\n            other_value = other.$$smap[key];\n          } else {\n            other_value = key.value;\n            key = key.key;\n          }\n\n          Opal.hash_put(self, key, other_value);\n        }\n\n        return self;\n      }\n\n      for (i = 0; i < length; i++) {\n        key = other_keys[i];\n\n        if (key.$$is_string) {\n          other_value = other.$$smap[key];\n        } else {\n          other_value = key.value;\n          key = key.key;\n        }\n\n        value = Opal.hash_get(self, key);\n\n        if (value === undefined) {\n          Opal.hash_put(self, key, other_value);\n          continue;\n        }\n\n        Opal.hash_put(self, key, block(key, value, other_value));\n      }\n\n      return self;\n    \n    }, TMP_Hash_merge$B_51.$$arity = 1);\n    \n    Opal.defn(self, '$rassoc', TMP_Hash_rassoc_52 = function $$rassoc(object) {\n      var self = this;\n\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        if ((value)['$=='](object)) {\n          return [key, value];\n        }\n      }\n\n      return nil;\n    \n    }, TMP_Hash_rassoc_52.$$arity = 1);\n    \n    Opal.defn(self, '$rehash', TMP_Hash_rehash_53 = function $$rehash() {\n      var self = this;\n\n      \n      Opal.hash_rehash(self);\n      return self;\n    \n    }, TMP_Hash_rehash_53.$$arity = 0);\n    \n    Opal.defn(self, '$reject', TMP_Hash_reject_54 = function $$reject() {\n      var TMP_55, self = this, $iter = TMP_Hash_reject_54.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_reject_54.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"reject\"], (TMP_55 = function(){var self = TMP_55.$$s || this;\n\n        return self.$size()}, TMP_55.$$s = self, TMP_55.$$arity = 0, TMP_55))\n      };\n      \n      var hash = Opal.hash();\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj === false || obj === nil) {\n          Opal.hash_put(hash, key, value);\n        }\n      }\n\n      return hash;\n    ;\n    }, TMP_Hash_reject_54.$$arity = 0);\n    \n    Opal.defn(self, '$reject!', TMP_Hash_reject$B_56 = function() {\n      var TMP_57, self = this, $iter = TMP_Hash_reject$B_56.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_reject$B_56.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"reject!\"], (TMP_57 = function(){var self = TMP_57.$$s || this;\n\n        return self.$size()}, TMP_57.$$s = self, TMP_57.$$arity = 0, TMP_57))\n      };\n      \n      var changes_were_made = false;\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj !== false && obj !== nil) {\n          if (Opal.hash_delete(self, key) !== undefined) {\n            changes_were_made = true;\n            length--;\n            i--;\n          }\n        }\n      }\n\n      return changes_were_made ? self : nil;\n    ;\n    }, TMP_Hash_reject$B_56.$$arity = 0);\n    \n    Opal.defn(self, '$replace', TMP_Hash_replace_58 = function $$replace(other) {\n      var self = this, $writer = nil;\n\n      \n      other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), \"to_hash\");\n      \n      Opal.hash_init(self);\n\n      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {\n        key = other_keys[i];\n\n        if (key.$$is_string) {\n          other_value = other.$$smap[key];\n        } else {\n          other_value = key.value;\n          key = key.key;\n        }\n\n        Opal.hash_put(self, key, other_value);\n      }\n    ;\n      if ($truthy(other.$default_proc())) {\n        \n        $writer = [other.$default_proc()];\n        $send(self, 'default_proc=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];\n        } else {\n        \n        $writer = [other.$default()];\n        $send(self, 'default=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];\n      };\n      return self;\n    }, TMP_Hash_replace_58.$$arity = 1);\n    \n    Opal.defn(self, '$select', TMP_Hash_select_59 = function $$select() {\n      var TMP_60, self = this, $iter = TMP_Hash_select_59.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_select_59.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"select\"], (TMP_60 = function(){var self = TMP_60.$$s || this;\n\n        return self.$size()}, TMP_60.$$s = self, TMP_60.$$arity = 0, TMP_60))\n      };\n      \n      var hash = Opal.hash();\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj !== false && obj !== nil) {\n          Opal.hash_put(hash, key, value);\n        }\n      }\n\n      return hash;\n    ;\n    }, TMP_Hash_select_59.$$arity = 0);\n    \n    Opal.defn(self, '$select!', TMP_Hash_select$B_61 = function() {\n      var TMP_62, self = this, $iter = TMP_Hash_select$B_61.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_select$B_61.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"select!\"], (TMP_62 = function(){var self = TMP_62.$$s || this;\n\n        return self.$size()}, TMP_62.$$s = self, TMP_62.$$arity = 0, TMP_62))\n      };\n      \n      var result = nil;\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj === false || obj === nil) {\n          if (Opal.hash_delete(self, key) !== undefined) {\n            length--;\n            i--;\n          }\n          result = self;\n        }\n      }\n\n      return result;\n    ;\n    }, TMP_Hash_select$B_61.$$arity = 0);\n    \n    Opal.defn(self, '$shift', TMP_Hash_shift_63 = function $$shift() {\n      var self = this;\n\n      \n      var keys = self.$$keys,\n          key;\n\n      if (keys.length > 0) {\n        key = keys[0];\n\n        key = key.$$is_string ? key : key.key;\n\n        return [key, Opal.hash_delete(self, key)];\n      }\n\n      return self.$default(nil);\n    \n    }, TMP_Hash_shift_63.$$arity = 0);\n    Opal.alias(self, \"size\", \"length\");\n    self.$alias_method(\"store\", \"[]=\");\n    \n    Opal.defn(self, '$to_a', TMP_Hash_to_a_64 = function $$to_a() {\n      var self = this;\n\n      \n      var result = [];\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        result.push([key, value]);\n      }\n\n      return result;\n    \n    }, TMP_Hash_to_a_64.$$arity = 0);\n    \n    Opal.defn(self, '$to_h', TMP_Hash_to_h_65 = function $$to_h() {\n      var self = this;\n\n      \n      if (self.$$class === Opal.Hash) {\n        return self;\n      }\n\n      var hash = new Opal.Hash.$$alloc();\n\n      Opal.hash_init(hash);\n      Opal.hash_clone(self, hash);\n\n      return hash;\n    \n    }, TMP_Hash_to_h_65.$$arity = 0);\n    \n    Opal.defn(self, '$to_hash', TMP_Hash_to_hash_66 = function $$to_hash() {\n      var self = this;\n\n      return self\n    }, TMP_Hash_to_hash_66.$$arity = 0);\n    \n    Opal.defn(self, '$to_proc', TMP_Hash_to_proc_68 = function $$to_proc() {\n      var TMP_67, self = this;\n\n      return $send(self, 'proc', [], (TMP_67 = function(key){var self = TMP_67.$$s || this;\n\n      \n        \n        if (key == null) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"no key given\")\n        }\n      ;\n        return self['$[]'](key);}, TMP_67.$$s = self, TMP_67.$$arity = -1, TMP_67))\n    }, TMP_Hash_to_proc_68.$$arity = 0);\n    Opal.alias(self, \"to_s\", \"inspect\");\n    \n    Opal.defn(self, '$transform_values', TMP_Hash_transform_values_69 = function $$transform_values() {\n      var TMP_70, self = this, $iter = TMP_Hash_transform_values_69.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_transform_values_69.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"transform_values\"], (TMP_70 = function(){var self = TMP_70.$$s || this;\n\n        return self.$size()}, TMP_70.$$s = self, TMP_70.$$arity = 0, TMP_70))\n      };\n      \n      var result = Opal.hash();\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        value = Opal.yield1(block, value);\n\n        Opal.hash_put(result, key, value);\n      }\n\n      return result;\n    ;\n    }, TMP_Hash_transform_values_69.$$arity = 0);\n    \n    Opal.defn(self, '$transform_values!', TMP_Hash_transform_values$B_71 = function() {\n      var TMP_72, self = this, $iter = TMP_Hash_transform_values$B_71.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_transform_values$B_71.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"transform_values!\"], (TMP_72 = function(){var self = TMP_72.$$s || this;\n\n        return self.$size()}, TMP_72.$$s = self, TMP_72.$$arity = 0, TMP_72))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        value = Opal.yield1(block, value);\n\n        Opal.hash_put(self, key, value);\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_transform_values$B_71.$$arity = 0);\n    Opal.alias(self, \"update\", \"merge!\");\n    Opal.alias(self, \"value?\", \"has_value?\");\n    Opal.alias(self, \"values_at\", \"indexes\");\n    return (Opal.defn(self, '$values', TMP_Hash_values_73 = function $$values() {\n      var self = this;\n\n      \n      var result = [];\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          result.push(self.$$smap[key]);\n        } else {\n          result.push(key.value);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Hash_values_73.$$arity = 0), nil) && 'values';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/number\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$bridge', '$raise', '$name', '$class', '$Float', '$respond_to?', '$coerce_to!', '$__coerced__', '$===', '$!', '$>', '$**', '$new', '$<', '$to_f', '$==', '$nan?', '$infinite?', '$enum_for', '$+', '$-', '$gcd', '$lcm', '$/', '$frexp', '$to_i', '$ldexp', '$rationalize', '$*', '$<<', '$to_r', '$-@', '$size', '$<=', '$>=', '$<=>', '$compare', '$empty?']);\n  \n  self.$require(\"corelib/numeric\");\n  (function($base, $super, $parent_nesting) {\n    function $Number(){};\n    var self = $Number = $klass($base, $super, 'Number', $Number);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Number_coerce_2, TMP_Number___id___3, TMP_Number_$_4, TMP_Number_$_5, TMP_Number_$_6, TMP_Number_$_7, TMP_Number_$_8, TMP_Number_$_9, TMP_Number_$_10, TMP_Number_$_11, TMP_Number_$lt_12, TMP_Number_$lt$eq_13, TMP_Number_$gt_14, TMP_Number_$gt$eq_15, TMP_Number_$lt$eq$gt_16, TMP_Number_$lt$lt_17, TMP_Number_$gt$gt_18, TMP_Number_$$_19, TMP_Number_$$_20, TMP_Number_$$_21, TMP_Number_$_22, TMP_Number_$$_23, TMP_Number_$eq$eq$eq_24, TMP_Number_$eq$eq_25, TMP_Number_abs_26, TMP_Number_abs2_27, TMP_Number_angle_28, TMP_Number_bit_length_29, TMP_Number_ceil_30, TMP_Number_chr_31, TMP_Number_denominator_32, TMP_Number_downto_33, TMP_Number_equal$q_35, TMP_Number_even$q_36, TMP_Number_floor_37, TMP_Number_gcd_38, TMP_Number_gcdlcm_39, TMP_Number_integer$q_40, TMP_Number_is_a$q_41, TMP_Number_instance_of$q_42, TMP_Number_lcm_43, TMP_Number_next_44, TMP_Number_nonzero$q_45, TMP_Number_numerator_46, TMP_Number_odd$q_47, TMP_Number_ord_48, TMP_Number_pred_49, TMP_Number_quo_50, TMP_Number_rationalize_51, TMP_Number_round_52, TMP_Number_step_53, TMP_Number_times_55, TMP_Number_to_f_57, TMP_Number_to_i_58, TMP_Number_to_r_59, TMP_Number_to_s_60, TMP_Number_divmod_61, TMP_Number_upto_62, TMP_Number_zero$q_64, TMP_Number_size_65, TMP_Number_nan$q_66, TMP_Number_finite$q_67, TMP_Number_infinite$q_68, TMP_Number_positive$q_69, TMP_Number_negative$q_70;\n\n    \n    Opal.const_get_relative($nesting, 'Opal').$bridge(self, Number);\n    Number.prototype.$$is_number = true;\n    self.$$is_number_class = true;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1;\n\n      \n      \n      Opal.defn(self, '$allocate', TMP_allocate_1 = function $$allocate() {\n        var self = this;\n\n        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"allocator undefined for \" + (self.$name()))\n      }, TMP_allocate_1.$$arity = 0);\n      \n      \n      Opal.udef(self, '$' + \"new\");;\n      return nil;;\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    Opal.defn(self, '$coerce', TMP_Number_coerce_2 = function $$coerce(other) {\n      var self = this;\n\n      \n      if (other === nil) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"can't convert \" + (other.$class()) + \" into Float\");\n      }\n      else if (other.$$is_string) {\n        return [self.$Float(other), self];\n      }\n      else if (other['$respond_to?'](\"to_f\")) {\n        return [Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Float'), \"to_f\"), self];\n      }\n      else if (other.$$is_number) {\n        return [other, self];\n      }\n      else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"can't convert \" + (other.$class()) + \" into Float\");\n      }\n    \n    }, TMP_Number_coerce_2.$$arity = 1);\n    \n    Opal.defn(self, '$__id__', TMP_Number___id___3 = function $$__id__() {\n      var self = this;\n\n      return (self * 2) + 1\n    }, TMP_Number___id___3.$$arity = 0);\n    Opal.alias(self, \"object_id\", \"__id__\");\n    \n    Opal.defn(self, '$+', TMP_Number_$_4 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self + other;\n      }\n      else {\n        return self.$__coerced__(\"+\", other);\n      }\n    \n    }, TMP_Number_$_4.$$arity = 1);\n    \n    Opal.defn(self, '$-', TMP_Number_$_5 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self - other;\n      }\n      else {\n        return self.$__coerced__(\"-\", other);\n      }\n    \n    }, TMP_Number_$_5.$$arity = 1);\n    \n    Opal.defn(self, '$*', TMP_Number_$_6 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self * other;\n      }\n      else {\n        return self.$__coerced__(\"*\", other);\n      }\n    \n    }, TMP_Number_$_6.$$arity = 1);\n    \n    Opal.defn(self, '$/', TMP_Number_$_7 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self / other;\n      }\n      else {\n        return self.$__coerced__(\"/\", other);\n      }\n    \n    }, TMP_Number_$_7.$$arity = 1);\n    Opal.alias(self, \"fdiv\", \"/\");\n    \n    Opal.defn(self, '$%', TMP_Number_$_8 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        if (other == -Infinity) {\n          return other;\n        }\n        else if (other == 0) {\n          self.$raise(Opal.const_get_relative($nesting, 'ZeroDivisionError'), \"divided by 0\");\n        }\n        else if (other < 0 || self < 0) {\n          return (self % other + other) % other;\n        }\n        else {\n          return self % other;\n        }\n      }\n      else {\n        return self.$__coerced__(\"%\", other);\n      }\n    \n    }, TMP_Number_$_8.$$arity = 1);\n    \n    Opal.defn(self, '$&', TMP_Number_$_9 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self & other;\n      }\n      else {\n        return self.$__coerced__(\"&\", other);\n      }\n    \n    }, TMP_Number_$_9.$$arity = 1);\n    \n    Opal.defn(self, '$|', TMP_Number_$_10 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self | other;\n      }\n      else {\n        return self.$__coerced__(\"|\", other);\n      }\n    \n    }, TMP_Number_$_10.$$arity = 1);\n    \n    Opal.defn(self, '$^', TMP_Number_$_11 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self ^ other;\n      }\n      else {\n        return self.$__coerced__(\"^\", other);\n      }\n    \n    }, TMP_Number_$_11.$$arity = 1);\n    \n    Opal.defn(self, '$<', TMP_Number_$lt_12 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self < other;\n      }\n      else {\n        return self.$__coerced__(\"<\", other);\n      }\n    \n    }, TMP_Number_$lt_12.$$arity = 1);\n    \n    Opal.defn(self, '$<=', TMP_Number_$lt$eq_13 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self <= other;\n      }\n      else {\n        return self.$__coerced__(\"<=\", other);\n      }\n    \n    }, TMP_Number_$lt$eq_13.$$arity = 1);\n    \n    Opal.defn(self, '$>', TMP_Number_$gt_14 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self > other;\n      }\n      else {\n        return self.$__coerced__(\">\", other);\n      }\n    \n    }, TMP_Number_$gt_14.$$arity = 1);\n    \n    Opal.defn(self, '$>=', TMP_Number_$gt$eq_15 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self >= other;\n      }\n      else {\n        return self.$__coerced__(\">=\", other);\n      }\n    \n    }, TMP_Number_$gt$eq_15.$$arity = 1);\n    \n    var spaceship_operator = function(self, other) {\n      if (other.$$is_number) {\n        if (isNaN(self) || isNaN(other)) {\n          return nil;\n        }\n\n        if (self > other) {\n          return 1;\n        } else if (self < other) {\n          return -1;\n        } else {\n          return 0;\n        }\n      }\n      else {\n        return self.$__coerced__(\"<=>\", other);\n      }\n    }\n  ;\n    \n    Opal.defn(self, '$<=>', TMP_Number_$lt$eq$gt_16 = function(other) {\n      var self = this;\n\n      try {\n        \n      return spaceship_operator(self, other);\n    \n      } catch ($err) {\n        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'ArgumentError')])) {\n          try {\n            return nil\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      }\n    }, TMP_Number_$lt$eq$gt_16.$$arity = 1);\n    \n    Opal.defn(self, '$<<', TMP_Number_$lt$lt_17 = function(count) {\n      var self = this;\n\n      \n      count = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](count, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      return count > 0 ? self << count : self >> -count;\n    }, TMP_Number_$lt$lt_17.$$arity = 1);\n    \n    Opal.defn(self, '$>>', TMP_Number_$gt$gt_18 = function(count) {\n      var self = this;\n\n      \n      count = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](count, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      return count > 0 ? self >> count : self << -count;\n    }, TMP_Number_$gt$gt_18.$$arity = 1);\n    \n    Opal.defn(self, '$[]', TMP_Number_$$_19 = function(bit) {\n      var self = this;\n\n      \n      bit = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](bit, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      \n      if (bit < 0) {\n        return 0;\n      }\n      if (bit >= 32) {\n        return self < 0 ? 1 : 0;\n      }\n      return (self >> bit) & 1;\n    ;\n    }, TMP_Number_$$_19.$$arity = 1);\n    \n    Opal.defn(self, '$+@', TMP_Number_$$_20 = function() {\n      var self = this;\n\n      return +self\n    }, TMP_Number_$$_20.$$arity = 0);\n    \n    Opal.defn(self, '$-@', TMP_Number_$$_21 = function() {\n      var self = this;\n\n      return -self\n    }, TMP_Number_$$_21.$$arity = 0);\n    \n    Opal.defn(self, '$~', TMP_Number_$_22 = function() {\n      var self = this;\n\n      return ~self\n    }, TMP_Number_$_22.$$arity = 0);\n    \n    Opal.defn(self, '$**', TMP_Number_$$_23 = function(other) {\n      var $a, $b, self = this;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](other))) {\n        if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Integer')['$==='](self)['$!']()) ? $a : $rb_gt(other, 0)))) {\n          return Math.pow(self, other)\n          } else {\n          return Opal.const_get_relative($nesting, 'Rational').$new(self, 1)['$**'](other)\n        }\n      } else if ($truthy((($a = $rb_lt(self, 0)) ? ($truthy($b = Opal.const_get_relative($nesting, 'Float')['$==='](other)) ? $b : Opal.const_get_relative($nesting, 'Rational')['$==='](other)) : $rb_lt(self, 0)))) {\n        return Opal.const_get_relative($nesting, 'Complex').$new(self, 0)['$**'](other.$to_f())\n      } else if ($truthy(other.$$is_number != null)) {\n        return Math.pow(self, other)\n        } else {\n        return self.$__coerced__(\"**\", other)\n      }\n    }, TMP_Number_$$_23.$$arity = 1);\n    \n    Opal.defn(self, '$===', TMP_Number_$eq$eq$eq_24 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self.valueOf() === other.valueOf();\n      }\n      else if (other['$respond_to?'](\"==\")) {\n        return other['$=='](self);\n      }\n      else {\n        return false;\n      }\n    \n    }, TMP_Number_$eq$eq$eq_24.$$arity = 1);\n    \n    Opal.defn(self, '$==', TMP_Number_$eq$eq_25 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self.valueOf() === other.valueOf();\n      }\n      else if (other['$respond_to?'](\"==\")) {\n        return other['$=='](self);\n      }\n      else {\n        return false;\n      }\n    \n    }, TMP_Number_$eq$eq_25.$$arity = 1);\n    \n    Opal.defn(self, '$abs', TMP_Number_abs_26 = function $$abs() {\n      var self = this;\n\n      return Math.abs(self)\n    }, TMP_Number_abs_26.$$arity = 0);\n    \n    Opal.defn(self, '$abs2', TMP_Number_abs2_27 = function $$abs2() {\n      var self = this;\n\n      return Math.abs(self * self)\n    }, TMP_Number_abs2_27.$$arity = 0);\n    \n    Opal.defn(self, '$angle', TMP_Number_angle_28 = function $$angle() {\n      var self = this;\n\n      \n      if ($truthy(self['$nan?']())) {\n        return self};\n      \n      if (self == 0) {\n        if (1 / self > 0) {\n          return 0;\n        }\n        else {\n          return Math.PI;\n        }\n      }\n      else if (self < 0) {\n        return Math.PI;\n      }\n      else {\n        return 0;\n      }\n    ;\n    }, TMP_Number_angle_28.$$arity = 0);\n    Opal.alias(self, \"arg\", \"angle\");\n    Opal.alias(self, \"phase\", \"angle\");\n    \n    Opal.defn(self, '$bit_length', TMP_Number_bit_length_29 = function $$bit_length() {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](self))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'NoMethodError').$new(\"\" + \"undefined method `bit_length` for \" + (self) + \":Float\", \"bit_length\"))\n      };\n      \n      if (self === 0 || self === -1) {\n        return 0;\n      }\n\n      var result = 0,\n          value  = self < 0 ? ~self : self;\n\n      while (value != 0) {\n        result   += 1;\n        value  >>>= 1;\n      }\n\n      return result;\n    ;\n    }, TMP_Number_bit_length_29.$$arity = 0);\n    \n    Opal.defn(self, '$ceil', TMP_Number_ceil_30 = function $$ceil() {\n      var self = this;\n\n      return Math.ceil(self)\n    }, TMP_Number_ceil_30.$$arity = 0);\n    \n    Opal.defn(self, '$chr', TMP_Number_chr_31 = function $$chr(encoding) {\n      var self = this;\n\n      return String.fromCharCode(self)\n    }, TMP_Number_chr_31.$$arity = -1);\n    \n    Opal.defn(self, '$denominator', TMP_Number_denominator_32 = function $$denominator() {\n      var $a, self = this, $iter = TMP_Number_denominator_32.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_denominator_32.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {\n        return 1\n        } else {\n        return $send(self, Opal.find_super_dispatcher(self, 'denominator', TMP_Number_denominator_32, false), $zuper, $iter)\n      }\n    }, TMP_Number_denominator_32.$$arity = 0);\n    \n    Opal.defn(self, '$downto', TMP_Number_downto_33 = function $$downto(stop) {\n      var TMP_34, self = this, $iter = TMP_Number_downto_33.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Number_downto_33.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"downto\", stop], (TMP_34 = function(){var self = TMP_34.$$s || this;\n\n        \n          if ($truthy(Opal.const_get_relative($nesting, 'Numeric')['$==='](stop))) {\n            } else {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (stop.$class()) + \" failed\")\n          };\n          if ($truthy($rb_gt(stop, self))) {\n            return 0\n            } else {\n            return $rb_plus($rb_minus(self, stop), 1)\n          };}, TMP_34.$$s = self, TMP_34.$$arity = 0, TMP_34))\n      };\n      \n      if (!stop.$$is_number) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (stop.$class()) + \" failed\")\n      }\n      for (var i = self; i >= stop; i--) {\n        block(i);\n      }\n    ;\n      return self;\n    }, TMP_Number_downto_33.$$arity = 1);\n    Opal.alias(self, \"eql?\", \"==\");\n    \n    Opal.defn(self, '$equal?', TMP_Number_equal$q_35 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = self['$=='](other)) ? $a : isNaN(self) && isNaN(other))\n    }, TMP_Number_equal$q_35.$$arity = 1);\n    \n    Opal.defn(self, '$even?', TMP_Number_even$q_36 = function() {\n      var self = this;\n\n      return self % 2 === 0\n    }, TMP_Number_even$q_36.$$arity = 0);\n    \n    Opal.defn(self, '$floor', TMP_Number_floor_37 = function $$floor() {\n      var self = this;\n\n      return Math.floor(self)\n    }, TMP_Number_floor_37.$$arity = 0);\n    \n    Opal.defn(self, '$gcd', TMP_Number_gcd_38 = function $$gcd(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](other))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"not an integer\")\n      };\n      \n      var min = Math.abs(self),\n          max = Math.abs(other);\n\n      while (min > 0) {\n        var tmp = min;\n\n        min = max % min;\n        max = tmp;\n      }\n\n      return max;\n    ;\n    }, TMP_Number_gcd_38.$$arity = 1);\n    \n    Opal.defn(self, '$gcdlcm', TMP_Number_gcdlcm_39 = function $$gcdlcm(other) {\n      var self = this;\n\n      return [self.$gcd(), self.$lcm()]\n    }, TMP_Number_gcdlcm_39.$$arity = 1);\n    \n    Opal.defn(self, '$integer?', TMP_Number_integer$q_40 = function() {\n      var self = this;\n\n      return self % 1 === 0\n    }, TMP_Number_integer$q_40.$$arity = 0);\n    \n    Opal.defn(self, '$is_a?', TMP_Number_is_a$q_41 = function(klass) {\n      var $a, self = this, $iter = TMP_Number_is_a$q_41.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_is_a$q_41.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Fixnum'))) ? Opal.const_get_relative($nesting, 'Integer')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Fixnum'))))) {\n        return true};\n      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Integer'))) ? Opal.const_get_relative($nesting, 'Integer')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Integer'))))) {\n        return true};\n      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Float'))) ? Opal.const_get_relative($nesting, 'Float')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Float'))))) {\n        return true};\n      return $send(self, Opal.find_super_dispatcher(self, 'is_a?', TMP_Number_is_a$q_41, false), $zuper, $iter);\n    }, TMP_Number_is_a$q_41.$$arity = 1);\n    Opal.alias(self, \"kind_of?\", \"is_a?\");\n    \n    Opal.defn(self, '$instance_of?', TMP_Number_instance_of$q_42 = function(klass) {\n      var $a, self = this, $iter = TMP_Number_instance_of$q_42.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_instance_of$q_42.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Fixnum'))) ? Opal.const_get_relative($nesting, 'Integer')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Fixnum'))))) {\n        return true};\n      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Integer'))) ? Opal.const_get_relative($nesting, 'Integer')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Integer'))))) {\n        return true};\n      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Float'))) ? Opal.const_get_relative($nesting, 'Float')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Float'))))) {\n        return true};\n      return $send(self, Opal.find_super_dispatcher(self, 'instance_of?', TMP_Number_instance_of$q_42, false), $zuper, $iter);\n    }, TMP_Number_instance_of$q_42.$$arity = 1);\n    \n    Opal.defn(self, '$lcm', TMP_Number_lcm_43 = function $$lcm(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](other))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"not an integer\")\n      };\n      \n      if (self == 0 || other == 0) {\n        return 0;\n      }\n      else {\n        return Math.abs(self * other / self.$gcd(other));\n      }\n    ;\n    }, TMP_Number_lcm_43.$$arity = 1);\n    Opal.alias(self, \"magnitude\", \"abs\");\n    Opal.alias(self, \"modulo\", \"%\");\n    \n    Opal.defn(self, '$next', TMP_Number_next_44 = function $$next() {\n      var self = this;\n\n      return self + 1\n    }, TMP_Number_next_44.$$arity = 0);\n    \n    Opal.defn(self, '$nonzero?', TMP_Number_nonzero$q_45 = function() {\n      var self = this;\n\n      return self == 0 ? nil : self\n    }, TMP_Number_nonzero$q_45.$$arity = 0);\n    \n    Opal.defn(self, '$numerator', TMP_Number_numerator_46 = function $$numerator() {\n      var $a, self = this, $iter = TMP_Number_numerator_46.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_numerator_46.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {\n        return self\n        } else {\n        return $send(self, Opal.find_super_dispatcher(self, 'numerator', TMP_Number_numerator_46, false), $zuper, $iter)\n      }\n    }, TMP_Number_numerator_46.$$arity = 0);\n    \n    Opal.defn(self, '$odd?', TMP_Number_odd$q_47 = function() {\n      var self = this;\n\n      return self % 2 !== 0\n    }, TMP_Number_odd$q_47.$$arity = 0);\n    \n    Opal.defn(self, '$ord', TMP_Number_ord_48 = function $$ord() {\n      var self = this;\n\n      return self\n    }, TMP_Number_ord_48.$$arity = 0);\n    \n    Opal.defn(self, '$pred', TMP_Number_pred_49 = function $$pred() {\n      var self = this;\n\n      return self - 1\n    }, TMP_Number_pred_49.$$arity = 0);\n    \n    Opal.defn(self, '$quo', TMP_Number_quo_50 = function $$quo(other) {\n      var self = this, $iter = TMP_Number_quo_50.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_quo_50.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](self))) {\n        return $send(self, Opal.find_super_dispatcher(self, 'quo', TMP_Number_quo_50, false), $zuper, $iter)\n        } else {\n        return $rb_divide(self, other)\n      }\n    }, TMP_Number_quo_50.$$arity = 1);\n    \n    Opal.defn(self, '$rationalize', TMP_Number_rationalize_51 = function $$rationalize(eps) {\n      var $a, $b, self = this, f = nil, n = nil;\n\n      \n      \n      if (arguments.length > 1) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" for 0..1)\");\n      }\n    ;\n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](self))) {\n        return Opal.const_get_relative($nesting, 'Rational').$new(self, 1)\n      } else if ($truthy(self['$infinite?']())) {\n        return self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), \"Infinity\")\n      } else if ($truthy(self['$nan?']())) {\n        return self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), \"NaN\")\n      } else if ($truthy(eps == null)) {\n        \n        $b = Opal.const_get_relative($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;\n        f = Opal.const_get_relative($nesting, 'Math').$ldexp(f, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'MANT_DIG')).$to_i();\n        n = $rb_minus(n, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'MANT_DIG'));\n        return Opal.const_get_relative($nesting, 'Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize(Opal.const_get_relative($nesting, 'Rational').$new(1, (1)['$<<']($rb_minus(1, n))));\n        } else {\n        return self.$to_r().$rationalize(eps)\n      };\n    }, TMP_Number_rationalize_51.$$arity = -1);\n    \n    Opal.defn(self, '$round', TMP_Number_round_52 = function $$round(ndigits) {\n      var $a, $b, self = this, _ = nil, exp = nil;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](self))) {\n        \n        if ($truthy(ndigits == null)) {\n          return self};\n        if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Float')['$==='](ndigits)) ? ndigits['$infinite?']() : $a))) {\n          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"Infinity\")};\n        ndigits = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](ndigits, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if ($truthy($rb_lt(ndigits, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Integer'), 'MIN')))) {\n          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"out of bounds\")};\n        if ($truthy(ndigits >= 0)) {\n          return self};\n        ndigits = ndigits['$-@']();\n        \n        if (0.415241 * ndigits - 0.125 > self.$size()) {\n          return 0;\n        }\n\n        var f = Math.pow(10, ndigits),\n            x = Math.floor((Math.abs(x) + f / 2) / f) * f;\n\n        return self < 0 ? -x : x;\n      ;\n        } else {\n        \n        if ($truthy(($truthy($a = self['$nan?']()) ? ndigits == null : $a))) {\n          self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), \"NaN\")};\n        ndigits = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](ndigits || 0, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if ($truthy($rb_le(ndigits, 0))) {\n          if ($truthy(self['$nan?']())) {\n            self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"NaN\")\n          } else if ($truthy(self['$infinite?']())) {\n            self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), \"Infinity\")}\n        } else if (ndigits['$=='](0)) {\n          return Math.round(self)\n        } else if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {\n          return self};\n        $b = Opal.const_get_relative($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;\n        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'DIG'), 2), (function() {if ($truthy($rb_gt(exp, 0))) {\n          return $rb_divide(exp, 4)\n          } else {\n          return $rb_minus($rb_divide(exp, 3), 1)\n        }; return nil; })())))) {\n          return self};\n        if ($truthy($rb_lt(ndigits, (function() {if ($truthy($rb_gt(exp, 0))) {\n          return $rb_plus($rb_divide(exp, 3), 1)\n          } else {\n          return $rb_divide(exp, 4)\n        }; return nil; })()['$-@']()))) {\n          return 0};\n        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);\n      }\n    }, TMP_Number_round_52.$$arity = -1);\n    \n    Opal.defn(self, '$step', TMP_Number_step_53 = function $$step($limit, $step, $kwargs) {\n      var TMP_54, self = this, $post_args, to, by, limit, step, $iter = TMP_Number_step_53.$$p, block = $iter || nil, positional_args = nil, keyword_args = nil;\n\n      $post_args = Opal.slice.call(arguments, 0, arguments.length);\n      $kwargs = Opal.extract_kwargs($post_args);\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      to = $kwargs.$$smap[\"to\"];\n      by = $kwargs.$$smap[\"by\"];\n      if (0 < $post_args.length) {\n        limit = $post_args.splice(0,1)[0];\n      }\n      if (0 < $post_args.length) {\n        step = $post_args.splice(0,1)[0];\n      }\n      if ($iter) TMP_Number_step_53.$$p = null;\n      \n      \n      if (limit !== undefined && to !== undefined) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"to is given twice\")\n      }\n\n      if (step !== undefined && by !== undefined) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"step is given twice\")\n      }\n\n      function validateParameters() {\n        if (to !== undefined) {\n          limit = to;\n        }\n\n        if (limit === undefined) {\n          limit = nil;\n        }\n\n        if (step === nil) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"step must be numeric\")\n        }\n\n        if (step === 0) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"step can't be 0\")\n        }\n\n        if (by !== undefined) {\n          step = by;\n        }\n\n        if (step === nil || step == null) {\n          step = 1;\n        }\n\n        var sign = step['$<=>'](0);\n\n        if (sign === nil) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"0 can't be coerced into \" + (step.$class()))\n        }\n\n        if (limit === nil || limit == null) {\n          limit = sign > 0 ? Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY') : Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY')['$-@']();\n        }\n\n        Opal.const_get_relative($nesting, 'Opal').$compare(self, limit)\n      }\n\n      function stepFloatSize() {\n        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {\n          return 0;\n        } else if (step === Infinity || step === -Infinity) {\n          return 1;\n        } else {\n          var abs = Math.abs, floor = Math.floor,\n              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'EPSILON');\n\n          if (err === Infinity || err === -Infinity) {\n            return 0;\n          } else {\n            if (err > 0.5) {\n              err = 0.5;\n            }\n\n            return floor((limit - self) / step + err) + 1\n          }\n        }\n      }\n\n      function stepSize() {\n        validateParameters();\n\n        if (step === 0) {\n          return Infinity;\n        }\n\n        if (step % 1 !== 0) {\n          return stepFloatSize();\n        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {\n          return 0;\n        } else {\n          var ceil = Math.ceil, abs = Math.abs,\n              lhs = abs(self - limit) + 1,\n              rhs = abs(step);\n\n          return ceil(lhs / rhs);\n        }\n      }\n    ;\n      if ((block !== nil)) {\n        } else {\n        \n        positional_args = [];\n        keyword_args = $hash2([], {});\n        \n        if (limit !== undefined) {\n          positional_args.push(limit);\n        }\n\n        if (step !== undefined) {\n          positional_args.push(step);\n        }\n\n        if (to !== undefined) {\n          Opal.hash_put(keyword_args, \"to\", to);\n        }\n\n        if (by !== undefined) {\n          Opal.hash_put(keyword_args, \"by\", by);\n        }\n\n        if (!keyword_args['$empty?']()) {\n          positional_args.push(keyword_args);\n        }\n      ;\n        return $send(self, 'enum_for', [\"step\"].concat(Opal.to_a(positional_args)), (TMP_54 = function(){var self = TMP_54.$$s || this;\n\n        return stepSize()}, TMP_54.$$s = self, TMP_54.$$arity = 0, TMP_54));\n      };\n      \n      validateParameters();\n\n      if (step === 0) {\n        while (true) {\n          block(self);\n        }\n      }\n\n      if (self % 1 !== 0 || limit % 1 !== 0 || step % 1 !== 0) {\n        var n = stepFloatSize();\n\n        if (n > 0) {\n          if (step === Infinity || step === -Infinity) {\n            block(self);\n          } else {\n            var i = 0, d;\n\n            if (step > 0) {\n              while (i < n) {\n                d = i * step + self;\n                if (limit < d) {\n                  d = limit;\n                }\n                block(d);\n                i += 1;\n              }\n            } else {\n              while (i < n) {\n                d = i * step + self;\n                if (limit > d) {\n                  d = limit;\n                }\n                block(d);\n                i += 1\n              }\n            }\n          }\n        }\n      } else {\n        var value = self;\n\n        if (step > 0) {\n          while (value <= limit) {\n            block(value);\n            value += step;\n          }\n        } else {\n          while (value >= limit) {\n            block(value);\n            value += step\n          }\n        }\n      }\n\n      return self;\n    ;\n    }, TMP_Number_step_53.$$arity = -1);\n    Opal.alias(self, \"succ\", \"next\");\n    \n    Opal.defn(self, '$times', TMP_Number_times_55 = function $$times() {\n      var TMP_56, self = this, $iter = TMP_Number_times_55.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Number_times_55.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return $send(self, 'enum_for', [\"times\"], (TMP_56 = function(){var self = TMP_56.$$s || this;\n\n        return self}, TMP_56.$$s = self, TMP_56.$$arity = 0, TMP_56))\n      };\n      \n      for (var i = 0; i < self; i++) {\n        block(i);\n      }\n    ;\n      return self;\n    }, TMP_Number_times_55.$$arity = 0);\n    \n    Opal.defn(self, '$to_f', TMP_Number_to_f_57 = function $$to_f() {\n      var self = this;\n\n      return self\n    }, TMP_Number_to_f_57.$$arity = 0);\n    \n    Opal.defn(self, '$to_i', TMP_Number_to_i_58 = function $$to_i() {\n      var self = this;\n\n      return parseInt(self, 10)\n    }, TMP_Number_to_i_58.$$arity = 0);\n    Opal.alias(self, \"to_int\", \"to_i\");\n    \n    Opal.defn(self, '$to_r', TMP_Number_to_r_59 = function $$to_r() {\n      var $a, $b, self = this, f = nil, e = nil;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](self))) {\n        return Opal.const_get_relative($nesting, 'Rational').$new(self, 1)\n        } else {\n        \n        $b = Opal.const_get_relative($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;\n        f = Opal.const_get_relative($nesting, 'Math').$ldexp(f, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'MANT_DIG')).$to_i();\n        e = $rb_minus(e, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'MANT_DIG'));\n        return $rb_times(f, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'RADIX')['$**'](e)).$to_r();\n      }\n    }, TMP_Number_to_r_59.$$arity = 0);\n    \n    Opal.defn(self, '$to_s', TMP_Number_to_s_60 = function $$to_s(base) {\n      var $a, self = this;\n\n      if (base == null) {\n        base = 10;\n      }\n      \n      if ($truthy(($truthy($a = $rb_lt(base, 2)) ? $a : $rb_gt(base, 36)))) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"base must be between 2 and 36\")};\n      return self.toString(base);\n    }, TMP_Number_to_s_60.$$arity = -1);\n    Opal.alias(self, \"truncate\", \"to_i\");\n    Opal.alias(self, \"inspect\", \"to_s\");\n    \n    Opal.defn(self, '$divmod', TMP_Number_divmod_61 = function $$divmod(other) {\n      var $a, self = this, $iter = TMP_Number_divmod_61.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_divmod_61.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if ($truthy(($truthy($a = self['$nan?']()) ? $a : other['$nan?']()))) {\n        return self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), \"NaN\")\n      } else if ($truthy(self['$infinite?']())) {\n        return self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), \"Infinity\")\n        } else {\n        return $send(self, Opal.find_super_dispatcher(self, 'divmod', TMP_Number_divmod_61, false), $zuper, $iter)\n      }\n    }, TMP_Number_divmod_61.$$arity = 1);\n    \n    Opal.defn(self, '$upto', TMP_Number_upto_62 = function $$upto(stop) {\n      var TMP_63, self = this, $iter = TMP_Number_upto_62.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Number_upto_62.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"upto\", stop], (TMP_63 = function(){var self = TMP_63.$$s || this;\n\n        \n          if ($truthy(Opal.const_get_relative($nesting, 'Numeric')['$==='](stop))) {\n            } else {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (stop.$class()) + \" failed\")\n          };\n          if ($truthy($rb_lt(stop, self))) {\n            return 0\n            } else {\n            return $rb_plus($rb_minus(stop, self), 1)\n          };}, TMP_63.$$s = self, TMP_63.$$arity = 0, TMP_63))\n      };\n      \n      if (!stop.$$is_number) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (stop.$class()) + \" failed\")\n      }\n      for (var i = self; i <= stop; i++) {\n        block(i);\n      }\n    ;\n      return self;\n    }, TMP_Number_upto_62.$$arity = 1);\n    \n    Opal.defn(self, '$zero?', TMP_Number_zero$q_64 = function() {\n      var self = this;\n\n      return self == 0\n    }, TMP_Number_zero$q_64.$$arity = 0);\n    \n    Opal.defn(self, '$size', TMP_Number_size_65 = function $$size() {\n      var self = this;\n\n      return 4\n    }, TMP_Number_size_65.$$arity = 0);\n    \n    Opal.defn(self, '$nan?', TMP_Number_nan$q_66 = function() {\n      var self = this;\n\n      return isNaN(self)\n    }, TMP_Number_nan$q_66.$$arity = 0);\n    \n    Opal.defn(self, '$finite?', TMP_Number_finite$q_67 = function() {\n      var self = this;\n\n      return self != Infinity && self != -Infinity && !isNaN(self)\n    }, TMP_Number_finite$q_67.$$arity = 0);\n    \n    Opal.defn(self, '$infinite?', TMP_Number_infinite$q_68 = function() {\n      var self = this;\n\n      \n      if (self == Infinity) {\n        return +1;\n      }\n      else if (self == -Infinity) {\n        return -1;\n      }\n      else {\n        return nil;\n      }\n    \n    }, TMP_Number_infinite$q_68.$$arity = 0);\n    \n    Opal.defn(self, '$positive?', TMP_Number_positive$q_69 = function() {\n      var self = this;\n\n      return self != 0 && (self == Infinity || 1 / self > 0)\n    }, TMP_Number_positive$q_69.$$arity = 0);\n    return (Opal.defn(self, '$negative?', TMP_Number_negative$q_70 = function() {\n      var self = this;\n\n      return self == -Infinity || 1 / self < 0\n    }, TMP_Number_negative$q_70.$$arity = 0), nil) && 'negative?';\n  })($nesting[0], Opal.const_get_relative($nesting, 'Numeric'), $nesting);\n  Opal.const_set($nesting[0], 'Fixnum', Opal.const_get_relative($nesting, 'Number'));\n  (function($base, $super, $parent_nesting) {\n    function $Integer(){};\n    var self = $Integer = $klass($base, $super, 'Integer', $Integer);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    self.$$is_number_class = true;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_71, TMP_$eq$eq$eq_72;\n\n      \n      \n      Opal.defn(self, '$allocate', TMP_allocate_71 = function $$allocate() {\n        var self = this;\n\n        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"allocator undefined for \" + (self.$name()))\n      }, TMP_allocate_71.$$arity = 0);\n      \n      Opal.udef(self, '$' + \"new\");;\n      return (Opal.defn(self, '$===', TMP_$eq$eq$eq_72 = function(other) {\n        var self = this;\n\n        \n        if (!other.$$is_number) {\n          return false;\n        }\n\n        return (other % 1) === 0;\n      \n      }, TMP_$eq$eq$eq_72.$$arity = 1), nil) && '===';\n    })(Opal.get_singleton_class(self), $nesting);\n    Opal.const_set($nesting[0], 'MAX', Math.pow(2, 30) - 1);\n    return Opal.const_set($nesting[0], 'MIN', -Math.pow(2, 30));\n  })($nesting[0], Opal.const_get_relative($nesting, 'Numeric'), $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $Float(){};\n    var self = $Float = $klass($base, $super, 'Float', $Float);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    self.$$is_number_class = true;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_73, TMP_$eq$eq$eq_74;\n\n      \n      \n      Opal.defn(self, '$allocate', TMP_allocate_73 = function $$allocate() {\n        var self = this;\n\n        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"allocator undefined for \" + (self.$name()))\n      }, TMP_allocate_73.$$arity = 0);\n      \n      Opal.udef(self, '$' + \"new\");;\n      return (Opal.defn(self, '$===', TMP_$eq$eq$eq_74 = function(other) {\n        var self = this;\n\n        return !!other.$$is_number\n      }, TMP_$eq$eq$eq_74.$$arity = 1), nil) && '===';\n    })(Opal.get_singleton_class(self), $nesting);\n    Opal.const_set($nesting[0], 'INFINITY', Infinity);\n    Opal.const_set($nesting[0], 'MAX', Number.MAX_VALUE);\n    Opal.const_set($nesting[0], 'MIN', Number.MIN_VALUE);\n    Opal.const_set($nesting[0], 'NAN', NaN);\n    Opal.const_set($nesting[0], 'DIG', 15);\n    Opal.const_set($nesting[0], 'MANT_DIG', 53);\n    Opal.const_set($nesting[0], 'RADIX', 2);\n    return Opal.const_set($nesting[0], 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);\n  })($nesting[0], Opal.const_get_relative($nesting, 'Numeric'), $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/range\"] = function(Opal) {\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$include', '$attr_reader', '$raise', '$<=>', '$include?', '$<=', '$<', '$enum_for', '$upto', '$to_proc', '$respond_to?', '$class', '$succ', '$!', '$==', '$===', '$exclude_end?', '$eql?', '$begin', '$end', '$last', '$to_a', '$>', '$-', '$abs', '$to_i', '$coerce_to!', '$ceil', '$/', '$size', '$loop', '$+', '$*', '$>=', '$each_with_index', '$%', '$bsearch', '$inspect', '$[]', '$hash']);\n  \n  self.$require(\"corelib/enumerable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Range(){};\n    var self = $Range = $klass($base, $super, 'Range', $Range);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Range_initialize_1, TMP_Range_$eq$eq_2, TMP_Range_$eq$eq$eq_3, TMP_Range_cover$q_4, TMP_Range_each_5, TMP_Range_eql$q_6, TMP_Range_exclude_end$q_7, TMP_Range_first_8, TMP_Range_last_9, TMP_Range_max_10, TMP_Range_min_11, TMP_Range_size_12, TMP_Range_step_13, TMP_Range_bsearch_17, TMP_Range_to_s_18, TMP_Range_inspect_19, TMP_Range_marshal_load_20, TMP_Range_hash_21;\n\n    def.begin = def.end = def.excl = nil;\n    \n    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n    def.$$is_range = true;;\n    self.$attr_reader(\"begin\", \"end\");\n    \n    Opal.defn(self, '$initialize', TMP_Range_initialize_1 = function $$initialize(first, last, exclude) {\n      var self = this;\n\n      if (exclude == null) {\n        exclude = false;\n      }\n      \n      if ($truthy(self.begin)) {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError'), \"'initialize' called twice\")};\n      if ($truthy(first['$<=>'](last))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"bad value for range\")\n      };\n      self.begin = first;\n      self.end = last;\n      return (self.excl = exclude);\n    }, TMP_Range_initialize_1.$$arity = -3);\n    \n    Opal.defn(self, '$==', TMP_Range_$eq$eq_2 = function(other) {\n      var self = this;\n\n      \n      if (!other.$$is_range) {\n        return false;\n      }\n\n      return self.excl  === other.excl &&\n             self.begin ==  other.begin &&\n             self.end   ==  other.end;\n    \n    }, TMP_Range_$eq$eq_2.$$arity = 1);\n    \n    Opal.defn(self, '$===', TMP_Range_$eq$eq$eq_3 = function(value) {\n      var self = this;\n\n      return self['$include?'](value)\n    }, TMP_Range_$eq$eq$eq_3.$$arity = 1);\n    \n    Opal.defn(self, '$cover?', TMP_Range_cover$q_4 = function(value) {\n      var $a, self = this, beg_cmp = nil, end_cmp = nil;\n\n      \n      beg_cmp = self.begin['$<=>'](value);\n      if ($truthy(($truthy($a = beg_cmp) ? $rb_le(beg_cmp, 0) : $a))) {\n        } else {\n        return false\n      };\n      end_cmp = value['$<=>'](self.end);\n      if ($truthy(self.excl)) {\n        return ($truthy($a = end_cmp) ? $rb_lt(end_cmp, 0) : $a)\n        } else {\n        return ($truthy($a = end_cmp) ? $rb_le(end_cmp, 0) : $a)\n      };\n    }, TMP_Range_cover$q_4.$$arity = 1);\n    \n    Opal.defn(self, '$each', TMP_Range_each_5 = function $$each() {\n      var $a, self = this, $iter = TMP_Range_each_5.$$p, block = $iter || nil, current = nil, last = nil;\n\n      if ($iter) TMP_Range_each_5.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"each\")\n      };\n      \n      var i, limit;\n\n      if (self.begin.$$is_number && self.end.$$is_number) {\n        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"can't iterate from Float\")\n        }\n\n        for (i = self.begin, limit = self.end + (function() {if ($truthy(self.excl)) {\n        return 0\n        } else {\n        return 1\n      }; return nil; })(); i < limit; i++) {\n          block(i);\n        }\n\n        return self;\n      }\n\n      if (self.begin.$$is_string && self.end.$$is_string) {\n        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())\n        return self;\n      }\n    ;\n      current = self.begin;\n      last = self.end;\n      if ($truthy(current['$respond_to?'](\"succ\"))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"can't iterate from \" + (current.$class()))\n      };\n      while ($truthy($rb_lt(current['$<=>'](last), 0))) {\n        \n        Opal.yield1(block, current);\n        current = current.$succ();\n      };\n      if ($truthy(($truthy($a = self.excl['$!']()) ? current['$=='](last) : $a))) {\n        Opal.yield1(block, current)};\n      return self;\n    }, TMP_Range_each_5.$$arity = 0);\n    \n    Opal.defn(self, '$eql?', TMP_Range_eql$q_6 = function(other) {\n      var $a, $b, self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Range')['$==='](other))) {\n        } else {\n        return false\n      };\n      return ($truthy($a = ($truthy($b = self.excl['$==='](other['$exclude_end?']())) ? self.begin['$eql?'](other.$begin()) : $b)) ? self.end['$eql?'](other.$end()) : $a);\n    }, TMP_Range_eql$q_6.$$arity = 1);\n    \n    Opal.defn(self, '$exclude_end?', TMP_Range_exclude_end$q_7 = function() {\n      var self = this;\n\n      return self.excl\n    }, TMP_Range_exclude_end$q_7.$$arity = 0);\n    \n    Opal.defn(self, '$first', TMP_Range_first_8 = function $$first(n) {\n      var self = this, $iter = TMP_Range_first_8.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Range_first_8.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      if ($truthy(n == null)) {\n        return self.begin};\n      return $send(self, Opal.find_super_dispatcher(self, 'first', TMP_Range_first_8, false), $zuper, $iter);\n    }, TMP_Range_first_8.$$arity = -1);\n    Opal.alias(self, \"include?\", \"cover?\");\n    \n    Opal.defn(self, '$last', TMP_Range_last_9 = function $$last(n) {\n      var self = this;\n\n      \n      if ($truthy(n == null)) {\n        return self.end};\n      return self.$to_a().$last(n);\n    }, TMP_Range_last_9.$$arity = -1);\n    \n    Opal.defn(self, '$max', TMP_Range_max_10 = function $$max() {\n      var $a, self = this, $iter = TMP_Range_max_10.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Range_max_10.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if (($yield !== nil)) {\n        return $send(self, Opal.find_super_dispatcher(self, 'max', TMP_Range_max_10, false), $zuper, $iter)\n      } else if ($truthy($rb_gt(self.begin, self.end))) {\n        return nil\n      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {\n        return nil\n        } else {\n        return self.excl ? self.end - 1 : self.end\n      }\n    }, TMP_Range_max_10.$$arity = 0);\n    Opal.alias(self, \"member?\", \"cover?\");\n    \n    Opal.defn(self, '$min', TMP_Range_min_11 = function $$min() {\n      var $a, self = this, $iter = TMP_Range_min_11.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Range_min_11.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if (($yield !== nil)) {\n        return $send(self, Opal.find_super_dispatcher(self, 'min', TMP_Range_min_11, false), $zuper, $iter)\n      } else if ($truthy($rb_gt(self.begin, self.end))) {\n        return nil\n      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {\n        return nil\n        } else {\n        return self.begin\n      }\n    }, TMP_Range_min_11.$$arity = 0);\n    \n    Opal.defn(self, '$size', TMP_Range_size_12 = function $$size() {\n      var $a, self = this, _begin = nil, _end = nil, infinity = nil;\n\n      \n      _begin = self.begin;\n      _end = self.end;\n      if ($truthy(self.excl)) {\n        _end = $rb_minus(_end, 1)};\n      if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](_begin)) ? Opal.const_get_relative($nesting, 'Numeric')['$==='](_end) : $a))) {\n        } else {\n        return nil\n      };\n      if ($truthy($rb_lt(_end, _begin))) {\n        return 0};\n      infinity = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY');\n      if ($truthy(($truthy($a = infinity['$=='](_begin.$abs())) ? $a : _end.$abs()['$=='](infinity)))) {\n        return infinity};\n      return (Math.abs(_end - _begin) + 1).$to_i();\n    }, TMP_Range_size_12.$$arity = 0);\n    \n    Opal.defn(self, '$step', TMP_Range_step_13 = function $$step(n) {\n      var TMP_14, TMP_15, TMP_16, self = this, $iter = TMP_Range_step_13.$$p, $yield = $iter || nil, i = nil;\n\n      if (n == null) {\n        n = 1;\n      }\n      if ($iter) TMP_Range_step_13.$$p = null;\n      \n      \n      function coerceStepSize() {\n        if (!n.$$is_number) {\n          n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\")\n        }\n\n        if (n < 0) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"step can't be negative\")\n        } else if (n === 0) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"step can't be 0\")\n        }\n      }\n\n      function enumeratorSize() {\n        if (!self.begin['$respond_to?'](\"succ\")) {\n          return nil;\n        }\n\n        if (self.begin.$$is_string && self.end.$$is_string) {\n          return nil;\n        }\n\n        if (n % 1 === 0) {\n          return $rb_divide(self.$size(), n).$ceil();\n        } else {\n          // n is a float\n          var begin = self.begin, end = self.end,\n              abs = Math.abs, floor = Math.floor,\n              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'EPSILON'),\n              size;\n\n          if (err > 0.5) {\n            err = 0.5;\n          }\n\n          if (self.excl) {\n            size = floor((end - begin) / n - err);\n            if (size * n + begin < end) {\n              size++;\n            }\n          } else {\n            size = floor((end - begin) / n + err) + 1\n          }\n\n          return size;\n        }\n      }\n    ;\n      if (($yield !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"step\", n], (TMP_14 = function(){var self = TMP_14.$$s || this;\n\n        \n          coerceStepSize();\n          return enumeratorSize();\n        }, TMP_14.$$s = self, TMP_14.$$arity = 0, TMP_14))\n      };\n      coerceStepSize();\n      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {\n        \n        i = 0;\n        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], (TMP_15 = function(){var self = TMP_15.$$s || this, current = nil;\n          if (self.begin == null) self.begin = nil;\n          if (self.excl == null) self.excl = nil;\n          if (self.end == null) self.end = nil;\n\n        \n          current = $rb_plus(self.begin, $rb_times(i, n));\n          if ($truthy(self.excl)) {\n            if ($truthy($rb_ge(current, self.end))) {\n              \n              Opal.brk(nil, $brk)}\n          } else if ($truthy($rb_gt(current, self.end))) {\n            \n            Opal.brk(nil, $brk)};\n          Opal.yield1($yield, current);\n          return (i = $rb_plus(i, 1));}, TMP_15.$$s = self, TMP_15.$$brk = $brk, TMP_15.$$arity = 0, TMP_15))\n        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();\n        } else {\n        \n        \n        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"no implicit conversion to float from string\")\n        }\n      ;\n        $send(self, 'each_with_index', [], (TMP_16 = function(value, idx){var self = TMP_16.$$s || this;\nif (value == null) value = nil;if (idx == null) idx = nil;\n        if (idx['$%'](n)['$=='](0)) {\n            return Opal.yield1($yield, value);\n            } else {\n            return nil\n          }}, TMP_16.$$s = self, TMP_16.$$arity = 2, TMP_16));\n      };\n      return self;\n    }, TMP_Range_step_13.$$arity = -1);\n    \n    Opal.defn(self, '$bsearch', TMP_Range_bsearch_17 = function $$bsearch() {\n      var self = this, $iter = TMP_Range_bsearch_17.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Range_bsearch_17.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"bsearch\")\n      };\n      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"can't do binary search for \" + (self.begin.$class()))\n      };\n      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());\n    }, TMP_Range_bsearch_17.$$arity = 0);\n    \n    Opal.defn(self, '$to_s', TMP_Range_to_s_18 = function $$to_s() {\n      var self = this;\n\n      return \"\" + (self.begin) + ((function() {if ($truthy(self.excl)) {\n        return \"...\"\n        } else {\n        return \"..\"\n      }; return nil; })()) + (self.end)\n    }, TMP_Range_to_s_18.$$arity = 0);\n    \n    Opal.defn(self, '$inspect', TMP_Range_inspect_19 = function $$inspect() {\n      var self = this;\n\n      return \"\" + (self.begin.$inspect()) + ((function() {if ($truthy(self.excl)) {\n        return \"...\"\n        } else {\n        return \"..\"\n      }; return nil; })()) + (self.end.$inspect())\n    }, TMP_Range_inspect_19.$$arity = 0);\n    \n    Opal.defn(self, '$marshal_load', TMP_Range_marshal_load_20 = function $$marshal_load(args) {\n      var self = this;\n\n      \n      self.begin = args['$[]'](\"begin\");\n      self.end = args['$[]'](\"end\");\n      return (self.excl = args['$[]'](\"excl\"));\n    }, TMP_Range_marshal_load_20.$$arity = 1);\n    return (Opal.defn(self, '$hash', TMP_Range_hash_21 = function $$hash() {\n      var self = this;\n\n      return [self.begin, self.end, self.excl].$hash()\n    }, TMP_Range_hash_21.$$arity = 0), nil) && 'hash';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/proc\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$raise', '$coerce_to!']);\n  return (function($base, $super, $parent_nesting) {\n    function $Proc(){};\n    var self = $Proc = $klass($base, $super, 'Proc', $Proc);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Proc_new_1, TMP_Proc_call_2, TMP_Proc_to_proc_3, TMP_Proc_lambda$q_4, TMP_Proc_arity_5, TMP_Proc_source_location_6, TMP_Proc_binding_7, TMP_Proc_parameters_8, TMP_Proc_curry_9, TMP_Proc_dup_10;\n\n    \n    def.$$is_proc = true;\n    def.$$is_lambda = false;\n    Opal.defs(self, '$new', TMP_Proc_new_1 = function() {\n      var self = this, $iter = TMP_Proc_new_1.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Proc_new_1.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"tried to create a Proc object without a block\")\n      };\n      return block;\n    }, TMP_Proc_new_1.$$arity = 0);\n    \n    Opal.defn(self, '$call', TMP_Proc_call_2 = function $$call($a_rest) {\n      var self = this, args, $iter = TMP_Proc_call_2.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Proc_call_2.$$p = null;\n      \n      if (block !== nil) {\n        self.$$p = block;\n      }\n\n      var result, $brk = self.$$brk;\n\n      if ($brk) {\n        try {\n          if (self.$$is_lambda) {\n            result = self.apply(null, args);\n          }\n          else {\n            result = Opal.yieldX(self, args);\n          }\n        } catch (err) {\n          if (err === $brk) {\n            return $brk.$v\n          }\n          else {\n            throw err\n          }\n        }\n      }\n      else {\n        if (self.$$is_lambda) {\n          result = self.apply(null, args);\n        }\n        else {\n          result = Opal.yieldX(self, args);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Proc_call_2.$$arity = -1);\n    Opal.alias(self, \"[]\", \"call\");\n    Opal.alias(self, \"===\", \"call\");\n    Opal.alias(self, \"yield\", \"call\");\n    \n    Opal.defn(self, '$to_proc', TMP_Proc_to_proc_3 = function $$to_proc() {\n      var self = this;\n\n      return self\n    }, TMP_Proc_to_proc_3.$$arity = 0);\n    \n    Opal.defn(self, '$lambda?', TMP_Proc_lambda$q_4 = function() {\n      var self = this;\n\n      return !!self.$$is_lambda\n    }, TMP_Proc_lambda$q_4.$$arity = 0);\n    \n    Opal.defn(self, '$arity', TMP_Proc_arity_5 = function $$arity() {\n      var self = this;\n\n      \n      if (self.$$is_curried) {\n        return -1;\n      } else {\n        return self.$$arity;\n      }\n    \n    }, TMP_Proc_arity_5.$$arity = 0);\n    \n    Opal.defn(self, '$source_location', TMP_Proc_source_location_6 = function $$source_location() {\n      var self = this;\n\n      \n      if (self.$$is_curried) { return nil; };\n      return nil;\n    }, TMP_Proc_source_location_6.$$arity = 0);\n    \n    Opal.defn(self, '$binding', TMP_Proc_binding_7 = function $$binding() {\n      var self = this;\n\n      \n      if (self.$$is_curried) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"Can't create Binding\") };\n      return nil;\n    }, TMP_Proc_binding_7.$$arity = 0);\n    \n    Opal.defn(self, '$parameters', TMP_Proc_parameters_8 = function $$parameters() {\n      var self = this;\n\n      \n      if (self.$$is_curried) {\n        return [[\"rest\"]];\n      } else if (self.$$parameters) {\n        if (self.$$is_lambda) {\n          return self.$$parameters;\n        } else {\n          var result = [], i, length;\n\n          for (i = 0, length = self.$$parameters.length; i < length; i++) {\n            var parameter = self.$$parameters[i];\n\n            if (parameter[0] === 'req') {\n              // required arguments always have name\n              parameter = ['opt', parameter[1]];\n            }\n\n            result.push(parameter);\n          }\n\n          return result;\n        }\n      } else {\n        return [];\n      }\n    \n    }, TMP_Proc_parameters_8.$$arity = 0);\n    \n    Opal.defn(self, '$curry', TMP_Proc_curry_9 = function $$curry(arity) {\n      var self = this;\n\n      \n      if (arity === undefined) {\n        arity = self.length;\n      }\n      else {\n        arity = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](arity, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        if (self.$$is_lambda && arity !== self.length) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arity) + \" for \" + (self.length) + \")\")\n        }\n      }\n\n      function curried () {\n        var args = $slice.call(arguments),\n            length = args.length,\n            result;\n\n        if (length > arity && self.$$is_lambda && !self.$$is_curried) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (length) + \" for \" + (arity) + \")\")\n        }\n\n        if (length >= arity) {\n          return self.$call.apply(self, args);\n        }\n\n        result = function () {\n          return curried.apply(null,\n            args.concat($slice.call(arguments)));\n        }\n        result.$$is_lambda = self.$$is_lambda;\n        result.$$is_curried = true;\n\n        return result;\n      };\n\n      curried.$$is_lambda = self.$$is_lambda;\n      curried.$$is_curried = true;\n      return curried;\n    \n    }, TMP_Proc_curry_9.$$arity = -1);\n    \n    Opal.defn(self, '$dup', TMP_Proc_dup_10 = function $$dup() {\n      var self = this;\n\n      \n      var original_proc = self.$$original_proc || self,\n          proc = function () {\n            return original_proc.apply(this, arguments);\n          };\n\n      for (var prop in self) {\n        if (self.hasOwnProperty(prop)) {\n          proc[prop] = self[prop];\n        }\n      }\n\n      return proc;\n    \n    }, TMP_Proc_dup_10.$$arity = 0);\n    return Opal.alias(self, \"clone\", \"dup\");\n  })($nesting[0], Function, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/method\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$attr_reader', '$arity', '$new', '$class', '$join', '$source_location', '$raise']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Method(){};\n    var self = $Method = $klass($base, $super, 'Method', $Method);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Method_initialize_1, TMP_Method_arity_2, TMP_Method_parameters_3, TMP_Method_source_location_4, TMP_Method_comments_5, TMP_Method_call_6, TMP_Method_unbind_7, TMP_Method_to_proc_8, TMP_Method_inspect_9;\n\n    def.method = def.receiver = def.owner = def.name = nil;\n    \n    self.$attr_reader(\"owner\", \"receiver\", \"name\");\n    \n    Opal.defn(self, '$initialize', TMP_Method_initialize_1 = function $$initialize(receiver, owner, method, name) {\n      var self = this;\n\n      \n      self.receiver = receiver;\n      self.owner = owner;\n      self.name = name;\n      return (self.method = method);\n    }, TMP_Method_initialize_1.$$arity = 4);\n    \n    Opal.defn(self, '$arity', TMP_Method_arity_2 = function $$arity() {\n      var self = this;\n\n      return self.method.$arity()\n    }, TMP_Method_arity_2.$$arity = 0);\n    \n    Opal.defn(self, '$parameters', TMP_Method_parameters_3 = function $$parameters() {\n      var self = this;\n\n      return self.method.$$parameters\n    }, TMP_Method_parameters_3.$$arity = 0);\n    \n    Opal.defn(self, '$source_location', TMP_Method_source_location_4 = function $$source_location() {\n      var $a, self = this;\n\n      return ($truthy($a = self.method.$$source_location) ? $a : [\"(eval)\", 0])\n    }, TMP_Method_source_location_4.$$arity = 0);\n    \n    Opal.defn(self, '$comments', TMP_Method_comments_5 = function $$comments() {\n      var $a, self = this;\n\n      return ($truthy($a = self.method.$$comments) ? $a : [])\n    }, TMP_Method_comments_5.$$arity = 0);\n    \n    Opal.defn(self, '$call', TMP_Method_call_6 = function $$call($a_rest) {\n      var self = this, args, $iter = TMP_Method_call_6.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Method_call_6.$$p = null;\n      \n      self.method.$$p = block;\n\n      return self.method.apply(self.receiver, args);\n    \n    }, TMP_Method_call_6.$$arity = -1);\n    Opal.alias(self, \"[]\", \"call\");\n    \n    Opal.defn(self, '$unbind', TMP_Method_unbind_7 = function $$unbind() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)\n    }, TMP_Method_unbind_7.$$arity = 0);\n    \n    Opal.defn(self, '$to_proc', TMP_Method_to_proc_8 = function $$to_proc() {\n      var self = this;\n\n      \n      var proc = self.$call.bind(self);\n      proc.$$unbound = self.method;\n      proc.$$is_lambda = true;\n      return proc;\n    \n    }, TMP_Method_to_proc_8.$$arity = 0);\n    return (Opal.defn(self, '$inspect', TMP_Method_inspect_9 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"#<\" + (self.$class()) + \": \" + (self.receiver.$class()) + \"#\" + (self.name) + \" (defined in \" + (self.owner) + \" in \" + (self.$source_location().$join(\":\")) + \")>\"\n    }, TMP_Method_inspect_9.$$arity = 0), nil) && 'inspect';\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $UnboundMethod(){};\n    var self = $UnboundMethod = $klass($base, $super, 'UnboundMethod', $UnboundMethod);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_UnboundMethod_initialize_10, TMP_UnboundMethod_arity_11, TMP_UnboundMethod_parameters_12, TMP_UnboundMethod_source_location_13, TMP_UnboundMethod_comments_14, TMP_UnboundMethod_bind_15, TMP_UnboundMethod_inspect_16;\n\n    def.method = def.owner = def.name = def.source = nil;\n    \n    self.$attr_reader(\"source\", \"owner\", \"name\");\n    \n    Opal.defn(self, '$initialize', TMP_UnboundMethod_initialize_10 = function $$initialize(source, owner, method, name) {\n      var self = this;\n\n      \n      self.source = source;\n      self.owner = owner;\n      self.method = method;\n      return (self.name = name);\n    }, TMP_UnboundMethod_initialize_10.$$arity = 4);\n    \n    Opal.defn(self, '$arity', TMP_UnboundMethod_arity_11 = function $$arity() {\n      var self = this;\n\n      return self.method.$arity()\n    }, TMP_UnboundMethod_arity_11.$$arity = 0);\n    \n    Opal.defn(self, '$parameters', TMP_UnboundMethod_parameters_12 = function $$parameters() {\n      var self = this;\n\n      return self.method.$$parameters\n    }, TMP_UnboundMethod_parameters_12.$$arity = 0);\n    \n    Opal.defn(self, '$source_location', TMP_UnboundMethod_source_location_13 = function $$source_location() {\n      var $a, self = this;\n\n      return ($truthy($a = self.method.$$source_location) ? $a : [\"(eval)\", 0])\n    }, TMP_UnboundMethod_source_location_13.$$arity = 0);\n    \n    Opal.defn(self, '$comments', TMP_UnboundMethod_comments_14 = function $$comments() {\n      var $a, self = this;\n\n      return ($truthy($a = self.method.$$comments) ? $a : [])\n    }, TMP_UnboundMethod_comments_14.$$arity = 0);\n    \n    Opal.defn(self, '$bind', TMP_UnboundMethod_bind_15 = function $$bind(object) {\n      var self = this;\n\n      \n      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {\n        return Opal.const_get_relative($nesting, 'Method').$new(object, self.owner, self.method, self.name);\n      }\n      else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"can't bind singleton method to a different class (expected \" + (object) + \".kind_of?(\" + (self.owner) + \" to be true)\");\n      }\n    \n    }, TMP_UnboundMethod_bind_15.$$arity = 1);\n    return (Opal.defn(self, '$inspect', TMP_UnboundMethod_inspect_16 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"#<\" + (self.$class()) + \": \" + (self.source) + \"#\" + (self.name) + \" (defined in \" + (self.owner) + \" in \" + (self.$source_location().$join(\":\")) + \")>\"\n    }, TMP_UnboundMethod_inspect_16.$$arity = 0), nil) && 'inspect';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/variables\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $gvars = Opal.gvars, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$new']);\n  \n  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars[\"'\"] = nil;\n  $gvars.LOADED_FEATURES = ($gvars[\"\\\"\"] = Opal.loaded_features);\n  $gvars.LOAD_PATH = ($gvars[\":\"] = []);\n  $gvars[\"/\"] = \"\\n\";\n  $gvars[\",\"] = nil;\n  Opal.const_set($nesting[0], 'ARGV', []);\n  Opal.const_set($nesting[0], 'ARGF', Opal.const_get_relative($nesting, 'Object').$new());\n  Opal.const_set($nesting[0], 'ENV', $hash2([], {}));\n  $gvars.VERBOSE = false;\n  $gvars.DEBUG = false;\n  return ($gvars.SAFE = 0);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/regexp_anchors\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;\n\n  Opal.add_stubs(['$==', '$new']);\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    Opal.const_set($nesting[0], 'REGEXP_START', (function() {if (Opal.const_get_relative($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n      return \"^\"\n      } else {\n      return nil\n    }; return nil; })());\n    Opal.const_set($nesting[0], 'REGEXP_END', (function() {if (Opal.const_get_relative($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n      return \"$\"\n      } else {\n      return nil\n    }; return nil; })());\n    Opal.const_set($nesting[0], 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', \"\\\\u0001-\\\\u002F\\\\u003A-\\\\u0040\\\\u005B-\\\\u005E\\\\u0060\\\\u007B-\\\\u007F\");\n    Opal.const_set($nesting[0], 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', \"\\\\u0001-\\\\u0020\\\\u0022-\\\\u002F\\\\u003A-\\\\u003E\\\\u0040\\\\u005B-\\\\u005E\\\\u0060\\\\u007B-\\\\u007F\");\n    Opal.const_set($nesting[0], 'INLINE_IDENTIFIER_REGEXP', Opal.const_get_relative($nesting, 'Regexp').$new(\"\" + \"[^\" + (Opal.const_get_relative($nesting, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + \"]*[^\" + (Opal.const_get_relative($nesting, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + \"]\"));\n    Opal.const_set($nesting[0], 'FORBIDDEN_CONST_NAME_CHARS', \"\\\\u0001-\\\\u0020\\\\u0021-\\\\u002F\\\\u003B-\\\\u003F\\\\u0040\\\\u005B-\\\\u005E\\\\u0060\\\\u007B-\\\\u007F\");\n    Opal.const_set($nesting[0], 'CONST_NAME_REGEXP', Opal.const_get_relative($nesting, 'Regexp').$new(\"\" + (Opal.const_get_relative($nesting, 'REGEXP_START')) + \"(::)?[A-Z][^\" + (Opal.const_get_relative($nesting, 'FORBIDDEN_CONST_NAME_CHARS')) + \"]*\" + (Opal.const_get_relative($nesting, 'REGEXP_END'))));\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/mini\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"opal/base\");\n  self.$require(\"corelib/nil\");\n  self.$require(\"corelib/boolean\");\n  self.$require(\"corelib/string\");\n  self.$require(\"corelib/comparable\");\n  self.$require(\"corelib/enumerable\");\n  self.$require(\"corelib/enumerator\");\n  self.$require(\"corelib/array\");\n  self.$require(\"corelib/hash\");\n  self.$require(\"corelib/number\");\n  self.$require(\"corelib/range\");\n  self.$require(\"corelib/proc\");\n  self.$require(\"corelib/method\");\n  self.$require(\"corelib/regexp\");\n  self.$require(\"corelib/variables\");\n  return self.$require(\"opal/regexp_anchors\");\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/string/inheritance\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$require', '$new', '$allocate', '$initialize', '$to_proc', '$__send__', '$class', '$clone', '$respond_to?', '$==', '$to_s', '$inspect', '$+', '$*', '$map', '$split', '$enum_for', '$each_line', '$to_a', '$%', '$-']);\n  \n  self.$require(\"corelib/string\");\n  (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_inherited_1;\n\n    return Opal.defs(self, '$inherited', TMP_String_inherited_1 = function $$inherited(klass) {\n      var self = this, replace = nil;\n\n      \n      replace = Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'String'), 'Wrapper'));\n      \n      klass.$$proto         = replace.$$proto;\n      klass.$$proto.$$class = klass;\n      klass.$$alloc         = replace.$$alloc;\n      klass.$$parent        = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'String'), 'Wrapper');\n\n      klass.$allocate = replace.$allocate;\n      klass.$new      = replace.$new;\n    ;\n    }, TMP_String_inherited_1.$$arity = 1)\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $Wrapper(){};\n    var self = $Wrapper = $klass($base, $super, 'Wrapper', $Wrapper);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Wrapper_allocate_2, TMP_Wrapper_new_3, TMP_Wrapper_$$_4, TMP_Wrapper_initialize_5, TMP_Wrapper_method_missing_6, TMP_Wrapper_initialize_copy_7, TMP_Wrapper_respond_to$q_8, TMP_Wrapper_$eq$eq_9, TMP_Wrapper_to_s_10, TMP_Wrapper_inspect_11, TMP_Wrapper_$_12, TMP_Wrapper_$_13, TMP_Wrapper_split_15, TMP_Wrapper_replace_16, TMP_Wrapper_each_line_17, TMP_Wrapper_lines_19, TMP_Wrapper_$_20, TMP_Wrapper_instance_variables_21;\n\n    def.literal = nil;\n    \n    def.$$is_string = true;\n    Opal.defs(self, '$allocate', TMP_Wrapper_allocate_2 = function $$allocate(string) {\n      var self = this, $iter = TMP_Wrapper_allocate_2.$$p, $yield = $iter || nil, obj = nil;\n\n      if (string == null) {\n        string = \"\";\n      }\n      if ($iter) TMP_Wrapper_allocate_2.$$p = null;\n      \n      obj = $send(self, Opal.find_super_dispatcher(self, 'allocate', TMP_Wrapper_allocate_2, false, $Wrapper), [], null);\n      obj.literal = string;\n      return obj;\n    }, TMP_Wrapper_allocate_2.$$arity = -1);\n    Opal.defs(self, '$new', TMP_Wrapper_new_3 = function($a_rest) {\n      var self = this, args, $iter = TMP_Wrapper_new_3.$$p, block = $iter || nil, obj = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Wrapper_new_3.$$p = null;\n      \n      obj = self.$allocate();\n      $send(obj, 'initialize', Opal.to_a(args), block.$to_proc());\n      return obj;\n    }, TMP_Wrapper_new_3.$$arity = -1);\n    Opal.defs(self, '$[]', TMP_Wrapper_$$_4 = function($a_rest) {\n      var self = this, objects;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      objects = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        objects[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return self.$allocate(objects)\n    }, TMP_Wrapper_$$_4.$$arity = -1);\n    \n    Opal.defn(self, '$initialize', TMP_Wrapper_initialize_5 = function $$initialize(string) {\n      var self = this;\n\n      if (string == null) {\n        string = \"\";\n      }\n      return (self.literal = string)\n    }, TMP_Wrapper_initialize_5.$$arity = -1);\n    \n    Opal.defn(self, '$method_missing', TMP_Wrapper_method_missing_6 = function $$method_missing($a_rest) {\n      var self = this, args, $iter = TMP_Wrapper_method_missing_6.$$p, block = $iter || nil, result = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Wrapper_method_missing_6.$$p = null;\n      \n      result = $send(self.literal, '__send__', Opal.to_a(args), block.$to_proc());\n      if ($truthy(result.$$is_string != null)) {\n        if ($truthy(result == self.literal)) {\n          return self\n          } else {\n          return self.$class().$allocate(result)\n        }\n        } else {\n        return result\n      };\n    }, TMP_Wrapper_method_missing_6.$$arity = -1);\n    \n    Opal.defn(self, '$initialize_copy', TMP_Wrapper_initialize_copy_7 = function $$initialize_copy(other) {\n      var self = this;\n\n      return (self.literal = (other.literal).$clone())\n    }, TMP_Wrapper_initialize_copy_7.$$arity = 1);\n    \n    Opal.defn(self, '$respond_to?', TMP_Wrapper_respond_to$q_8 = function(name, $a_rest) {\n      var $b, self = this, $iter = TMP_Wrapper_respond_to$q_8.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Wrapper_respond_to$q_8.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      return ($truthy($b = $send(self, Opal.find_super_dispatcher(self, 'respond_to?', TMP_Wrapper_respond_to$q_8, false), $zuper, $iter)) ? $b : self.literal['$respond_to?'](name))\n    }, TMP_Wrapper_respond_to$q_8.$$arity = -2);\n    \n    Opal.defn(self, '$==', TMP_Wrapper_$eq$eq_9 = function(other) {\n      var self = this;\n\n      return self.literal['$=='](other)\n    }, TMP_Wrapper_$eq$eq_9.$$arity = 1);\n    Opal.alias(self, \"eql?\", \"==\");\n    Opal.alias(self, \"===\", \"==\");\n    \n    Opal.defn(self, '$to_s', TMP_Wrapper_to_s_10 = function $$to_s() {\n      var self = this;\n\n      return self.literal.$to_s()\n    }, TMP_Wrapper_to_s_10.$$arity = 0);\n    Opal.alias(self, \"to_str\", \"to_s\");\n    \n    Opal.defn(self, '$inspect', TMP_Wrapper_inspect_11 = function $$inspect() {\n      var self = this;\n\n      return self.literal.$inspect()\n    }, TMP_Wrapper_inspect_11.$$arity = 0);\n    \n    Opal.defn(self, '$+', TMP_Wrapper_$_12 = function(other) {\n      var self = this;\n\n      return $rb_plus(self.literal, other)\n    }, TMP_Wrapper_$_12.$$arity = 1);\n    \n    Opal.defn(self, '$*', TMP_Wrapper_$_13 = function(other) {\n      var self = this;\n\n      \n      var result = $rb_times(self.literal, other);\n\n      if (result.$$is_string) {\n        return self.$class().$allocate(result)\n      }\n      else {\n        return result;\n      }\n    \n    }, TMP_Wrapper_$_13.$$arity = 1);\n    \n    Opal.defn(self, '$split', TMP_Wrapper_split_15 = function $$split(pattern, limit) {\n      var TMP_14, self = this;\n\n      return $send(self.literal.$split(pattern, limit), 'map', [], (TMP_14 = function(str){var self = TMP_14.$$s || this;\nif (str == null) str = nil;\n      return self.$class().$allocate(str)}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14))\n    }, TMP_Wrapper_split_15.$$arity = -1);\n    \n    Opal.defn(self, '$replace', TMP_Wrapper_replace_16 = function $$replace(string) {\n      var self = this;\n\n      return (self.literal = string)\n    }, TMP_Wrapper_replace_16.$$arity = 1);\n    \n    Opal.defn(self, '$each_line', TMP_Wrapper_each_line_17 = function $$each_line(separator) {\n      var TMP_18, self = this, $iter = TMP_Wrapper_each_line_17.$$p, $yield = $iter || nil;\n      if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n      if (separator == null) {\n        separator = $gvars[\"/\"];\n      }\n      if ($iter) TMP_Wrapper_each_line_17.$$p = null;\n      \n      if (($yield !== nil)) {\n        } else {\n        return self.$enum_for(\"each_line\", separator)\n      };\n      return $send(self.literal, 'each_line', [separator], (TMP_18 = function(str){var self = TMP_18.$$s || this;\nif (str == null) str = nil;\n      return Opal.yield1($yield, self.$class().$allocate(str));}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18));\n    }, TMP_Wrapper_each_line_17.$$arity = -1);\n    \n    Opal.defn(self, '$lines', TMP_Wrapper_lines_19 = function $$lines(separator) {\n      var self = this, $iter = TMP_Wrapper_lines_19.$$p, block = $iter || nil, e = nil;\n      if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n      if (separator == null) {\n        separator = $gvars[\"/\"];\n      }\n      if ($iter) TMP_Wrapper_lines_19.$$p = null;\n      \n      e = $send(self, 'each_line', [separator], block.$to_proc());\n      if ($truthy(block)) {\n        return self\n        } else {\n        return e.$to_a()\n      };\n    }, TMP_Wrapper_lines_19.$$arity = -1);\n    \n    Opal.defn(self, '$%', TMP_Wrapper_$_20 = function(data) {\n      var self = this;\n\n      return self.literal['$%'](data)\n    }, TMP_Wrapper_$_20.$$arity = 1);\n    return (Opal.defn(self, '$instance_variables', TMP_Wrapper_instance_variables_21 = function $$instance_variables() {\n      var self = this, $iter = TMP_Wrapper_instance_variables_21.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Wrapper_instance_variables_21.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      return $rb_minus($send(self, Opal.find_super_dispatcher(self, 'instance_variables', TMP_Wrapper_instance_variables_21, false), $zuper, $iter), [\"@literal\"])\n    }, TMP_Wrapper_instance_variables_21.$$arity = 0), nil) && 'instance_variables';\n  })(Opal.const_get_relative($nesting, 'String'), null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/string/encoding\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var TMP_12, TMP_15, TMP_18, TMP_21, TMP_24, self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$+', '$[]', '$new', '$to_proc', '$each', '$const_set', '$sub', '$==', '$default_external', '$upcase', '$raise', '$attr_accessor', '$attr_reader', '$register', '$length', '$bytes', '$to_a', '$each_byte', '$bytesize', '$enum_for', '$force_encoding', '$dup', '$coerce_to!', '$find', '$getbyte']);\n  \n  self.$require(\"corelib/string\");\n  (function($base, $super, $parent_nesting) {\n    function $Encoding(){};\n    var self = $Encoding = $klass($base, $super, 'Encoding', $Encoding);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Encoding_register_1, TMP_Encoding_find_3, TMP_Encoding_initialize_4, TMP_Encoding_ascii_compatible$q_5, TMP_Encoding_dummy$q_6, TMP_Encoding_to_s_7, TMP_Encoding_inspect_8, TMP_Encoding_each_byte_9, TMP_Encoding_getbyte_10, TMP_Encoding_bytesize_11;\n\n    def.ascii = def.dummy = def.name = nil;\n    \n    self[\"$$register\"] = {};\n    Opal.defs(self, '$register', TMP_Encoding_register_1 = function $$register(name, options) {\n      var $a, TMP_2, self = this, $iter = TMP_Encoding_register_1.$$p, block = $iter || nil, names = nil, encoding = nil, register = nil;\n\n      if (options == null) {\n        options = $hash2([], {});\n      }\n      if ($iter) TMP_Encoding_register_1.$$p = null;\n      \n      names = $rb_plus([name], ($truthy($a = options['$[]'](\"aliases\")) ? $a : []));\n      encoding = $send(Opal.const_get_relative($nesting, 'Class'), 'new', [self], block.$to_proc()).$new(name, names, ($truthy($a = options['$[]'](\"ascii\")) ? $a : false), ($truthy($a = options['$[]'](\"dummy\")) ? $a : false));\n      register = self[\"$$register\"];\n      return $send(names, 'each', [], (TMP_2 = function(name){var self = TMP_2.$$s || this;\nif (name == null) name = nil;\n      \n        self.$const_set(name.$sub(\"-\", \"_\"), encoding);\n        return register[\"\" + \"$$\" + (name)] = encoding;}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));\n    }, TMP_Encoding_register_1.$$arity = -2);\n    Opal.defs(self, '$find', TMP_Encoding_find_3 = function $$find(name) {\n      var $a, self = this, register = nil, encoding = nil;\n\n      \n      if (name['$=='](\"default_external\")) {\n        return self.$default_external()};\n      register = self[\"$$register\"];\n      encoding = ($truthy($a = register[\"\" + \"$$\" + (name)]) ? $a : register[\"\" + \"$$\" + (name.$upcase())]);\n      if ($truthy(encoding)) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"unknown encoding name - \" + (name))\n      };\n      return encoding;\n    }, TMP_Encoding_find_3.$$arity = 1);\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"default_external\")\n    })(Opal.get_singleton_class(self), $nesting);\n    self.$attr_reader(\"name\", \"names\");\n    \n    Opal.defn(self, '$initialize', TMP_Encoding_initialize_4 = function $$initialize(name, names, ascii, dummy) {\n      var self = this;\n\n      \n      self.name = name;\n      self.names = names;\n      self.ascii = ascii;\n      return (self.dummy = dummy);\n    }, TMP_Encoding_initialize_4.$$arity = 4);\n    \n    Opal.defn(self, '$ascii_compatible?', TMP_Encoding_ascii_compatible$q_5 = function() {\n      var self = this;\n\n      return self.ascii\n    }, TMP_Encoding_ascii_compatible$q_5.$$arity = 0);\n    \n    Opal.defn(self, '$dummy?', TMP_Encoding_dummy$q_6 = function() {\n      var self = this;\n\n      return self.dummy\n    }, TMP_Encoding_dummy$q_6.$$arity = 0);\n    \n    Opal.defn(self, '$to_s', TMP_Encoding_to_s_7 = function $$to_s() {\n      var self = this;\n\n      return self.name\n    }, TMP_Encoding_to_s_7.$$arity = 0);\n    \n    Opal.defn(self, '$inspect', TMP_Encoding_inspect_8 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"#<Encoding:\" + (self.name) + ((function() {if ($truthy(self.dummy)) {\n        return \" (dummy)\"\n        } else {\n        return nil\n      }; return nil; })()) + \">\"\n    }, TMP_Encoding_inspect_8.$$arity = 0);\n    \n    Opal.defn(self, '$each_byte', TMP_Encoding_each_byte_9 = function $$each_byte($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n    }, TMP_Encoding_each_byte_9.$$arity = -1);\n    \n    Opal.defn(self, '$getbyte', TMP_Encoding_getbyte_10 = function $$getbyte($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n    }, TMP_Encoding_getbyte_10.$$arity = -1);\n    \n    Opal.defn(self, '$bytesize', TMP_Encoding_bytesize_11 = function $$bytesize($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n    }, TMP_Encoding_bytesize_11.$$arity = -1);\n    (function($base, $super, $parent_nesting) {\n      function $EncodingError(){};\n      var self = $EncodingError = $klass($base, $super, 'EncodingError', $EncodingError);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return nil\n    })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);\n    return (function($base, $super, $parent_nesting) {\n      function $CompatibilityError(){};\n      var self = $CompatibilityError = $klass($base, $super, 'CompatibilityError', $CompatibilityError);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return nil\n    })($nesting[0], Opal.const_get_relative($nesting, 'EncodingError'), $nesting);\n  })($nesting[0], null, $nesting);\n  $send(Opal.const_get_relative($nesting, 'Encoding'), 'register', [\"UTF-8\", $hash2([\"aliases\", \"ascii\"], {\"aliases\": [\"CP65001\"], \"ascii\": true})], (TMP_12 = function(){var self = TMP_12.$$s || this, TMP_each_byte_13, TMP_bytesize_14;\n\n  \n    \n    Opal.def(self, '$each_byte', TMP_each_byte_13 = function $$each_byte(string) {\n      var self = this, $iter = TMP_each_byte_13.$$p, block = $iter || nil;\n\n      if ($iter) TMP_each_byte_13.$$p = null;\n      \n      for (var i = 0, length = string.length; i < length; i++) {\n        var code = string.charCodeAt(i);\n\n        if (code <= 0x7f) {\n          Opal.yield1(block, code);\n        }\n        else {\n          var encoded = encodeURIComponent(string.charAt(i)).substr(1).split('%');\n\n          for (var j = 0, encoded_length = encoded.length; j < encoded_length; j++) {\n            Opal.yield1(block, parseInt(encoded[j], 16));\n          }\n        }\n      }\n    \n    }, TMP_each_byte_13.$$arity = 1);\n    return (Opal.def(self, '$bytesize', TMP_bytesize_14 = function $$bytesize(string) {\n      var self = this;\n\n      return string.$bytes().$length()\n    }, TMP_bytesize_14.$$arity = 1), nil) && 'bytesize';}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12));\n  $send(Opal.const_get_relative($nesting, 'Encoding'), 'register', [\"UTF-16LE\"], (TMP_15 = function(){var self = TMP_15.$$s || this, TMP_each_byte_16, TMP_bytesize_17;\n\n  \n    \n    Opal.def(self, '$each_byte', TMP_each_byte_16 = function $$each_byte(string) {\n      var self = this, $iter = TMP_each_byte_16.$$p, block = $iter || nil;\n\n      if ($iter) TMP_each_byte_16.$$p = null;\n      \n      for (var i = 0, length = string.length; i < length; i++) {\n        var code = string.charCodeAt(i);\n\n        Opal.yield1(block, code & 0xff);\n        Opal.yield1(block, code >> 8);\n      }\n    \n    }, TMP_each_byte_16.$$arity = 1);\n    return (Opal.def(self, '$bytesize', TMP_bytesize_17 = function $$bytesize(string) {\n      var self = this;\n\n      return string.$bytes().$length()\n    }, TMP_bytesize_17.$$arity = 1), nil) && 'bytesize';}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15));\n  $send(Opal.const_get_relative($nesting, 'Encoding'), 'register', [\"UTF-16BE\"], (TMP_18 = function(){var self = TMP_18.$$s || this, TMP_each_byte_19, TMP_bytesize_20;\n\n  \n    \n    Opal.def(self, '$each_byte', TMP_each_byte_19 = function $$each_byte(string) {\n      var self = this, $iter = TMP_each_byte_19.$$p, block = $iter || nil;\n\n      if ($iter) TMP_each_byte_19.$$p = null;\n      \n      for (var i = 0, length = string.length; i < length; i++) {\n        var code = string.charCodeAt(i);\n\n        Opal.yield1(block, code >> 8);\n        Opal.yield1(block, code & 0xff);\n      }\n    \n    }, TMP_each_byte_19.$$arity = 1);\n    return (Opal.def(self, '$bytesize', TMP_bytesize_20 = function $$bytesize(string) {\n      var self = this;\n\n      return string.$bytes().$length()\n    }, TMP_bytesize_20.$$arity = 1), nil) && 'bytesize';}, TMP_18.$$s = self, TMP_18.$$arity = 0, TMP_18));\n  $send(Opal.const_get_relative($nesting, 'Encoding'), 'register', [\"UTF-32LE\"], (TMP_21 = function(){var self = TMP_21.$$s || this, TMP_each_byte_22, TMP_bytesize_23;\n\n  \n    \n    Opal.def(self, '$each_byte', TMP_each_byte_22 = function $$each_byte(string) {\n      var self = this, $iter = TMP_each_byte_22.$$p, block = $iter || nil;\n\n      if ($iter) TMP_each_byte_22.$$p = null;\n      \n      for (var i = 0, length = string.length; i < length; i++) {\n        var code = string.charCodeAt(i);\n\n        Opal.yield1(block, code & 0xff);\n        Opal.yield1(block, code >> 8);\n      }\n    \n    }, TMP_each_byte_22.$$arity = 1);\n    return (Opal.def(self, '$bytesize', TMP_bytesize_23 = function $$bytesize(string) {\n      var self = this;\n\n      return string.$bytes().$length()\n    }, TMP_bytesize_23.$$arity = 1), nil) && 'bytesize';}, TMP_21.$$s = self, TMP_21.$$arity = 0, TMP_21));\n  $send(Opal.const_get_relative($nesting, 'Encoding'), 'register', [\"ASCII-8BIT\", $hash2([\"aliases\", \"ascii\", \"dummy\"], {\"aliases\": [\"BINARY\", \"US-ASCII\", \"ASCII\"], \"ascii\": true, \"dummy\": true})], (TMP_24 = function(){var self = TMP_24.$$s || this, TMP_each_byte_25, TMP_bytesize_26;\n\n  \n    \n    Opal.def(self, '$each_byte', TMP_each_byte_25 = function $$each_byte(string) {\n      var self = this, $iter = TMP_each_byte_25.$$p, block = $iter || nil;\n\n      if ($iter) TMP_each_byte_25.$$p = null;\n      \n      for (var i = 0, length = string.length; i < length; i++) {\n        var code = string.charCodeAt(i);\n        Opal.yield1(block, code & 0xff);\n        Opal.yield1(block, code >> 8);\n      }\n    \n    }, TMP_each_byte_25.$$arity = 1);\n    return (Opal.def(self, '$bytesize', TMP_bytesize_26 = function $$bytesize(string) {\n      var self = this;\n\n      return string.$bytes().$length()\n    }, TMP_bytesize_26.$$arity = 1), nil) && 'bytesize';}, TMP_24.$$s = self, TMP_24.$$arity = 0, TMP_24));\n  return (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_bytes_27, TMP_String_bytesize_28, TMP_String_each_byte_29, TMP_String_encode_30, TMP_String_encoding_31, TMP_String_force_encoding_32, TMP_String_getbyte_33, TMP_String_valid_encoding$q_34;\n\n    def.encoding = nil;\n    \n    String.prototype.encoding = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_16LE');\n    \n    Opal.defn(self, '$bytes', TMP_String_bytes_27 = function $$bytes() {\n      var self = this;\n\n      return self.$each_byte().$to_a()\n    }, TMP_String_bytes_27.$$arity = 0);\n    \n    Opal.defn(self, '$bytesize', TMP_String_bytesize_28 = function $$bytesize() {\n      var self = this;\n\n      return self.encoding.$bytesize(self)\n    }, TMP_String_bytesize_28.$$arity = 0);\n    \n    Opal.defn(self, '$each_byte', TMP_String_each_byte_29 = function $$each_byte() {\n      var self = this, $iter = TMP_String_each_byte_29.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_each_byte_29.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"each_byte\")\n      };\n      $send(self.encoding, 'each_byte', [self], block.$to_proc());\n      return self;\n    }, TMP_String_each_byte_29.$$arity = 0);\n    \n    Opal.defn(self, '$encode', TMP_String_encode_30 = function $$encode(encoding) {\n      var self = this;\n\n      return self.$dup().$force_encoding(encoding)\n    }, TMP_String_encode_30.$$arity = 1);\n    \n    Opal.defn(self, '$encoding', TMP_String_encoding_31 = function $$encoding() {\n      var self = this;\n\n      return self.encoding\n    }, TMP_String_encoding_31.$$arity = 0);\n    \n    Opal.defn(self, '$force_encoding', TMP_String_force_encoding_32 = function $$force_encoding(encoding) {\n      var self = this;\n\n      \n      if (encoding === self.encoding) { return self; }\n\n      encoding = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](encoding, Opal.const_get_relative($nesting, 'String'), \"to_s\");\n      encoding = Opal.const_get_relative($nesting, 'Encoding').$find(encoding);\n\n      if (encoding === self.encoding) { return self; }\n\n      self.encoding = encoding;\n      return self;\n    \n    }, TMP_String_force_encoding_32.$$arity = 1);\n    \n    Opal.defn(self, '$getbyte', TMP_String_getbyte_33 = function $$getbyte(idx) {\n      var self = this;\n\n      return self.encoding.$getbyte(self, idx)\n    }, TMP_String_getbyte_33.$$arity = 1);\n    return (Opal.defn(self, '$valid_encoding?', TMP_String_valid_encoding$q_34 = function() {\n      var self = this;\n\n      return true\n    }, TMP_String_valid_encoding$q_34.$$arity = 0), nil) && 'valid_encoding?';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/math\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$new', '$raise', '$Float', '$type_error', '$Integer', '$module_function', '$checked', '$float!', '$===', '$gamma', '$-', '$integer!', '$/', '$infinite?']);\n  return (function($base, $parent_nesting) {\n    var $Math, self = $Math = $module($base, 'Math');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Math_checked_1, TMP_Math_float$B_2, TMP_Math_integer$B_3, TMP_Math_acos_4, TMP_Math_acosh_5, TMP_Math_asin_6, TMP_Math_asinh_7, TMP_Math_atan_8, TMP_Math_atan2_9, TMP_Math_atanh_10, TMP_Math_cbrt_11, TMP_Math_cos_12, TMP_Math_cosh_13, TMP_Math_erf_14, TMP_Math_erfc_15, TMP_Math_exp_16, TMP_Math_frexp_17, TMP_Math_gamma_18, TMP_Math_hypot_19, TMP_Math_ldexp_20, TMP_Math_lgamma_21, TMP_Math_log_22, TMP_Math_log10_23, TMP_Math_log2_24, TMP_Math_sin_25, TMP_Math_sinh_26, TMP_Math_sqrt_27, TMP_Math_tan_28, TMP_Math_tanh_29;\n\n    \n    Opal.const_set($nesting[0], 'E', Math.E);\n    Opal.const_set($nesting[0], 'PI', Math.PI);\n    Opal.const_set($nesting[0], 'DomainError', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));\n    Opal.defs(self, '$checked', TMP_Math_checked_1 = function $$checked(method, $a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {\n        return NaN;\n      }\n\n      var result = Math[method].apply(null, args);\n\n      if (isNaN(result)) {\n        self.$raise(Opal.const_get_relative($nesting, 'DomainError'), \"\" + \"Numerical argument is out of domain - \\\"\" + (method) + \"\\\"\");\n      }\n\n      return result;\n    \n    }, TMP_Math_checked_1.$$arity = -2);\n    Opal.defs(self, '$float!', TMP_Math_float$B_2 = function(value) {\n      var self = this;\n\n      \n      try {\n        return self.$Float(value)\n      } catch ($err) {\n        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'ArgumentError')])) {\n          try {\n            return self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(value, Opal.const_get_relative($nesting, 'Float')))\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      };\n    }, TMP_Math_float$B_2.$$arity = 1);\n    Opal.defs(self, '$integer!', TMP_Math_integer$B_3 = function(value) {\n      var self = this;\n\n      \n      try {\n        return self.$Integer(value)\n      } catch ($err) {\n        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'ArgumentError')])) {\n          try {\n            return self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(value, Opal.const_get_relative($nesting, 'Integer')))\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      };\n    }, TMP_Math_integer$B_3.$$arity = 1);\n    self.$module_function();\n    \n    Opal.defn(self, '$acos', TMP_Math_acos_4 = function $$acos(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"acos\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_acos_4.$$arity = 1);\n    if ($truthy((typeof(Math.acosh) !== \"undefined\"))) {\n      } else {\n      \n      Math.acosh = function(x) {\n        return Math.log(x + Math.sqrt(x * x - 1));\n      }\n    \n    };\n    \n    Opal.defn(self, '$acosh', TMP_Math_acosh_5 = function $$acosh(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"acosh\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_acosh_5.$$arity = 1);\n    \n    Opal.defn(self, '$asin', TMP_Math_asin_6 = function $$asin(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"asin\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_asin_6.$$arity = 1);\n    if ($truthy((typeof(Math.asinh) !== \"undefined\"))) {\n      } else {\n      \n      Math.asinh = function(x) {\n        return Math.log(x + Math.sqrt(x * x + 1))\n      }\n    \n    };\n    \n    Opal.defn(self, '$asinh', TMP_Math_asinh_7 = function $$asinh(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"asinh\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_asinh_7.$$arity = 1);\n    \n    Opal.defn(self, '$atan', TMP_Math_atan_8 = function $$atan(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"atan\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_atan_8.$$arity = 1);\n    \n    Opal.defn(self, '$atan2', TMP_Math_atan2_9 = function $$atan2(y, x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"atan2\", Opal.const_get_relative($nesting, 'Math')['$float!'](y), Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_atan2_9.$$arity = 2);\n    if ($truthy((typeof(Math.atanh) !== \"undefined\"))) {\n      } else {\n      \n      Math.atanh = function(x) {\n        return 0.5 * Math.log((1 + x) / (1 - x));\n      }\n    \n    };\n    \n    Opal.defn(self, '$atanh', TMP_Math_atanh_10 = function $$atanh(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"atanh\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_atanh_10.$$arity = 1);\n    if ($truthy((typeof(Math.cbrt) !== \"undefined\"))) {\n      } else {\n      \n      Math.cbrt = function(x) {\n        if (x == 0) {\n          return 0;\n        }\n\n        if (x < 0) {\n          return -Math.cbrt(-x);\n        }\n\n        var r  = x,\n            ex = 0;\n\n        while (r < 0.125) {\n          r *= 8;\n          ex--;\n        }\n\n        while (r > 1.0) {\n          r *= 0.125;\n          ex++;\n        }\n\n        r = (-0.46946116 * r + 1.072302) * r + 0.3812513;\n\n        while (ex < 0) {\n          r *= 0.5;\n          ex++;\n        }\n\n        while (ex > 0) {\n          r *= 2;\n          ex--;\n        }\n\n        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);\n        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);\n        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);\n        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);\n\n        return r;\n      }\n    \n    };\n    \n    Opal.defn(self, '$cbrt', TMP_Math_cbrt_11 = function $$cbrt(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"cbrt\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_cbrt_11.$$arity = 1);\n    \n    Opal.defn(self, '$cos', TMP_Math_cos_12 = function $$cos(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"cos\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_cos_12.$$arity = 1);\n    if ($truthy((typeof(Math.cosh) !== \"undefined\"))) {\n      } else {\n      \n      Math.cosh = function(x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2;\n      }\n    \n    };\n    \n    Opal.defn(self, '$cosh', TMP_Math_cosh_13 = function $$cosh(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"cosh\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_cosh_13.$$arity = 1);\n    if ($truthy((typeof(Math.erf) !== \"undefined\"))) {\n      } else {\n      \n      Math.erf = function(x) {\n        var A1 =  0.254829592,\n            A2 = -0.284496736,\n            A3 =  1.421413741,\n            A4 = -1.453152027,\n            A5 =  1.061405429,\n            P  =  0.3275911;\n\n        var sign = 1;\n\n        if (x < 0) {\n            sign = -1;\n        }\n\n        x = Math.abs(x);\n\n        var t = 1.0 / (1.0 + P * x);\n        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);\n\n        return sign * y;\n      }\n    \n    };\n    \n    Opal.defn(self, '$erf', TMP_Math_erf_14 = function $$erf(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"erf\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_erf_14.$$arity = 1);\n    if ($truthy((typeof(Math.erfc) !== \"undefined\"))) {\n      } else {\n      \n      Math.erfc = function(x) {\n        var z = Math.abs(x),\n            t = 1.0 / (0.5 * z + 1.0);\n\n        var A1 = t * 0.17087277 + -0.82215223,\n            A2 = t * A1 + 1.48851587,\n            A3 = t * A2 + -1.13520398,\n            A4 = t * A3 + 0.27886807,\n            A5 = t * A4 + -0.18628806,\n            A6 = t * A5 + 0.09678418,\n            A7 = t * A6 + 0.37409196,\n            A8 = t * A7 + 1.00002368,\n            A9 = t * A8,\n            A10 = -z * z - 1.26551223 + A9;\n\n        var a = t * Math.exp(A10);\n\n        if (x < 0.0) {\n          return 2.0 - a;\n        }\n        else {\n          return a;\n        }\n      }\n    \n    };\n    \n    Opal.defn(self, '$erfc', TMP_Math_erfc_15 = function $$erfc(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"erfc\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_erfc_15.$$arity = 1);\n    \n    Opal.defn(self, '$exp', TMP_Math_exp_16 = function $$exp(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"exp\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_exp_16.$$arity = 1);\n    \n    Opal.defn(self, '$frexp', TMP_Math_frexp_17 = function $$frexp(x) {\n      var self = this;\n\n      \n      x = Opal.const_get_relative($nesting, 'Math')['$float!'](x);\n      \n      if (isNaN(x)) {\n        return [NaN, 0];\n      }\n\n      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,\n          frac = x / Math.pow(2, ex);\n\n      return [frac, ex];\n    ;\n    }, TMP_Math_frexp_17.$$arity = 1);\n    \n    Opal.defn(self, '$gamma', TMP_Math_gamma_18 = function $$gamma(n) {\n      var self = this;\n\n      \n      n = Opal.const_get_relative($nesting, 'Math')['$float!'](n);\n      \n      var i, t, x, value, result, twoN, threeN, fourN, fiveN;\n\n      var G = 4.7421875;\n\n      var P = [\n         0.99999999999999709182,\n         57.156235665862923517,\n        -59.597960355475491248,\n         14.136097974741747174,\n        -0.49191381609762019978,\n         0.33994649984811888699e-4,\n         0.46523628927048575665e-4,\n        -0.98374475304879564677e-4,\n         0.15808870322491248884e-3,\n        -0.21026444172410488319e-3,\n         0.21743961811521264320e-3,\n        -0.16431810653676389022e-3,\n         0.84418223983852743293e-4,\n        -0.26190838401581408670e-4,\n         0.36899182659531622704e-5\n      ];\n\n\n      if (isNaN(n)) {\n        return NaN;\n      }\n\n      if (n === 0 && 1 / n < 0) {\n        return -Infinity;\n      }\n\n      if (n === -1 || n === -Infinity) {\n        self.$raise(Opal.const_get_relative($nesting, 'DomainError'), \"Numerical argument is out of domain - \\\"gamma\\\"\");\n      }\n\n      if (Opal.const_get_relative($nesting, 'Integer')['$==='](n)) {\n        if (n <= 0) {\n          return isFinite(n) ? Infinity : NaN;\n        }\n\n        if (n > 171) {\n          return Infinity;\n        }\n\n        value  = n - 2;\n        result = n - 1;\n\n        while (value > 1) {\n          result *= value;\n          value--;\n        }\n\n        if (result == 0) {\n          result = 1;\n        }\n\n        return result;\n      }\n\n      if (n < 0.5) {\n        return Math.PI / (Math.sin(Math.PI * n) * Opal.const_get_relative($nesting, 'Math').$gamma($rb_minus(1, n)));\n      }\n\n      if (n >= 171.35) {\n        return Infinity;\n      }\n\n      if (n > 85.0) {\n        twoN   = n * n;\n        threeN = twoN * n;\n        fourN  = threeN * n;\n        fiveN  = fourN * n;\n\n        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *\n          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -\n          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +\n          5246819 / (75246796800 * fiveN * n));\n      }\n\n      n -= 1;\n      x  = P[0];\n\n      for (i = 1; i < P.length; ++i) {\n        x += P[i] / (n + i);\n      }\n\n      t = n + G + 0.5;\n\n      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;\n    ;\n    }, TMP_Math_gamma_18.$$arity = 1);\n    if ($truthy((typeof(Math.hypot) !== \"undefined\"))) {\n      } else {\n      \n      Math.hypot = function(x, y) {\n        return Math.sqrt(x * x + y * y)\n      }\n    \n    };\n    \n    Opal.defn(self, '$hypot', TMP_Math_hypot_19 = function $$hypot(x, y) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"hypot\", Opal.const_get_relative($nesting, 'Math')['$float!'](x), Opal.const_get_relative($nesting, 'Math')['$float!'](y))\n    }, TMP_Math_hypot_19.$$arity = 2);\n    \n    Opal.defn(self, '$ldexp', TMP_Math_ldexp_20 = function $$ldexp(mantissa, exponent) {\n      var self = this;\n\n      \n      mantissa = Opal.const_get_relative($nesting, 'Math')['$float!'](mantissa);\n      exponent = Opal.const_get_relative($nesting, 'Math')['$integer!'](exponent);\n      \n      if (isNaN(exponent)) {\n        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"float NaN out of range of integer\");\n      }\n\n      return mantissa * Math.pow(2, exponent);\n    ;\n    }, TMP_Math_ldexp_20.$$arity = 2);\n    \n    Opal.defn(self, '$lgamma', TMP_Math_lgamma_21 = function $$lgamma(n) {\n      var self = this;\n\n      \n      if (n == -1) {\n        return [Infinity, 1];\n      }\n      else {\n        return [Math.log(Math.abs(Opal.const_get_relative($nesting, 'Math').$gamma(n))), Opal.const_get_relative($nesting, 'Math').$gamma(n) < 0 ? -1 : 1];\n      }\n    \n    }, TMP_Math_lgamma_21.$$arity = 1);\n    \n    Opal.defn(self, '$log', TMP_Math_log_22 = function $$log(x, base) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](x))) {\n        self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(x, Opal.const_get_relative($nesting, 'Float')))};\n      if ($truthy(base == null)) {\n        return Opal.const_get_relative($nesting, 'Math').$checked(\"log\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n        } else {\n        \n        if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](base))) {\n          self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(base, Opal.const_get_relative($nesting, 'Float')))};\n        return $rb_divide(Opal.const_get_relative($nesting, 'Math').$checked(\"log\", Opal.const_get_relative($nesting, 'Math')['$float!'](x)), Opal.const_get_relative($nesting, 'Math').$checked(\"log\", Opal.const_get_relative($nesting, 'Math')['$float!'](base)));\n      };\n    }, TMP_Math_log_22.$$arity = -2);\n    if ($truthy((typeof(Math.log10) !== \"undefined\"))) {\n      } else {\n      \n      Math.log10 = function(x) {\n        return Math.log(x) / Math.LN10;\n      }\n    \n    };\n    \n    Opal.defn(self, '$log10', TMP_Math_log10_23 = function $$log10(x) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](x))) {\n        self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(x, Opal.const_get_relative($nesting, 'Float')))};\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"log10\", Opal.const_get_relative($nesting, 'Math')['$float!'](x));\n    }, TMP_Math_log10_23.$$arity = 1);\n    if ($truthy((typeof(Math.log2) !== \"undefined\"))) {\n      } else {\n      \n      Math.log2 = function(x) {\n        return Math.log(x) / Math.LN2;\n      }\n    \n    };\n    \n    Opal.defn(self, '$log2', TMP_Math_log2_24 = function $$log2(x) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](x))) {\n        self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(x, Opal.const_get_relative($nesting, 'Float')))};\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"log2\", Opal.const_get_relative($nesting, 'Math')['$float!'](x));\n    }, TMP_Math_log2_24.$$arity = 1);\n    \n    Opal.defn(self, '$sin', TMP_Math_sin_25 = function $$sin(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"sin\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_sin_25.$$arity = 1);\n    if ($truthy((typeof(Math.sinh) !== \"undefined\"))) {\n      } else {\n      \n      Math.sinh = function(x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2;\n      }\n    \n    };\n    \n    Opal.defn(self, '$sinh', TMP_Math_sinh_26 = function $$sinh(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"sinh\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_sinh_26.$$arity = 1);\n    \n    Opal.defn(self, '$sqrt', TMP_Math_sqrt_27 = function $$sqrt(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"sqrt\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_sqrt_27.$$arity = 1);\n    \n    Opal.defn(self, '$tan', TMP_Math_tan_28 = function $$tan(x) {\n      var self = this;\n\n      \n      x = Opal.const_get_relative($nesting, 'Math')['$float!'](x);\n      if ($truthy(x['$infinite?']())) {\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'NAN')};\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"tan\", Opal.const_get_relative($nesting, 'Math')['$float!'](x));\n    }, TMP_Math_tan_28.$$arity = 1);\n    if ($truthy((typeof(Math.tanh) !== \"undefined\"))) {\n      } else {\n      \n      Math.tanh = function(x) {\n        if (x == Infinity) {\n          return 1;\n        }\n        else if (x == -Infinity) {\n          return -1;\n        }\n        else {\n          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));\n        }\n      }\n    \n    };\n    \n    Opal.defn(self, '$tanh', TMP_Math_tanh_29 = function $$tanh(x) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$checked(\"tanh\", Opal.const_get_relative($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_tanh_29.$$arity = 1);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/complex\"] = function(Opal) {\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;\n\n  Opal.add_stubs(['$require', '$===', '$real?', '$raise', '$new', '$*', '$cos', '$sin', '$attr_reader', '$class', '$==', '$real', '$imag', '$Complex', '$-@', '$+', '$__coerced__', '$-', '$nan?', '$/', '$conj', '$abs2', '$quo', '$polar', '$exp', '$log', '$>', '$!=', '$divmod', '$**', '$hypot', '$atan2', '$lcm', '$denominator', '$to_s', '$numerator', '$abs', '$arg', '$rationalize', '$to_f', '$to_i', '$to_r', '$inspect', '$positive?', '$zero?', '$infinite?']);\n  \n  self.$require(\"corelib/numeric\");\n  (function($base, $super, $parent_nesting) {\n    function $Complex(){};\n    var self = $Complex = $klass($base, $super, 'Complex', $Complex);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Complex_rect_1, TMP_Complex_polar_2, TMP_Complex_initialize_3, TMP_Complex_coerce_4, TMP_Complex_$eq$eq_5, TMP_Complex_$$_6, TMP_Complex_$_7, TMP_Complex_$_8, TMP_Complex_$_9, TMP_Complex_$_10, TMP_Complex_$$_11, TMP_Complex_abs_12, TMP_Complex_abs2_13, TMP_Complex_angle_14, TMP_Complex_conj_15, TMP_Complex_denominator_16, TMP_Complex_eql$q_17, TMP_Complex_fdiv_18, TMP_Complex_hash_19, TMP_Complex_inspect_20, TMP_Complex_numerator_21, TMP_Complex_polar_22, TMP_Complex_rationalize_23, TMP_Complex_real$q_24, TMP_Complex_rect_25, TMP_Complex_to_f_26, TMP_Complex_to_i_27, TMP_Complex_to_r_28, TMP_Complex_to_s_29;\n\n    def.real = def.imag = nil;\n    \n    Opal.defs(self, '$rect', TMP_Complex_rect_1 = function $$rect(real, imag) {\n      var $a, $b, $c, self = this;\n\n      if (imag == null) {\n        imag = 0;\n      }\n      \n      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = Opal.const_get_relative($nesting, 'Numeric')['$==='](real)) ? real['$real?']() : $c)) ? Opal.const_get_relative($nesting, 'Numeric')['$==='](imag) : $b)) ? imag['$real?']() : $a))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"not a real\")\n      };\n      return self.$new(real, imag);\n    }, TMP_Complex_rect_1.$$arity = -2);\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return Opal.alias(self, \"rectangular\", \"rect\")\n    })(Opal.get_singleton_class(self), $nesting);\n    Opal.defs(self, '$polar', TMP_Complex_polar_2 = function $$polar(r, theta) {\n      var $a, $b, $c, self = this;\n\n      if (theta == null) {\n        theta = 0;\n      }\n      \n      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = Opal.const_get_relative($nesting, 'Numeric')['$==='](r)) ? r['$real?']() : $c)) ? Opal.const_get_relative($nesting, 'Numeric')['$==='](theta) : $b)) ? theta['$real?']() : $a))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"not a real\")\n      };\n      return self.$new($rb_times(r, Opal.const_get_relative($nesting, 'Math').$cos(theta)), $rb_times(r, Opal.const_get_relative($nesting, 'Math').$sin(theta)));\n    }, TMP_Complex_polar_2.$$arity = -2);\n    self.$attr_reader(\"real\", \"imag\");\n    \n    Opal.defn(self, '$initialize', TMP_Complex_initialize_3 = function $$initialize(real, imag) {\n      var self = this;\n\n      if (imag == null) {\n        imag = 0;\n      }\n      \n      self.real = real;\n      return (self.imag = imag);\n    }, TMP_Complex_initialize_3.$$arity = -2);\n    \n    Opal.defn(self, '$coerce', TMP_Complex_coerce_4 = function $$coerce(other) {\n      var $a, self = this;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {\n        return [other, self]\n      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return [Opal.const_get_relative($nesting, 'Complex').$new(other, 0), self]\n        } else {\n        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + (other.$class()) + \" can't be coerced into Complex\")\n      }\n    }, TMP_Complex_coerce_4.$$arity = 1);\n    \n    Opal.defn(self, '$==', TMP_Complex_$eq$eq_5 = function(other) {\n      var $a, self = this;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {\n        return (($a = self.real['$=='](other.$real())) ? self.imag['$=='](other.$imag()) : self.real['$=='](other.$real()))\n      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return (($a = self.real['$=='](other)) ? self.imag['$=='](0) : self.real['$=='](other))\n        } else {\n        return other['$=='](self)\n      }\n    }, TMP_Complex_$eq$eq_5.$$arity = 1);\n    \n    Opal.defn(self, '$-@', TMP_Complex_$$_6 = function() {\n      var self = this;\n\n      return self.$Complex(self.real['$-@'](), self.imag['$-@']())\n    }, TMP_Complex_$$_6.$$arity = 0);\n    \n    Opal.defn(self, '$+', TMP_Complex_$_7 = function(other) {\n      var $a, self = this;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {\n        return self.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))\n      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return self.$Complex($rb_plus(self.real, other), self.imag)\n        } else {\n        return self.$__coerced__(\"+\", other)\n      }\n    }, TMP_Complex_$_7.$$arity = 1);\n    \n    Opal.defn(self, '$-', TMP_Complex_$_8 = function(other) {\n      var $a, self = this;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {\n        return self.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))\n      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return self.$Complex($rb_minus(self.real, other), self.imag)\n        } else {\n        return self.$__coerced__(\"-\", other)\n      }\n    }, TMP_Complex_$_8.$$arity = 1);\n    \n    Opal.defn(self, '$*', TMP_Complex_$_9 = function(other) {\n      var $a, self = this;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {\n        return self.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))\n      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return self.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))\n        } else {\n        return self.$__coerced__(\"*\", other)\n      }\n    }, TMP_Complex_$_9.$$arity = 1);\n    \n    Opal.defn(self, '$/', TMP_Complex_$_10 = function(other) {\n      var $a, $b, $c, $d, self = this;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {\n        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = Opal.const_get_relative($nesting, 'Number')['$==='](self.real)) ? self.real['$nan?']() : $d)) ? $c : ($truthy($d = Opal.const_get_relative($nesting, 'Number')['$==='](self.imag)) ? self.imag['$nan?']() : $d))) ? $b : ($truthy($c = Opal.const_get_relative($nesting, 'Number')['$==='](other.$real())) ? other.$real()['$nan?']() : $c))) ? $a : ($truthy($b = Opal.const_get_relative($nesting, 'Number')['$==='](other.$imag())) ? other.$imag()['$nan?']() : $b)))) {\n          return Opal.const_get_relative($nesting, 'Complex').$new(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'NAN'), Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'NAN'))\n          } else {\n          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())\n        }\n      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return self.$Complex(self.real.$quo(other), self.imag.$quo(other))\n        } else {\n        return self.$__coerced__(\"/\", other)\n      }\n    }, TMP_Complex_$_10.$$arity = 1);\n    \n    Opal.defn(self, '$**', TMP_Complex_$$_11 = function(other) {\n      var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;\n\n      \n      if (other['$=='](0)) {\n        return Opal.const_get_relative($nesting, 'Complex').$new(1, 0)};\n      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {\n        \n        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;\n        ore = other.$real();\n        oim = other.$imag();\n        nr = Opal.const_get_relative($nesting, 'Math').$exp($rb_minus($rb_times(ore, Opal.const_get_relative($nesting, 'Math').$log(r)), $rb_times(oim, theta)));\n        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, Opal.const_get_relative($nesting, 'Math').$log(r)));\n        return Opal.const_get_relative($nesting, 'Complex').$polar(nr, ntheta);\n      } else if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](other))) {\n        if ($truthy($rb_gt(other, 0))) {\n          \n          x = self;\n          z = x;\n          n = $rb_minus(other, 1);\n          while ($truthy(n['$!='](0))) {\n            \n            while ($truthy(($d = n.$divmod(2), $c = Opal.to_ary($d), (div = ($c[0] == null ? nil : $c[0])), (mod = ($c[1] == null ? nil : $c[1])), $d, mod['$=='](0)))) {\n              \n              x = self.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));\n              n = div;\n            };\n            z = $rb_times(z, x);\n            n = $rb_minus(n, 1);\n          };\n          return z;\n          } else {\n          return $rb_divide(Opal.const_get_relative($nesting, 'Rational').$new(1, 1), self)['$**'](other['$-@']())\n        }\n      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Float')['$==='](other)) ? $a : Opal.const_get_relative($nesting, 'Rational')['$==='](other)))) {\n        \n        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;\n        return Opal.const_get_relative($nesting, 'Complex').$polar(r['$**'](other), $rb_times(theta, other));\n        } else {\n        return self.$__coerced__(\"**\", other)\n      };\n    }, TMP_Complex_$$_11.$$arity = 1);\n    \n    Opal.defn(self, '$abs', TMP_Complex_abs_12 = function $$abs() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$hypot(self.real, self.imag)\n    }, TMP_Complex_abs_12.$$arity = 0);\n    \n    Opal.defn(self, '$abs2', TMP_Complex_abs2_13 = function $$abs2() {\n      var self = this;\n\n      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))\n    }, TMP_Complex_abs2_13.$$arity = 0);\n    \n    Opal.defn(self, '$angle', TMP_Complex_angle_14 = function $$angle() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Math').$atan2(self.imag, self.real)\n    }, TMP_Complex_angle_14.$$arity = 0);\n    Opal.alias(self, \"arg\", \"angle\");\n    \n    Opal.defn(self, '$conj', TMP_Complex_conj_15 = function $$conj() {\n      var self = this;\n\n      return self.$Complex(self.real, self.imag['$-@']())\n    }, TMP_Complex_conj_15.$$arity = 0);\n    Opal.alias(self, \"conjugate\", \"conj\");\n    \n    Opal.defn(self, '$denominator', TMP_Complex_denominator_16 = function $$denominator() {\n      var self = this;\n\n      return self.real.$denominator().$lcm(self.imag.$denominator())\n    }, TMP_Complex_denominator_16.$$arity = 0);\n    Opal.alias(self, \"divide\", \"/\");\n    \n    Opal.defn(self, '$eql?', TMP_Complex_eql$q_17 = function(other) {\n      var $a, $b, self = this;\n\n      return ($truthy($a = ($truthy($b = Opal.const_get_relative($nesting, 'Complex')['$==='](other)) ? self.real.$class()['$=='](self.imag.$class()) : $b)) ? self['$=='](other) : $a)\n    }, TMP_Complex_eql$q_17.$$arity = 1);\n    \n    Opal.defn(self, '$fdiv', TMP_Complex_fdiv_18 = function $$fdiv(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Numeric')['$==='](other))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + (other.$class()) + \" can't be coerced into Complex\")\n      };\n      return $rb_divide(self, other);\n    }, TMP_Complex_fdiv_18.$$arity = 1);\n    \n    Opal.defn(self, '$hash', TMP_Complex_hash_19 = function $$hash() {\n      var self = this;\n\n      return \"\" + \"Complex:\" + (self.real) + \":\" + (self.imag)\n    }, TMP_Complex_hash_19.$$arity = 0);\n    Opal.alias(self, \"imaginary\", \"imag\");\n    \n    Opal.defn(self, '$inspect', TMP_Complex_inspect_20 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"(\" + (self.$to_s()) + \")\"\n    }, TMP_Complex_inspect_20.$$arity = 0);\n    Opal.alias(self, \"magnitude\", \"abs\");\n    \n    Opal.udef(self, '$' + \"negative?\");;\n    \n    Opal.defn(self, '$numerator', TMP_Complex_numerator_21 = function $$numerator() {\n      var self = this, d = nil;\n\n      \n      d = self.$denominator();\n      return self.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));\n    }, TMP_Complex_numerator_21.$$arity = 0);\n    Opal.alias(self, \"phase\", \"arg\");\n    \n    Opal.defn(self, '$polar', TMP_Complex_polar_22 = function $$polar() {\n      var self = this;\n\n      return [self.$abs(), self.$arg()]\n    }, TMP_Complex_polar_22.$$arity = 0);\n    \n    Opal.udef(self, '$' + \"positive?\");;\n    Opal.alias(self, \"quo\", \"/\");\n    \n    Opal.defn(self, '$rationalize', TMP_Complex_rationalize_23 = function $$rationalize(eps) {\n      var self = this;\n\n      \n      \n      if (arguments.length > 1) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" for 0..1)\");\n      }\n    ;\n      if ($truthy(self.imag['$!='](0))) {\n        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"\" + \"can't' convert \" + (self) + \" into Rational\")};\n      return self.$real().$rationalize(eps);\n    }, TMP_Complex_rationalize_23.$$arity = -1);\n    \n    Opal.defn(self, '$real?', TMP_Complex_real$q_24 = function() {\n      var self = this;\n\n      return false\n    }, TMP_Complex_real$q_24.$$arity = 0);\n    \n    Opal.defn(self, '$rect', TMP_Complex_rect_25 = function $$rect() {\n      var self = this;\n\n      return [self.real, self.imag]\n    }, TMP_Complex_rect_25.$$arity = 0);\n    Opal.alias(self, \"rectangular\", \"rect\");\n    \n    Opal.defn(self, '$to_f', TMP_Complex_to_f_26 = function $$to_f() {\n      var self = this;\n\n      \n      if (self.imag['$=='](0)) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"\" + \"can't convert \" + (self) + \" into Float\")\n      };\n      return self.real.$to_f();\n    }, TMP_Complex_to_f_26.$$arity = 0);\n    \n    Opal.defn(self, '$to_i', TMP_Complex_to_i_27 = function $$to_i() {\n      var self = this;\n\n      \n      if (self.imag['$=='](0)) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"\" + \"can't convert \" + (self) + \" into Integer\")\n      };\n      return self.real.$to_i();\n    }, TMP_Complex_to_i_27.$$arity = 0);\n    \n    Opal.defn(self, '$to_r', TMP_Complex_to_r_28 = function $$to_r() {\n      var self = this;\n\n      \n      if (self.imag['$=='](0)) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"\" + \"can't convert \" + (self) + \" into Rational\")\n      };\n      return self.real.$to_r();\n    }, TMP_Complex_to_r_28.$$arity = 0);\n    \n    Opal.defn(self, '$to_s', TMP_Complex_to_s_29 = function $$to_s() {\n      var $a, $b, $c, self = this, result = nil;\n\n      \n      result = self.real.$inspect();\n      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = Opal.const_get_relative($nesting, 'Number')['$==='](self.imag)) ? self.imag['$nan?']() : $c)) ? $b : self.imag['$positive?']())) ? $a : self.imag['$zero?']()))) {\n        result = $rb_plus(result, \"+\")\n        } else {\n        result = $rb_plus(result, \"-\")\n      };\n      result = $rb_plus(result, self.imag.$abs().$inspect());\n      if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Number')['$==='](self.imag)) ? ($truthy($b = self.imag['$nan?']()) ? $b : self.imag['$infinite?']()) : $a))) {\n        result = $rb_plus(result, \"*\")};\n      return $rb_plus(result, \"i\");\n    }, TMP_Complex_to_s_29.$$arity = 0);\n    return Opal.const_set($nesting[0], 'I', self.$new(0, 1));\n  })($nesting[0], Opal.const_get_relative($nesting, 'Numeric'), $nesting);\n  return (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_Complex_30;\n\n    \n    Opal.defn(self, '$Complex', TMP_Kernel_Complex_30 = function $$Complex(real, imag) {\n      var self = this;\n\n      if (imag == null) {\n        imag = nil;\n      }\n      if ($truthy(imag)) {\n        return Opal.const_get_relative($nesting, 'Complex').$new(real, imag)\n        } else {\n        return Opal.const_get_relative($nesting, 'Complex').$new(real, 0)\n      }\n    }, TMP_Kernel_Complex_30.$$arity = -2)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/rational\"] = function(Opal) {\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;\n\n  Opal.add_stubs(['$require', '$to_i', '$==', '$raise', '$<', '$-@', '$new', '$gcd', '$/', '$nil?', '$===', '$reduce', '$to_r', '$equal?', '$!', '$coerce_to!', '$attr_reader', '$to_f', '$numerator', '$denominator', '$<=>', '$-', '$*', '$__coerced__', '$+', '$Rational', '$>', '$**', '$abs', '$ceil', '$with_precision', '$floor', '$to_s', '$<=', '$truncate', '$send', '$convert']);\n  \n  self.$require(\"corelib/numeric\");\n  (function($base, $super, $parent_nesting) {\n    function $Rational(){};\n    var self = $Rational = $klass($base, $super, 'Rational', $Rational);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Rational_reduce_1, TMP_Rational_convert_2, TMP_Rational_initialize_3, TMP_Rational_numerator_4, TMP_Rational_denominator_5, TMP_Rational_coerce_6, TMP_Rational_$eq$eq_7, TMP_Rational_$lt$eq$gt_8, TMP_Rational_$_9, TMP_Rational_$_10, TMP_Rational_$_11, TMP_Rational_$_12, TMP_Rational_$$_13, TMP_Rational_abs_14, TMP_Rational_ceil_15, TMP_Rational_floor_16, TMP_Rational_hash_17, TMP_Rational_inspect_18, TMP_Rational_rationalize_19, TMP_Rational_round_20, TMP_Rational_to_f_21, TMP_Rational_to_i_22, TMP_Rational_to_r_23, TMP_Rational_to_s_24, TMP_Rational_truncate_25, TMP_Rational_with_precision_26;\n\n    def.num = def.den = nil;\n    \n    Opal.defs(self, '$reduce', TMP_Rational_reduce_1 = function $$reduce(num, den) {\n      var self = this, gcd = nil;\n\n      \n      num = num.$to_i();\n      den = den.$to_i();\n      if (den['$=='](0)) {\n        self.$raise(Opal.const_get_relative($nesting, 'ZeroDivisionError'), \"divided by 0\")\n      } else if ($truthy($rb_lt(den, 0))) {\n        \n        num = num['$-@']();\n        den = den['$-@']();\n      } else if (den['$=='](1)) {\n        return self.$new(num, den)};\n      gcd = num.$gcd(den);\n      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));\n    }, TMP_Rational_reduce_1.$$arity = 2);\n    Opal.defs(self, '$convert', TMP_Rational_convert_2 = function $$convert(num, den) {\n      var $a, $b, self = this;\n\n      \n      if ($truthy(($truthy($a = num['$nil?']()) ? $a : den['$nil?']()))) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"cannot convert nil into Rational\")};\n      if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Integer')['$==='](num)) ? Opal.const_get_relative($nesting, 'Integer')['$==='](den) : $a))) {\n        return self.$reduce(num, den)};\n      if ($truthy(($truthy($a = ($truthy($b = Opal.const_get_relative($nesting, 'Float')['$==='](num)) ? $b : Opal.const_get_relative($nesting, 'String')['$==='](num))) ? $a : Opal.const_get_relative($nesting, 'Complex')['$==='](num)))) {\n        num = num.$to_r()};\n      if ($truthy(($truthy($a = ($truthy($b = Opal.const_get_relative($nesting, 'Float')['$==='](den)) ? $b : Opal.const_get_relative($nesting, 'String')['$==='](den))) ? $a : Opal.const_get_relative($nesting, 'Complex')['$==='](den)))) {\n        den = den.$to_r()};\n      if ($truthy(($truthy($a = den['$equal?'](1)) ? Opal.const_get_relative($nesting, 'Integer')['$==='](num)['$!']() : $a))) {\n        return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](num, Opal.const_get_relative($nesting, 'Rational'), \"to_r\")\n      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](num)) ? Opal.const_get_relative($nesting, 'Numeric')['$==='](den) : $a))) {\n        return $rb_divide(num, den)\n        } else {\n        return self.$reduce(num, den)\n      };\n    }, TMP_Rational_convert_2.$$arity = 2);\n    self.$attr_reader(\"numerator\", \"denominator\");\n    \n    Opal.defn(self, '$initialize', TMP_Rational_initialize_3 = function $$initialize(num, den) {\n      var self = this;\n\n      \n      self.num = num;\n      return (self.den = den);\n    }, TMP_Rational_initialize_3.$$arity = 2);\n    \n    Opal.defn(self, '$numerator', TMP_Rational_numerator_4 = function $$numerator() {\n      var self = this;\n\n      return self.num\n    }, TMP_Rational_numerator_4.$$arity = 0);\n    \n    Opal.defn(self, '$denominator', TMP_Rational_denominator_5 = function $$denominator() {\n      var self = this;\n\n      return self.den\n    }, TMP_Rational_denominator_5.$$arity = 0);\n    \n    Opal.defn(self, '$coerce', TMP_Rational_coerce_6 = function $$coerce(other) {\n      var self = this, $case = nil;\n\n      return (function() {$case = other;\n      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {return [other, self]}\n      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return [other.$to_r(), self]}\n      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return [other, self.$to_f()]}\n      else { return nil }})()\n    }, TMP_Rational_coerce_6.$$arity = 1);\n    \n    Opal.defn(self, '$==', TMP_Rational_$eq$eq_7 = function(other) {\n      var $a, self = this, $case = nil;\n\n      return (function() {$case = other;\n      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {return (($a = self.num['$=='](other.$numerator())) ? self.den['$=='](other.$denominator()) : self.num['$=='](other.$numerator()))}\n      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return (($a = self.num['$=='](other)) ? self.den['$=='](1) : self.num['$=='](other))}\n      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return self.$to_f()['$=='](other)}\n      else {return other['$=='](self)}})()\n    }, TMP_Rational_$eq$eq_7.$$arity = 1);\n    \n    Opal.defn(self, '$<=>', TMP_Rational_$lt$eq$gt_8 = function(other) {\n      var self = this, $case = nil;\n\n      return (function() {$case = other;\n      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)}\n      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)}\n      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return self.$to_f()['$<=>'](other)}\n      else {return self.$__coerced__(\"<=>\", other)}})()\n    }, TMP_Rational_$lt$eq$gt_8.$$arity = 1);\n    \n    Opal.defn(self, '$+', TMP_Rational_$_9 = function(other) {\n      var self = this, $case = nil, num = nil, den = nil;\n\n      return (function() {$case = other;\n      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {\n      num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));\n      den = $rb_times(self.den, other.$denominator());\n      return self.$Rational(num, den);}\n      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)}\n      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return $rb_plus(self.$to_f(), other)}\n      else {return self.$__coerced__(\"+\", other)}})()\n    }, TMP_Rational_$_9.$$arity = 1);\n    \n    Opal.defn(self, '$-', TMP_Rational_$_10 = function(other) {\n      var self = this, $case = nil, num = nil, den = nil;\n\n      return (function() {$case = other;\n      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {\n      num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));\n      den = $rb_times(self.den, other.$denominator());\n      return self.$Rational(num, den);}\n      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)}\n      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return $rb_minus(self.$to_f(), other)}\n      else {return self.$__coerced__(\"-\", other)}})()\n    }, TMP_Rational_$_10.$$arity = 1);\n    \n    Opal.defn(self, '$*', TMP_Rational_$_11 = function(other) {\n      var self = this, $case = nil, num = nil, den = nil;\n\n      return (function() {$case = other;\n      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {\n      num = $rb_times(self.num, other.$numerator());\n      den = $rb_times(self.den, other.$denominator());\n      return self.$Rational(num, den);}\n      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_times(self.num, other), self.den)}\n      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return $rb_times(self.$to_f(), other)}\n      else {return self.$__coerced__(\"*\", other)}})()\n    }, TMP_Rational_$_11.$$arity = 1);\n    \n    Opal.defn(self, '$/', TMP_Rational_$_12 = function(other) {\n      var self = this, $case = nil, num = nil, den = nil;\n\n      return (function() {$case = other;\n      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {\n      num = $rb_times(self.num, other.$denominator());\n      den = $rb_times(self.den, other.$numerator());\n      return self.$Rational(num, den);}\n      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {if (other['$=='](0)) {\n        return $rb_divide(self.$to_f(), 0.0)\n        } else {\n        return self.$Rational(self.num, $rb_times(self.den, other))\n      }}\n      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return $rb_divide(self.$to_f(), other)}\n      else {return self.$__coerced__(\"/\", other)}})()\n    }, TMP_Rational_$_12.$$arity = 1);\n    \n    Opal.defn(self, '$**', TMP_Rational_$$_13 = function(other) {\n      var $a, self = this, $case = nil;\n\n      return (function() {$case = other;\n      if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {if ($truthy((($a = self['$=='](0)) ? $rb_lt(other, 0) : self['$=='](0)))) {\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY')\n      } else if ($truthy($rb_gt(other, 0))) {\n        return self.$Rational(self.num['$**'](other), self.den['$**'](other))\n      } else if ($truthy($rb_lt(other, 0))) {\n        return self.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))\n        } else {\n        return self.$Rational(1, 1)\n      }}\n      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return self.$to_f()['$**'](other)}\n      else if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {if (other['$=='](0)) {\n        return self.$Rational(1, 1)\n      } else if (other.$denominator()['$=='](1)) {\n        if ($truthy($rb_lt(other, 0))) {\n          return self.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))\n          } else {\n          return self.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))\n        }\n      } else if ($truthy((($a = self['$=='](0)) ? $rb_lt(other, 0) : self['$=='](0)))) {\n        return self.$raise(Opal.const_get_relative($nesting, 'ZeroDivisionError'), \"divided by 0\")\n        } else {\n        return self.$to_f()['$**'](other)\n      }}\n      else {return self.$__coerced__(\"**\", other)}})()\n    }, TMP_Rational_$$_13.$$arity = 1);\n    \n    Opal.defn(self, '$abs', TMP_Rational_abs_14 = function $$abs() {\n      var self = this;\n\n      return self.$Rational(self.num.$abs(), self.den.$abs())\n    }, TMP_Rational_abs_14.$$arity = 0);\n    \n    Opal.defn(self, '$ceil', TMP_Rational_ceil_15 = function $$ceil(precision) {\n      var self = this;\n\n      if (precision == null) {\n        precision = 0;\n      }\n      if (precision['$=='](0)) {\n        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()\n        } else {\n        return self.$with_precision(\"ceil\", precision)\n      }\n    }, TMP_Rational_ceil_15.$$arity = -1);\n    Opal.alias(self, \"divide\", \"/\");\n    \n    Opal.defn(self, '$floor', TMP_Rational_floor_16 = function $$floor(precision) {\n      var self = this;\n\n      if (precision == null) {\n        precision = 0;\n      }\n      if (precision['$=='](0)) {\n        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()\n        } else {\n        return self.$with_precision(\"floor\", precision)\n      }\n    }, TMP_Rational_floor_16.$$arity = -1);\n    \n    Opal.defn(self, '$hash', TMP_Rational_hash_17 = function $$hash() {\n      var self = this;\n\n      return \"\" + \"Rational:\" + (self.num) + \":\" + (self.den)\n    }, TMP_Rational_hash_17.$$arity = 0);\n    \n    Opal.defn(self, '$inspect', TMP_Rational_inspect_18 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"(\" + (self.$to_s()) + \")\"\n    }, TMP_Rational_inspect_18.$$arity = 0);\n    Opal.alias(self, \"quo\", \"/\");\n    \n    Opal.defn(self, '$rationalize', TMP_Rational_rationalize_19 = function $$rationalize(eps) {\n      var self = this;\n\n      \n      if (arguments.length > 1) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" for 0..1)\");\n      }\n\n      if (eps == null) {\n        return self;\n      }\n\n      var e = eps.$abs(),\n          a = $rb_minus(self, e),\n          b = $rb_plus(self, e);\n\n      var p0 = 0,\n          p1 = 1,\n          q0 = 1,\n          q1 = 0,\n          p2, q2;\n\n      var c, k, t;\n\n      while (true) {\n        c = (a).$ceil();\n\n        if ($rb_le(c, b)) {\n          break;\n        }\n\n        k  = c - 1;\n        p2 = k * p1 + p0;\n        q2 = k * q1 + q0;\n        t  = $rb_divide(1, $rb_minus(b, k));\n        b  = $rb_divide(1, $rb_minus(a, k));\n        a  = t;\n\n        p0 = p1;\n        q0 = q1;\n        p1 = p2;\n        q1 = q2;\n      }\n\n      return self.$Rational(c * p1 + p0, c * q1 + q0);\n    \n    }, TMP_Rational_rationalize_19.$$arity = -1);\n    \n    Opal.defn(self, '$round', TMP_Rational_round_20 = function $$round(precision) {\n      var self = this, num = nil, den = nil, approx = nil;\n\n      if (precision == null) {\n        precision = 0;\n      }\n      \n      if (precision['$=='](0)) {\n        } else {\n        return self.$with_precision(\"round\", precision)\n      };\n      if (self.num['$=='](0)) {\n        return 0};\n      if (self.den['$=='](1)) {\n        return self.num};\n      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);\n      den = $rb_times(self.den, 2);\n      approx = $rb_divide(num, den).$truncate();\n      if ($truthy($rb_lt(self.num, 0))) {\n        return approx['$-@']()\n        } else {\n        return approx\n      };\n    }, TMP_Rational_round_20.$$arity = -1);\n    \n    Opal.defn(self, '$to_f', TMP_Rational_to_f_21 = function $$to_f() {\n      var self = this;\n\n      return $rb_divide(self.num, self.den)\n    }, TMP_Rational_to_f_21.$$arity = 0);\n    \n    Opal.defn(self, '$to_i', TMP_Rational_to_i_22 = function $$to_i() {\n      var self = this;\n\n      return self.$truncate()\n    }, TMP_Rational_to_i_22.$$arity = 0);\n    \n    Opal.defn(self, '$to_r', TMP_Rational_to_r_23 = function $$to_r() {\n      var self = this;\n\n      return self\n    }, TMP_Rational_to_r_23.$$arity = 0);\n    \n    Opal.defn(self, '$to_s', TMP_Rational_to_s_24 = function $$to_s() {\n      var self = this;\n\n      return \"\" + (self.num) + \"/\" + (self.den)\n    }, TMP_Rational_to_s_24.$$arity = 0);\n    \n    Opal.defn(self, '$truncate', TMP_Rational_truncate_25 = function $$truncate(precision) {\n      var self = this;\n\n      if (precision == null) {\n        precision = 0;\n      }\n      if (precision['$=='](0)) {\n        if ($truthy($rb_lt(self.num, 0))) {\n          return self.$ceil()\n          } else {\n          return self.$floor()\n        }\n        } else {\n        return self.$with_precision(\"truncate\", precision)\n      }\n    }, TMP_Rational_truncate_25.$$arity = -1);\n    return (Opal.defn(self, '$with_precision', TMP_Rational_with_precision_26 = function $$with_precision(method, precision) {\n      var self = this, p = nil, s = nil;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](precision))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"not an Integer\")\n      };\n      p = (10)['$**'](precision);\n      s = $rb_times(self, p);\n      if ($truthy($rb_lt(precision, 1))) {\n        return $rb_divide(s.$send(method), p).$to_i()\n        } else {\n        return self.$Rational(s.$send(method), p)\n      };\n    }, TMP_Rational_with_precision_26.$$arity = 2), nil) && 'with_precision';\n  })($nesting[0], Opal.const_get_relative($nesting, 'Numeric'), $nesting);\n  return (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_Rational_27;\n\n    \n    Opal.defn(self, '$Rational', TMP_Kernel_Rational_27 = function $$Rational(numerator, denominator) {\n      var self = this;\n\n      if (denominator == null) {\n        denominator = 1;\n      }\n      return Opal.const_get_relative($nesting, 'Rational').$convert(numerator, denominator)\n    }, TMP_Kernel_Rational_27.$$arity = -2)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/time\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range;\n\n  Opal.add_stubs(['$require', '$include', '$===', '$raise', '$coerce_to!', '$respond_to?', '$to_str', '$to_i', '$new', '$<=>', '$to_f', '$nil?', '$>', '$<', '$strftime', '$year', '$month', '$day', '$+', '$round', '$/', '$-', '$copy_instance_variables', '$initialize_dup', '$is_a?', '$zero?', '$wday', '$utc?', '$mon', '$yday', '$hour', '$min', '$sec', '$rjust', '$ljust', '$zone', '$to_s', '$[]', '$cweek_cyear', '$isdst', '$<=', '$!=', '$==', '$ceil']);\n  \n  self.$require(\"corelib/comparable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Time(){};\n    var self = $Time = $klass($base, $super, 'Time', $Time);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Time_at_1, TMP_Time_new_2, TMP_Time_local_3, TMP_Time_gm_4, TMP_Time_now_5, TMP_Time_$_6, TMP_Time_$_7, TMP_Time_$lt$eq$gt_8, TMP_Time_$eq$eq_9, TMP_Time_asctime_10, TMP_Time_day_11, TMP_Time_yday_12, TMP_Time_isdst_13, TMP_Time_dup_14, TMP_Time_eql$q_15, TMP_Time_friday$q_16, TMP_Time_hash_17, TMP_Time_hour_18, TMP_Time_inspect_19, TMP_Time_min_20, TMP_Time_mon_21, TMP_Time_monday$q_22, TMP_Time_saturday$q_23, TMP_Time_sec_24, TMP_Time_succ_25, TMP_Time_usec_26, TMP_Time_zone_27, TMP_Time_getgm_28, TMP_Time_gmtime_29, TMP_Time_gmt$q_30, TMP_Time_gmt_offset_31, TMP_Time_strftime_32, TMP_Time_sunday$q_33, TMP_Time_thursday$q_34, TMP_Time_to_a_35, TMP_Time_to_f_36, TMP_Time_to_i_37, TMP_Time_tuesday$q_38, TMP_Time_wday_39, TMP_Time_wednesday$q_40, TMP_Time_year_41, TMP_Time_cweek_cyear_42;\n\n    \n    self.$include(Opal.const_get_relative($nesting, 'Comparable'));\n    \n    var days_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n        short_days   = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n        short_months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n        long_months  = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n  ;\n    Opal.defs(self, '$at', TMP_Time_at_1 = function $$at(seconds, frac) {\n      var self = this;\n\n      \n      var result;\n\n      if (Opal.const_get_relative($nesting, 'Time')['$==='](seconds)) {\n        if (frac !== undefined) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"can't convert Time into an exact number\")\n        }\n        result = new Date(seconds.getTime());\n        result.is_utc = seconds.is_utc;\n        return result;\n      }\n\n      if (!seconds.$$is_number) {\n        seconds = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](seconds, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (frac === undefined) {\n        return new Date(seconds * 1000);\n      }\n\n      if (!frac.$$is_number) {\n        frac = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](frac, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      }\n\n      return new Date(seconds * 1000 + (frac / 1000));\n    \n    }, TMP_Time_at_1.$$arity = -2);\n    \n    function time_params(year, month, day, hour, min, sec) {\n      if (year.$$is_string) {\n        year = parseInt(year, 10);\n      } else {\n        year = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](year, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (month === nil) {\n        month = 1;\n      } else if (!month.$$is_number) {\n        if ((month)['$respond_to?'](\"to_str\")) {\n          month = (month).$to_str();\n          switch (month.toLowerCase()) {\n          case 'jan': month =  1; break;\n          case 'feb': month =  2; break;\n          case 'mar': month =  3; break;\n          case 'apr': month =  4; break;\n          case 'may': month =  5; break;\n          case 'jun': month =  6; break;\n          case 'jul': month =  7; break;\n          case 'aug': month =  8; break;\n          case 'sep': month =  9; break;\n          case 'oct': month = 10; break;\n          case 'nov': month = 11; break;\n          case 'dec': month = 12; break;\n          default: month = (month).$to_i();\n          }\n        } else {\n          month = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](month, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        }\n      }\n\n      if (month < 1 || month > 12) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"month out of range: \" + (month))\n      }\n      month = month - 1;\n\n      if (day === nil) {\n        day = 1;\n      } else if (day.$$is_string) {\n        day = parseInt(day, 10);\n      } else {\n        day = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](day, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (day < 1 || day > 31) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"day out of range: \" + (day))\n      }\n\n      if (hour === nil) {\n        hour = 0;\n      } else if (hour.$$is_string) {\n        hour = parseInt(hour, 10);\n      } else {\n        hour = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](hour, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (hour < 0 || hour > 24) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"hour out of range: \" + (hour))\n      }\n\n      if (min === nil) {\n        min = 0;\n      } else if (min.$$is_string) {\n        min = parseInt(min, 10);\n      } else {\n        min = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](min, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (min < 0 || min > 59) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"min out of range: \" + (min))\n      }\n\n      if (sec === nil) {\n        sec = 0;\n      } else if (!sec.$$is_number) {\n        if (sec.$$is_string) {\n          sec = parseInt(sec, 10);\n        } else {\n          sec = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](sec, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n        }\n      }\n\n      if (sec < 0 || sec > 60) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"sec out of range: \" + (sec))\n      }\n\n      return [year, month, day, hour, min, sec];\n    }\n  ;\n    Opal.defs(self, '$new', TMP_Time_new_2 = function(year, month, day, hour, min, sec, utc_offset) {\n      var self = this;\n\n      if (month == null) {\n        month = nil;\n      }\n      if (day == null) {\n        day = nil;\n      }\n      if (hour == null) {\n        hour = nil;\n      }\n      if (min == null) {\n        min = nil;\n      }\n      if (sec == null) {\n        sec = nil;\n      }\n      if (utc_offset == null) {\n        utc_offset = nil;\n      }\n      \n      var args, result;\n\n      if (year === undefined) {\n        return new Date();\n      }\n\n      if (utc_offset !== nil) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"Opal does not support explicitly specifying UTC offset for Time\")\n      }\n\n      args  = time_params(year, month, day, hour, min, sec);\n      year  = args[0];\n      month = args[1];\n      day   = args[2];\n      hour  = args[3];\n      min   = args[4];\n      sec   = args[5];\n\n      result = new Date(year, month, day, hour, min, 0, sec * 1000);\n      if (year < 100) {\n        result.setFullYear(year);\n      }\n      return result;\n    \n    }, TMP_Time_new_2.$$arity = -1);\n    Opal.defs(self, '$local', TMP_Time_local_3 = function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {\n      var self = this;\n\n      if (month == null) {\n        month = nil;\n      }\n      if (day == null) {\n        day = nil;\n      }\n      if (hour == null) {\n        hour = nil;\n      }\n      if (min == null) {\n        min = nil;\n      }\n      if (sec == null) {\n        sec = nil;\n      }\n      if (millisecond == null) {\n        millisecond = nil;\n      }\n      if (_dummy1 == null) {\n        _dummy1 = nil;\n      }\n      if (_dummy2 == null) {\n        _dummy2 = nil;\n      }\n      if (_dummy3 == null) {\n        _dummy3 = nil;\n      }\n      \n      var args, result;\n\n      if (arguments.length === 10) {\n        args  = $slice.call(arguments);\n        year  = args[5];\n        month = args[4];\n        day   = args[3];\n        hour  = args[2];\n        min   = args[1];\n        sec   = args[0];\n      }\n\n      args  = time_params(year, month, day, hour, min, sec);\n      year  = args[0];\n      month = args[1];\n      day   = args[2];\n      hour  = args[3];\n      min   = args[4];\n      sec   = args[5];\n\n      result = new Date(year, month, day, hour, min, 0, sec * 1000);\n      if (year < 100) {\n        result.setFullYear(year);\n      }\n      return result;\n    \n    }, TMP_Time_local_3.$$arity = -2);\n    Opal.defs(self, '$gm', TMP_Time_gm_4 = function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {\n      var self = this;\n\n      if (month == null) {\n        month = nil;\n      }\n      if (day == null) {\n        day = nil;\n      }\n      if (hour == null) {\n        hour = nil;\n      }\n      if (min == null) {\n        min = nil;\n      }\n      if (sec == null) {\n        sec = nil;\n      }\n      if (millisecond == null) {\n        millisecond = nil;\n      }\n      if (_dummy1 == null) {\n        _dummy1 = nil;\n      }\n      if (_dummy2 == null) {\n        _dummy2 = nil;\n      }\n      if (_dummy3 == null) {\n        _dummy3 = nil;\n      }\n      \n      var args, result;\n\n      if (arguments.length === 10) {\n        args  = $slice.call(arguments);\n        year  = args[5];\n        month = args[4];\n        day   = args[3];\n        hour  = args[2];\n        min   = args[1];\n        sec   = args[0];\n      }\n\n      args  = time_params(year, month, day, hour, min, sec);\n      year  = args[0];\n      month = args[1];\n      day   = args[2];\n      hour  = args[3];\n      min   = args[4];\n      sec   = args[5];\n\n      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));\n      if (year < 100) {\n        result.setUTCFullYear(year);\n      }\n      result.is_utc = true;\n      return result;\n    \n    }, TMP_Time_gm_4.$$arity = -2);\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      Opal.alias(self, \"mktime\", \"local\");\n      return Opal.alias(self, \"utc\", \"gm\");\n    })(Opal.get_singleton_class(self), $nesting);\n    Opal.defs(self, '$now', TMP_Time_now_5 = function $$now() {\n      var self = this;\n\n      return self.$new()\n    }, TMP_Time_now_5.$$arity = 0);\n    \n    Opal.defn(self, '$+', TMP_Time_$_6 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Time')['$==='](other))) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"time + time?\")};\n      \n      if (!other.$$is_number) {\n        other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      }\n      var result = new Date(self.getTime() + (other * 1000));\n      result.is_utc = self.is_utc;\n      return result;\n    ;\n    }, TMP_Time_$_6.$$arity = 1);\n    \n    Opal.defn(self, '$-', TMP_Time_$_7 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Time')['$==='](other))) {\n        return (self.getTime() - other.getTime()) / 1000};\n      \n      if (!other.$$is_number) {\n        other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      }\n      var result = new Date(self.getTime() - (other * 1000));\n      result.is_utc = self.is_utc;\n      return result;\n    ;\n    }, TMP_Time_$_7.$$arity = 1);\n    \n    Opal.defn(self, '$<=>', TMP_Time_$lt$eq$gt_8 = function(other) {\n      var self = this, r = nil;\n\n      if ($truthy(Opal.const_get_relative($nesting, 'Time')['$==='](other))) {\n        return self.$to_f()['$<=>'](other.$to_f())\n        } else {\n        \n        r = other['$<=>'](self);\n        if ($truthy(r['$nil?']())) {\n          return nil\n        } else if ($truthy($rb_gt(r, 0))) {\n          return -1\n        } else if ($truthy($rb_lt(r, 0))) {\n          return 1\n          } else {\n          return 0\n        };\n      }\n    }, TMP_Time_$lt$eq$gt_8.$$arity = 1);\n    \n    Opal.defn(self, '$==', TMP_Time_$eq$eq_9 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = Opal.const_get_relative($nesting, 'Time')['$==='](other)) ? self.$to_f() === other.$to_f() : $a)\n    }, TMP_Time_$eq$eq_9.$$arity = 1);\n    \n    Opal.defn(self, '$asctime', TMP_Time_asctime_10 = function $$asctime() {\n      var self = this;\n\n      return self.$strftime(\"%a %b %e %H:%M:%S %Y\")\n    }, TMP_Time_asctime_10.$$arity = 0);\n    Opal.alias(self, \"ctime\", \"asctime\");\n    \n    Opal.defn(self, '$day', TMP_Time_day_11 = function $$day() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCDate() : self.getDate()\n    }, TMP_Time_day_11.$$arity = 0);\n    \n    Opal.defn(self, '$yday', TMP_Time_yday_12 = function $$yday() {\n      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;\n\n      \n      start_of_year = Opal.const_get_relative($nesting, 'Time').$new(self.$year()).$to_i();\n      start_of_day = Opal.const_get_relative($nesting, 'Time').$new(self.$year(), self.$month(), self.$day()).$to_i();\n      one_day = 86400;\n      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);\n    }, TMP_Time_yday_12.$$arity = 0);\n    \n    Opal.defn(self, '$isdst', TMP_Time_isdst_13 = function $$isdst() {\n      var self = this;\n\n      \n      var jan = new Date(self.getFullYear(), 0, 1),\n          jul = new Date(self.getFullYear(), 6, 1);\n      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n    \n    }, TMP_Time_isdst_13.$$arity = 0);\n    Opal.alias(self, \"dst?\", \"isdst\");\n    \n    Opal.defn(self, '$dup', TMP_Time_dup_14 = function $$dup() {\n      var self = this, copy = nil;\n\n      \n      copy = new Date(self.getTime());\n      copy.$copy_instance_variables(self);\n      copy.$initialize_dup(self);\n      return copy;\n    }, TMP_Time_dup_14.$$arity = 0);\n    \n    Opal.defn(self, '$eql?', TMP_Time_eql$q_15 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = other['$is_a?'](Opal.const_get_relative($nesting, 'Time'))) ? self['$<=>'](other)['$zero?']() : $a)\n    }, TMP_Time_eql$q_15.$$arity = 1);\n    \n    Opal.defn(self, '$friday?', TMP_Time_friday$q_16 = function() {\n      var self = this;\n\n      return self.$wday() == 5\n    }, TMP_Time_friday$q_16.$$arity = 0);\n    \n    Opal.defn(self, '$hash', TMP_Time_hash_17 = function $$hash() {\n      var self = this;\n\n      return 'Time:' + self.getTime()\n    }, TMP_Time_hash_17.$$arity = 0);\n    \n    Opal.defn(self, '$hour', TMP_Time_hour_18 = function $$hour() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCHours() : self.getHours()\n    }, TMP_Time_hour_18.$$arity = 0);\n    \n    Opal.defn(self, '$inspect', TMP_Time_inspect_19 = function $$inspect() {\n      var self = this;\n\n      if ($truthy(self['$utc?']())) {\n        return self.$strftime(\"%Y-%m-%d %H:%M:%S UTC\")\n        } else {\n        return self.$strftime(\"%Y-%m-%d %H:%M:%S %z\")\n      }\n    }, TMP_Time_inspect_19.$$arity = 0);\n    Opal.alias(self, \"mday\", \"day\");\n    \n    Opal.defn(self, '$min', TMP_Time_min_20 = function $$min() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCMinutes() : self.getMinutes()\n    }, TMP_Time_min_20.$$arity = 0);\n    \n    Opal.defn(self, '$mon', TMP_Time_mon_21 = function $$mon() {\n      var self = this;\n\n      return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1\n    }, TMP_Time_mon_21.$$arity = 0);\n    \n    Opal.defn(self, '$monday?', TMP_Time_monday$q_22 = function() {\n      var self = this;\n\n      return self.$wday() == 1\n    }, TMP_Time_monday$q_22.$$arity = 0);\n    Opal.alias(self, \"month\", \"mon\");\n    \n    Opal.defn(self, '$saturday?', TMP_Time_saturday$q_23 = function() {\n      var self = this;\n\n      return self.$wday() == 6\n    }, TMP_Time_saturday$q_23.$$arity = 0);\n    \n    Opal.defn(self, '$sec', TMP_Time_sec_24 = function $$sec() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCSeconds() : self.getSeconds()\n    }, TMP_Time_sec_24.$$arity = 0);\n    \n    Opal.defn(self, '$succ', TMP_Time_succ_25 = function $$succ() {\n      var self = this;\n\n      \n      var result = new Date(self.getTime() + 1000);\n      result.is_utc = self.is_utc;\n      return result;\n    \n    }, TMP_Time_succ_25.$$arity = 0);\n    \n    Opal.defn(self, '$usec', TMP_Time_usec_26 = function $$usec() {\n      var self = this;\n\n      return self.getMilliseconds() * 1000\n    }, TMP_Time_usec_26.$$arity = 0);\n    \n    Opal.defn(self, '$zone', TMP_Time_zone_27 = function $$zone() {\n      var self = this;\n\n      \n      var string = self.toString(),\n          result;\n\n      if (string.indexOf('(') == -1) {\n        result = string.match(/[A-Z]{3,4}/)[0];\n      }\n      else {\n        result = string.match(/\\((.+)\\)(?:\\s|$)/)[1]\n      }\n\n      if (result == \"GMT\" && /(GMT\\W*\\d{4})/.test(string)) {\n        return RegExp.$1;\n      }\n      else {\n        return result;\n      }\n    \n    }, TMP_Time_zone_27.$$arity = 0);\n    \n    Opal.defn(self, '$getgm', TMP_Time_getgm_28 = function $$getgm() {\n      var self = this;\n\n      \n      var result = new Date(self.getTime());\n      result.is_utc = true;\n      return result;\n    \n    }, TMP_Time_getgm_28.$$arity = 0);\n    Opal.alias(self, \"getutc\", \"getgm\");\n    \n    Opal.defn(self, '$gmtime', TMP_Time_gmtime_29 = function $$gmtime() {\n      var self = this;\n\n      \n      self.is_utc = true;\n      return self;\n    \n    }, TMP_Time_gmtime_29.$$arity = 0);\n    Opal.alias(self, \"utc\", \"gmtime\");\n    \n    Opal.defn(self, '$gmt?', TMP_Time_gmt$q_30 = function() {\n      var self = this;\n\n      return self.is_utc === true\n    }, TMP_Time_gmt$q_30.$$arity = 0);\n    \n    Opal.defn(self, '$gmt_offset', TMP_Time_gmt_offset_31 = function $$gmt_offset() {\n      var self = this;\n\n      return -self.getTimezoneOffset() * 60\n    }, TMP_Time_gmt_offset_31.$$arity = 0);\n    \n    Opal.defn(self, '$strftime', TMP_Time_strftime_32 = function $$strftime(format) {\n      var self = this;\n\n      \n      return format.replace(/%([\\-_#^0]*:{0,2})(\\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {\n        var result = \"\",\n            zero   = flags.indexOf('0') !== -1,\n            pad    = flags.indexOf('-') === -1,\n            blank  = flags.indexOf('_') !== -1,\n            upcase = flags.indexOf('^') !== -1,\n            invert = flags.indexOf('#') !== -1,\n            colons = (flags.match(':') || []).length;\n\n        width = parseInt(width, 10);\n\n        if (zero && blank) {\n          if (flags.indexOf('0') < flags.indexOf('_')) {\n            zero = false;\n          }\n          else {\n            blank = false;\n          }\n        }\n\n        switch (conv) {\n          case 'Y':\n            result += self.$year();\n            break;\n\n          case 'C':\n            zero    = !blank;\n            result += Math.round(self.$year() / 100);\n            break;\n\n          case 'y':\n            zero    = !blank;\n            result += (self.$year() % 100);\n            break;\n\n          case 'm':\n            zero    = !blank;\n            result += self.$mon();\n            break;\n\n          case 'B':\n            result += long_months[self.$mon() - 1];\n            break;\n\n          case 'b':\n          case 'h':\n            blank   = !zero;\n            result += short_months[self.$mon() - 1];\n            break;\n\n          case 'd':\n            zero    = !blank\n            result += self.$day();\n            break;\n\n          case 'e':\n            blank   = !zero\n            result += self.$day();\n            break;\n\n          case 'j':\n            result += self.$yday();\n            break;\n\n          case 'H':\n            zero    = !blank;\n            result += self.$hour();\n            break;\n\n          case 'k':\n            blank   = !zero;\n            result += self.$hour();\n            break;\n\n          case 'I':\n            zero    = !blank;\n            result += (self.$hour() % 12 || 12);\n            break;\n\n          case 'l':\n            blank   = !zero;\n            result += (self.$hour() % 12 || 12);\n            break;\n\n          case 'P':\n            result += (self.$hour() >= 12 ? \"pm\" : \"am\");\n            break;\n\n          case 'p':\n            result += (self.$hour() >= 12 ? \"PM\" : \"AM\");\n            break;\n\n          case 'M':\n            zero    = !blank;\n            result += self.$min();\n            break;\n\n          case 'S':\n            zero    = !blank;\n            result += self.$sec()\n            break;\n\n          case 'L':\n            zero    = !blank;\n            width   = isNaN(width) ? 3 : width;\n            result += self.getMilliseconds();\n            break;\n\n          case 'N':\n            width   = isNaN(width) ? 9 : width;\n            result += (self.getMilliseconds().toString()).$rjust(3, \"0\");\n            result  = (result).$ljust(width, \"0\");\n            break;\n\n          case 'z':\n            var offset  = self.getTimezoneOffset(),\n                hours   = Math.floor(Math.abs(offset) / 60),\n                minutes = Math.abs(offset) % 60;\n\n            result += offset < 0 ? \"+\" : \"-\";\n            result += hours < 10 ? \"0\" : \"\";\n            result += hours;\n\n            if (colons > 0) {\n              result += \":\";\n            }\n\n            result += minutes < 10 ? \"0\" : \"\";\n            result += minutes;\n\n            if (colons > 1) {\n              result += \":00\";\n            }\n\n            break;\n\n          case 'Z':\n            result += self.$zone();\n            break;\n\n          case 'A':\n            result += days_of_week[self.$wday()];\n            break;\n\n          case 'a':\n            result += short_days[self.$wday()];\n            break;\n\n          case 'u':\n            result += (self.$wday() + 1);\n            break;\n\n          case 'w':\n            result += self.$wday();\n            break;\n\n          case 'V':\n            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, \"0\");\n            break;\n\n          case 'G':\n            result += self.$cweek_cyear()['$[]'](1);\n            break;\n\n          case 'g':\n            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));\n            break;\n\n          case 's':\n            result += self.$to_i();\n            break;\n\n          case 'n':\n            result += \"\\n\";\n            break;\n\n          case 't':\n            result += \"\\t\";\n            break;\n\n          case '%':\n            result += \"%\";\n            break;\n\n          case 'c':\n            result += self.$strftime(\"%a %b %e %T %Y\");\n            break;\n\n          case 'D':\n          case 'x':\n            result += self.$strftime(\"%m/%d/%y\");\n            break;\n\n          case 'F':\n            result += self.$strftime(\"%Y-%m-%d\");\n            break;\n\n          case 'v':\n            result += self.$strftime(\"%e-%^b-%4Y\");\n            break;\n\n          case 'r':\n            result += self.$strftime(\"%I:%M:%S %p\");\n            break;\n\n          case 'R':\n            result += self.$strftime(\"%H:%M\");\n            break;\n\n          case 'T':\n          case 'X':\n            result += self.$strftime(\"%H:%M:%S\");\n            break;\n\n          default:\n            return full;\n        }\n\n        if (upcase) {\n          result = result.toUpperCase();\n        }\n\n        if (invert) {\n          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).\n                          replace(/[a-z]/, function(c) { c.toUpperCase() });\n        }\n\n        if (pad && (zero || blank)) {\n          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? \" \" : \"0\");\n        }\n\n        return result;\n      });\n    \n    }, TMP_Time_strftime_32.$$arity = 1);\n    \n    Opal.defn(self, '$sunday?', TMP_Time_sunday$q_33 = function() {\n      var self = this;\n\n      return self.$wday() == 0\n    }, TMP_Time_sunday$q_33.$$arity = 0);\n    \n    Opal.defn(self, '$thursday?', TMP_Time_thursday$q_34 = function() {\n      var self = this;\n\n      return self.$wday() == 4\n    }, TMP_Time_thursday$q_34.$$arity = 0);\n    \n    Opal.defn(self, '$to_a', TMP_Time_to_a_35 = function $$to_a() {\n      var self = this;\n\n      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]\n    }, TMP_Time_to_a_35.$$arity = 0);\n    \n    Opal.defn(self, '$to_f', TMP_Time_to_f_36 = function $$to_f() {\n      var self = this;\n\n      return self.getTime() / 1000\n    }, TMP_Time_to_f_36.$$arity = 0);\n    \n    Opal.defn(self, '$to_i', TMP_Time_to_i_37 = function $$to_i() {\n      var self = this;\n\n      return parseInt(self.getTime() / 1000, 10)\n    }, TMP_Time_to_i_37.$$arity = 0);\n    Opal.alias(self, \"to_s\", \"inspect\");\n    \n    Opal.defn(self, '$tuesday?', TMP_Time_tuesday$q_38 = function() {\n      var self = this;\n\n      return self.$wday() == 2\n    }, TMP_Time_tuesday$q_38.$$arity = 0);\n    Opal.alias(self, \"tv_sec\", \"to_i\");\n    Opal.alias(self, \"tv_usec\", \"usec\");\n    Opal.alias(self, \"utc?\", \"gmt?\");\n    Opal.alias(self, \"gmtoff\", \"gmt_offset\");\n    Opal.alias(self, \"utc_offset\", \"gmt_offset\");\n    \n    Opal.defn(self, '$wday', TMP_Time_wday_39 = function $$wday() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCDay() : self.getDay()\n    }, TMP_Time_wday_39.$$arity = 0);\n    \n    Opal.defn(self, '$wednesday?', TMP_Time_wednesday$q_40 = function() {\n      var self = this;\n\n      return self.$wday() == 3\n    }, TMP_Time_wednesday$q_40.$$arity = 0);\n    \n    Opal.defn(self, '$year', TMP_Time_year_41 = function $$year() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCFullYear() : self.getFullYear()\n    }, TMP_Time_year_41.$$arity = 0);\n    return (Opal.defn(self, '$cweek_cyear', TMP_Time_cweek_cyear_42 = function $$cweek_cyear() {\n      var $a, self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;\n\n      \n      jan01 = Opal.const_get_relative($nesting, 'Time').$new(self.$year(), 1, 1);\n      jan01_wday = jan01.$wday();\n      first_monday = 0;\n      year = self.$year();\n      if ($truthy(($truthy($a = $rb_le(jan01_wday, 4)) ? jan01_wday['$!='](0) : $a))) {\n        offset = $rb_minus(jan01_wday, 1)\n        } else {\n        \n        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);\n        if (offset['$=='](-8)) {\n          offset = -1};\n      };\n      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();\n      if ($truthy($rb_le(week, 0))) {\n        return Opal.const_get_relative($nesting, 'Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()\n      } else if (week['$=='](53)) {\n        \n        dec31 = Opal.const_get_relative($nesting, 'Time').$new(self.$year(), 12, 31);\n        dec31_wday = dec31.$wday();\n        if ($truthy(($truthy($a = $rb_le(dec31_wday, 3)) ? dec31_wday['$!='](0) : $a))) {\n          \n          week = 1;\n          year = $rb_plus(year, 1);};};\n      return [week, year];\n    }, TMP_Time_cweek_cyear_42.$$arity = 0), nil) && 'cweek_cyear';\n  })($nesting[0], Date, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/struct\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$include', '$const_name!', '$unshift', '$map', '$coerce_to!', '$new', '$each', '$define_struct_attribute', '$allocate', '$initialize', '$module_eval', '$to_proc', '$const_set', '$==', '$raise', '$<<', '$members', '$define_method', '$instance_eval', '$>', '$length', '$class', '$each_with_index', '$[]', '$[]=', '$-', '$hash', '$===', '$<', '$-@', '$size', '$>=', '$include?', '$to_sym', '$instance_of?', '$__id__', '$eql?', '$enum_for', '$name', '$+', '$join', '$each_pair', '$inspect', '$inject', '$flatten', '$to_a', '$respond_to?', '$dig']);\n  \n  self.$require(\"corelib/enumerable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Struct(){};\n    var self = $Struct = $klass($base, $super, 'Struct', $Struct);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Struct_new_1, TMP_Struct_define_struct_attribute_8, TMP_Struct_members_9, TMP_Struct_inherited_11, TMP_Struct_initialize_13, TMP_Struct_members_14, TMP_Struct_hash_15, TMP_Struct_$$_16, TMP_Struct_$$$eq_17, TMP_Struct_$eq$eq_18, TMP_Struct_eql$q_19, TMP_Struct_each_20, TMP_Struct_each_pair_23, TMP_Struct_length_26, TMP_Struct_to_a_28, TMP_Struct_inspect_30, TMP_Struct_to_h_32, TMP_Struct_values_at_34, TMP_Struct_dig_35;\n\n    \n    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n    Opal.defs(self, '$new', TMP_Struct_new_1 = function(const_name, $a_rest) {\n      var TMP_2, TMP_3, self = this, args, $iter = TMP_Struct_new_1.$$p, block = $iter || nil, klass = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Struct_new_1.$$p = null;\n      \n      if ($truthy(const_name)) {\n        \n        try {\n          const_name = Opal.const_get_relative($nesting, 'Opal')['$const_name!'](const_name)\n        } catch ($err) {\n          if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'TypeError'), Opal.const_get_relative($nesting, 'NameError')])) {\n            try {\n              \n              args.$unshift(const_name);\n              const_name = nil;\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        };};\n      $send(args, 'map', [], (TMP_2 = function(arg){var self = TMP_2.$$s || this;\nif (arg == null) arg = nil;\n      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](arg, Opal.const_get_relative($nesting, 'String'), \"to_str\")}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));\n      klass = $send(Opal.const_get_relative($nesting, 'Class'), 'new', [self], (TMP_3 = function(){var self = TMP_3.$$s || this, TMP_4;\n\n      \n        $send(args, 'each', [], (TMP_4 = function(arg){var self = TMP_4.$$s || this;\nif (arg == null) arg = nil;\n        return self.$define_struct_attribute(arg)}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));\n        return (function(self, $parent_nesting) {\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_new_5;\n\n          \n          \n          Opal.defn(self, '$new', TMP_new_5 = function($a_rest) {\n            var self = this, args, instance = nil;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n            \n            instance = self.$allocate();\n            instance.$$data = {};;\n            $send(instance, 'initialize', Opal.to_a(args));\n            return instance;\n          }, TMP_new_5.$$arity = -1);\n          return Opal.alias(self, \"[]\", \"new\");\n        })(Opal.get_singleton_class(self), $nesting);}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3));\n      if ($truthy(block)) {\n        $send(klass, 'module_eval', [], block.$to_proc())};\n      if ($truthy(const_name)) {\n        Opal.const_get_relative($nesting, 'Struct').$const_set(const_name, klass)};\n      return klass;\n    }, TMP_Struct_new_1.$$arity = -2);\n    Opal.defs(self, '$define_struct_attribute', TMP_Struct_define_struct_attribute_8 = function $$define_struct_attribute(name) {\n      var TMP_6, TMP_7, self = this;\n\n      \n      if (self['$=='](Opal.const_get_relative($nesting, 'Struct'))) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"you cannot define attributes to the Struct class\")};\n      self.$members()['$<<'](name);\n      $send(self, 'define_method', [name], (TMP_6 = function(){var self = TMP_6.$$s || this;\n\n      return self.$$data[name]}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6));\n      return $send(self, 'define_method', [\"\" + (name) + \"=\"], (TMP_7 = function(value){var self = TMP_7.$$s || this;\nif (value == null) value = nil;\n      return self.$$data[name] = value}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));\n    }, TMP_Struct_define_struct_attribute_8.$$arity = 1);\n    Opal.defs(self, '$members', TMP_Struct_members_9 = function $$members() {\n      var $a, self = this;\n      if (self.members == null) self.members = nil;\n\n      \n      if (self['$=='](Opal.const_get_relative($nesting, 'Struct'))) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"the Struct class has no members\")};\n      return (self.members = ($truthy($a = self.members) ? $a : []));\n    }, TMP_Struct_members_9.$$arity = 0);\n    Opal.defs(self, '$inherited', TMP_Struct_inherited_11 = function $$inherited(klass) {\n      var TMP_10, self = this, members = nil;\n      if (self.members == null) self.members = nil;\n\n      \n      members = self.members;\n      return $send(klass, 'instance_eval', [], (TMP_10 = function(){var self = TMP_10.$$s || this;\n\n      return (self.members = members)}, TMP_10.$$s = self, TMP_10.$$arity = 0, TMP_10));\n    }, TMP_Struct_inherited_11.$$arity = 1);\n    \n    Opal.defn(self, '$initialize', TMP_Struct_initialize_13 = function $$initialize($a_rest) {\n      var TMP_12, self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"struct size differs\")};\n      return $send(self.$class().$members(), 'each_with_index', [], (TMP_12 = function(name, index){var self = TMP_12.$$s || this, $writer = nil;\nif (name == null) name = nil;if (index == null) index = nil;\n      \n        $writer = [name, args['$[]'](index)];\n        $send(self, '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_12.$$s = self, TMP_12.$$arity = 2, TMP_12));\n    }, TMP_Struct_initialize_13.$$arity = -1);\n    \n    Opal.defn(self, '$members', TMP_Struct_members_14 = function $$members() {\n      var self = this;\n\n      return self.$class().$members()\n    }, TMP_Struct_members_14.$$arity = 0);\n    \n    Opal.defn(self, '$hash', TMP_Struct_hash_15 = function $$hash() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Hash').$new(self.$$data).$hash()\n    }, TMP_Struct_hash_15.$$arity = 0);\n    \n    Opal.defn(self, '$[]', TMP_Struct_$$_16 = function(name) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](name))) {\n        \n        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {\n          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), \"\" + \"offset \" + (name) + \" too small for struct(size:\" + (self.$class().$members().$size()) + \")\")};\n        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {\n          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), \"\" + \"offset \" + (name) + \" too large for struct(size:\" + (self.$class().$members().$size()) + \")\")};\n        name = self.$class().$members()['$[]'](name);\n      } else if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](name))) {\n        \n        if(!self.$$data.hasOwnProperty(name)) {\n          self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"no member '\" + (name) + \"' in struct\", name))\n        }\n      \n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"no implicit conversion of \" + (name.$class()) + \" into Integer\")\n      };\n      name = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](name, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      return self.$$data[name];\n    }, TMP_Struct_$$_16.$$arity = 1);\n    \n    Opal.defn(self, '$[]=', TMP_Struct_$$$eq_17 = function(name, value) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](name))) {\n        \n        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {\n          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), \"\" + \"offset \" + (name) + \" too small for struct(size:\" + (self.$class().$members().$size()) + \")\")};\n        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {\n          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), \"\" + \"offset \" + (name) + \" too large for struct(size:\" + (self.$class().$members().$size()) + \")\")};\n        name = self.$class().$members()['$[]'](name);\n      } else if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](name))) {\n        if ($truthy(self.$class().$members()['$include?'](name.$to_sym()))) {\n          } else {\n          self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"no member '\" + (name) + \"' in struct\", name))\n        }\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"no implicit conversion of \" + (name.$class()) + \" into Integer\")\n      };\n      name = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](name, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      return self.$$data[name] = value;\n    }, TMP_Struct_$$$eq_17.$$arity = 2);\n    \n    Opal.defn(self, '$==', TMP_Struct_$eq$eq_18 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$instance_of?'](self.$class()))) {\n        } else {\n        return false\n      };\n      \n      var recursed1 = {}, recursed2 = {};\n\n      function _eqeq(struct, other) {\n        var key, a, b;\n\n        recursed1[(struct).$__id__()] = true;\n        recursed2[(other).$__id__()] = true;\n\n        for (key in struct.$$data) {\n          a = struct.$$data[key];\n          b = other.$$data[key];\n\n          if (Opal.const_get_relative($nesting, 'Struct')['$==='](a)) {\n            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {\n              if (!_eqeq(a, b)) {\n                return false;\n              }\n            }\n          } else {\n            if (!(a)['$=='](b)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n\n      return _eqeq(self, other);\n    ;\n    }, TMP_Struct_$eq$eq_18.$$arity = 1);\n    \n    Opal.defn(self, '$eql?', TMP_Struct_eql$q_19 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$instance_of?'](self.$class()))) {\n        } else {\n        return false\n      };\n      \n      var recursed1 = {}, recursed2 = {};\n\n      function _eqeq(struct, other) {\n        var key, a, b;\n\n        recursed1[(struct).$__id__()] = true;\n        recursed2[(other).$__id__()] = true;\n\n        for (key in struct.$$data) {\n          a = struct.$$data[key];\n          b = other.$$data[key];\n\n          if (Opal.const_get_relative($nesting, 'Struct')['$==='](a)) {\n            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {\n              if (!_eqeq(a, b)) {\n                return false;\n              }\n            }\n          } else {\n            if (!(a)['$eql?'](b)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n\n      return _eqeq(self, other);\n    ;\n    }, TMP_Struct_eql$q_19.$$arity = 1);\n    \n    Opal.defn(self, '$each', TMP_Struct_each_20 = function $$each() {\n      var TMP_21, TMP_22, self = this, $iter = TMP_Struct_each_20.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_Struct_each_20.$$p = null;\n      \n      if (($yield !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"each\"], (TMP_21 = function(){var self = TMP_21.$$s || this;\n\n        return self.$size()}, TMP_21.$$s = self, TMP_21.$$arity = 0, TMP_21))\n      };\n      $send(self.$class().$members(), 'each', [], (TMP_22 = function(name){var self = TMP_22.$$s || this;\nif (name == null) name = nil;\n      return Opal.yield1($yield, self['$[]'](name));}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22));\n      return self;\n    }, TMP_Struct_each_20.$$arity = 0);\n    \n    Opal.defn(self, '$each_pair', TMP_Struct_each_pair_23 = function $$each_pair() {\n      var TMP_24, TMP_25, self = this, $iter = TMP_Struct_each_pair_23.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_Struct_each_pair_23.$$p = null;\n      \n      if (($yield !== nil)) {\n        } else {\n        return $send(self, 'enum_for', [\"each_pair\"], (TMP_24 = function(){var self = TMP_24.$$s || this;\n\n        return self.$size()}, TMP_24.$$s = self, TMP_24.$$arity = 0, TMP_24))\n      };\n      $send(self.$class().$members(), 'each', [], (TMP_25 = function(name){var self = TMP_25.$$s || this;\nif (name == null) name = nil;\n      return Opal.yield1($yield, [name, self['$[]'](name)]);}, TMP_25.$$s = self, TMP_25.$$arity = 1, TMP_25));\n      return self;\n    }, TMP_Struct_each_pair_23.$$arity = 0);\n    \n    Opal.defn(self, '$length', TMP_Struct_length_26 = function $$length() {\n      var self = this;\n\n      return self.$class().$members().$length()\n    }, TMP_Struct_length_26.$$arity = 0);\n    Opal.alias(self, \"size\", \"length\");\n    \n    Opal.defn(self, '$to_a', TMP_Struct_to_a_28 = function $$to_a() {\n      var TMP_27, self = this;\n\n      return $send(self.$class().$members(), 'map', [], (TMP_27 = function(name){var self = TMP_27.$$s || this;\nif (name == null) name = nil;\n      return self['$[]'](name)}, TMP_27.$$s = self, TMP_27.$$arity = 1, TMP_27))\n    }, TMP_Struct_to_a_28.$$arity = 0);\n    Opal.alias(self, \"values\", \"to_a\");\n    \n    Opal.defn(self, '$inspect', TMP_Struct_inspect_30 = function $$inspect() {\n      var $a, TMP_29, self = this, result = nil;\n\n      \n      result = \"#<struct \";\n      if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Struct')['$==='](self)) ? self.$class().$name() : $a))) {\n        result = $rb_plus(result, \"\" + (self.$class()) + \" \")};\n      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], (TMP_29 = function(name, value){var self = TMP_29.$$s || this;\nif (name == null) name = nil;if (value == null) value = nil;\n      return \"\" + (name) + \"=\" + (value.$inspect())}, TMP_29.$$s = self, TMP_29.$$arity = 2, TMP_29)).$join(\", \"));\n      result = $rb_plus(result, \">\");\n      return result;\n    }, TMP_Struct_inspect_30.$$arity = 0);\n    Opal.alias(self, \"to_s\", \"inspect\");\n    \n    Opal.defn(self, '$to_h', TMP_Struct_to_h_32 = function $$to_h() {\n      var TMP_31, self = this;\n\n      return $send(self.$class().$members(), 'inject', [$hash2([], {})], (TMP_31 = function(h, name){var self = TMP_31.$$s || this, $writer = nil;\nif (h == null) h = nil;if (name == null) name = nil;\n      \n        \n        $writer = [name, self['$[]'](name)];\n        $send(h, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return h;}, TMP_31.$$s = self, TMP_31.$$arity = 2, TMP_31))\n    }, TMP_Struct_to_h_32.$$arity = 0);\n    \n    Opal.defn(self, '$values_at', TMP_Struct_values_at_34 = function $$values_at($a_rest) {\n      var TMP_33, self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      args = $send(args, 'map', [], (TMP_33 = function(arg){var self = TMP_33.$$s || this;\nif (arg == null) arg = nil;\n      return arg.$$is_range ? arg.$to_a() : arg}, TMP_33.$$s = self, TMP_33.$$arity = 1, TMP_33)).$flatten();\n      \n      var result = [];\n      for (var i = 0, len = args.length; i < len; i++) {\n        if (!args[i].$$is_number) {\n          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"no implicit conversion of \" + ((args[i]).$class()) + \" into Integer\")\n        }\n        result.push(self['$[]'](args[i]));\n      }\n      return result;\n    ;\n    }, TMP_Struct_values_at_34.$$arity = -1);\n    return (Opal.defn(self, '$dig', TMP_Struct_dig_35 = function $$dig(key, $a_rest) {\n      var self = this, keys, item = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      keys = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        keys[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {\n        item = self.$$data[key] || nil\n        } else {\n        item = nil\n      };\n      \n      if (item === nil || keys.length === 0) {\n        return item;\n      }\n    ;\n      if ($truthy(item['$respond_to?'](\"dig\"))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + (item.$class()) + \" does not have #dig method\")\n      };\n      return $send(item, 'dig', Opal.to_a(keys));\n    }, TMP_Struct_dig_35.$$arity = -2), nil) && 'dig';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/io\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $writer = nil;\n\n  Opal.add_stubs(['$attr_accessor', '$size', '$write', '$join', '$map', '$String', '$empty?', '$concat', '$chomp', '$getbyte', '$getc', '$raise', '$new', '$write_proc=', '$-', '$extend']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $IO(){};\n    var self = $IO = $klass($base, $super, 'IO', $IO);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_IO_tty$q_1, TMP_IO_closed$q_2, TMP_IO_write_3, TMP_IO_flush_4;\n\n    def.tty = def.closed = nil;\n    \n    Opal.const_set($nesting[0], 'SEEK_SET', 0);\n    Opal.const_set($nesting[0], 'SEEK_CUR', 1);\n    Opal.const_set($nesting[0], 'SEEK_END', 2);\n    \n    Opal.defn(self, '$tty?', TMP_IO_tty$q_1 = function() {\n      var self = this;\n\n      return self.tty\n    }, TMP_IO_tty$q_1.$$arity = 0);\n    \n    Opal.defn(self, '$closed?', TMP_IO_closed$q_2 = function() {\n      var self = this;\n\n      return self.closed\n    }, TMP_IO_closed$q_2.$$arity = 0);\n    self.$attr_accessor(\"write_proc\");\n    \n    Opal.defn(self, '$write', TMP_IO_write_3 = function $$write(string) {\n      var self = this;\n\n      \n      self.write_proc(string);\n      return string.$size();\n    }, TMP_IO_write_3.$$arity = 1);\n    self.$attr_accessor(\"sync\", \"tty\");\n    \n    Opal.defn(self, '$flush', TMP_IO_flush_4 = function $$flush() {\n      var self = this;\n\n      return nil\n    }, TMP_IO_flush_4.$$arity = 0);\n    (function($base, $parent_nesting) {\n      var $Writable, self = $Writable = $module($base, 'Writable');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Writable_$lt$lt_5, TMP_Writable_print_7, TMP_Writable_puts_9;\n\n      \n      \n      Opal.defn(self, '$<<', TMP_Writable_$lt$lt_5 = function(string) {\n        var self = this;\n\n        \n        self.$write(string);\n        return self;\n      }, TMP_Writable_$lt$lt_5.$$arity = 1);\n      \n      Opal.defn(self, '$print', TMP_Writable_print_7 = function $$print($a_rest) {\n        var TMP_6, self = this, args;\n        if ($gvars[\",\"] == null) $gvars[\",\"] = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        self.$write($send(args, 'map', [], (TMP_6 = function(arg){var self = TMP_6.$$s || this;\nif (arg == null) arg = nil;\n        return self.$String(arg)}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6)).$join($gvars[\",\"]));\n        return nil;\n      }, TMP_Writable_print_7.$$arity = -1);\n      \n      Opal.defn(self, '$puts', TMP_Writable_puts_9 = function $$puts($a_rest) {\n        var TMP_8, self = this, args, newline = nil;\n        if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        newline = $gvars[\"/\"];\n        if ($truthy(args['$empty?']())) {\n          self.$write($gvars[\"/\"])\n          } else {\n          self.$write($send(args, 'map', [], (TMP_8 = function(arg){var self = TMP_8.$$s || this;\nif (arg == null) arg = nil;\n          return self.$String(arg).$chomp()}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8)).$concat([nil]).$join(newline))\n        };\n        return nil;\n      }, TMP_Writable_puts_9.$$arity = -1);\n    })($nesting[0], $nesting);\n    return (function($base, $parent_nesting) {\n      var $Readable, self = $Readable = $module($base, 'Readable');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Readable_readbyte_10, TMP_Readable_readchar_11, TMP_Readable_readline_12, TMP_Readable_readpartial_13;\n\n      \n      \n      Opal.defn(self, '$readbyte', TMP_Readable_readbyte_10 = function $$readbyte() {\n        var self = this;\n\n        return self.$getbyte()\n      }, TMP_Readable_readbyte_10.$$arity = 0);\n      \n      Opal.defn(self, '$readchar', TMP_Readable_readchar_11 = function $$readchar() {\n        var self = this;\n\n        return self.$getc()\n      }, TMP_Readable_readchar_11.$$arity = 0);\n      \n      Opal.defn(self, '$readline', TMP_Readable_readline_12 = function $$readline(sep) {\n        var self = this;\n        if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n        if (sep == null) {\n          sep = $gvars[\"/\"];\n        }\n        return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n      }, TMP_Readable_readline_12.$$arity = -1);\n      \n      Opal.defn(self, '$readpartial', TMP_Readable_readpartial_13 = function $$readpartial(integer, outbuf) {\n        var self = this;\n\n        if (outbuf == null) {\n          outbuf = nil;\n        }\n        return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n      }, TMP_Readable_readpartial_13.$$arity = -2);\n    })($nesting[0], $nesting);\n  })($nesting[0], null, $nesting);\n  Opal.const_set($nesting[0], 'STDERR', ($gvars.stderr = Opal.const_get_relative($nesting, 'IO').$new()));\n  Opal.const_set($nesting[0], 'STDIN', ($gvars.stdin = Opal.const_get_relative($nesting, 'IO').$new()));\n  Opal.const_set($nesting[0], 'STDOUT', ($gvars.stdout = Opal.const_get_relative($nesting, 'IO').$new()));\n  var console = Opal.global.console;\n  \n  $writer = [typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)}];\n  $send(Opal.const_get_relative($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));\n  $writer[$rb_minus($writer[\"length\"], 1)];;\n  \n  $writer = [typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)}];\n  $send(Opal.const_get_relative($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));\n  $writer[$rb_minus($writer[\"length\"], 1)];;\n  Opal.const_get_relative($nesting, 'STDOUT').$extend(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'Writable'));\n  return Opal.const_get_relative($nesting, 'STDERR').$extend(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'Writable'));\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/main\"] = function(Opal) {\n  var TMP_to_s_1, TMP_include_2, self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$include']);\n  \n  Opal.defs(self, '$to_s', TMP_to_s_1 = function $$to_s() {\n    var self = this;\n\n    return \"main\"\n  }, TMP_to_s_1.$$arity = 0);\n  return Opal.defs(self, '$include', TMP_include_2 = function $$include(mod) {\n    var self = this;\n\n    return Opal.const_get_relative($nesting, 'Object').$include(mod)\n  }, TMP_include_2.$$arity = 1);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/dir\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$[]']);\n  return (function($base, $super, $parent_nesting) {\n    function $Dir(){};\n    var self = $Dir = $klass($base, $super, 'Dir', $Dir);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_chdir_1, TMP_pwd_2, TMP_home_3;\n\n      \n      \n      Opal.defn(self, '$chdir', TMP_chdir_1 = function $$chdir(dir) {\n        var self = this, $iter = TMP_chdir_1.$$p, $yield = $iter || nil, prev_cwd = nil;\n\n        if ($iter) TMP_chdir_1.$$p = null;\n        return (function() { try {\n        \n        prev_cwd = Opal.current_dir;\n        Opal.current_dir = dir;\n        return Opal.yieldX($yield, []);;\n        } finally {\n          Opal.current_dir = prev_cwd\n        }; })()\n      }, TMP_chdir_1.$$arity = 1);\n      \n      Opal.defn(self, '$pwd', TMP_pwd_2 = function $$pwd() {\n        var self = this;\n\n        return Opal.current_dir || '.'\n      }, TMP_pwd_2.$$arity = 0);\n      Opal.alias(self, \"getwd\", \"pwd\");\n      return (Opal.defn(self, '$home', TMP_home_3 = function $$home() {\n        var $a, self = this;\n\n        return ($truthy($a = Opal.const_get_relative($nesting, 'ENV')['$[]'](\"HOME\")) ? $a : \".\")\n      }, TMP_home_3.$$arity = 0), nil) && 'home';\n    })(Opal.get_singleton_class(self), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/file\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $send = Opal.send;\n\n  Opal.add_stubs(['$home', '$raise', '$start_with?', '$+', '$sub', '$pwd', '$split', '$unshift', '$join', '$respond_to?', '$coerce_to!', '$basename', '$empty?', '$rindex', '$[]', '$nil?', '$==', '$-', '$length', '$gsub', '$find', '$=~', '$map', '$each_with_index', '$flatten', '$reject', '$end_with?']);\n  return (function($base, $super, $parent_nesting) {\n    function $File(){};\n    var self = $File = $klass($base, $super, 'File', $File);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), windows_root_rx = nil;\n\n    \n    Opal.const_set($nesting[0], 'Separator', Opal.const_set($nesting[0], 'SEPARATOR', \"/\"));\n    Opal.const_set($nesting[0], 'ALT_SEPARATOR', nil);\n    Opal.const_set($nesting[0], 'PATH_SEPARATOR', \":\");\n    Opal.const_set($nesting[0], 'FNM_SYSCASE', 0);\n    windows_root_rx = /^[a-zA-Z]:(?:\\\\|\\/)/;\n    return (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_expand_path_1, TMP_dirname_2, TMP_basename_3, TMP_extname_4, TMP_exist$q_5, TMP_directory$q_7, TMP_join_11, TMP_split_12;\n\n      \n      \n      Opal.defn(self, '$expand_path', TMP_expand_path_1 = function $$expand_path(path, basedir) {\n        var self = this, sep = nil, sep_chars = nil, new_parts = nil, home = nil, home_path_regexp = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;\n\n        if (basedir == null) {\n          basedir = nil;\n        }\n        \n        sep = Opal.const_get_relative($nesting, 'SEPARATOR');\n        sep_chars = $sep_chars();\n        new_parts = [];\n        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {\n          \n          home = Opal.const_get_relative($nesting, 'Dir').$home();\n          if ($truthy(home)) {\n            } else {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"couldn't find HOME environment -- expanding `~'\")\n          };\n          if ($truthy(home['$start_with?'](sep))) {\n            } else {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"non-absolute home\")\n          };\n          home = $rb_plus(home, sep);\n          home_path_regexp = new RegExp(\"\" + \"^\\\\~(?:\" + (sep) + \"|$)\");\n          path = path.$sub(home_path_regexp, home);\n          if ($truthy(basedir)) {\n            basedir = basedir.$sub(home_path_regexp, home)};};\n        if ($truthy(basedir)) {\n          } else {\n          basedir = Opal.const_get_relative($nesting, 'Dir').$pwd()\n        };\n        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);\n        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);\n        if ($truthy(path_abs)) {\n          \n          parts = path.$split(new RegExp(\"\" + \"[\" + (sep_chars) + \"]\"));\n          leading_sep = windows_root_rx.test(path) ? '' : path.$sub(new RegExp(\"\" + \"^([\" + (sep_chars) + \"]+).*$\"), \"\\\\1\");\n          abs = true;\n          } else {\n          \n          parts = $rb_plus(basedir.$split(new RegExp(\"\" + \"[\" + (sep_chars) + \"]\")), path.$split(new RegExp(\"\" + \"[\" + (sep_chars) + \"]\")));\n          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(new RegExp(\"\" + \"^([\" + (sep_chars) + \"]+).*$\"), \"\\\\1\");\n          abs = basedir_abs;\n        };\n        \n        var part;\n        for (var i = 0, ii = parts.length; i < ii; i++) {\n          part = parts[i];\n\n          if (\n            (part === nil) ||\n            (part === ''  && ((new_parts.length === 0) || abs)) ||\n            (part === '.' && ((new_parts.length === 0) || abs))\n          ) {\n            continue;\n          }\n          if (part === '..') {\n            new_parts.pop();\n          } else {\n            new_parts.push(part);\n          }\n        }\n\n        if (!abs && parts[0] !== '.') {\n          new_parts.$unshift(\".\")\n        }\n      ;\n        new_path = new_parts.$join(sep);\n        if ($truthy(abs)) {\n          new_path = $rb_plus(leading_sep, new_path)};\n        return new_path;\n      }, TMP_expand_path_1.$$arity = -2);\n      Opal.alias(self, \"realpath\", \"expand_path\");\n      \n      // Coerce a given path to a path string using #to_path and #to_str\n      function $coerce_to_path(path) {\n        if ($truthy((path)['$respond_to?'](\"to_path\"))) {\n          path = path.$to_path();\n        }\n\n        path = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](path, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n\n        return path;\n      }\n\n      // Return a RegExp compatible char class\n      function $sep_chars() {\n        if (Opal.const_get_relative($nesting, 'ALT_SEPARATOR') === nil) {\n          return Opal.escape_regexp(Opal.const_get_relative($nesting, 'SEPARATOR'));\n        } else {\n          return Opal.escape_regexp($rb_plus(Opal.const_get_relative($nesting, 'SEPARATOR'), Opal.const_get_relative($nesting, 'ALT_SEPARATOR')));\n        }\n      }\n    ;\n      \n      Opal.defn(self, '$dirname', TMP_dirname_2 = function $$dirname(path) {\n        var self = this, sep_chars = nil;\n\n        \n        sep_chars = $sep_chars();\n        path = $coerce_to_path(path);\n        \n        var absolute = path.match(new RegExp(\"\" + \"^[\" + (sep_chars) + \"]\"));\n\n        path = path.replace(new RegExp(\"\" + \"[\" + (sep_chars) + \"]+$\"), ''); // remove trailing separators\n        path = path.replace(new RegExp(\"\" + \"[^\" + (sep_chars) + \"]+$\"), ''); // remove trailing basename\n        path = path.replace(new RegExp(\"\" + \"[\" + (sep_chars) + \"]+$\"), ''); // remove final trailing separators\n\n        if (path === '') {\n          return absolute ? '/' : '.';\n        }\n\n        return path;\n      ;\n      }, TMP_dirname_2.$$arity = 1);\n      \n      Opal.defn(self, '$basename', TMP_basename_3 = function $$basename(name, suffix) {\n        var self = this, sep_chars = nil;\n\n        if (suffix == null) {\n          suffix = nil;\n        }\n        \n        sep_chars = $sep_chars();\n        name = $coerce_to_path(name);\n        \n        if (name.length == 0) {\n          return name;\n        }\n\n        if (suffix !== nil) {\n          suffix = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](suffix, Opal.const_get_relative($nesting, 'String'), \"to_str\")\n        } else {\n          suffix = null;\n        }\n\n        name = name.replace(new RegExp(\"\" + \"(.)[\" + (sep_chars) + \"]*$\"), '$1');\n        name = name.replace(new RegExp(\"\" + \"^(?:.*[\" + (sep_chars) + \"])?([^\" + (sep_chars) + \"]+)$\"), '$1');\n\n        if (suffix === \".*\") {\n          name = name.replace(/\\.[^\\.]+$/, '');\n        } else if(suffix !== null) {\n          suffix = Opal.escape_regexp(suffix);\n          name = name.replace(new RegExp(\"\" + (suffix) + \"$\"), '');\n        }\n\n        return name;\n      ;\n      }, TMP_basename_3.$$arity = -2);\n      \n      Opal.defn(self, '$extname', TMP_extname_4 = function $$extname(path) {\n        var $a, self = this, filename = nil, last_dot_idx = nil;\n\n        \n        path = $coerce_to_path(path);;\n        filename = self.$basename(path);\n        if ($truthy(filename['$empty?']())) {\n          return \"\"};\n        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(\".\");\n        if ($truthy(($truthy($a = last_dot_idx['$nil?']()) ? $a : $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1))))) {\n          return \"\"\n          } else {\n          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))\n        };\n      }, TMP_extname_4.$$arity = 1);\n      \n      Opal.defn(self, '$exist?', TMP_exist$q_5 = function(path) {\n        var self = this;\n\n        return Opal.modules[path] != null\n      }, TMP_exist$q_5.$$arity = 1);\n      Opal.alias(self, \"exists?\", \"exist?\");\n      \n      Opal.defn(self, '$directory?', TMP_directory$q_7 = function(path) {\n        var TMP_6, self = this, files = nil, file = nil;\n\n        \n        files = [];\n        \n        for (var key in Opal.modules) {\n          files.push(key)\n        }\n      ;\n        path = path.$gsub(new RegExp(\"\" + \"(^.\" + (Opal.const_get_relative($nesting, 'SEPARATOR')) + \"+|\" + (Opal.const_get_relative($nesting, 'SEPARATOR')) + \"+$)\"));\n        file = $send(files, 'find', [], (TMP_6 = function(file){var self = TMP_6.$$s || this;\nif (file == null) file = nil;\n        return file['$=~'](new RegExp(\"\" + \"^\" + (path)))}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));\n        return file;\n      }, TMP_directory$q_7.$$arity = 1);\n      \n      Opal.defn(self, '$join', TMP_join_11 = function $$join($a_rest) {\n        var TMP_8, TMP_9, TMP_10, self = this, paths, result = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        paths = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          paths[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        if (paths.$length()['$=='](0)) {\n          return \"\"};\n        result = \"\";\n        paths = $send(paths.$flatten().$each_with_index(), 'map', [], (TMP_8 = function(item, index){var self = TMP_8.$$s || this, $a;\nif (item == null) item = nil;if (index == null) index = nil;\n        if ($truthy((($a = index['$=='](0)) ? item['$empty?']() : index['$=='](0)))) {\n            return Opal.const_get_relative($nesting, 'SEPARATOR')\n          } else if ($truthy((($a = paths.$length()['$==']($rb_plus(index, 1))) ? item['$empty?']() : paths.$length()['$==']($rb_plus(index, 1))))) {\n            return Opal.const_get_relative($nesting, 'SEPARATOR')\n            } else {\n            return item\n          }}, TMP_8.$$s = self, TMP_8.$$arity = 2, TMP_8));\n        paths = $send(paths, 'reject', [], (TMP_9 = function(path){var self = TMP_9.$$s || this;\nif (path == null) path = nil;\n        return path['$empty?']()}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9));\n        $send(paths, 'each_with_index', [], (TMP_10 = function(item, index){var self = TMP_10.$$s || this, $a, next_item = nil;\nif (item == null) item = nil;if (index == null) index = nil;\n        \n          next_item = paths['$[]']($rb_plus(index, 1));\n          if ($truthy(next_item['$nil?']())) {\n            return (result = \"\" + (result) + (item))\n            } else {\n            \n            if ($truthy(($truthy($a = item['$end_with?'](Opal.const_get_relative($nesting, 'SEPARATOR'))) ? next_item['$start_with?'](Opal.const_get_relative($nesting, 'SEPARATOR')) : $a))) {\n              item = item.$sub(new RegExp(\"\" + (Opal.const_get_relative($nesting, 'SEPARATOR')) + \"+$\"), \"\")};\n            if ($truthy(($truthy($a = item['$end_with?'](Opal.const_get_relative($nesting, 'SEPARATOR'))) ? $a : next_item['$start_with?'](Opal.const_get_relative($nesting, 'SEPARATOR'))))) {\n              return (result = \"\" + (result) + (item))\n              } else {\n              return (result = \"\" + (result) + (item) + (Opal.const_get_relative($nesting, 'SEPARATOR')))\n            };\n          };}, TMP_10.$$s = self, TMP_10.$$arity = 2, TMP_10));\n        return result;\n      }, TMP_join_11.$$arity = -1);\n      return (Opal.defn(self, '$split', TMP_split_12 = function $$split(path) {\n        var self = this;\n\n        return path.$split(Opal.const_get_relative($nesting, 'SEPARATOR'))\n      }, TMP_split_12.$$arity = 1), nil) && 'split';\n    })(Opal.get_singleton_class(self), $nesting);\n  })($nesting[0], Opal.const_get_relative($nesting, 'IO'), $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/process\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$const_set', '$size', '$<<', '$__register_clock__', '$to_f', '$now', '$new', '$[]', '$raise']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Process(){};\n    var self = $Process = $klass($base, $super, 'Process', $Process);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Process___register_clock___1, TMP_Process_pid_2, TMP_Process_times_3, TMP_Process_clock_gettime_4, monotonic = nil;\n\n    \n    self.__clocks__ = [];\n    Opal.defs(self, '$__register_clock__', TMP_Process___register_clock___1 = function $$__register_clock__(name, func) {\n      var self = this;\n      if (self.__clocks__ == null) self.__clocks__ = nil;\n\n      \n      self.$const_set(name, self.__clocks__.$size());\n      return self.__clocks__['$<<'](func);\n    }, TMP_Process___register_clock___1.$$arity = 2);\n    self.$__register_clock__(\"CLOCK_REALTIME\", function() { return Date.now() });\n    monotonic = false;\n    \n    if (Opal.global.performance) {\n      monotonic = function() {\n        return performance.now()\n      };\n    }\n    else if (Opal.global.process && process.hrtime) {\n      // let now be the base to get smaller numbers\n      var hrtime_base = process.hrtime();\n\n      monotonic = function() {\n        var hrtime = process.hrtime(hrtime_base);\n        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;\n        return ((hrtime[0] * 1000) + (us / 1000));\n      };\n    }\n  ;\n    if ($truthy(monotonic)) {\n      self.$__register_clock__(\"CLOCK_MONOTONIC\", monotonic)};\n    Opal.defs(self, '$pid', TMP_Process_pid_2 = function $$pid() {\n      var self = this;\n\n      return 0\n    }, TMP_Process_pid_2.$$arity = 0);\n    Opal.defs(self, '$times', TMP_Process_times_3 = function $$times() {\n      var self = this, t = nil;\n\n      \n      t = Opal.const_get_relative($nesting, 'Time').$now().$to_f();\n      return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Benchmark'), 'Tms').$new(t, t, t, t, t);\n    }, TMP_Process_times_3.$$arity = 0);\n    return Opal.defs(self, '$clock_gettime', TMP_Process_clock_gettime_4 = function $$clock_gettime(clock_id, unit) {\n      var $a, self = this, clock = nil;\n      if (self.__clocks__ == null) self.__clocks__ = nil;\n\n      if (unit == null) {\n        unit = \"float_second\";\n      }\n      \n      ($truthy($a = (clock = self.__clocks__['$[]'](clock_id))) ? $a : self.$raise(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Errno'), 'EINVAL'), \"\" + \"clock_gettime(\" + (clock_id) + \") \" + (self.__clocks__['$[]'](clock_id))));\n      \n      var ms = clock();\n      switch (unit) {\n        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)\n        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float\n        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float\n        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer\n        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer\n        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer\n        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer\n        default: self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"unexpected unit: \" + (unit))\n      }\n    ;\n    }, TMP_Process_clock_gettime_4.$$arity = -2);\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Signal(){};\n    var self = $Signal = $klass($base, $super, 'Signal', $Signal);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Signal_trap_5;\n\n    return Opal.defs(self, '$trap', TMP_Signal_trap_5 = function $$trap($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_Signal_trap_5.$$arity = -1)\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $GC(){};\n    var self = $GC = $klass($base, $super, 'GC', $GC);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_GC_start_6;\n\n    return Opal.defs(self, '$start', TMP_GC_start_6 = function $$start() {\n      var self = this;\n\n      return nil\n    }, TMP_GC_start_6.$$arity = 0)\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/random/seedrandom\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass;\n\n  return (function($base, $super, $parent_nesting) {\n    function $Random(){};\n    var self = $Random = $klass($base, $super, 'Random', $Random);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    /* jshint ignore:start */\n    /*\n    seedrandom.min.js 2.4.1 (original source: https://github.com/davidbau/seedrandom/blob/2.4.1/seedrandom.min.js)\n    How to update:\n     . Chekout the latest release from GitHub: https://github.com/davidbau/seedrandom\n     . Apply the following commits:\n     .. Check for hasOwnProperty in flatten(): https://github.com/iliabylich/seedrandom/commit/06a94f59ae3d3956c8b1a2488334cafab6744b04\n     .. Add a module id for the RequireJS `define` method: https://github.com/Mogztter/seedrandom/commit/e047540c3d81f955cab9a01d17b8141d439fbd7d\n    */\n    !function(a,b){function c(c,j,k){var n=[];j=1==j?{entropy:!0}:j||{};var s=g(f(j.entropy?[c,i(a)]:null==c?h():c,3),n),t=new d(n),u=function(){for(var a=t.g(m),b=p,c=0;a<q;)a=(a+c)*l,b*=l,c=t.g(1);for(;a>=r;)a/=2,b/=2,c>>>=1;return(a+c)/b};return u.int32=function(){return 0|t.g(4)},u.quick=function(){return t.g(4)/4294967296},u.double=u,g(i(t.S),a),(j.pass||k||function(a,c,d,f){return f&&(f.S&&e(f,t),a.state=function(){return e(t,{})}),d?(b[o]=a,c):a})(u,s,\"global\"in j?j.global:this==b,j.state)}function d(a){var b,c=a.length,d=this,e=0,f=d.i=d.j=0,g=d.S=[];for(c||(a=[c++]);e<l;)g[e]=e++;for(e=0;e<l;e++)g[e]=g[f=s&f+a[e%c]+(b=g[e])],g[f]=b;(d.g=function(a){for(var b,c=0,e=d.i,f=d.j,g=d.S;a--;)b=g[e=s&e+1],c=c*l+g[s&(g[e]=g[f=s&f+b])+(g[f]=b)];return d.i=e,d.j=f,c})(l)}function e(a,b){return b.i=a.i,b.j=a.j,b.S=a.S.slice(),b}function f(a,b){var c,d=[],e=typeof a;if(b&&\"object\"==e)for(c in a)if(a.hasOwnProperty(c))try{d.push(f(a[c],b-1))}catch(a){}return d.length?d:\"string\"==e?a:a+\"\\0\"}function g(a,b){for(var c,d=a+\"\",e=0;e<d.length;)b[s&e]=s&(c^=19*b[s&e])+d.charCodeAt(e++);return i(b)}function h(){try{if(j)return i(j.randomBytes(l));var b=new Uint8Array(l);return(k.crypto||k.msCrypto).getRandomValues(b),i(b)}catch(b){var c=k.navigator,d=c&&c.plugins;return[+new Date,k,d,k.screen,i(a)]}}function i(a){return String.fromCharCode.apply(0,a)}var j,k=this,l=256,m=6,n=52,o=\"random\",p=b.pow(l,m),q=b.pow(2,n),r=2*q,s=l-1;if(b[\"seed\"+o]=c,g(b.random(),a),\"object\"==typeof module&&module.exports){module.exports=c;try{j=__webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\")}catch(a){}}else\"function\"==\"function\"&&__webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")&&!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return c}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}([],Math);\n    /* jshint ignore:end */\n  \n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/random\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$attr_reader', '$coerce_to!', '$reseed', '$new_seed', '$rand', '$seed', '$new', '$===', '$==', '$state', '$encode', '$join', '$map', '$times', '$chr', '$raise']);\n  \n  self.$require(\"corelib/random/seedrandom.js\");\n  return (function($base, $super, $parent_nesting) {\n    function $Random(){};\n    var self = $Random = $klass($base, $super, 'Random', $Random);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Random_initialize_1, TMP_Random_reseed_2, TMP_Random_new_seed_3, TMP_Random_rand_4, TMP_Random_srand_5, TMP_Random_$eq$eq_6, TMP_Random_bytes_8, TMP_Random_rand_9;\n\n    \n    self.$attr_reader(\"seed\", \"state\");\n    \n    Opal.defn(self, '$initialize', TMP_Random_initialize_1 = function $$initialize(seed) {\n      var self = this;\n\n      if (seed == null) {\n        seed = Opal.const_get_relative($nesting, 'Random').$new_seed();\n      }\n      \n      seed = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](seed, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      self.state = seed;\n      return self.$reseed(seed);\n    }, TMP_Random_initialize_1.$$arity = -1);\n    \n    Opal.defn(self, '$reseed', TMP_Random_reseed_2 = function $$reseed(seed) {\n      var self = this;\n\n      \n      self.seed = seed;\n      return self.$rng = new Math.seedrandom(seed);;\n    }, TMP_Random_reseed_2.$$arity = 1);\n    var $seed_generator = new Math.seedrandom('opal', { entropy: true });;\n    Opal.defs(self, '$new_seed', TMP_Random_new_seed_3 = function $$new_seed() {\n      var self = this;\n\n      \n      return Math.abs($seed_generator.int32());\n    \n    }, TMP_Random_new_seed_3.$$arity = 0);\n    Opal.defs(self, '$rand', TMP_Random_rand_4 = function $$rand(limit) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'DEFAULT').$rand(limit)\n    }, TMP_Random_rand_4.$$arity = -1);\n    Opal.defs(self, '$srand', TMP_Random_srand_5 = function $$srand(n) {\n      var self = this, previous_seed = nil;\n\n      if (n == null) {\n        n = Opal.const_get_relative($nesting, 'Random').$new_seed();\n      }\n      \n      n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      previous_seed = Opal.const_get_relative($nesting, 'DEFAULT').$seed();\n      Opal.const_get_relative($nesting, 'DEFAULT').$reseed(n);\n      return previous_seed;\n    }, TMP_Random_srand_5.$$arity = -1);\n    Opal.const_set($nesting[0], 'DEFAULT', self.$new(self.$new_seed()));\n    \n    Opal.defn(self, '$==', TMP_Random_$eq$eq_6 = function(other) {\n      var $a, self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Random')['$==='](other))) {\n        } else {\n        return false\n      };\n      return (($a = self.$seed()['$=='](other.$seed())) ? self.$state()['$=='](other.$state()) : self.$seed()['$=='](other.$seed()));\n    }, TMP_Random_$eq$eq_6.$$arity = 1);\n    \n    Opal.defn(self, '$bytes', TMP_Random_bytes_8 = function $$bytes(length) {\n      var TMP_7, self = this;\n\n      \n      length = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](length, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n      return $send(length.$times(), 'map', [], (TMP_7 = function(){var self = TMP_7.$$s || this;\n\n      return self.$rand(255).$chr()}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7)).$join().$encode(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'ASCII_8BIT'));\n    }, TMP_Random_bytes_8.$$arity = 1);\n    return (Opal.defn(self, '$rand', TMP_Random_rand_9 = function $$rand(limit) {\n      var self = this;\n\n      \n      function randomFloat() {\n        self.state++;\n        return self.$rng.quick();\n      }\n\n      function randomInt() {\n        return Math.floor(randomFloat() * limit);\n      }\n\n      function randomRange() {\n        var min = limit.begin,\n            max = limit.end;\n\n        if (min === nil || max === nil) {\n          return nil;\n        }\n\n        var length = max - min;\n\n        if (length < 0) {\n          return nil;\n        }\n\n        if (length === 0) {\n          return min;\n        }\n\n        if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {\n          length++;\n        }\n\n        return self.$rand(length) + min;\n      }\n\n      if (limit == null) {\n        return randomFloat();\n      } else if (limit.$$is_range) {\n        return randomRange();\n      } else if (limit.$$is_number) {\n        if (limit <= 0) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid argument - \" + (limit))\n        }\n\n        if (limit % 1 === 0) {\n          // integer\n          return randomInt();\n        } else {\n          return randomFloat() * limit;\n        }\n      } else {\n        limit = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](limit, Opal.const_get_relative($nesting, 'Integer'), \"to_int\");\n\n        if (limit <= 0) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"invalid argument - \" + (limit))\n        }\n\n        return randomInt();\n      }\n    \n    }, TMP_Random_rand_9.$$arity = -1), nil) && 'rand';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"corelib/unsupported\"] = function(Opal) {\n  var TMP_public_30, TMP_private_31, self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module;\n\n  Opal.add_stubs(['$raise', '$warn', '$%']);\n  \n  \n  var warnings = {};\n\n  function handle_unsupported_feature(message) {\n    switch (Opal.config.unsupported_features_severity) {\n    case 'error':\n      Opal.const_get_relative($nesting, 'Kernel').$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), message)\n      break;\n    case 'warning':\n      warn(message)\n      break;\n    default: // ignore\n      // noop\n    }\n  }\n\n  function warn(string) {\n    if (warnings[string]) {\n      return;\n    }\n\n    warnings[string] = true;\n    self.$warn(string);\n  }\n;\n  (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_$lt$lt_1, TMP_String_capitalize$B_2, TMP_String_chomp$B_3, TMP_String_chop$B_4, TMP_String_downcase$B_5, TMP_String_gsub$B_6, TMP_String_lstrip$B_7, TMP_String_next$B_8, TMP_String_reverse$B_9, TMP_String_slice$B_10, TMP_String_squeeze$B_11, TMP_String_strip$B_12, TMP_String_sub$B_13, TMP_String_succ$B_14, TMP_String_swapcase$B_15, TMP_String_tr$B_16, TMP_String_tr_s$B_17, TMP_String_upcase$B_18;\n\n    \n    var ERROR = \"String#%s not supported. Mutable String methods are not supported in Opal.\";;\n    \n    Opal.defn(self, '$<<', TMP_String_$lt$lt_1 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"<<\"))\n    }, TMP_String_$lt$lt_1.$$arity = -1);\n    \n    Opal.defn(self, '$capitalize!', TMP_String_capitalize$B_2 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"capitalize!\"))\n    }, TMP_String_capitalize$B_2.$$arity = -1);\n    \n    Opal.defn(self, '$chomp!', TMP_String_chomp$B_3 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"chomp!\"))\n    }, TMP_String_chomp$B_3.$$arity = -1);\n    \n    Opal.defn(self, '$chop!', TMP_String_chop$B_4 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"chop!\"))\n    }, TMP_String_chop$B_4.$$arity = -1);\n    \n    Opal.defn(self, '$downcase!', TMP_String_downcase$B_5 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"downcase!\"))\n    }, TMP_String_downcase$B_5.$$arity = -1);\n    \n    Opal.defn(self, '$gsub!', TMP_String_gsub$B_6 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"gsub!\"))\n    }, TMP_String_gsub$B_6.$$arity = -1);\n    \n    Opal.defn(self, '$lstrip!', TMP_String_lstrip$B_7 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"lstrip!\"))\n    }, TMP_String_lstrip$B_7.$$arity = -1);\n    \n    Opal.defn(self, '$next!', TMP_String_next$B_8 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"next!\"))\n    }, TMP_String_next$B_8.$$arity = -1);\n    \n    Opal.defn(self, '$reverse!', TMP_String_reverse$B_9 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"reverse!\"))\n    }, TMP_String_reverse$B_9.$$arity = -1);\n    \n    Opal.defn(self, '$slice!', TMP_String_slice$B_10 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"slice!\"))\n    }, TMP_String_slice$B_10.$$arity = -1);\n    \n    Opal.defn(self, '$squeeze!', TMP_String_squeeze$B_11 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"squeeze!\"))\n    }, TMP_String_squeeze$B_11.$$arity = -1);\n    \n    Opal.defn(self, '$strip!', TMP_String_strip$B_12 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"strip!\"))\n    }, TMP_String_strip$B_12.$$arity = -1);\n    \n    Opal.defn(self, '$sub!', TMP_String_sub$B_13 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"sub!\"))\n    }, TMP_String_sub$B_13.$$arity = -1);\n    \n    Opal.defn(self, '$succ!', TMP_String_succ$B_14 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"succ!\"))\n    }, TMP_String_succ$B_14.$$arity = -1);\n    \n    Opal.defn(self, '$swapcase!', TMP_String_swapcase$B_15 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"swapcase!\"))\n    }, TMP_String_swapcase$B_15.$$arity = -1);\n    \n    Opal.defn(self, '$tr!', TMP_String_tr$B_16 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"tr!\"))\n    }, TMP_String_tr$B_16.$$arity = -1);\n    \n    Opal.defn(self, '$tr_s!', TMP_String_tr_s$B_17 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"tr_s!\"))\n    }, TMP_String_tr_s$B_17.$$arity = -1);\n    return (Opal.defn(self, '$upcase!', TMP_String_upcase$B_18 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%'](\"upcase!\"))\n    }, TMP_String_upcase$B_18.$$arity = -1), nil) && 'upcase!';\n  })($nesting[0], null, $nesting);\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_freeze_19, TMP_Kernel_frozen$q_20;\n\n    \n    var ERROR = \"Object freezing is not supported by Opal\";;\n    \n    Opal.defn(self, '$freeze', TMP_Kernel_freeze_19 = function $$freeze() {\n      var self = this;\n\n      \n      handle_unsupported_feature(ERROR);\n      return self;\n    }, TMP_Kernel_freeze_19.$$arity = 0);\n    \n    Opal.defn(self, '$frozen?', TMP_Kernel_frozen$q_20 = function() {\n      var self = this;\n\n      \n      handle_unsupported_feature(ERROR);\n      return false;\n    }, TMP_Kernel_frozen$q_20.$$arity = 0);\n  })($nesting[0], $nesting);\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_taint_21, TMP_Kernel_untaint_22, TMP_Kernel_tainted$q_23;\n\n    \n    var ERROR = \"Object tainting is not supported by Opal\";;\n    \n    Opal.defn(self, '$taint', TMP_Kernel_taint_21 = function $$taint() {\n      var self = this;\n\n      \n      handle_unsupported_feature(ERROR);\n      return self;\n    }, TMP_Kernel_taint_21.$$arity = 0);\n    \n    Opal.defn(self, '$untaint', TMP_Kernel_untaint_22 = function $$untaint() {\n      var self = this;\n\n      \n      handle_unsupported_feature(ERROR);\n      return self;\n    }, TMP_Kernel_untaint_22.$$arity = 0);\n    \n    Opal.defn(self, '$tainted?', TMP_Kernel_tainted$q_23 = function() {\n      var self = this;\n\n      \n      handle_unsupported_feature(ERROR);\n      return false;\n    }, TMP_Kernel_tainted$q_23.$$arity = 0);\n  })($nesting[0], $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Module(){};\n    var self = $Module = $klass($base, $super, 'Module', $Module);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Module_public_24, TMP_Module_private_class_method_25, TMP_Module_private_method_defined$q_26, TMP_Module_private_constant_27;\n\n    \n    \n    Opal.defn(self, '$public', TMP_Module_public_24 = function($a_rest) {\n      var self = this, methods;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      methods = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        methods[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if (methods.length === 0) {\n        self.$$module_function = false;\n      }\n\n      return nil;\n    \n    }, TMP_Module_public_24.$$arity = -1);\n    Opal.alias(self, \"private\", \"public\");\n    Opal.alias(self, \"protected\", \"public\");\n    Opal.alias(self, \"nesting\", \"public\");\n    \n    Opal.defn(self, '$private_class_method', TMP_Module_private_class_method_25 = function $$private_class_method($a_rest) {\n      var self = this;\n\n      return self\n    }, TMP_Module_private_class_method_25.$$arity = -1);\n    Opal.alias(self, \"public_class_method\", \"private_class_method\");\n    \n    Opal.defn(self, '$private_method_defined?', TMP_Module_private_method_defined$q_26 = function(obj) {\n      var self = this;\n\n      return false\n    }, TMP_Module_private_method_defined$q_26.$$arity = 1);\n    \n    Opal.defn(self, '$private_constant', TMP_Module_private_constant_27 = function $$private_constant($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_private_constant_27.$$arity = -1);\n    Opal.alias(self, \"protected_method_defined?\", \"private_method_defined?\");\n    Opal.alias(self, \"public_instance_methods\", \"instance_methods\");\n    return Opal.alias(self, \"public_method_defined?\", \"method_defined?\");\n  })($nesting[0], null, $nesting);\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_private_methods_28;\n\n    \n    \n    Opal.defn(self, '$private_methods', TMP_Kernel_private_methods_28 = function $$private_methods($a_rest) {\n      var self = this;\n\n      return []\n    }, TMP_Kernel_private_methods_28.$$arity = -1);\n    Opal.alias(self, \"private_instance_methods\", \"private_methods\");\n  })($nesting[0], $nesting);\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_eval_29;\n\n    \n    Opal.defn(self, '$eval', TMP_Kernel_eval_29 = function($a_rest) {\n      var self = this;\n\n      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"\" + \"To use Kernel#eval, you must first require 'opal-parser'. \" + (\"\" + \"See https://github.com/opal/opal/blob/\" + (Opal.const_get_relative($nesting, 'RUBY_ENGINE_VERSION')) + \"/docs/opal_parser.md for details.\"))\n    }, TMP_Kernel_eval_29.$$arity = -1)\n  })($nesting[0], $nesting);\n  Opal.defs(self, '$public', TMP_public_30 = function($a_rest) {\n    var self = this;\n\n    return nil\n  }, TMP_public_30.$$arity = -1);\n  return Opal.defs(self, '$private', TMP_private_31 = function($a_rest) {\n    var self = this;\n\n    return nil\n  }, TMP_private_31.$$arity = -1);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"opal/base\");\n  self.$require(\"opal/mini\");\n  self.$require(\"corelib/string/inheritance\");\n  self.$require(\"corelib/string/encoding\");\n  self.$require(\"corelib/math\");\n  self.$require(\"corelib/complex\");\n  self.$require(\"corelib/rational\");\n  self.$require(\"corelib/time\");\n  self.$require(\"corelib/struct\");\n  self.$require(\"corelib/io\");\n  self.$require(\"corelib/main\");\n  self.$require(\"corelib/dir\");\n  self.$require(\"corelib/file\");\n  self.$require(\"corelib/process\");\n  self.$require(\"corelib/random\");\n  return self.$require(\"corelib/unsupported\");\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/version\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;\n\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    Opal.const_set($nesting[0], 'VERSION', \"0.11.3\")\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"native\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2, $klass = Opal.klass, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$try_convert', '$native?', '$respond_to?', '$to_n', '$raise', '$inspect', '$Native', '$proc', '$map!', '$end_with?', '$define_method', '$[]', '$convert', '$call', '$to_proc', '$new', '$each', '$native_reader', '$native_writer', '$extend', '$is_a?', '$map', '$alias_method', '$to_a', '$_Array', '$include', '$method_missing', '$bind', '$instance_method', '$slice', '$-', '$length', '$[]=', '$enum_for', '$===', '$>=', '$<<', '$each_pair', '$_initialize', '$name', '$exiting_mid', '$native_module']);\n  \n  (function($base, $parent_nesting) {\n    var $Native, self = $Native = $module($base, 'Native');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Native_is_a$q_1, TMP_Native_try_convert_2, TMP_Native_convert_3, TMP_Native_call_4, TMP_Native_proc_5, TMP_Native_included_19, TMP_Native_initialize_20, TMP_Native_to_n_21;\n\n    \n    Opal.defs(self, '$is_a?', TMP_Native_is_a$q_1 = function(object, klass) {\n      var self = this;\n\n      \n      try {\n        return object instanceof self.$try_convert(klass);\n      }\n      catch (e) {\n        return false;\n      }\n    \n    }, TMP_Native_is_a$q_1.$$arity = 2);\n    Opal.defs(self, '$try_convert', TMP_Native_try_convert_2 = function $$try_convert(value, default$) {\n      var self = this;\n\n      if (default$ == null) {\n        default$ = nil;\n      }\n      \n      if (self['$native?'](value)) {\n        return value;\n      }\n      else if (value['$respond_to?'](\"to_n\")) {\n        return value.$to_n();\n      }\n      else {\n        return default$;\n      }\n    \n    }, TMP_Native_try_convert_2.$$arity = -2);\n    Opal.defs(self, '$convert', TMP_Native_convert_3 = function $$convert(value) {\n      var self = this;\n\n      \n      if (self['$native?'](value)) {\n        return value;\n      }\n      else if (value['$respond_to?'](\"to_n\")) {\n        return value.$to_n();\n      }\n      else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + (value.$inspect()) + \" isn't native\");\n      }\n    \n    }, TMP_Native_convert_3.$$arity = 1);\n    Opal.defs(self, '$call', TMP_Native_call_4 = function $$call(obj, key, $a_rest) {\n      var self = this, args, $iter = TMP_Native_call_4.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 2;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 2; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 2] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Native_call_4.$$p = null;\n      \n      var prop = obj[key];\n\n      if (prop instanceof Function) {\n        var converted = new Array(args.length);\n\n        for (var i = 0, l = args.length; i < l; i++) {\n          var item = args[i],\n              conv = self.$try_convert(item);\n\n          converted[i] = conv === nil ? item : conv;\n        }\n\n        if (block !== nil) {\n          converted.push(block);\n        }\n\n        return self.$Native(prop.apply(obj, converted));\n      }\n      else {\n        return self.$Native(prop);\n      }\n    \n    }, TMP_Native_call_4.$$arity = -3);\n    Opal.defs(self, '$proc', TMP_Native_proc_5 = function $$proc() {\n      var TMP_6, self = this, $iter = TMP_Native_proc_5.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Native_proc_5.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'LocalJumpError'), \"no block given\")\n      };\n      return $send(Opal.const_get_qualified('::', 'Kernel'), 'proc', [], (TMP_6 = function($a_rest){var self = TMP_6.$$s || this, args, TMP_7, instance = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        $send(args, 'map!', [], (TMP_7 = function(arg){var self = TMP_7.$$s || this;\nif (arg == null) arg = nil;\n        return self.$Native(arg)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));\n        instance = self.$Native(this);\n        \n        // if global is current scope, run the block in the scope it was defined\n        if (this === Opal.global) {\n          return block.apply(self, args);\n        }\n\n        var self_ = block.$$s;\n        block.$$s = null;\n\n        try {\n          return block.apply(instance, args);\n        }\n        finally {\n          block.$$s = self_;\n        }\n      ;}, TMP_6.$$s = self, TMP_6.$$arity = -1, TMP_6));\n    }, TMP_Native_proc_5.$$arity = 0);\n    (function($base, $parent_nesting) {\n      var $Helpers, self = $Helpers = $module($base, 'Helpers');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Helpers_alias_native_11, TMP_Helpers_native_reader_14, TMP_Helpers_native_writer_17, TMP_Helpers_native_accessor_18;\n\n      \n      \n      Opal.defn(self, '$alias_native', TMP_Helpers_alias_native_11 = function $$alias_native(new$, $old, $kwargs) {\n        var TMP_8, TMP_9, TMP_10, self = this, $post_args, as, old;\n\n        $post_args = Opal.slice.call(arguments, 1, arguments.length);\n        $kwargs = Opal.extract_kwargs($post_args);\n        if ($kwargs == null || !$kwargs.$$is_hash) {\n          if ($kwargs == null) {\n            $kwargs = $hash2([], {});\n          } else {\n            throw Opal.ArgumentError.$new('expected kwargs');\n          }\n        }\n        as = $kwargs.$$smap[\"as\"];\n        if (as == null) {\n          as = nil\n        }\n        if (0 < $post_args.length) {\n          old = $post_args.splice(0,1)[0];\n        }\n        if (old == null) {\n          old = new$;\n        }\n        if ($truthy(old['$end_with?'](\"=\"))) {\n          return $send(self, 'define_method', [new$], (TMP_8 = function(value){var self = TMP_8.$$s || this;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\nif (value == null) value = nil;\n          \n            self[\"native\"][old['$[]']($range(0, -2, false))] = Opal.const_get_relative($nesting, 'Native').$convert(value);\n            return value;}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8))\n        } else if ($truthy(as)) {\n          return $send(self, 'define_method', [new$], (TMP_9 = function($a_rest){var self = TMP_9.$$s || this, block, args, value = nil;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\n\n            block = TMP_9.$$p || nil;\n            if (block) TMP_9.$$p = null;\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n          if ($truthy((value = $send(Opal.const_get_relative($nesting, 'Native'), 'call', [self[\"native\"], old].concat(Opal.to_a(args)), block.$to_proc())))) {\n              return as.$new(value.$to_n())\n              } else {\n              return nil\n            }}, TMP_9.$$s = self, TMP_9.$$arity = -1, TMP_9))\n          } else {\n          return $send(self, 'define_method', [new$], (TMP_10 = function($a_rest){var self = TMP_10.$$s || this, block, args;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\n\n            block = TMP_10.$$p || nil;\n            if (block) TMP_10.$$p = null;\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n          return $send(Opal.const_get_relative($nesting, 'Native'), 'call', [self[\"native\"], old].concat(Opal.to_a(args)), block.$to_proc())}, TMP_10.$$s = self, TMP_10.$$arity = -1, TMP_10))\n        }\n      }, TMP_Helpers_alias_native_11.$$arity = -2);\n      \n      Opal.defn(self, '$native_reader', TMP_Helpers_native_reader_14 = function $$native_reader($a_rest) {\n        var TMP_12, self = this, names;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        names = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          names[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        return $send(names, 'each', [], (TMP_12 = function(name){var self = TMP_12.$$s || this, TMP_13;\nif (name == null) name = nil;\n        return $send(self, 'define_method', [name], (TMP_13 = function(){var self = TMP_13.$$s || this;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\n\n          return self.$Native(self[\"native\"][name])}, TMP_13.$$s = self, TMP_13.$$arity = 0, TMP_13))}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12))\n      }, TMP_Helpers_native_reader_14.$$arity = -1);\n      \n      Opal.defn(self, '$native_writer', TMP_Helpers_native_writer_17 = function $$native_writer($a_rest) {\n        var TMP_15, self = this, names;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        names = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          names[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        return $send(names, 'each', [], (TMP_15 = function(name){var self = TMP_15.$$s || this, TMP_16;\nif (name == null) name = nil;\n        return $send(self, 'define_method', [\"\" + (name) + \"=\"], (TMP_16 = function(value){var self = TMP_16.$$s || this;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\nif (value == null) value = nil;\n          return self.$Native(self[\"native\"][name] = value)}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16))}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15))\n      }, TMP_Helpers_native_writer_17.$$arity = -1);\n      \n      Opal.defn(self, '$native_accessor', TMP_Helpers_native_accessor_18 = function $$native_accessor($a_rest) {\n        var self = this, names;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        names = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          names[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        $send(self, 'native_reader', Opal.to_a(names));\n        return $send(self, 'native_writer', Opal.to_a(names));\n      }, TMP_Helpers_native_accessor_18.$$arity = -1);\n    })($nesting[0], $nesting);\n    Opal.defs(self, '$included', TMP_Native_included_19 = function $$included(klass) {\n      var self = this;\n\n      return klass.$extend(Opal.const_get_relative($nesting, 'Helpers'))\n    }, TMP_Native_included_19.$$arity = 1);\n    \n    Opal.defn(self, '$initialize', TMP_Native_initialize_20 = function $$initialize(native$) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_qualified('::', 'Kernel')['$native?'](native$))) {\n        } else {\n        Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + (native$.$inspect()) + \" isn't native\")\n      };\n      return (self[\"native\"] = native$);\n    }, TMP_Native_initialize_20.$$arity = 1);\n    \n    Opal.defn(self, '$to_n', TMP_Native_to_n_21 = function $$to_n() {\n      var self = this;\n      if (self[\"native\"] == null) self[\"native\"] = nil;\n\n      return self[\"native\"]\n    }, TMP_Native_to_n_21.$$arity = 0);\n  })($nesting[0], $nesting);\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_native$q_22, TMP_Kernel_Native_25, TMP_Kernel_Array_26;\n\n    \n    \n    Opal.defn(self, '$native?', TMP_Kernel_native$q_22 = function(value) {\n      var self = this;\n\n      return value == null || !value.$$class\n    }, TMP_Kernel_native$q_22.$$arity = 1);\n    \n    Opal.defn(self, '$Native', TMP_Kernel_Native_25 = function $$Native(obj) {\n      var TMP_23, TMP_24, self = this;\n\n      if ($truthy(obj == null)) {\n        return nil\n      } else if ($truthy(self['$native?'](obj))) {\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Object').$new(obj)\n      } else if ($truthy(obj['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {\n        return $send(obj, 'map', [], (TMP_23 = function(o){var self = TMP_23.$$s || this;\nif (o == null) o = nil;\n        return self.$Native(o)}, TMP_23.$$s = self, TMP_23.$$arity = 1, TMP_23))\n      } else if ($truthy(obj['$is_a?'](Opal.const_get_relative($nesting, 'Proc')))) {\n        return $send(self, 'proc', [], (TMP_24 = function($a_rest){var self = TMP_24.$$s || this, block, args;\n\n          block = TMP_24.$$p || nil;\n          if (block) TMP_24.$$p = null;\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        return self.$Native($send(obj, 'call', Opal.to_a(args), block.$to_proc()))}, TMP_24.$$s = self, TMP_24.$$arity = -1, TMP_24))\n        } else {\n        return obj\n      }\n    }, TMP_Kernel_Native_25.$$arity = 1);\n    self.$alias_method(\"_Array\", \"Array\");\n    \n    Opal.defn(self, '$Array', TMP_Kernel_Array_26 = function $$Array(object, $a_rest) {\n      var self = this, args, $iter = TMP_Kernel_Array_26.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Kernel_Array_26.$$p = null;\n      \n      if ($truthy(self['$native?'](object))) {\n        return $send(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array'), 'new', [object].concat(Opal.to_a(args)), block.$to_proc()).$to_a()};\n      return self.$_Array(object);\n    }, TMP_Kernel_Array_26.$$arity = -2);\n  })($nesting[0], $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Object(){};\n    var self = $Object = $klass($base, $super, 'Object', $Object);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Object_$eq$eq_27, TMP_Object_has_key$q_28, TMP_Object_each_29, TMP_Object_$$_30, TMP_Object_$$$eq_31, TMP_Object_merge$B_32, TMP_Object_respond_to$q_33, TMP_Object_respond_to_missing$q_34, TMP_Object_method_missing_35, TMP_Object_nil$q_36, TMP_Object_is_a$q_37, TMP_Object_instance_of$q_38, TMP_Object_class_39, TMP_Object_to_a_40, TMP_Object_inspect_41;\n\n    def[\"native\"] = nil;\n    \n    self.$include(Opal.const_get_qualified('::', 'Native'));\n    \n    Opal.defn(self, '$==', TMP_Object_$eq$eq_27 = function(other) {\n      var self = this;\n\n      return self[\"native\"] === Opal.const_get_qualified('::', 'Native').$try_convert(other)\n    }, TMP_Object_$eq$eq_27.$$arity = 1);\n    \n    Opal.defn(self, '$has_key?', TMP_Object_has_key$q_28 = function(name) {\n      var self = this;\n\n      return Opal.hasOwnProperty.call(self[\"native\"], name)\n    }, TMP_Object_has_key$q_28.$$arity = 1);\n    Opal.alias(self, \"key?\", \"has_key?\");\n    Opal.alias(self, \"include?\", \"has_key?\");\n    Opal.alias(self, \"member?\", \"has_key?\");\n    \n    Opal.defn(self, '$each', TMP_Object_each_29 = function $$each($a_rest) {\n      var self = this, args, $iter = TMP_Object_each_29.$$p, $yield = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Object_each_29.$$p = null;\n      if (($yield !== nil)) {\n        \n        \n        for (var key in self[\"native\"]) {\n          Opal.yieldX($yield, [key, self[\"native\"][key]])\n        }\n      ;\n        return self;\n        } else {\n        return $send(self, 'method_missing', [\"each\"].concat(Opal.to_a(args)))\n      }\n    }, TMP_Object_each_29.$$arity = -1);\n    \n    Opal.defn(self, '$[]', TMP_Object_$$_30 = function(key) {\n      var self = this;\n\n      \n      var prop = self[\"native\"][key];\n\n      if (prop instanceof Function) {\n        return prop;\n      }\n      else {\n        return Opal.const_get_qualified('::', 'Native').$call(self[\"native\"], key)\n      }\n    \n    }, TMP_Object_$$_30.$$arity = 1);\n    \n    Opal.defn(self, '$[]=', TMP_Object_$$$eq_31 = function(key, value) {\n      var self = this, native$ = nil;\n\n      \n      native$ = Opal.const_get_qualified('::', 'Native').$try_convert(value);\n      if ($truthy(native$ === nil)) {\n        return self[\"native\"][key] = value\n        } else {\n        return self[\"native\"][key] = native$\n      };\n    }, TMP_Object_$$$eq_31.$$arity = 2);\n    \n    Opal.defn(self, '$merge!', TMP_Object_merge$B_32 = function(other) {\n      var self = this;\n\n      \n      \n      other = Opal.const_get_qualified('::', 'Native').$convert(other);\n\n      for (var prop in other) {\n        self[\"native\"][prop] = other[prop];\n      }\n    ;\n      return self;\n    }, TMP_Object_merge$B_32.$$arity = 1);\n    \n    Opal.defn(self, '$respond_to?', TMP_Object_respond_to$q_33 = function(name, include_all) {\n      var self = this;\n\n      if (include_all == null) {\n        include_all = false;\n      }\n      return Opal.const_get_qualified('::', 'Kernel').$instance_method(\"respond_to?\").$bind(self).$call(name, include_all)\n    }, TMP_Object_respond_to$q_33.$$arity = -2);\n    \n    Opal.defn(self, '$respond_to_missing?', TMP_Object_respond_to_missing$q_34 = function(name, include_all) {\n      var self = this;\n\n      if (include_all == null) {\n        include_all = false;\n      }\n      return Opal.hasOwnProperty.call(self[\"native\"], name)\n    }, TMP_Object_respond_to_missing$q_34.$$arity = -2);\n    \n    Opal.defn(self, '$method_missing', TMP_Object_method_missing_35 = function $$method_missing(mid, $a_rest) {\n      var self = this, args, $iter = TMP_Object_method_missing_35.$$p, block = $iter || nil, $writer = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Object_method_missing_35.$$p = null;\n      \n      if (mid.charAt(mid.length - 1) === '=') {\n        return (($writer = [mid.$slice(0, $rb_minus(mid.$length(), 1)), args['$[]'](0)]), $send(self, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]);\n      }\n      else {\n        return $send(Opal.const_get_qualified('::', 'Native'), 'call', [self[\"native\"], mid].concat(Opal.to_a(args)), block.$to_proc());\n      }\n    \n    }, TMP_Object_method_missing_35.$$arity = -2);\n    \n    Opal.defn(self, '$nil?', TMP_Object_nil$q_36 = function() {\n      var self = this;\n\n      return false\n    }, TMP_Object_nil$q_36.$$arity = 0);\n    \n    Opal.defn(self, '$is_a?', TMP_Object_is_a$q_37 = function(klass) {\n      var self = this;\n\n      return Opal.is_a(self, klass)\n    }, TMP_Object_is_a$q_37.$$arity = 1);\n    Opal.alias(self, \"kind_of?\", \"is_a?\");\n    \n    Opal.defn(self, '$instance_of?', TMP_Object_instance_of$q_38 = function(klass) {\n      var self = this;\n\n      return self.$$class === klass\n    }, TMP_Object_instance_of$q_38.$$arity = 1);\n    \n    Opal.defn(self, '$class', TMP_Object_class_39 = function() {\n      var self = this;\n\n      return self.$$class\n    }, TMP_Object_class_39.$$arity = 0);\n    \n    Opal.defn(self, '$to_a', TMP_Object_to_a_40 = function $$to_a(options) {\n      var self = this, $iter = TMP_Object_to_a_40.$$p, block = $iter || nil;\n\n      if (options == null) {\n        options = $hash2([], {});\n      }\n      if ($iter) TMP_Object_to_a_40.$$p = null;\n      return $send(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Native'), 'Array'), 'new', [self[\"native\"], options], block.$to_proc()).$to_a()\n    }, TMP_Object_to_a_40.$$arity = -1);\n    return (Opal.defn(self, '$inspect', TMP_Object_inspect_41 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"#<Native:\" + (String(self[\"native\"])) + \">\"\n    }, TMP_Object_inspect_41.$$arity = 0), nil) && 'inspect';\n  })(Opal.const_get_relative($nesting, 'Native'), Opal.const_get_relative($nesting, 'BasicObject'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Array(){};\n    var self = $Array = $klass($base, $super, 'Array', $Array);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_initialize_42, TMP_Array_each_43, TMP_Array_$$_44, TMP_Array_$$$eq_45, TMP_Array_last_46, TMP_Array_length_47, TMP_Array_inspect_48;\n\n    def.named = def[\"native\"] = def.get = def.block = def.set = def.length = nil;\n    \n    self.$include(Opal.const_get_relative($nesting, 'Native'));\n    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n    \n    Opal.defn(self, '$initialize', TMP_Array_initialize_42 = function $$initialize(native$, options) {\n      var $a, self = this, $iter = TMP_Array_initialize_42.$$p, block = $iter || nil;\n\n      if (options == null) {\n        options = $hash2([], {});\n      }\n      if ($iter) TMP_Array_initialize_42.$$p = null;\n      \n      $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Array_initialize_42, false), [native$], null);\n      self.get = ($truthy($a = options['$[]'](\"get\")) ? $a : options['$[]'](\"access\"));\n      self.named = options['$[]'](\"named\");\n      self.set = ($truthy($a = options['$[]'](\"set\")) ? $a : options['$[]'](\"access\"));\n      self.length = ($truthy($a = options['$[]'](\"length\")) ? $a : \"length\");\n      self.block = block;\n      if ($truthy(self.$length() == null)) {\n        return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"no length found on the array-like object\")\n        } else {\n        return nil\n      };\n    }, TMP_Array_initialize_42.$$arity = -2);\n    \n    Opal.defn(self, '$each', TMP_Array_each_43 = function $$each() {\n      var self = this, $iter = TMP_Array_each_43.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_each_43.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return self.$enum_for(\"each\")\n      };\n      \n      for (var i = 0, length = self.$length(); i < length; i++) {\n        Opal.yield1(block, self['$[]'](i));\n      }\n    ;\n      return self;\n    }, TMP_Array_each_43.$$arity = 0);\n    \n    Opal.defn(self, '$[]', TMP_Array_$$_44 = function(index) {\n      var self = this, result = nil, $case = nil;\n\n      \n      result = (function() {$case = index;\n      if (Opal.const_get_relative($nesting, 'String')['$===']($case) || Opal.const_get_relative($nesting, 'Symbol')['$===']($case)) {if ($truthy(self.named)) {\n        return self[\"native\"][self.named](index)\n        } else {\n        return self[\"native\"][index]\n      }}\n      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {if ($truthy(self.get)) {\n        return self[\"native\"][self.get](index)\n        } else {\n        return self[\"native\"][index]\n      }}\n      else { return nil }})();\n      if ($truthy(result)) {\n        if ($truthy(self.block)) {\n          return self.block.$call(result)\n          } else {\n          return self.$Native(result)\n        }\n        } else {\n        return nil\n      };\n    }, TMP_Array_$$_44.$$arity = 1);\n    \n    Opal.defn(self, '$[]=', TMP_Array_$$$eq_45 = function(index, value) {\n      var self = this;\n\n      if ($truthy(self.set)) {\n        return self[\"native\"][self.set](index, Opal.const_get_relative($nesting, 'Native').$convert(value))\n        } else {\n        return self[\"native\"][index] = Opal.const_get_relative($nesting, 'Native').$convert(value)\n      }\n    }, TMP_Array_$$$eq_45.$$arity = 2);\n    \n    Opal.defn(self, '$last', TMP_Array_last_46 = function $$last(count) {\n      var $a, self = this, index = nil, result = nil;\n\n      if (count == null) {\n        count = nil;\n      }\n      if ($truthy(count)) {\n        \n        index = $rb_minus(self.$length(), 1);\n        result = [];\n        while ($truthy($rb_ge(index, 0))) {\n          \n          result['$<<'](self['$[]'](index));\n          index = $rb_minus(index, 1);\n        };\n        return result;\n        } else {\n        return self['$[]']($rb_minus(self.$length(), 1))\n      }\n    }, TMP_Array_last_46.$$arity = -1);\n    \n    Opal.defn(self, '$length', TMP_Array_length_47 = function $$length() {\n      var self = this;\n\n      return self[\"native\"][self.length]\n    }, TMP_Array_length_47.$$arity = 0);\n    Opal.alias(self, \"to_ary\", \"to_a\");\n    return (Opal.defn(self, '$inspect', TMP_Array_inspect_48 = function $$inspect() {\n      var self = this;\n\n      return self.$to_a().$inspect()\n    }, TMP_Array_inspect_48.$$arity = 0), nil) && 'inspect';\n  })(Opal.const_get_relative($nesting, 'Native'), null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Numeric(){};\n    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Numeric_to_n_49;\n\n    return (Opal.defn(self, '$to_n', TMP_Numeric_to_n_49 = function $$to_n() {\n      var self = this;\n\n      return self.valueOf()\n    }, TMP_Numeric_to_n_49.$$arity = 0), nil) && 'to_n'\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Proc(){};\n    var self = $Proc = $klass($base, $super, 'Proc', $Proc);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Proc_to_n_50;\n\n    return (Opal.defn(self, '$to_n', TMP_Proc_to_n_50 = function $$to_n() {\n      var self = this;\n\n      return self\n    }, TMP_Proc_to_n_50.$$arity = 0), nil) && 'to_n'\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_to_n_51;\n\n    return (Opal.defn(self, '$to_n', TMP_String_to_n_51 = function $$to_n() {\n      var self = this;\n\n      return self.valueOf()\n    }, TMP_String_to_n_51.$$arity = 0), nil) && 'to_n'\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Regexp(){};\n    var self = $Regexp = $klass($base, $super, 'Regexp', $Regexp);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Regexp_to_n_52;\n\n    return (Opal.defn(self, '$to_n', TMP_Regexp_to_n_52 = function $$to_n() {\n      var self = this;\n\n      return self.valueOf()\n    }, TMP_Regexp_to_n_52.$$arity = 0), nil) && 'to_n'\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $MatchData(){};\n    var self = $MatchData = $klass($base, $super, 'MatchData', $MatchData);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MatchData_to_n_53;\n\n    def.matches = nil;\n    return (Opal.defn(self, '$to_n', TMP_MatchData_to_n_53 = function $$to_n() {\n      var self = this;\n\n      return self.matches\n    }, TMP_MatchData_to_n_53.$$arity = 0), nil) && 'to_n'\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Struct(){};\n    var self = $Struct = $klass($base, $super, 'Struct', $Struct);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Struct_to_n_55;\n\n    return (Opal.defn(self, '$to_n', TMP_Struct_to_n_55 = function $$to_n() {\n      var TMP_54, self = this, result = nil;\n\n      \n      result = {};\n      $send(self, 'each_pair', [], (TMP_54 = function(name, value){var self = TMP_54.$$s || this;\nif (name == null) name = nil;if (value == null) value = nil;\n      return result[name] = Opal.const_get_relative($nesting, 'Native').$try_convert(value, value)}, TMP_54.$$s = self, TMP_54.$$arity = 2, TMP_54));\n      return result;\n    }, TMP_Struct_to_n_55.$$arity = 0), nil) && 'to_n'\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Array(){};\n    var self = $Array = $klass($base, $super, 'Array', $Array);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_to_n_56;\n\n    return (Opal.defn(self, '$to_n', TMP_Array_to_n_56 = function $$to_n() {\n      var self = this;\n\n      \n      var result = [];\n\n      for (var i = 0, length = self.length; i < length; i++) {\n        var obj = self[i];\n\n        result.push(Opal.const_get_relative($nesting, 'Native').$try_convert(obj, obj));\n      }\n\n      return result;\n    \n    }, TMP_Array_to_n_56.$$arity = 0), nil) && 'to_n'\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Boolean(){};\n    var self = $Boolean = $klass($base, $super, 'Boolean', $Boolean);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Boolean_to_n_57;\n\n    return (Opal.defn(self, '$to_n', TMP_Boolean_to_n_57 = function $$to_n() {\n      var self = this;\n\n      return self.valueOf()\n    }, TMP_Boolean_to_n_57.$$arity = 0), nil) && 'to_n'\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Time(){};\n    var self = $Time = $klass($base, $super, 'Time', $Time);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Time_to_n_58;\n\n    return (Opal.defn(self, '$to_n', TMP_Time_to_n_58 = function $$to_n() {\n      var self = this;\n\n      return self\n    }, TMP_Time_to_n_58.$$arity = 0), nil) && 'to_n'\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NilClass(){};\n    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NilClass_to_n_59;\n\n    return (Opal.defn(self, '$to_n', TMP_NilClass_to_n_59 = function $$to_n() {\n      var self = this;\n\n      return null\n    }, TMP_NilClass_to_n_59.$$arity = 0), nil) && 'to_n'\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Hash(){};\n    var self = $Hash = $klass($base, $super, 'Hash', $Hash);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hash_initialize_60, TMP_Hash_to_n_61;\n\n    \n    self.$alias_method(\"_initialize\", \"initialize\");\n    \n    Opal.defn(self, '$initialize', TMP_Hash_initialize_60 = function $$initialize(defaults) {\n      var self = this, $iter = TMP_Hash_initialize_60.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_initialize_60.$$p = null;\n      \n      if (defaults != null &&\n           (defaults.constructor === undefined ||\n             defaults.constructor === Object)) {\n        var smap = self.$$smap,\n            keys = self.$$keys,\n            key, value;\n\n        for (key in defaults) {\n          value = defaults[key];\n\n          if (value &&\n               (value.constructor === undefined ||\n                 value.constructor === Object)) {\n            smap[key] = Opal.const_get_relative($nesting, 'Hash').$new(value);\n          } else if (value && value.$$is_array) {\n            value = value.map(function(item) {\n              if (item &&\n                   (item.constructor === undefined ||\n                     item.constructor === Object)) {\n                return Opal.const_get_relative($nesting, 'Hash').$new(item);\n              }\n\n              return self.$Native(item);\n            });\n            smap[key] = value\n          } else {\n            smap[key] = self.$Native(value);\n          }\n\n          keys.push(key);\n        }\n\n        return self;\n      }\n\n      return $send(self, '_initialize', [defaults], block.$to_proc());\n    \n    }, TMP_Hash_initialize_60.$$arity = -1);\n    return (Opal.defn(self, '$to_n', TMP_Hash_to_n_61 = function $$to_n() {\n      var self = this;\n\n      \n      var result = {},\n          keys = self.$$keys,\n          smap = self.$$smap,\n          key, value;\n\n      for (var i = 0, length = keys.length; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = smap[key];\n        } else {\n          key = key.key;\n          value = key.value;\n        }\n\n        result[key] = Opal.const_get_relative($nesting, 'Native').$try_convert(value, value);\n      }\n\n      return result;\n    \n    }, TMP_Hash_to_n_61.$$arity = 0), nil) && 'to_n';\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Module(){};\n    var self = $Module = $klass($base, $super, 'Module', $Module);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Module_native_module_62;\n\n    return (Opal.defn(self, '$native_module', TMP_Module_native_module_62 = function $$native_module() {\n      var self = this;\n\n      return Opal.global[self.$name()] = self\n    }, TMP_Module_native_module_62.$$arity = 0), nil) && 'native_module'\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Class(){};\n    var self = $Class = $klass($base, $super, 'Class', $Class);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Class_native_alias_63, TMP_Class_native_class_64;\n\n    \n    \n    Opal.defn(self, '$native_alias', TMP_Class_native_alias_63 = function $$native_alias(new_jsid, existing_mid) {\n      var self = this;\n\n      \n      var aliased = self.$$proto['$' + existing_mid];\n      if (!aliased) {\n        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new(\"\" + \"undefined method `\" + (existing_mid) + \"' for class `\" + (self.$inspect()) + \"'\", self.$exiting_mid()));\n      }\n      self.$$proto[new_jsid] = aliased;\n    \n    }, TMP_Class_native_alias_63.$$arity = 2);\n    return (Opal.defn(self, '$native_class', TMP_Class_native_class_64 = function $$native_class() {\n      var self = this;\n\n      \n      self.$native_module();\n      return self[\"new\"] = self.$new;;\n    }, TMP_Class_native_class_64.$$arity = 0), nil) && 'native_class';\n  })($nesting[0], null, $nesting);\n  return ($gvars.$ = ($gvars.global = self.$Native(Opal.global)));\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/utils\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$size', '$min', '$scan', '$gsub', '$proc', '$===', '$merge', '$to_proc', '$merge!']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $parent_nesting) {\n      var $Utils, self = $Utils = $module($base, 'Utils');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Utils_heredoc_1, TMP_Utils_deep_merge_3, TMP_Utils_deep_merge$B_5;\n\n      \n      Opal.defs(self, '$heredoc', TMP_Utils_heredoc_1 = function $$heredoc(string) {\n        var self = this, indent = nil;\n\n        \n        indent = (function() { try {\n          return string.$scan(/^[ \\t]*(?=\\S)/).$min().$size()\n        } catch ($err) {\n          if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {\n            try {\n              return 0\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        }})();\n        return string.$gsub(new RegExp(\"\" + \"^[ \\\\t]{\" + (indent) + \"}\"), \"\");\n      }, TMP_Utils_heredoc_1.$$arity = 1);\n      Opal.defs(self, '$deep_merge', TMP_Utils_deep_merge_3 = function $$deep_merge(a, b) {\n        var TMP_2, self = this, merger = nil;\n\n        \n        merger = $send(self, 'proc', [], (TMP_2 = function(key, v1, v2){var self = TMP_2.$$s || this, $a;\nif (key == null) key = nil;if (v1 == null) v1 = nil;if (v2 == null) v2 = nil;\n        if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Hash')['$==='](v1)) ? Opal.const_get_relative($nesting, 'Hash')['$==='](v2) : $a))) {\n            return $send(v1, 'merge', [v2], merger.$to_proc())\n            } else {\n            return v2\n          }}, TMP_2.$$s = self, TMP_2.$$arity = 3, TMP_2));\n        return $send(a, 'merge', [b], merger.$to_proc());\n      }, TMP_Utils_deep_merge_3.$$arity = 2);\n      Opal.defs(self, '$deep_merge!', TMP_Utils_deep_merge$B_5 = function(a, b) {\n        var TMP_4, self = this, merger = nil;\n\n        \n        merger = $send(self, 'proc', [], (TMP_4 = function(key, v1, v2){var self = TMP_4.$$s || this, $a;\nif (key == null) key = nil;if (v1 == null) v1 = nil;if (v2 == null) v2 = nil;\n        if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Hash')['$==='](v1)) ? Opal.const_get_relative($nesting, 'Hash')['$==='](v2) : $a))) {\n            \n            $send(v1, 'merge!', [v2], merger.$to_proc());\n            return v1;\n            } else {\n            return v2\n          }}, TMP_4.$$s = self, TMP_4.$$arity = 3, TMP_4));\n        return $send(a, 'merge!', [b], merger.$to_proc());\n      }, TMP_Utils_deep_merge$B_5.$$arity = 2);\n    })($nesting[0], $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/helpers\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$define_method', '$instance_exec', '$to_proc', '$do', '$defhelper', '$[]=', '$-']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Element_defhelper_1, TMP_Element_defhelper$B_4;\n\n        \n        Opal.defs(self, '$defhelper', TMP_Element_defhelper_1 = function $$defhelper(name) {\n          var TMP_2, self = this, $iter = TMP_Element_defhelper_1.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Element_defhelper_1.$$p = null;\n          return $send(self, 'define_method', [name], (TMP_2 = function($a_rest){var self = TMP_2.$$s || this, body, args;\n\n            body = TMP_2.$$p || nil;\n            if (body) TMP_2.$$p = null;\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n          \n            $send(self, 'instance_exec', Opal.to_a(args), block.$to_proc());\n            if ($truthy(body)) {\n              $send(self, 'do', [], body.$to_proc())};\n            return self;}, TMP_2.$$s = self, TMP_2.$$arity = -1, TMP_2))\n        }, TMP_Element_defhelper_1.$$arity = 1);\n        return Opal.defs(self, '$defhelper!', TMP_Element_defhelper$B_4 = function(name, attribute) {\n          var TMP_3, self = this;\n\n          if (attribute == null) {\n            attribute = name;\n          }\n          return $send(self, 'defhelper', [\"\" + (name) + \"!\"], (TMP_3 = function(){var self = TMP_3.$$s || this, $writer = nil;\n            if (self.attributes == null) self.attributes = nil;\n\n          \n            $writer = [attribute, true];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3))\n        }, TMP_Element_defhelper$B_4.$$arity = -2);\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/a\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$each', '$defhelper', '$to_s', '$[]=', '$-', '$defhelper!', '$<<']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $A(){};\n          var self = $A = $klass($base, $super, 'A', $A);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_A_1, TMP_A_3;\n\n          \n          $send($hash2([\"href\", \"url\", \"rel\", \"relative\", \"target\", \"type\", \"lang\", \"language\", \"media\"], {\"href\": \"href\", \"url\": \"href\", \"rel\": \"rel\", \"relative\": \"rel\", \"target\": \"target\", \"type\": \"type\", \"lang\": \"hreflang\", \"language\": \"hreflang\", \"media\": \"media\"}), 'each', [], (TMP_A_1 = function(name, attribute){var self = TMP_A_1.$$s || this, TMP_2;\nif (name == null) name = nil;if (attribute == null) attribute = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value.$to_s()];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_A_1.$$s = self, TMP_A_1.$$arity = 2, TMP_A_1));\n          self['$defhelper!'](\"download\");\n          self['$defhelper!'](\"ping\");\n          return $send(self, 'defhelper', [\"text\"], (TMP_A_3 = function(string){var self = TMP_A_3.$$s || this;\nif (string == null) string = nil;\n          return self['$<<'](string)}, TMP_A_3.$$s = self, TMP_A_3.$$arity = 1, TMP_A_3));\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/base\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$each', '$defhelper', '$to_s', '$[]=', '$-']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Base(){};\n          var self = $Base = $klass($base, $super, 'Base', $Base);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Base_1;\n\n          return $send($hash2([\"href\", \"url\", \"target\"], {\"href\": \"href\", \"url\": \"href\", \"target\": \"target\"}), 'each', [], (TMP_Base_1 = function(name, attribute){var self = TMP_Base_1.$$s || this, TMP_2;\nif (name == null) name = nil;if (attribute == null) attribute = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value.$to_s()];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_Base_1.$$s = self, TMP_Base_1.$$arity = 2, TMP_Base_1))\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/blockquote\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$defhelper', '$to_s', '$[]=', '$-']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Blockquote(){};\n          var self = $Blockquote = $klass($base, $super, 'Blockquote', $Blockquote);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Blockquote_1;\n\n          return $send(self, 'defhelper', [\"cite\"], (TMP_Blockquote_1 = function(value){var self = TMP_Blockquote_1.$$s || this, $writer = nil;\n            if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n          \n            $writer = [\"cite\", value.$to_s()];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_Blockquote_1.$$s = self, TMP_Blockquote_1.$$arity = 1, TMP_Blockquote_1))\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/button\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$each', '$defhelper', '$to_s', '$[]=', '$-', '$defhelper!']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Button(){};\n          var self = $Button = $klass($base, $super, 'Button', $Button);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Button_1;\n\n          \n          $send($hash2([\"form\", \"name\", \"type\", \"value\", \"action\", \"encoding\", \"method\", \"target\"], {\"form\": \"form\", \"name\": \"name\", \"type\": \"type\", \"value\": \"value\", \"action\": \"formaction\", \"encoding\": \"formenctype\", \"method\": \"formmethod\", \"target\": \"formtarget\"}), 'each', [], (TMP_Button_1 = function(name, attributes){var self = TMP_Button_1.$$s || this, TMP_2;\nif (name == null) name = nil;if (attributes == null) attributes = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value.$to_s()];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_Button_1.$$s = self, TMP_Button_1.$$arity = 2, TMP_Button_1));\n          self['$defhelper!'](\"autofocus\");\n          return self['$defhelper!'](\"disabled\");\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/canvas\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$each', '$defhelper', '$to_s', '$[]=', '$-']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Canvas(){};\n          var self = $Canvas = $klass($base, $super, 'Canvas', $Canvas);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Canvas_1;\n\n          return $send($hash2([\"width\", \"height\"], {\"width\": \"width\", \"height\": \"height\"}), 'each', [], (TMP_Canvas_1 = function(name, attribute){var self = TMP_Canvas_1.$$s || this, TMP_2;\nif (name == null) name = nil;if (attribute == null) attribute = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value.$to_s()];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_Canvas_1.$$s = self, TMP_Canvas_1.$$arity = 2, TMP_Canvas_1))\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/embed\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$each', '$defhelper', '$[]=', '$-']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Embed(){};\n          var self = $Embed = $klass($base, $super, 'Embed', $Embed);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Embed_1;\n\n          return $send($hash2([\"type\", \"height\", \"width\"], {\"type\": \"type\", \"height\": \"height\", \"width\": \"width\"}), 'each', [], (TMP_Embed_1 = function(name, attribute){var self = TMP_Embed_1.$$s || this, TMP_2;\nif (name == null) name = nil;if (attribute == null) attribute = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_Embed_1.$$s = self, TMP_Embed_1.$$arity = 2, TMP_Embed_1))\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/img\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$each', '$defhelper', '$to_s', '$[]=', '$-']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Img(){};\n          var self = $Img = $klass($base, $super, 'Img', $Img);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Img_1, TMP_Img_3;\n\n          \n          $send($hash2([\"src\", \"url\", \"alt\", \"description\", \"height\", \"width\", \"map\"], {\"src\": \"src\", \"url\": \"src\", \"alt\": \"alt\", \"description\": \"alt\", \"height\": \"height\", \"width\": \"width\", \"map\": \"usemap\"}), 'each', [], (TMP_Img_1 = function(name, attribute){var self = TMP_Img_1.$$s || this, TMP_2;\nif (name == null) name = nil;if (attribute == null) attribute = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value.$to_s()];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_Img_1.$$s = self, TMP_Img_1.$$arity = 2, TMP_Img_1));\n          return $send(self, 'defhelper', [\"map!\"], (TMP_Img_3 = function(){var self = TMP_Img_3.$$s || this, $writer = nil;\n            if (self.attributes == null) self.attributes = nil;\n\n          \n            $writer = [\"ismap\", true];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_Img_3.$$s = self, TMP_Img_3.$$arity = 0, TMP_Img_3));\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/input\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$each', '$defhelper', '$[]=', '$-']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Input(){};\n          var self = $Input = $klass($base, $super, 'Input', $Input);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Input_1;\n\n          return $send($hash2([\"type\", \"name\", \"value\", \"size\", \"place_holder\", \"read_only\", \"required\", \"limit\"], {\"type\": \"type\", \"name\": \"name\", \"value\": \"value\", \"size\": \"size\", \"place_holder\": \"placeholder\", \"read_only\": \"readonly\", \"required\": \"required\", \"limit\": \"maxlength\"}), 'each', [], (TMP_Input_1 = function(name, attribute){var self = TMP_Input_1.$$s || this, TMP_2;\nif (name == null) name = nil;if (attribute == null) attribute = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_Input_1.$$s = self, TMP_Input_1.$$arity = 2, TMP_Input_1))\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/link\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$each', '$defhelper', '$to_s', '$[]=', '$-']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Link(){};\n          var self = $Link = $klass($base, $super, 'Link', $Link);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Link_1;\n\n          return $send($hash2([\"cross_origin\", \"href\", \"href_lang\", \"media\", \"rel\", \"sizes\", \"type\"], {\"cross_origin\": \"crossorigin\", \"href\": \"href\", \"href_lang\": \"hreflang\", \"media\": \"media\", \"rel\": \"rel\", \"sizes\": \"sizes\", \"type\": \"type\"}), 'each', [], (TMP_Link_1 = function(name, attribute){var self = TMP_Link_1.$$s || this, TMP_2;\nif (name == null) name = nil;if (attribute == null) attribute = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value.$to_s()];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_Link_1.$$s = self, TMP_Link_1.$$arity = 2, TMP_Link_1))\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/object\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$each', '$defhelper', '$[]=', '$-']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Object(){};\n          var self = $Object = $klass($base, $super, 'Object', $Object);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Object_1;\n\n          return $send($hash2([\"type\", \"data\", \"name\", \"height\", \"width\"], {\"type\": \"type\", \"data\": \"data\", \"name\": \"name\", \"height\": \"height\", \"width\": \"width\"}), 'each', [], (TMP_Object_1 = function(name, attribute){var self = TMP_Object_1.$$s || this, TMP_2;\nif (name == null) name = nil;if (attribute == null) attribute = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_Object_1.$$s = self, TMP_Object_1.$$arity = 2, TMP_Object_1))\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/option\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$each', '$defhelper', '$[]=', '$-', '$defhelper!']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Option(){};\n          var self = $Option = $klass($base, $super, 'Option', $Option);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Option_1;\n\n          \n          $send([\"label\", \"value\"], 'each', [], (TMP_Option_1 = function(name){var self = TMP_Option_1.$$s || this, TMP_2;\nif (name == null) name = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_Option_1.$$s = self, TMP_Option_1.$$arity = 1, TMP_Option_1));\n          self['$defhelper!'](\"disabled\");\n          return self['$defhelper!'](\"selected\");\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/optgroup\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$each', '$defhelper', '$[]=', '$-', '$defhelper!']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Optgroup(){};\n          var self = $Optgroup = $klass($base, $super, 'Optgroup', $Optgroup);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Optgroup_1;\n\n          \n          $send([\"label\", \"value\"], 'each', [], (TMP_Optgroup_1 = function(name){var self = TMP_Optgroup_1.$$s || this, TMP_2;\nif (name == null) name = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_Optgroup_1.$$s = self, TMP_Optgroup_1.$$arity = 1, TMP_Optgroup_1));\n          self['$defhelper!'](\"disabled\");\n          return self['$defhelper!'](\"selected\");\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/select\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$each', '$defhelper', '$[]=', '$-', '$defhelper!']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Select(){};\n          var self = $Select = $klass($base, $super, 'Select', $Select);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Select_1;\n\n          \n          $send([\"form\", \"name\", \"size\"], 'each', [], (TMP_Select_1 = function(name){var self = TMP_Select_1.$$s || this, TMP_2;\nif (name == null) name = nil;\n          return $send(self, 'defhelper', [name], (TMP_2 = function(value){var self = TMP_2.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n            \n              $writer = [name, value];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_Select_1.$$s = self, TMP_Select_1.$$arity = 1, TMP_Select_1));\n          self['$defhelper!'](\"auto_focus\", \"autofocus\");\n          self['$defhelper!'](\"disabled\");\n          return self['$defhelper!'](\"required\");\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element/td\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$defhelper', '$to_s', '$[]=', '$-', '$join']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Td(){};\n          var self = $Td = $klass($base, $super, 'Td', $Td);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Td_1, TMP_Td_2, TMP_Td_3;\n\n          \n          $send(self, 'defhelper', [\"columns\"], (TMP_Td_1 = function(value){var self = TMP_Td_1.$$s || this, $writer = nil;\n            if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n          \n            $writer = [\"colspan\", value.$to_s()];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_Td_1.$$s = self, TMP_Td_1.$$arity = 1, TMP_Td_1));\n          $send(self, 'defhelper', [\"rows\"], (TMP_Td_2 = function(value){var self = TMP_Td_2.$$s || this, $writer = nil;\n            if (self.attributes == null) self.attributes = nil;\nif (value == null) value = nil;\n          \n            $writer = [\"rowspan\", value.$to_s()];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_Td_2.$$s = self, TMP_Td_2.$$arity = 1, TMP_Td_2));\n          return $send(self, 'defhelper', [\"headers\"], (TMP_Td_3 = function($a_rest){var self = TMP_Td_3.$$s || this, args, $writer = nil;\n            if (self.attributes == null) self.attributes = nil;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n          \n            $writer = [\"headers\", args.$join(\" \")];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_Td_3.$$s = self, TMP_Td_3.$$arity = -1, TMP_Td_3));\n        })($nesting[0], self, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html/element\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $range = Opal.range;\n\n  Opal.add_stubs(['$require', '$==', '$capitalize', '$const_defined?', '$new', '$const_get', '$each', '$to_proc', '$<<', '$end_with?', '$to_s', '$[]', '$[]=', '$-', '$===', '$has_key?', '$unshift', '$|', '$split', '$delete', '$to_a', '$deep_merge!', '$>>', '$extend!', '$pop', '$join', '$heredoc', '$defhelper', '$map', '$empty?', '$upcase', '$inspect']);\n  \n  self.$require(\"paggio/html/element/a\");\n  self.$require(\"paggio/html/element/base\");\n  self.$require(\"paggio/html/element/blockquote\");\n  self.$require(\"paggio/html/element/button\");\n  self.$require(\"paggio/html/element/canvas\");\n  self.$require(\"paggio/html/element/embed\");\n  self.$require(\"paggio/html/element/img\");\n  self.$require(\"paggio/html/element/input\");\n  self.$require(\"paggio/html/element/link\");\n  self.$require(\"paggio/html/element/object\");\n  self.$require(\"paggio/html/element/option\");\n  self.$require(\"paggio/html/element/optgroup\");\n  self.$require(\"paggio/html/element/select\");\n  self.$require(\"paggio/html/element/td\");\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Element_new_1, TMP_Element_initialize_2, TMP_Element_each_3, TMP_Element_$lt$lt_4, TMP_Element_method_missing_5, TMP_Element_$$_6, TMP_Element_do_7, TMP_Element_$gt$gt_8, TMP_Element_9, TMP_Element_11, TMP_Element_inspect_13;\n\n        def.children = def.attributes = def.class_names = def.owner = def.name = nil;\n        \n        Opal.defs(self, '$new', TMP_Element_new_1 = function(owner, name, attributes) {\n          var self = this, $iter = TMP_Element_new_1.$$p, $yield = $iter || nil, const$ = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if (attributes == null) {\n            attributes = $hash2([], {});\n          }\n          if ($iter) TMP_Element_new_1.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          if (self['$=='](Opal.const_get_relative($nesting, 'Element'))) {\n            } else {\n            return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_Element_new_1, false, $Element), $zuper, $iter)\n          };\n          const$ = name.$capitalize();\n          if ($truthy(self['$const_defined?'](const$))) {\n            return self.$const_get(const$).$new(owner, name, attributes)\n            } else {\n            return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_Element_new_1, false, $Element), $zuper, $iter)\n          };\n        }, TMP_Element_new_1.$$arity = -3);\n        \n        Opal.defn(self, '$initialize', TMP_Element_initialize_2 = function $$initialize(owner, name, attributes) {\n          var self = this;\n\n          if (attributes == null) {\n            attributes = $hash2([], {});\n          }\n          \n          self.owner = owner;\n          self.name = name;\n          self.attributes = attributes;\n          self.children = [];\n          return (self.class_names = []);\n        }, TMP_Element_initialize_2.$$arity = -3);\n        \n        Opal.defn(self, '$each', TMP_Element_each_3 = function $$each() {\n          var self = this, $iter = TMP_Element_each_3.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Element_each_3.$$p = null;\n          return $send(self.children, 'each', [], block.$to_proc())\n        }, TMP_Element_each_3.$$arity = 0);\n        \n        Opal.defn(self, '$<<', TMP_Element_$lt$lt_4 = function(what) {\n          var self = this;\n\n          \n          self.children['$<<'](what);\n          return self;\n        }, TMP_Element_$lt$lt_4.$$arity = 1);\n        \n        Opal.defn(self, '$method_missing', TMP_Element_method_missing_5 = function $$method_missing(name, content) {\n          var $a, self = this, $iter = TMP_Element_method_missing_5.$$p, block = $iter || nil, $writer = nil;\n\n          if (content == null) {\n            content = nil;\n          }\n          if ($iter) TMP_Element_method_missing_5.$$p = null;\n          \n          if ($truthy(name.$to_s()['$end_with?'](\"!\"))) {\n            \n            $writer = [\"id\", name['$[]']($range(0, -2, false))];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n            } else {\n            self.class_names['$<<'](name)\n          };\n          if ($truthy(Opal.const_get_qualified('::', 'Hash')['$==='](content))) {\n            \n            if ($truthy(($truthy($a = content['$has_key?'](\"class\")) ? $a : content['$has_key?'](\"classes\")))) {\n              $send(self.class_names, 'unshift', Opal.to_a(content.$delete(\"class\").$to_s().$split()['$|'](content.$delete(\"classes\").$to_a())))};\n            Opal.const_get_qualified(Opal.const_get_qualified('::', 'Paggio'), 'Utils')['$deep_merge!'](self.attributes, content);\n          } else if ($truthy(content)) {\n            self['$>>'](content)};\n          if ($truthy(block)) {\n            $send(self.owner, 'extend!', [self], block.$to_proc())};\n          return self;\n        }, TMP_Element_method_missing_5.$$arity = -2);\n        \n        Opal.defn(self, '$[]', TMP_Element_$$_6 = function($a_rest) {\n          var self = this, names, last = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          names = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            names[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          if ($truthy((last = self.class_names.$pop()))) {\n            self.class_names['$<<']([last].concat(Opal.to_a(names)).$join(\"-\"))};\n          return self;\n        }, TMP_Element_$$_6.$$arity = -1);\n        \n        Opal.defn(self, '$do', TMP_Element_do_7 = function() {\n          var self = this, $iter = TMP_Element_do_7.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Element_do_7.$$p = null;\n          \n          $send(self.owner, 'extend!', [self], block.$to_proc());\n          return self;\n        }, TMP_Element_do_7.$$arity = 0);\n        \n        Opal.defn(self, '$>>', TMP_Element_$gt$gt_8 = function(content) {\n          var self = this;\n\n          \n          self['$<<'](Opal.const_get_qualified(Opal.const_get_qualified('::', 'Paggio'), 'Utils').$heredoc(content.$to_s()));\n          return self;\n        }, TMP_Element_$gt$gt_8.$$arity = 1);\n        $send(self, 'defhelper', [\"style\"], (TMP_Element_9 = function(hash){var self = TMP_Element_9.$$s || this, TMP_10, $writer = nil;\n          if (self.attributes == null) self.attributes = nil;\nif (hash == null) hash = nil;\n        \n          $writer = [\"style\", $send(hash, 'map', [], (TMP_10 = function(name, value){var self = TMP_10.$$s || this;\nif (name == null) name = nil;if (value == null) value = nil;\n          return \"\" + (name) + \": \" + (value)}, TMP_10.$$s = self, TMP_10.$$arity = 2, TMP_10)).$join(\";\")];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_Element_9.$$s = self, TMP_Element_9.$$arity = 1, TMP_Element_9));\n        $send(self, 'defhelper', [\"data\"], (TMP_Element_11 = function(hash){var self = TMP_Element_11.$$s || this, TMP_12;\nif (hash == null) hash = nil;\n        return $send(hash, 'each', [], (TMP_12 = function(name, value){var self = TMP_12.$$s || this, $writer = nil;\n            if (self.attributes == null) self.attributes = nil;\nif (name == null) name = nil;if (value == null) value = nil;\n          \n            $writer = [\"\" + \"data-\" + (name), value.$to_s()];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_12.$$s = self, TMP_12.$$arity = 2, TMP_12))}, TMP_Element_11.$$s = self, TMP_Element_11.$$arity = 1, TMP_Element_11));\n        return (Opal.defn(self, '$inspect', TMP_Element_inspect_13 = function $$inspect() {\n          var self = this;\n\n          if ($truthy(self.children['$empty?']())) {\n            return \"\" + \"#<HTML::Element(\" + (self.name.$upcase()) + \")>\"\n            } else {\n            return \"\" + \"#<HTML::Element(\" + (self.name.$upcase()) + \"): \" + (self.children.$inspect()['$[]']($range(1, -2, false))) + \">\"\n          }\n        }, TMP_Element_inspect_13.$$arity = 0), nil) && 'inspect';\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/html\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;\n\n  Opal.add_stubs(['$require', '$attr_reader', '$raise', '$==', '$arity', '$instance_exec', '$to_proc', '$call', '$<<', '$first', '$===', '$instance_eval', '$each', '$end_with?', '$to_s', '$empty?', '$heredoc', '$shift', '$new', '$[]', '$inspect']);\n  \n  self.$require(\"paggio/html/helpers\");\n  self.$require(\"paggio/html/element\");\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_HTML_initialize_1, TMP_HTML_$lt$lt_2, TMP_HTML_root$B_3, TMP_HTML_roots$B_4, TMP_HTML_element$B_5, TMP_HTML_extend$B_6, TMP_HTML_each_8, TMP_HTML_method_missing_9, TMP_HTML_inspect_11;\n\n      def.current = def.roots = def.version = nil;\n      \n      self.$attr_reader(\"version\");\n      \n      Opal.defn(self, '$initialize', TMP_HTML_initialize_1 = function $$initialize(version) {\n        var self = this, $iter = TMP_HTML_initialize_1.$$p, block = $iter || nil;\n\n        if (version == null) {\n          version = 5;\n        }\n        if ($iter) TMP_HTML_initialize_1.$$p = null;\n        \n        if ($truthy(block)) {\n          } else {\n          Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_qualified('::', 'ArgumentError'), \"no block given\")\n        };\n        self.version = version;\n        self.roots = [];\n        self.current = nil;\n        if (block.$arity()['$=='](0)) {\n          return $send(self, 'instance_exec', [], block.$to_proc())\n          } else {\n          return block.$call(self)\n        };\n      }, TMP_HTML_initialize_1.$$arity = -1);\n      \n      Opal.defn(self, '$<<', TMP_HTML_$lt$lt_2 = function(what) {\n        var $a, self = this;\n\n        return ($truthy($a = self.current) ? $a : self.roots)['$<<'](what)\n      }, TMP_HTML_$lt$lt_2.$$arity = 1);\n      \n      Opal.defn(self, '$root!', TMP_HTML_root$B_3 = function() {\n        var self = this;\n\n        return self.roots.$first()\n      }, TMP_HTML_root$B_3.$$arity = 0);\n      \n      Opal.defn(self, '$roots!', TMP_HTML_roots$B_4 = function() {\n        var self = this;\n\n        return self.roots\n      }, TMP_HTML_roots$B_4.$$arity = 0);\n      \n      Opal.defn(self, '$element!', TMP_HTML_element$B_5 = function() {\n        var self = this;\n\n        return self.current\n      }, TMP_HTML_element$B_5.$$arity = 0);\n      \n      Opal.defn(self, '$extend!', TMP_HTML_extend$B_6 = function(element) {\n        var $a, TMP_7, self = this, $iter = TMP_HTML_extend$B_6.$$p, block = $iter || nil, old = nil, result = nil;\n\n        if (element == null) {\n          element = nil;\n        }\n        if ($iter) TMP_HTML_extend$B_6.$$p = null;\n        \n        $a = [self.current, element], (old = $a[0]), (self.current = $a[1]), $a;\n        result = block.$call(self);\n        if ($truthy(Opal.const_get_qualified('::', 'String')['$==='](result))) {\n          $send(self.current, 'instance_eval', [], (TMP_7 = function(){var self = TMP_7.$$s || this;\n\n          return (self.inner_html = result)}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7))};\n        self.current = old;\n        return self;\n      }, TMP_HTML_extend$B_6.$$arity = -1);\n      \n      Opal.defn(self, '$each', TMP_HTML_each_8 = function $$each() {\n        var self = this, $iter = TMP_HTML_each_8.$$p, block = $iter || nil;\n\n        if ($iter) TMP_HTML_each_8.$$p = null;\n        return $send(self.roots, 'each', [], block.$to_proc())\n      }, TMP_HTML_each_8.$$arity = 0);\n      \n      Opal.defn(self, '$method_missing', TMP_HTML_method_missing_9 = function $$method_missing(name, $a_rest) {\n        var $b, TMP_10, self = this, args, $iter = TMP_HTML_method_missing_9.$$p, block = $iter || nil, content = nil, element = nil, parent = nil, result = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 1] = arguments[$arg_idx];\n        }\n        if ($iter) TMP_HTML_method_missing_9.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        \n        if ($truthy(name.$to_s()['$end_with?'](\"!\"))) {\n          return $send(self, Opal.find_super_dispatcher(self, 'method_missing', TMP_HTML_method_missing_9, false), $zuper, $iter)};\n        if ($truthy(($truthy($b = args['$empty?']()) ? $b : Opal.const_get_qualified('::', 'Hash')['$==='](args.$first())))) {\n          } else {\n          content = Opal.const_get_qualified(Opal.const_get_qualified('::', 'Paggio'), 'Utils').$heredoc(args.$shift().$to_s())\n        };\n        element = $send(Opal.const_get_relative($nesting, 'Element'), 'new', [self, name].concat(Opal.to_a(args)));\n        if ($truthy(content)) {\n          element['$<<'](content)};\n        if ($truthy(block)) {\n          \n          parent = self.current;\n          self.current = element;\n          result = block.$call(self);\n          self.current = parent;\n          if ($truthy(Opal.const_get_qualified('::', 'String')['$==='](result))) {\n            $send(element, 'instance_eval', [], (TMP_10 = function(){var self = TMP_10.$$s || this;\n\n            return (self.inner_html = result)}, TMP_10.$$s = self, TMP_10.$$arity = 0, TMP_10))};};\n        self['$<<'](element);\n        return element;\n      }, TMP_HTML_method_missing_9.$$arity = -2);\n      return (Opal.defn(self, '$inspect', TMP_HTML_inspect_11 = function $$inspect() {\n        var self = this;\n\n        if ($truthy(self.roots['$empty?']())) {\n          return \"\" + \"#<HTML(\" + (self.version) + \")>\"\n          } else {\n          return \"\" + \"#<HTML(\" + (self.version) + \"): \" + (self.roots.$inspect()['$[]']($range(1, -2, false))) + \">\"\n        }\n      }, TMP_HTML_inspect_11.$$arity = 0), nil) && 'inspect';\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/css/unit\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  var TMP_23, self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$map', '$to_proc', '$attr_reader', '$===', '$respond_to?', '$raise', '$class', '$to_u', '$new', '$==', '$convert', '$type', '$number', '$hash', '$each', '$define_method', '$+', '$compatible?', '$-', '$*', '$/', '$to_i', '$to_f', '$private', '$include?', '$class_eval', '$old_percent', '$match', '$[]', '$__send__', '$downcase']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $CSS(){};\n      var self = $CSS = $klass($base, $super, 'CSS', $CSS);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Unit(){};\n        var self = $Unit = $klass($base, $super, 'Unit', $Unit);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Unit_initialize_1, TMP_Unit_coerce_2, TMP_Unit_$eq$eq_3, TMP_Unit_$eq$eq$eq_4, TMP_Unit_hash_5, TMP_Unit_6, TMP_Unit_$_8, TMP_Unit_$_9, TMP_Unit_$_10, TMP_Unit_$_11, TMP_Unit_$$_12, TMP_Unit_$$_13, TMP_Unit_to_i_14, TMP_Unit_to_f_15, TMP_Unit_to_u_16, TMP_Unit_to_s_17, TMP_Unit_compatible$q_18, TMP_Unit_convert_19;\n\n        def.type = def.number = nil;\n        \n        Opal.const_set($nesting[0], 'TYPES', $send([\"em\", \"ex\", \"ch\", \"rem\", \"vh\", \"vw\", \"vmin\", \"vmax\", \"px\", \"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"s\", \"deg\"], 'map', [], \"to_sym\".$to_proc()));\n        Opal.const_set($nesting[0], 'COMPATIBLE', $send([\"in\", \"pt\", \"mm\", \"cm\", \"px\", \"pc\"], 'map', [], \"to_sym\".$to_proc()));\n        self.$attr_reader(\"type\", \"number\");\n        \n        Opal.defn(self, '$initialize', TMP_Unit_initialize_1 = function $$initialize(number, type) {\n          var self = this;\n\n          \n          self.number = number;\n          return (self.type = type);\n        }, TMP_Unit_initialize_1.$$arity = 2);\n        \n        Opal.defn(self, '$coerce', TMP_Unit_coerce_2 = function $$coerce(other) {\n          var self = this;\n\n          return [self, other]\n        }, TMP_Unit_coerce_2.$$arity = 1);\n        \n        Opal.defn(self, '$==', TMP_Unit_$eq$eq_3 = function(other) {\n          var self = this;\n\n          \n          if ($truthy(Opal.const_get_relative($nesting, 'Unit')['$==='](other))) {\n            } else {\n            \n            if ($truthy(other['$respond_to?'](\"to_u\"))) {\n              } else {\n              self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"no implicit conversion of \" + (other.$class()) + \" into Unit\")\n            };\n            other = other.$to_u();\n          };\n          if ($truthy(Opal.const_get_relative($nesting, 'Unit')['$==='](other))) {\n            } else {\n            other = Opal.const_get_relative($nesting, 'Unit').$new(other, self.type)\n          };\n          return self.number['$=='](self.$convert(other, self.type));\n        }, TMP_Unit_$eq$eq_3.$$arity = 1);\n        \n        Opal.defn(self, '$===', TMP_Unit_$eq$eq$eq_4 = function(other) {\n          var $a, self = this;\n\n          return (($a = self.type['$=='](other.$type())) ? self.number['$=='](other.$number()) : self.type['$=='](other.$type()))\n        }, TMP_Unit_$eq$eq$eq_4.$$arity = 1);\n        Opal.alias(self, \"eql?\", \"==\");\n        \n        Opal.defn(self, '$hash', TMP_Unit_hash_5 = function $$hash() {\n          var self = this;\n\n          return [self.number, self.type].$hash()\n        }, TMP_Unit_hash_5.$$arity = 0);\n        $send(Opal.const_get_relative($nesting, 'TYPES'), 'each', [], (TMP_Unit_6 = function(name){var self = TMP_Unit_6.$$s || this, TMP_7;\nif (name == null) name = nil;\n        return $send(self, 'define_method', [name], (TMP_7 = function(){var self = TMP_7.$$s || this;\n\n          return Opal.const_get_relative($nesting, 'Unit').$new(self.$convert(self, name), name)}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7))}, TMP_Unit_6.$$s = self, TMP_Unit_6.$$arity = 1, TMP_Unit_6));\n        \n        Opal.defn(self, '$+', TMP_Unit_$_8 = function(other) {\n          var $a, self = this;\n\n          \n          if ($truthy(Opal.const_get_relative($nesting, 'Unit')['$==='](other))) {\n            } else {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_plus(self.number, other), self.type)\n          };\n          if (self.type['$=='](other.$type())) {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_plus(self.number, other.$number()), self.type)\n          } else if ($truthy(($truthy($a = self['$compatible?'](self)) ? self['$compatible?'](other) : $a))) {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_plus(self.number, self.$convert(other, self.type)), self.type)\n            } else {\n            return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + (other.$type()) + \" isn't compatible with \" + (self.type))\n          };\n        }, TMP_Unit_$_8.$$arity = 1);\n        \n        Opal.defn(self, '$-', TMP_Unit_$_9 = function(other) {\n          var $a, self = this;\n\n          \n          if ($truthy(Opal.const_get_relative($nesting, 'Unit')['$==='](other))) {\n            } else {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_minus(self.number, other), self.type)\n          };\n          if (self.type['$=='](other.$type())) {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_minus(self.number, other.$number()), self.type)\n          } else if ($truthy(($truthy($a = self['$compatible?'](self)) ? self['$compatible?'](other) : $a))) {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_minus(self.number, self.$convert(other, self.type)), self.type)\n            } else {\n            return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + (other.$type()) + \" isn't compatible with \" + (self.type))\n          };\n        }, TMP_Unit_$_9.$$arity = 1);\n        \n        Opal.defn(self, '$*', TMP_Unit_$_10 = function(other) {\n          var $a, self = this;\n\n          \n          if ($truthy(Opal.const_get_relative($nesting, 'Unit')['$==='](other))) {\n            } else {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_times(self.number, other), self.type)\n          };\n          if (self.type['$=='](other.$type())) {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_times(self.number, other.$number()), self.type)\n          } else if ($truthy(($truthy($a = self['$compatible?'](self)) ? self['$compatible?'](other) : $a))) {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_times(self.number, self.$convert(other, self.type)), self.type)\n            } else {\n            return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + (other.$type()) + \" isn't compatible with \" + (self.type))\n          };\n        }, TMP_Unit_$_10.$$arity = 1);\n        \n        Opal.defn(self, '$/', TMP_Unit_$_11 = function(other) {\n          var $a, self = this;\n\n          \n          if ($truthy(Opal.const_get_relative($nesting, 'Unit')['$==='](other))) {\n            } else {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_divide(self.number, other), self.type)\n          };\n          if (self.type['$=='](other.$type())) {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_divide(self.number, other.$number()), self.type)\n          } else if ($truthy(($truthy($a = self['$compatible?'](self)) ? self['$compatible?'](other) : $a))) {\n            return Opal.const_get_relative($nesting, 'Unit').$new($rb_divide(self.number, self.$convert(other, self.type)), self.type)\n            } else {\n            return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + (other.$type()) + \" isn't compatible with \" + (self.type))\n          };\n        }, TMP_Unit_$_11.$$arity = 1);\n        \n        Opal.defn(self, '$-@', TMP_Unit_$$_12 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Unit').$new($rb_times(self.number, -1), self.type)\n        }, TMP_Unit_$$_12.$$arity = 0);\n        \n        Opal.defn(self, '$+@', TMP_Unit_$$_13 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Unit').$new(self.number, self.type)\n        }, TMP_Unit_$$_13.$$arity = 0);\n        \n        Opal.defn(self, '$to_i', TMP_Unit_to_i_14 = function $$to_i() {\n          var self = this;\n\n          return self.number.$to_i()\n        }, TMP_Unit_to_i_14.$$arity = 0);\n        \n        Opal.defn(self, '$to_f', TMP_Unit_to_f_15 = function $$to_f() {\n          var self = this;\n\n          return self.number.$to_f()\n        }, TMP_Unit_to_f_15.$$arity = 0);\n        \n        Opal.defn(self, '$to_u', TMP_Unit_to_u_16 = function $$to_u() {\n          var self = this;\n\n          return self\n        }, TMP_Unit_to_u_16.$$arity = 0);\n        \n        Opal.defn(self, '$to_s', TMP_Unit_to_s_17 = function $$to_s() {\n          var self = this;\n\n          return \"\" + (self.number) + (self.type)\n        }, TMP_Unit_to_s_17.$$arity = 0);\n        Opal.alias(self, \"to_str\", \"to_s\");\n        Opal.alias(self, \"inspect\", \"to_s\");\n        self.$private();\n        \n        Opal.defn(self, '$compatible?', TMP_Unit_compatible$q_18 = function(unit) {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'COMPATIBLE')['$include?'](unit.$type())\n        }, TMP_Unit_compatible$q_18.$$arity = 1);\n        return (Opal.defn(self, '$convert', TMP_Unit_convert_19 = function $$convert(unit, type) {\n          var self = this, value = nil, px = nil, $case = nil;\n\n          \n          value = unit.$number();\n          if (unit.$type()['$=='](type)) {\n            return value};\n          px = (function() {$case = unit.$type();\n          if (\"in\"['$===']($case)) {return $rb_times(value, 96)}\n          else if (\"pt\"['$===']($case)) {return $rb_divide($rb_times(value, 4.0), 3.0)}\n          else if (\"pc\"['$===']($case)) {return $rb_divide($rb_times($rb_divide(value, 12), 4.0), 3.0)}\n          else if (\"mm\"['$===']($case)) {return $rb_times(value, 3.77953)}\n          else if (\"cm\"['$===']($case)) {return $rb_times($rb_times(value, 10), 3.77953)}\n          else if (\"px\"['$===']($case)) {return value}\n          else { return nil }})();\n          return (function() {$case = type;\n          if (\"in\"['$===']($case)) {return $rb_divide(px, 96.0)}\n          else if (\"pt\"['$===']($case)) {return $rb_divide($rb_divide(px, 4.0), 3.0)}\n          else if (\"pc\"['$===']($case)) {return $rb_divide($rb_divide($rb_times(px, 12), 4.0), 3.0)}\n          else if (\"mm\"['$===']($case)) {return $rb_divide(px, 3.77953)}\n          else if (\"cm\"['$===']($case)) {return $rb_divide($rb_divide(px, 10), 3.77953)}\n          else if (\"px\"['$===']($case)) {return px}\n          else { return nil }})();\n        }, TMP_Unit_convert_19.$$arity = 2), nil) && 'convert';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Numeric(){};\n    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Numeric_20, TMP_Numeric_to_u_22;\n\n    \n    $send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Paggio'), 'CSS'), 'Unit'), 'TYPES'), 'each', [], (TMP_Numeric_20 = function(name){var self = TMP_Numeric_20.$$s || this, TMP_21;\nif (name == null) name = nil;\n    return $send(self, 'define_method', [name], (TMP_21 = function(){var self = TMP_21.$$s || this;\n\n      return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Paggio'), 'CSS'), 'Unit').$new(self, name)}, TMP_21.$$s = self, TMP_21.$$arity = 0, TMP_21))}, TMP_Numeric_20.$$s = self, TMP_Numeric_20.$$arity = 1, TMP_Numeric_20));\n    return (Opal.defn(self, '$to_u', TMP_Numeric_to_u_22 = function $$to_u() {\n      var self = this;\n\n      return self\n    }, TMP_Numeric_to_u_22.$$arity = 0), nil) && 'to_u';\n  })($nesting[0], null, $nesting);\n  $send([Opal.const_get_relative($nesting, 'Fixnum'), Opal.const_get_relative($nesting, 'Float')], 'each', [], (TMP_23 = function(klass){var self = TMP_23.$$s || this, TMP_24;\nif (klass == null) klass = nil;\n  return $send(klass, 'class_eval', [], (TMP_24 = function(){var self = TMP_24.$$s || this, TMP_$_25;\n\n    \n      Opal.alias(self, \"old_percent\", \"%\");\n      return (Opal.def(self, '$%', TMP_$_25 = function(other) {\n        var self = this;\n\n        if (other == null) {\n          other = nil;\n        }\n        if ($truthy(other)) {\n          return self.$old_percent(other)\n          } else {\n          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Paggio'), 'CSS'), 'Unit').$new(self, \"%\")\n        }\n      }, TMP_$_25.$$arity = -1), nil) && '%';}, TMP_24.$$s = self, TMP_24.$$arity = 0, TMP_24))}, TMP_23.$$s = self, TMP_23.$$arity = 1, TMP_23));\n  (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_to_u_26;\n\n    return (Opal.defn(self, '$to_u', TMP_String_to_u_26 = function $$to_u() {\n      var self = this, matches = nil, value = nil, unit = nil;\n\n      if ($truthy((matches = self.$match(/^([\\d+.]+)(.+)?$/)))) {\n        \n        value = matches['$[]'](1).$to_f();\n        if ($truthy((unit = matches['$[]'](2)))) {\n          return value.$__send__(unit.$downcase())\n          } else {\n          return value\n        };\n        } else {\n        return 0\n      }\n    }, TMP_String_to_u_26.$$arity = 0), nil) && 'to_u'\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $NilClass(){};\n    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NilClass_to_u_27;\n\n    return (Opal.defn(self, '$to_u', TMP_NilClass_to_u_27 = function $$to_u() {\n      var self = this;\n\n      return 0\n    }, TMP_NilClass_to_u_27.$$arity = 0), nil) && 'to_u'\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/css/color\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$each', '$map', '$to_proc', '$define_method', '$new']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $CSS(){};\n      var self = $CSS = $klass($base, $super, 'CSS', $CSS);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Color(){};\n        var self = $Color = $klass($base, $super, 'Color', $Color);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Color_initialize_1;\n\n        return (Opal.defn(self, '$initialize', TMP_Color_initialize_1 = function $$initialize(value, type) {\n          var self = this;\n\n          \n          self.internal = value;\n          return (self.type = type);\n        }, TMP_Color_initialize_1.$$arity = 2), nil) && 'initialize'\n      })($nesting[0], null, $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_2;\n\n    return $send($send([\"rgb\", \"rgba\", \"hsl\", \"hsla\"], 'map', [], \"to_sym\".$to_proc()), 'each', [], (TMP_String_2 = function(name){var self = TMP_String_2.$$s || this, TMP_3;\nif (name == null) name = nil;\n    return $send(self, 'define_method', [name], (TMP_3 = function(){var self = TMP_3.$$s || this;\n\n      return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Paggio'), 'CSS'), 'Color').$new(self, name)}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3))}, TMP_String_2.$$s = self, TMP_String_2.$$arity = 1, TMP_String_2))\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $Array(){};\n    var self = $Array = $klass($base, $super, 'Array', $Array);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_4;\n\n    return $send($send([\"rgb\", \"rgba\", \"hsl\", \"hsla\"], 'map', [], \"to_sym\".$to_proc()), 'each', [], (TMP_Array_4 = function(name){var self = TMP_Array_4.$$s || this, TMP_5;\nif (name == null) name = nil;\n    return $send(self, 'define_method', [name], (TMP_5 = function(){var self = TMP_5.$$s || this;\n\n      return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Paggio'), 'CSS'), 'Color').$new(self, name)}, TMP_5.$$s = self, TMP_5.$$arity = 0, TMP_5))}, TMP_Array_4.$$s = self, TMP_Array_4.$$arity = 1, TMP_Array_4))\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/css/definition\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$new', '$==', '$arity', '$instance_exec', '$to_proc', '$call', '$empty?', '$each', '$inspect', '$to_s', '$define_method', '$a', '$===', '$first', '$>', '$length', '$raise', '$style', '$name', '$value', '$[]', '$join', '$map', '$to_i', '$*', '$end_with?', '$__send__', '$<<', '$last', '$pop', '$!', '$other', '$shift', '$horizontal?', '$private']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $CSS(){};\n      var self = $CSS = $klass($base, $super, 'CSS', $CSS);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Definition(){};\n        var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_initialize_1, TMP_Definition_empty$q_2, TMP_Definition_each_3, TMP_Definition_gradient_4, TMP_Definition_url_5, TMP_Definition_6, TMP_Definition_rgb_8, TMP_Definition_rgba_9, TMP_Definition_10, TMP_Definition_12, TMP_Definition_background_16, TMP_Definition_border_22, TMP_Definition_box_25, TMP_Definition_opacity_26, TMP_Definition_animation_28, TMP_Definition_transition_29, TMP_Definition_user_select_30, TMP_Definition_transform_31, TMP_Definition_filter_32, TMP_Definition_method_missing_33, TMP_Definition_style_35, TMP_Definition_style$B_36;\n\n        def.style = def.important = nil;\n        \n        Opal.const_set($nesting[0], 'Style', Opal.const_get_qualified('::', 'Struct').$new(\"name\", \"value\", \"important\"));\n        \n        Opal.defn(self, '$initialize', TMP_Definition_initialize_1 = function $$initialize() {\n          var self = this, $iter = TMP_Definition_initialize_1.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Definition_initialize_1.$$p = null;\n          \n          self.style = [];\n          if ($truthy(block)) {\n            if (block.$arity()['$=='](0)) {\n              return $send(self, 'instance_exec', [], block.$to_proc())\n              } else {\n              return block.$call(self)\n            }\n            } else {\n            return nil\n          };\n        }, TMP_Definition_initialize_1.$$arity = 0);\n        \n        Opal.defn(self, '$empty?', TMP_Definition_empty$q_2 = function() {\n          var self = this;\n\n          return self.style['$empty?']()\n        }, TMP_Definition_empty$q_2.$$arity = 0);\n        \n        Opal.defn(self, '$each', TMP_Definition_each_3 = function $$each() {\n          var self = this, $iter = TMP_Definition_each_3.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Definition_each_3.$$p = null;\n          return $send(self.style, 'each', [], block.$to_proc())\n        }, TMP_Definition_each_3.$$arity = 0);\n        \n        Opal.defn(self, '$gradient', TMP_Definition_gradient_4 = function $$gradient($a_rest) {\n          var self = this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return $send(Opal.const_get_relative($nesting, 'Gradient'), 'new', Opal.to_a(args))\n        }, TMP_Definition_gradient_4.$$arity = -1);\n        \n        Opal.defn(self, '$url', TMP_Definition_url_5 = function $$url(value) {\n          var self = this;\n\n          return \"\" + \"url(\" + (value.$to_s().$inspect()) + \")\"\n        }, TMP_Definition_url_5.$$arity = 1);\n        $send([\"url\", \"blur\", \"brightness\", \"rotate\", \"contrast\", \"grayscale\", \"invert\", \"opacity\", \"saturate\", \"sepia\"], 'each', [], (TMP_Definition_6 = function(name){var self = TMP_Definition_6.$$s || this, TMP_7;\nif (name == null) name = nil;\n        return $send(self, 'define_method', [name], (TMP_7 = function(value){var self = TMP_7.$$s || this;\nif (value == null) value = nil;\n          return \"\" + (name) + \"(\" + (value) + \")\"}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7))}, TMP_Definition_6.$$s = self, TMP_Definition_6.$$arity = 1, TMP_Definition_6));\n        \n        Opal.defn(self, '$rgb', TMP_Definition_rgb_8 = function $$rgb(r, g, b) {\n          var self = this;\n\n          return \"\" + \"rgb(\" + (r) + \", \" + (g) + \", \" + (b) + \", \" + (self.$a()) + \")\"\n        }, TMP_Definition_rgb_8.$$arity = 3);\n        \n        Opal.defn(self, '$rgba', TMP_Definition_rgba_9 = function $$rgba(r, g, b, a) {\n          var self = this;\n\n          return \"\" + \"rgba(\" + (r) + \", \" + (g) + \", \" + (b) + \", \" + (a) + \")\"\n        }, TMP_Definition_rgba_9.$$arity = 4);\n        $send([\"scale\", \"skew\", \"translate\"], 'each', [], (TMP_Definition_10 = function(name){var self = TMP_Definition_10.$$s || this, TMP_11;\nif (name == null) name = nil;\n        return $send(self, 'define_method', [name], (TMP_11 = function(a, b){var self = TMP_11.$$s || this;\n\n            if (b == null) {\n              b = nil;\n            }if (a == null) a = nil;\n          if ($truthy(b)) {\n              return \"\" + (name) + \"(\" + (a) + \", \" + (b) + \")\"\n              } else {\n              return \"\" + (name) + \"(\" + (a) + \")\"\n            }}, TMP_11.$$s = self, TMP_11.$$arity = -2, TMP_11))}, TMP_Definition_10.$$s = self, TMP_Definition_10.$$arity = 1, TMP_Definition_10));\n        $send([\"translateX\", \"translateY\", \"translateZ\", \"rotateX\", \"rotateY\", \"rotateZ\", \"skewX\", \"skewY\", \"scaleX\", \"scaleY\"], 'each', [], (TMP_Definition_12 = function(name){var self = TMP_Definition_12.$$s || this, TMP_13;\nif (name == null) name = nil;\n        return $send(self, 'define_method', [name], (TMP_13 = function(value){var self = TMP_13.$$s || this;\nif (value == null) value = nil;\n          return \"\" + (name) + \"(\" + (value) + \")\"}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13))}, TMP_Definition_12.$$s = self, TMP_Definition_12.$$arity = 1, TMP_Definition_12));\n        \n        Opal.defn(self, '$background', TMP_Definition_background_16 = function $$background($a_rest) {\n          var TMP_14, TMP_15, self = this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($truthy(Opal.const_get_relative($nesting, 'Gradient')['$==='](args.$first()))) {\n            \n            if ($truthy($rb_gt(args.$length(), 1))) {\n              self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"multiple gradients not implemented yet\")};\n            return $send(args.$first(), 'each', [], (TMP_14 = function(s){var self = TMP_14.$$s || this, $a;\nif (s == null) s = nil;\n            return self.$style(($truthy($a = s.$name()) ? $a : \"background-image\"), s.$value())}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14));\n          } else if ($truthy(Opal.const_get_qualified('::', 'Hash')['$==='](args.$first()))) {\n            return $send(args.$first(), 'each', [], (TMP_15 = function(sub, value){var self = TMP_15.$$s || this;\nif (sub == null) sub = nil;if (value == null) value = nil;\n            return self.$style(\"\" + \"background-\" + (sub), value)}, TMP_15.$$s = self, TMP_15.$$arity = 2, TMP_15))\n            } else {\n            return self.$style(\"background\", args)\n          }\n        }, TMP_Definition_background_16.$$arity = -1);\n        \n        Opal.defn(self, '$border', TMP_Definition_border_22 = function $$border($a_rest) {\n          var TMP_17, self = this, args, options = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($truthy(Opal.const_get_qualified('::', 'Hash')['$==='](args.$first()))) {\n            \n            if (args.$length()['$=='](1)) {\n              options = args.$first()};\n            return $send(options, 'each', [], (TMP_17 = function(name, value){var self = TMP_17.$$s || this, TMP_18, TMP_19, TMP_21, $case = nil;\nif (name == null) name = nil;if (value == null) value = nil;\n            return (function() {$case = name;\n              if (\"top\"['$===']($case) || \"bottom\"['$===']($case) || \"left\"['$===']($case) || \"right\"['$===']($case)) {if ($truthy(Opal.const_get_qualified('::', 'Hash')['$==='](value))) {\n                return $send(value, 'each', [], (TMP_18 = function(n, v){var self = TMP_18.$$s || this;\nif (n == null) n = nil;if (v == null) v = nil;\n                return self.$style(\"\" + \"border-\" + (name) + \"-\" + (n), v)}, TMP_18.$$s = self, TMP_18.$$arity = 2, TMP_18))\n                } else {\n                return self.$style(\"\" + \"border-\" + (name), value)\n              }}\n              else if (\"radius\"['$===']($case)) {if ($truthy(Opal.const_get_qualified('::', 'Hash')['$==='](value))) {\n                return $send(value, 'each', [], (TMP_19 = function(horizontal, value){var self = TMP_19.$$s || this, TMP_20;\nif (horizontal == null) horizontal = nil;if (value == null) value = nil;\n                return $send(value, 'each', [], (TMP_20 = function(vertical, value){var self = TMP_20.$$s || this;\nif (vertical == null) vertical = nil;if (value == null) value = nil;\n                  \n                    self.$style(\"\" + \"-moz-border-radius-\" + (horizontal) + (vertical), value);\n                    self.$style(\"\" + \"-webkit-border-\" + (horizontal) + \"-\" + (vertical) + \"-radius\", value);\n                    return self.$style(\"\" + \"border-\" + (horizontal) + \"-\" + (vertical) + \"-radius\", value);}, TMP_20.$$s = self, TMP_20.$$arity = 2, TMP_20))}, TMP_19.$$s = self, TMP_19.$$arity = 2, TMP_19))\n                } else {\n                \n                self.$style(\"-moz-border-radius\", value);\n                self.$style(\"-webkit-border-radius\", value);\n                return self.$style(\"border-radius\", value);\n              }}\n              else if (\"color\"['$===']($case)) {if ($truthy(Opal.const_get_qualified('::', 'Hash')['$==='](value))) {\n                return $send(value, 'each', [], (TMP_21 = function(name, value){var self = TMP_21.$$s || this;\nif (name == null) name = nil;if (value == null) value = nil;\n                return self.$style(\"\" + \"border-\" + (name) + \"-color\", value)}, TMP_21.$$s = self, TMP_21.$$arity = 2, TMP_21))\n                } else {\n                return self.$style(\"border-color\", value)\n              }}\n              else {return self.$style(\"\" + \"border-\" + (name), value)}})()}, TMP_17.$$s = self, TMP_17.$$arity = 2, TMP_17));\n            } else {\n            return self.$style(\"border\", args)\n          }\n        }, TMP_Definition_border_22.$$arity = -1);\n        \n        Opal.defn(self, '$box', TMP_Definition_box_25 = function $$box(options) {\n          var TMP_23, self = this;\n\n          if ($truthy(Opal.const_get_qualified('::', 'Hash')['$==='](options))) {\n            return $send(options, 'each', [], (TMP_23 = function(name, value){var self = TMP_23.$$s || this, TMP_24, $case = nil;\nif (name == null) name = nil;if (value == null) value = nil;\n            return (function() {$case = name;\n              if (\"shadow\"['$===']($case)) {\n              if ($truthy(Opal.const_get_qualified('::', 'Array')['$==='](value))) {\n                if ($truthy(Opal.const_get_qualified('::', 'Array')['$==='](value['$[]'](0)))) {\n                  value = $send(value, 'map', [], (TMP_24 = function(v){var self = TMP_24.$$s || this;\nif (v == null) v = nil;\n                  return v.$join(\" \")}, TMP_24.$$s = self, TMP_24.$$arity = 1, TMP_24)).$join(\", \")\n                  } else {\n                  value = value.$join(\" \")\n                }};\n              self.$style(\"-moz-box-shadow\", value);\n              self.$style(\"-webkit-box-shadow\", value);\n              return self.$style(\"box-shadow\", value);}\n              else {return self.$style(\"\" + \"box-\" + (name), value)}})()}, TMP_23.$$s = self, TMP_23.$$arity = 2, TMP_23))\n            } else {\n            return self.$style(\"box\", options)\n          }\n        }, TMP_Definition_box_25.$$arity = 1);\n        \n        Opal.defn(self, '$opacity', TMP_Definition_opacity_26 = function $$opacity(value) {\n          var self = this;\n\n          \n          self.$style(\"opacity\", value);\n          self.$style(\"-moz-opacity\", value);\n          self.$style(\"-ms-filter\", \"\" + \"\\\"progid:DXImageTransform.Microsoft.Alpha(Opacity=\" + ($rb_times(value, 100).$to_i()) + \")\\\"\");\n          return self.$style(\"filter\", \"\" + \"alpha(opacity=\" + ($rb_times(value, 100).$to_i()) + \")\");\n        }, TMP_Definition_opacity_26.$$arity = 1);\n        \n        Opal.defn(self, '$animation', TMP_Definition_animation_28 = function $$animation($a_rest) {\n          var TMP_27, self = this, args, options = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](args.$first()))) {\n            \n            if (args.$length()['$=='](1)) {\n              options = args.$first()};\n            return $send(options, 'each', [], (TMP_27 = function(name, value){var self = TMP_27.$$s || this;\nif (name == null) name = nil;if (value == null) value = nil;\n            \n              self.$style(\"\" + \"-webkit-animation-\" + (name), value);\n              return self.$style(\"\" + \"animation-\" + (name), value);}, TMP_27.$$s = self, TMP_27.$$arity = 2, TMP_27));\n            } else {\n            \n            self.$style(\"animation\", args);\n            return self.$style(\"-webkit-animation\", args);\n          }\n        }, TMP_Definition_animation_28.$$arity = -1);\n        \n        Opal.defn(self, '$transition', TMP_Definition_transition_29 = function $$transition($a_rest) {\n          var self = this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          self.$style(\"transition\", args);\n          self.$style(\"-webkit-transition\", args);\n          return self.$style(\"-moz-transition\", args);\n        }, TMP_Definition_transition_29.$$arity = -1);\n        \n        Opal.defn(self, '$user_select', TMP_Definition_user_select_30 = function $$user_select($a_rest) {\n          var self = this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          self.$style(\"user-select\", args);\n          self.$style(\"-webkit-user-select\", args);\n          self.$style(\"-moz-user-select\", args);\n          return self.$style(\"-ms-user-select\", args);\n        }, TMP_Definition_user_select_30.$$arity = -1);\n        \n        Opal.defn(self, '$transform', TMP_Definition_transform_31 = function $$transform($a_rest) {\n          var self = this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          self.$style(\"transform\", args);\n          self.$style(\"-webkit-transform\", args);\n          self.$style(\"-moz-transform\", args);\n          self.$style(\"-ms-transform\", args);\n          return self.$style(\"-o-transform\", args);\n        }, TMP_Definition_transform_31.$$arity = -1);\n        \n        Opal.defn(self, '$filter', TMP_Definition_filter_32 = function $$filter($a_rest) {\n          var self = this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          self.$style(\"filter\", args);\n          self.$style(\"-webkit-filter\", args);\n          self.$style(\"-moz-filter\", args);\n          self.$style(\"-ms-filter\", args);\n          return self.$style(\"-o-filter\", args);\n        }, TMP_Definition_filter_32.$$arity = -1);\n        \n        Opal.defn(self, '$method_missing', TMP_Definition_method_missing_33 = function $$method_missing(name, $a_rest) {\n          var TMP_34, self = this, args, $iter = TMP_Definition_method_missing_33.$$p, block = $iter || nil, argument = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Definition_method_missing_33.$$p = null;\n          \n          name = name.$to_s();\n          if ($truthy(name['$end_with?'](\"!\"))) {\n            \n            name = name['$[]']($range(0, -2, false));\n            self.important = true;\n            $send(self, '__send__', [name].concat(Opal.to_a(args)), block.$to_proc());\n            self.important = false;\n            return nil;};\n          if (args.$length()['$=='](1)) {\n            \n            argument = args.$first();\n            if ($truthy(Opal.const_get_qualified('::', 'Hash')['$==='](argument))) {\n              $send(argument, 'each', [], (TMP_34 = function(sub, value){var self = TMP_34.$$s || this;\nif (sub == null) sub = nil;if (value == null) value = nil;\n              return self.$style(\"\" + (name) + \"-\" + (sub), value)}, TMP_34.$$s = self, TMP_34.$$arity = 2, TMP_34))\n              } else {\n              self.$style(name, argument)\n            };\n            } else {\n            self.$style(name, args.$join(\" \"))\n          };\n          self.important = false;\n          return self;\n        }, TMP_Definition_method_missing_33.$$arity = -2);\n        \n        Opal.defn(self, '$style', TMP_Definition_style_35 = function $$style(name, value, important) {\n          var self = this;\n\n          if (value == null) {\n            value = nil;\n          }\n          if (important == null) {\n            important = self.important;\n          }\n          \n          if ($truthy(Opal.const_get_qualified('::', 'Array')['$==='](value))) {\n            value = value.$join(\" \")};\n          if ($truthy(Opal.const_get_relative($nesting, 'Style')['$==='](name))) {\n            return self.style['$<<'](name)\n            } else {\n            return self.style['$<<'](Opal.const_get_relative($nesting, 'Style').$new(name, value, important))\n          };\n        }, TMP_Definition_style_35.$$arity = -2);\n        \n        Opal.defn(self, '$style!', TMP_Definition_style$B_36 = function(name, value) {\n          var self = this;\n\n          if (value == null) {\n            value = nil;\n          }\n          return self.$style(name, value, true)\n        }, TMP_Definition_style$B_36.$$arity = -2);\n        return (function($base, $super, $parent_nesting) {\n          function $Gradient(){};\n          var self = $Gradient = $klass($base, $super, 'Gradient', $Gradient);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Gradient_initialize_37, TMP_Gradient_each_38, TMP_Gradient_horizontal$q_39, TMP_Gradient_vertical$q_40, TMP_Gradient_other_41, TMP_Gradient_style_42;\n\n          def.to = def.from = def.start = def.end = nil;\n          \n          \n          Opal.defn(self, '$initialize', TMP_Gradient_initialize_37 = function $$initialize($a_rest) {\n            var $b, self = this, args, options = nil;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n            \n            options = (function() {if ($truthy(Opal.const_get_qualified('::', 'Hash')['$==='](args.$last()))) {\n              return args.$pop()\n              } else {\n              return $hash2([], {})\n            }; return nil; })();\n            self.to = options['$[]'](\"to\");\n            self.from = options['$[]'](\"from\");\n            if ($truthy(($truthy($b = self.to) ? self.from['$!']() : $b))) {\n              self.from = self.$other(self.to)\n            } else if ($truthy(($truthy($b = self.from) ? self.to['$!']() : $b))) {\n              self.to = self.$other(self.from)};\n            self.start = args.$shift();\n            return (self.end = args.$shift());\n          }, TMP_Gradient_initialize_37.$$arity = -1);\n          \n          Opal.defn(self, '$each', TMP_Gradient_each_38 = function $$each() {\n            var self = this, $iter = TMP_Gradient_each_38.$$p, block = $iter || nil;\n\n            if ($iter) TMP_Gradient_each_38.$$p = null;\n            \n            block.$call(self.$style(\"\" + \"-moz-linear-gradient(\" + (self.to) + \", \" + (self.start) + \" 0%, \" + (self.end) + \" 100%)\"));\n            if ($truthy(self['$horizontal?']())) {\n              block.$call(self.$style(\"\" + \"-webkit-gradient(linear, \" + (self.from) + \" top, \" + (self.to) + \" top, color-stop(0%, \" + (self.start) + \"), color-stop(100%, \" + (self.end) + \"))\"))\n              } else {\n              block.$call(self.$style(\"\" + \"-webkit-gradient(linear, left \" + (self.from) + \", left \" + (self.to) + \", color-stop(0%, \" + (self.start) + \"), color-stop(100%, \" + (self.end) + \"))\"))\n            };\n            block.$call(self.$style(\"\" + \"-webkit-linear-gradient(\" + (self.to) + \", \" + (self.start) + \" 0%, \" + (self.end) + \" 100%)\"));\n            block.$call(self.$style(\"\" + \"-o-linear-gradient(\" + (self.to) + \", \" + (self.start) + \" 0%, \" + (self.end) + \" 100%)\"));\n            block.$call(self.$style(\"\" + \"-ms-linear-gradient(\" + (self.to) + \", \" + (self.start) + \" 0%, \" + (self.end) + \" 100%)\"));\n            return block.$call(self.$style(\"\" + \"linear-gradient(to \" + (self.to) + \", \" + (self.start) + \" 0%, \" + (self.end) + \" 100%)\"));\n          }, TMP_Gradient_each_38.$$arity = 0);\n          \n          Opal.defn(self, '$horizontal?', TMP_Gradient_horizontal$q_39 = function() {\n            var $a, self = this;\n\n            return ($truthy($a = self.to['$=='](\"left\")) ? $a : self.to['$=='](\"right\"))\n          }, TMP_Gradient_horizontal$q_39.$$arity = 0);\n          \n          Opal.defn(self, '$vertical?', TMP_Gradient_vertical$q_40 = function() {\n            var $a, self = this;\n\n            return ($truthy($a = self.to['$=='](\"top\")) ? $a : self.to['$=='](\"bottom\"))\n          }, TMP_Gradient_vertical$q_40.$$arity = 0);\n          self.$private();\n          \n          Opal.defn(self, '$other', TMP_Gradient_other_41 = function $$other(side) {\n            var self = this, $case = nil;\n\n            return (function() {$case = side;\n            if (\"left\"['$===']($case)) {return \"right\"}\n            else if (\"right\"['$===']($case)) {return \"left\"}\n            else if (\"top\"['$===']($case)) {return \"bottom\"}\n            else if (\"bottom\"['$===']($case)) {return \"top\"}\n            else { return nil }})()\n          }, TMP_Gradient_other_41.$$arity = 1);\n          return (Opal.defn(self, '$style', TMP_Gradient_style_42 = function $$style($a_rest) {\n            var self = this, args;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n            if (args.$length()['$=='](1)) {\n              return Opal.const_get_relative($nesting, 'Style').$new(nil, args.$first())\n              } else {\n              return $send(Opal.const_get_relative($nesting, 'Style'), 'new', Opal.to_a(args))\n            }\n          }, TMP_Gradient_style_42.$$arity = -1), nil) && 'style';\n        })($nesting[0], null, $nesting);\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/css/rule\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$new', '$__send__', '$to_proc']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $CSS(){};\n      var self = $CSS = $klass($base, $super, 'CSS', $CSS);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Rule(){};\n        var self = $Rule = $klass($base, $super, 'Rule', $Rule);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Rule_initialize_1, TMP_Rule_method_missing_2;\n\n        def.definition = nil;\n        \n        self.$attr_reader(\"selector\", \"media\");\n        \n        Opal.defn(self, '$initialize', TMP_Rule_initialize_1 = function $$initialize(selector, media) {\n          var self = this;\n\n          \n          self.selector = selector;\n          self.media = media;\n          return (self.definition = Opal.const_get_relative($nesting, 'Definition').$new());\n        }, TMP_Rule_initialize_1.$$arity = 2);\n        return (Opal.defn(self, '$method_missing', TMP_Rule_method_missing_2 = function $$method_missing($a_rest) {\n          var self = this, args, $iter = TMP_Rule_method_missing_2.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Rule_method_missing_2.$$p = null;\n          return $send(self.definition, '__send__', Opal.to_a(args), block.$to_proc())\n        }, TMP_Rule_method_missing_2.$$arity = -1), nil) && 'method_missing';\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/css/font\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$new', '$font', '$__send__', '$to_proc']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $CSS(){};\n      var self = $CSS = $klass($base, $super, 'CSS', $CSS);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Font(){};\n        var self = $Font = $klass($base, $super, 'Font', $Font);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Font_initialize_1, TMP_Font_method_missing_2;\n\n        def.definition = nil;\n        \n        self.$attr_reader(\"name\");\n        \n        Opal.defn(self, '$initialize', TMP_Font_initialize_1 = function $$initialize(name) {\n          var self = this;\n\n          \n          self.name = name;\n          self.definition = Opal.const_get_relative($nesting, 'Definition').$new();\n          return self.$font($hash2([\"family\"], {\"family\": name}));\n        }, TMP_Font_initialize_1.$$arity = 1);\n        return (Opal.defn(self, '$method_missing', TMP_Font_method_missing_2 = function $$method_missing($a_rest) {\n          var self = this, args, $iter = TMP_Font_method_missing_2.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Font_method_missing_2.$$p = null;\n          return $send(self.definition, '__send__', Opal.to_a(args), block.$to_proc())\n        }, TMP_Font_method_missing_2.$$arity = -1), nil) && 'method_missing';\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/css/animation\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$new', '$__send__', '$to_proc', '$<<', '$call', '$%', '$last']);\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $CSS(){};\n      var self = $CSS = $klass($base, $super, 'CSS', $CSS);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Animation(){};\n        var self = $Animation = $klass($base, $super, 'Animation', $Animation);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Animation_initialize_3, TMP_Animation_step_4, TMP_Animation_from_5, TMP_Animation_to_6, TMP_Animation_method_missing_7;\n\n        def.steps = nil;\n        \n        (function($base, $super, $parent_nesting) {\n          function $Step(){};\n          var self = $Step = $klass($base, $super, 'Step', $Step);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Step_initialize_1, TMP_Step_method_missing_2;\n\n          def.definition = nil;\n          \n          self.$attr_reader(\"value\");\n          \n          Opal.defn(self, '$initialize', TMP_Step_initialize_1 = function $$initialize(value) {\n            var self = this;\n\n            \n            self.value = value;\n            return (self.definition = Opal.const_get_relative($nesting, 'Definition').$new());\n          }, TMP_Step_initialize_1.$$arity = 1);\n          return (Opal.defn(self, '$method_missing', TMP_Step_method_missing_2 = function $$method_missing($a_rest) {\n            var self = this, args, $iter = TMP_Step_method_missing_2.$$p, block = $iter || nil;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n            if ($iter) TMP_Step_method_missing_2.$$p = null;\n            return $send(self.definition, '__send__', Opal.to_a(args), block.$to_proc())\n          }, TMP_Step_method_missing_2.$$arity = -1), nil) && 'method_missing';\n        })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting);\n        self.$attr_reader(\"name\", \"steps\");\n        \n        Opal.defn(self, '$initialize', TMP_Animation_initialize_3 = function $$initialize(name) {\n          var self = this;\n\n          \n          self.name = name;\n          return (self.steps = []);\n        }, TMP_Animation_initialize_3.$$arity = 1);\n        \n        Opal.defn(self, '$step', TMP_Animation_step_4 = function $$step(value) {\n          var self = this, $iter = TMP_Animation_step_4.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Animation_step_4.$$p = null;\n          \n          self.steps['$<<'](Opal.const_get_relative($nesting, 'Step').$new(value));\n          return block.$call();\n        }, TMP_Animation_step_4.$$arity = 1);\n        \n        Opal.defn(self, '$from', TMP_Animation_from_5 = function $$from(value) {\n          var self = this, $iter = TMP_Animation_from_5.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Animation_from_5.$$p = null;\n          \n          self.steps['$<<'](Opal.const_get_relative($nesting, 'Step').$new((0)['$%']()));\n          return block.$call();\n        }, TMP_Animation_from_5.$$arity = 1);\n        \n        Opal.defn(self, '$to', TMP_Animation_to_6 = function $$to(value) {\n          var self = this, $iter = TMP_Animation_to_6.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Animation_to_6.$$p = null;\n          \n          self.steps['$<<'](Opal.const_get_relative($nesting, 'Step').$new((100)['$%']()));\n          return block.$call();\n        }, TMP_Animation_to_6.$$arity = 1);\n        return (Opal.defn(self, '$method_missing', TMP_Animation_method_missing_7 = function $$method_missing($a_rest) {\n          var self = this, args, $iter = TMP_Animation_method_missing_7.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Animation_method_missing_7.$$p = null;\n          return $send(self.steps.$last(), '__send__', Opal.to_a(args), block.$to_proc())\n        }, TMP_Animation_method_missing_7.$$arity = -1), nil) && 'method_missing';\n      })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/css\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $range = Opal.range;\n\n  Opal.add_stubs(['$require', '$each', '$start_with?', '$+', '$[]', '$==', '$attr_reader', '$raise', '$arity', '$instance_exec', '$to_proc', '$call', '$any?', '$include?', '$<<', '$new', '$selector', '$pop', '$method_missing', '$__send__', '$last']);\n  \n  self.$require(\"paggio/css/unit\");\n  self.$require(\"paggio/css/color\");\n  self.$require(\"paggio/css/definition\");\n  self.$require(\"paggio/css/rule\");\n  self.$require(\"paggio/css/font\");\n  self.$require(\"paggio/css/animation\");\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    (function($base, $super, $parent_nesting) {\n      function $CSS(){};\n      var self = $CSS = $klass($base, $super, 'CSS', $CSS);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_CSS_selector_2, TMP_CSS_initialize_3, TMP_CSS_rule_4, TMP_CSS_media_7, TMP_CSS_font_8, TMP_CSS_animation_9, TMP_CSS_method_missing_10;\n\n      def.media = def.current = def.fonts = def.animations = nil;\n      \n      Opal.defs(self, '$selector', TMP_CSS_selector_2 = function $$selector(list) {\n        var TMP_1, self = this, result = nil;\n\n        \n        result = \"\";\n        $send(list, 'each', [], (TMP_1 = function(part){var self = TMP_1.$$s || this;\nif (part == null) part = nil;\n        if ($truthy(part['$start_with?'](\"&\"))) {\n            return (result = $rb_plus(result, part['$[]']($range(1, -1, false))))\n            } else {\n            return (result = $rb_plus(result, $rb_plus(\" \", part)))\n          }}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));\n        if (result['$[]'](0)['$=='](\" \")) {\n          return result['$[]']($range(1, -1, false))\n          } else {\n          return result\n        };\n      }, TMP_CSS_selector_2.$$arity = 1);\n      self.$attr_reader(\"rules\", \"media\", \"fonts\", \"animations\");\n      \n      Opal.defn(self, '$initialize', TMP_CSS_initialize_3 = function $$initialize() {\n        var self = this, $iter = TMP_CSS_initialize_3.$$p, block = $iter || nil;\n\n        if ($iter) TMP_CSS_initialize_3.$$p = null;\n        \n        if ($truthy(block)) {\n          } else {\n          Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_qualified('::', 'ArgumentError'), \"no block given\")\n        };\n        self.selector = [];\n        self.current = [];\n        self.rules = [];\n        self.fonts = [];\n        self.animations = [];\n        if (block.$arity()['$=='](0)) {\n          return $send(self, 'instance_exec', [], block.$to_proc())\n          } else {\n          return block.$call(self)\n        };\n      }, TMP_CSS_initialize_3.$$arity = 0);\n      \n      Opal.defn(self, '$rule', TMP_CSS_rule_4 = function $$rule($a_rest) {\n        var TMP_5, TMP_6, self = this, names, $iter = TMP_CSS_rule_4.$$p, block = $iter || nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        names = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          names[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        if ($iter) TMP_CSS_rule_4.$$p = null;\n        \n        if ($truthy(block)) {\n          } else {\n          return nil\n        };\n        if ($truthy($send(names, 'any?', [], (TMP_5 = function(n){var self = TMP_5.$$s || this;\nif (n == null) n = nil;\n        return n['$include?'](\",\")}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5)))) {\n          Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_qualified('::', 'ArgumentError'), \"selectors cannot contain commas\")};\n        return $send(names, 'each', [], (TMP_6 = function(name){var self = TMP_6.$$s || this;\n          if (self.selector == null) self.selector = nil;\n          if (self.current == null) self.current = nil;\n          if (self.media == null) self.media = nil;\n          if (self.rules == null) self.rules = nil;\nif (name == null) name = nil;\n        \n          self.selector['$<<'](name);\n          self.current['$<<'](Opal.const_get_relative($nesting, 'Rule').$new(Opal.const_get_relative($nesting, 'CSS').$selector(self.selector), self.media));\n          block.$call();\n          self.selector.$pop();\n          return self.rules['$<<'](self.current.$pop());}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));\n      }, TMP_CSS_rule_4.$$arity = -1);\n      \n      Opal.defn(self, '$media', TMP_CSS_media_7 = function $$media(query, $a_rest) {\n        var $b, self = this, args, $iter = TMP_CSS_media_7.$$p, block = $iter || nil, old = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 1] = arguments[$arg_idx];\n        }\n        if ($iter) TMP_CSS_media_7.$$p = null;\n        if ($truthy(block)) {\n          \n          $b = [self.media, query], (old = $b[0]), (self.media = $b[1]), $b;\n          block.$call();\n          return (self.media = old);\n          } else {\n          return $send(self, 'method_missing', [\"media\", query].concat(Opal.to_a(args)))\n        }\n      }, TMP_CSS_media_7.$$arity = -2);\n      \n      Opal.defn(self, '$font', TMP_CSS_font_8 = function $$font(name, $a_rest) {\n        var self = this, args, $iter = TMP_CSS_font_8.$$p, block = $iter || nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 1] = arguments[$arg_idx];\n        }\n        if ($iter) TMP_CSS_font_8.$$p = null;\n        if ($truthy(block)) {\n          \n          self.current['$<<'](Opal.const_get_relative($nesting, 'Font').$new(name));\n          block.$call();\n          return self.fonts['$<<'](self.current.$pop());\n          } else {\n          return $send(self, 'method_missing', [\"font\", name].concat(Opal.to_a(args)))\n        }\n      }, TMP_CSS_font_8.$$arity = -2);\n      \n      Opal.defn(self, '$animation', TMP_CSS_animation_9 = function $$animation(name, $a_rest) {\n        var self = this, args, $iter = TMP_CSS_animation_9.$$p, block = $iter || nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 1] = arguments[$arg_idx];\n        }\n        if ($iter) TMP_CSS_animation_9.$$p = null;\n        if ($truthy(block)) {\n          \n          self.current['$<<'](Opal.const_get_relative($nesting, 'Animation').$new(name));\n          block.$call();\n          return self.animations['$<<'](self.current.$pop());\n          } else {\n          return $send(self, 'method_missing', [\"animation\", name].concat(Opal.to_a(args)))\n        }\n      }, TMP_CSS_animation_9.$$arity = -2);\n      return (Opal.defn(self, '$method_missing', TMP_CSS_method_missing_10 = function $$method_missing($a_rest) {\n        var self = this, args, $iter = TMP_CSS_method_missing_10.$$p, block = $iter || nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        if ($iter) TMP_CSS_method_missing_10.$$p = null;\n        return $send(self.current.$last(), '__send__', Opal.to_a(args), block.$to_proc())\n      }, TMP_CSS_method_missing_10.$$arity = -1), nil) && 'method_missing';\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting);\n    return (function($base, $super, $parent_nesting) {\n      function $HTML(){};\n      var self = $HTML = $klass($base, $super, 'HTML', $HTML);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_HTML_style_11;\n\n      def.current = def.roots = nil;\n      return (Opal.defn(self, '$style', TMP_HTML_style_11 = function $$style() {\n        var $a, self = this, $iter = TMP_HTML_style_11.$$p, block = $iter || nil;\n\n        if ($iter) TMP_HTML_style_11.$$p = null;\n        return ($truthy($a = self.current) ? $a : self.roots)['$<<']($send(Opal.const_get_relative($nesting, 'CSS'), 'new', [], block.$to_proc()))\n      }, TMP_HTML_style_11.$$arity = 0), nil) && 'style'\n    })($nesting[0], Opal.const_get_relative($nesting, 'BasicObject'), $nesting);\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"stringio\"] = function(Opal) {\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$include', '$new', '$call', '$close', '$attr_accessor', '$length', '$include?', '$!', '$check_readable', '$==', '$===', '$>=', '$raise', '$>', '$+', '$-', '$seek', '$enum_for', '$eof?', '$ord', '$[]', '$check_writable', '$String', '$write', '$closed_write?', '$closed_read?']);\n  return (function($base, $super, $parent_nesting) {\n    function $StringIO(){};\n    var self = $StringIO = $klass($base, $super, 'StringIO', $StringIO);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_StringIO_open_1, TMP_StringIO_initialize_2, TMP_StringIO_eof$q_3, TMP_StringIO_seek_4, TMP_StringIO_tell_5, TMP_StringIO_rewind_6, TMP_StringIO_each_byte_7, TMP_StringIO_each_char_8, TMP_StringIO_write_9, TMP_StringIO_read_10, TMP_StringIO_close_11, TMP_StringIO_close_read_12, TMP_StringIO_close_write_13, TMP_StringIO_closed$q_14, TMP_StringIO_closed_read$q_15, TMP_StringIO_closed_write$q_16, TMP_StringIO_check_writable_17, TMP_StringIO_check_readable_18;\n\n    def.position = def.string = def.closed = nil;\n    \n    self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'Readable'));\n    self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'Writable'));\n    Opal.defs(self, '$open', TMP_StringIO_open_1 = function $$open(string, mode) {\n      var self = this, $iter = TMP_StringIO_open_1.$$p, block = $iter || nil, io = nil, res = nil;\n\n      if (string == null) {\n        string = \"\";\n      }\n      if (mode == null) {\n        mode = nil;\n      }\n      if ($iter) TMP_StringIO_open_1.$$p = null;\n      \n      io = self.$new(string, mode);\n      res = block.$call(io);\n      io.$close();\n      return res;\n    }, TMP_StringIO_open_1.$$arity = -1);\n    self.$attr_accessor(\"string\");\n    \n    Opal.defn(self, '$initialize', TMP_StringIO_initialize_2 = function $$initialize(string, mode) {\n      var $a, self = this;\n\n      if (string == null) {\n        string = \"\";\n      }\n      if (mode == null) {\n        mode = \"rw\";\n      }\n      \n      self.string = string;\n      self.position = string.$length();\n      if ($truthy(($truthy($a = mode['$include?'](\"r\")) ? mode['$include?'](\"w\")['$!']() : $a))) {\n        return (self.closed = \"write\")\n      } else if ($truthy(($truthy($a = mode['$include?'](\"w\")) ? mode['$include?'](\"r\")['$!']() : $a))) {\n        return (self.closed = \"read\")\n        } else {\n        return nil\n      };\n    }, TMP_StringIO_initialize_2.$$arity = -1);\n    \n    Opal.defn(self, '$eof?', TMP_StringIO_eof$q_3 = function() {\n      var self = this;\n\n      \n      self.$check_readable();\n      return self.position['$=='](self.string.$length());\n    }, TMP_StringIO_eof$q_3.$$arity = 0);\n    Opal.alias(self, \"eof\", \"eof?\");\n    \n    Opal.defn(self, '$seek', TMP_StringIO_seek_4 = function $$seek(pos, whence) {\n      var self = this, $case = nil;\n\n      if (whence == null) {\n        whence = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'SEEK_SET');\n      }\n      \n      $case = whence;\n      if (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'SEEK_SET')['$===']($case)) {\n      if ($truthy($rb_ge(pos, 0))) {\n        } else {\n        self.$raise(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Errno'), 'EINVAL'))\n      };\n      self.position = pos;}\n      else if (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'SEEK_CUR')['$===']($case)) {if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {\n        self.position = self.string.$length()\n        } else {\n        self.position = $rb_plus(self.position, pos)\n      }}\n      else if (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'SEEK_END')['$===']($case)) {if ($truthy($rb_gt(pos, self.string.$length()))) {\n        self.position = 0\n        } else {\n        self.position = $rb_minus(self.position, pos)\n      }};\n      return 0;\n    }, TMP_StringIO_seek_4.$$arity = -2);\n    \n    Opal.defn(self, '$tell', TMP_StringIO_tell_5 = function $$tell() {\n      var self = this;\n\n      return self.position\n    }, TMP_StringIO_tell_5.$$arity = 0);\n    Opal.alias(self, \"pos\", \"tell\");\n    Opal.alias(self, \"pos=\", \"seek\");\n    \n    Opal.defn(self, '$rewind', TMP_StringIO_rewind_6 = function $$rewind() {\n      var self = this;\n\n      return self.$seek(0)\n    }, TMP_StringIO_rewind_6.$$arity = 0);\n    \n    Opal.defn(self, '$each_byte', TMP_StringIO_each_byte_7 = function $$each_byte() {\n      var $a, self = this, $iter = TMP_StringIO_each_byte_7.$$p, block = $iter || nil, i = nil;\n\n      if ($iter) TMP_StringIO_each_byte_7.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return self.$enum_for(\"each_byte\")\n      };\n      self.$check_readable();\n      i = self.position;\n      while (!($truthy(self['$eof?']()))) {\n        \n        block.$call(self.string['$[]'](i).$ord());\n        i = $rb_plus(i, 1);\n      };\n      return self;\n    }, TMP_StringIO_each_byte_7.$$arity = 0);\n    \n    Opal.defn(self, '$each_char', TMP_StringIO_each_char_8 = function $$each_char() {\n      var $a, self = this, $iter = TMP_StringIO_each_char_8.$$p, block = $iter || nil, i = nil;\n\n      if ($iter) TMP_StringIO_each_char_8.$$p = null;\n      \n      if ($truthy(block)) {\n        } else {\n        return self.$enum_for(\"each_char\")\n      };\n      self.$check_readable();\n      i = self.position;\n      while (!($truthy(self['$eof?']()))) {\n        \n        block.$call(self.string['$[]'](i));\n        i = $rb_plus(i, 1);\n      };\n      return self;\n    }, TMP_StringIO_each_char_8.$$arity = 0);\n    \n    Opal.defn(self, '$write', TMP_StringIO_write_9 = function $$write(string) {\n      var self = this, before = nil, after = nil;\n\n      \n      self.$check_writable();\n      string = self.$String(string);\n      if (self.string.$length()['$=='](self.position)) {\n        \n        self.string = $rb_plus(self.string, string);\n        return (self.position = $rb_plus(self.position, string.$length()));\n        } else {\n        \n        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));\n        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));\n        self.string = $rb_plus($rb_plus(before, string), after);\n        return (self.position = $rb_plus(self.position, string.$length()));\n      };\n    }, TMP_StringIO_write_9.$$arity = 1);\n    \n    Opal.defn(self, '$read', TMP_StringIO_read_10 = function $$read(length, outbuf) {\n      var self = this, string = nil, str = nil;\n\n      if (length == null) {\n        length = nil;\n      }\n      if (outbuf == null) {\n        outbuf = nil;\n      }\n      \n      self.$check_readable();\n      if ($truthy(self['$eof?']())) {\n        return nil};\n      string = (function() {if ($truthy(length)) {\n        \n        str = self.string['$[]'](self.position, length);\n        self.position = $rb_plus(self.position, length);\n        return str;\n        } else {\n        \n        str = self.string['$[]'](Opal.Range.$new(self.position, -1, false));\n        self.position = self.string.$length();\n        return str;\n      }; return nil; })();\n      if ($truthy(outbuf)) {\n        return outbuf.$write(string)\n        } else {\n        return string\n      };\n    }, TMP_StringIO_read_10.$$arity = -1);\n    \n    Opal.defn(self, '$close', TMP_StringIO_close_11 = function $$close() {\n      var self = this;\n\n      return (self.closed = \"both\")\n    }, TMP_StringIO_close_11.$$arity = 0);\n    \n    Opal.defn(self, '$close_read', TMP_StringIO_close_read_12 = function $$close_read() {\n      var self = this;\n\n      if (self.closed['$=='](\"write\")) {\n        return (self.closed = \"both\")\n        } else {\n        return (self.closed = \"read\")\n      }\n    }, TMP_StringIO_close_read_12.$$arity = 0);\n    \n    Opal.defn(self, '$close_write', TMP_StringIO_close_write_13 = function $$close_write() {\n      var self = this;\n\n      if (self.closed['$=='](\"read\")) {\n        return (self.closed = \"both\")\n        } else {\n        return (self.closed = \"write\")\n      }\n    }, TMP_StringIO_close_write_13.$$arity = 0);\n    \n    Opal.defn(self, '$closed?', TMP_StringIO_closed$q_14 = function() {\n      var self = this;\n\n      return self.closed['$=='](\"both\")\n    }, TMP_StringIO_closed$q_14.$$arity = 0);\n    \n    Opal.defn(self, '$closed_read?', TMP_StringIO_closed_read$q_15 = function() {\n      var $a, self = this;\n\n      return ($truthy($a = self.closed['$=='](\"read\")) ? $a : self.closed['$=='](\"both\"))\n    }, TMP_StringIO_closed_read$q_15.$$arity = 0);\n    \n    Opal.defn(self, '$closed_write?', TMP_StringIO_closed_write$q_16 = function() {\n      var $a, self = this;\n\n      return ($truthy($a = self.closed['$=='](\"write\")) ? $a : self.closed['$=='](\"both\"))\n    }, TMP_StringIO_closed_write$q_16.$$arity = 0);\n    \n    Opal.defn(self, '$check_writable', TMP_StringIO_check_writable_17 = function $$check_writable() {\n      var self = this;\n\n      if ($truthy(self['$closed_write?']())) {\n        return self.$raise(Opal.const_get_relative($nesting, 'IOError'), \"not opened for writing\")\n        } else {\n        return nil\n      }\n    }, TMP_StringIO_check_writable_17.$$arity = 0);\n    return (Opal.defn(self, '$check_readable', TMP_StringIO_check_readable_18 = function $$check_readable() {\n      var self = this;\n\n      if ($truthy(self['$closed_read?']())) {\n        return self.$raise(Opal.const_get_relative($nesting, 'IOError'), \"not opened for reading\")\n        } else {\n        return nil\n      }\n    }, TMP_StringIO_check_readable_18.$$arity = 0), nil) && 'check_readable';\n  })($nesting[0], Opal.const_get_relative($nesting, 'IO'), $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio/formatter\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$[]=', '$to_h', '$-', '$[]', '$dup', '$deep_merge!', '$call', '$replace', '$===', '$new', '$merge', '$each', '$string', '$indent?', '$+', '$lines', '$puts', '$*', '$chomp', '$print', '$gsub', '$to_s', '$for', '$version', '$indent', '$format', '$instance_eval', '$empty?', '$map', '$escape', '$<<', '$join', '$include?', '$downcase', '$name', '$value', '$important', '$fonts', '$animations', '$steps', '$reverse', '$rules', '$media', '$selector', '$deindent']);\n  \n  self.$require(\"stringio\");\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Paggio_14, TMP_Paggio_17, TMP_Paggio_24, TMP_Paggio_25;\n\n    \n    (function($base, $super, $parent_nesting) {\n      function $Formatter(){};\n      var self = $Formatter = $klass($base, $super, 'Formatter', $Formatter);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Formatter_to_h_1, TMP_Formatter_for_2, TMP_Formatter_options_3, TMP_Formatter_initialize_4, TMP_Formatter_format_6, TMP_Formatter_to_s_7, TMP_Formatter_indent$q_8, TMP_Formatter_indent_9, TMP_Formatter_deindent_10, TMP_Formatter_print_12, TMP_Formatter_escape_13;\n\n      def.options = def.io = nil;\n      \n      Opal.defs(self, '$to_h', TMP_Formatter_to_h_1 = function $$to_h() {\n        var $a, self = this;\n        if (self.formatters == null) self.formatters = nil;\n\n        return (self.formatters = ($truthy($a = self.formatters) ? $a : $hash2([], {})))\n      }, TMP_Formatter_to_h_1.$$arity = 0);\n      Opal.defs(self, '$for', TMP_Formatter_for_2 = function(klass) {\n        var self = this, $iter = TMP_Formatter_for_2.$$p, block = $iter || nil, $writer = nil;\n\n        if ($iter) TMP_Formatter_for_2.$$p = null;\n        if ($truthy(block)) {\n          \n          $writer = [klass, block];\n          $send(self.$to_h(), '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n          return self.$to_h()['$[]'](klass)\n        }\n      }, TMP_Formatter_for_2.$$arity = 1);\n      Opal.defs(self, '$options', TMP_Formatter_options_3 = function $$options(options) {\n        var self = this, $iter = TMP_Formatter_options_3.$$p, block = $iter || nil, old = nil, result = nil;\n\n        if ($iter) TMP_Formatter_options_3.$$p = null;\n        \n        old = Opal.const_get_relative($nesting, 'OPTIONS').$dup();\n        Opal.const_get_relative($nesting, 'Utils')['$deep_merge!'](Opal.const_get_relative($nesting, 'OPTIONS'), options);\n        result = block.$call();\n        Opal.const_get_relative($nesting, 'OPTIONS').$replace(old);\n        return result;\n      }, TMP_Formatter_options_3.$$arity = 1);\n      Opal.const_set($nesting[0], 'OPTIONS', $hash2([\"indent\"], {\"indent\": $hash2([\"level\", \"with\"], {\"level\": 0, \"with\": \"\\t\"})}));\n      \n      Opal.defn(self, '$initialize', TMP_Formatter_initialize_4 = function $$initialize(io, options) {\n        var $a, self = this;\n\n        if (io == null) {\n          io = nil;\n        }\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        \n        if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](io))) {\n          \n          self.io = Opal.const_get_relative($nesting, 'StringIO').$new();\n          self.options = io;\n          } else {\n          \n          self.io = ($truthy($a = io) ? $a : Opal.const_get_relative($nesting, 'StringIO').$new());\n          self.options = options;\n        };\n        return (self.options = Opal.const_get_relative($nesting, 'OPTIONS').$merge(self.options));\n      }, TMP_Formatter_initialize_4.$$arity = -1);\n      \n      Opal.defn(self, '$format', TMP_Formatter_format_6 = function $$format(item) {\n        var TMP_5, self = this;\n\n        \n        (function(){var $brk = Opal.new_brk(); try {return $send(Opal.const_get_relative($nesting, 'Formatter').$to_h(), 'each', [], (TMP_5 = function(klass, block){var self = TMP_5.$$s || this;\nif (klass == null) klass = nil;if (block == null) block = nil;\n        if ($truthy(klass['$==='](item))) {\n            \n            block.$call(self, item);\n            \n            Opal.brk(nil, $brk);\n            } else {\n            return nil\n          }}, TMP_5.$$s = self, TMP_5.$$brk = $brk, TMP_5.$$arity = 2, TMP_5))\n        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();\n        return self;\n      }, TMP_Formatter_format_6.$$arity = 1);\n      \n      Opal.defn(self, '$to_s', TMP_Formatter_to_s_7 = function $$to_s() {\n        var self = this;\n\n        return self.io.$string()\n      }, TMP_Formatter_to_s_7.$$arity = 0);\n      \n      Opal.defn(self, '$indent?', TMP_Formatter_indent$q_8 = function() {\n        var self = this, $iter = TMP_Formatter_indent$q_8.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Formatter_indent$q_8.$$p = null;\n        try {\n          return self.options['$[]'](\"indent\")['$[]'](\"level\")\n        } catch ($err) {\n          if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {\n            try {\n              return false\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        }\n      }, TMP_Formatter_indent$q_8.$$arity = 0);\n      \n      Opal.defn(self, '$indent', TMP_Formatter_indent_9 = function $$indent() {\n        var self = this, $iter = TMP_Formatter_indent_9.$$p, block = $iter || nil, $binary_op_recvr_tmp_1 = nil, $writer = nil, $binary_op_recvr_tmp_2 = nil, $binary_op_recvr_tmp_3 = nil;\n\n        if ($iter) TMP_Formatter_indent_9.$$p = null;\n        if ($truthy(self['$indent?']())) {\n          if ($truthy(block)) {\n            \n            \n            $binary_op_recvr_tmp_1 = self.options['$[]'](\"indent\");\n            \n            $writer = [\"level\", $rb_plus($binary_op_recvr_tmp_1['$[]'](\"level\"), 1)];\n            $send($binary_op_recvr_tmp_1, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;;\n            block.$call();\n            \n            $binary_op_recvr_tmp_2 = self.options['$[]'](\"indent\");\n            \n            $writer = [\"level\", $rb_minus($binary_op_recvr_tmp_2['$[]'](\"level\"), 1)];\n            $send($binary_op_recvr_tmp_2, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];;;\n            } else {\n            \n            $binary_op_recvr_tmp_3 = self.options['$[]'](\"indent\");\n            \n            $writer = [\"level\", $rb_plus($binary_op_recvr_tmp_3['$[]'](\"level\"), 1)];\n            $send($binary_op_recvr_tmp_3, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];;\n          }\n        } else if ($truthy(block)) {\n          return block.$call()\n          } else {\n          return nil\n        }\n      }, TMP_Formatter_indent_9.$$arity = 0);\n      \n      Opal.defn(self, '$deindent', TMP_Formatter_deindent_10 = function $$deindent() {\n        var self = this, $binary_op_recvr_tmp_4 = nil, $writer = nil;\n\n        if ($truthy(self['$indent?']())) {\n          \n          $binary_op_recvr_tmp_4 = self.options['$[]'](\"indent\");\n          \n          $writer = [\"level\", $rb_minus($binary_op_recvr_tmp_4['$[]'](\"level\"), 1)];\n          $send($binary_op_recvr_tmp_4, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];;\n          } else {\n          return nil\n        }\n      }, TMP_Formatter_deindent_10.$$arity = 0);\n      \n      Opal.defn(self, '$print', TMP_Formatter_print_12 = function $$print(text) {\n        var TMP_11, self = this, level = nil;\n\n        if ($truthy((level = self['$indent?']()))) {\n          return $send(text.$lines(), 'each', [], (TMP_11 = function(line){var self = TMP_11.$$s || this;\n            if (self.io == null) self.io = nil;\n            if (self.options == null) self.options = nil;\nif (line == null) line = nil;\n          return self.io.$puts(\"\" + ($rb_times(self.options['$[]'](\"indent\")['$[]'](\"with\"), level)) + (line.$chomp()))}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11))\n          } else {\n          return self.io.$print(text)\n        }\n      }, TMP_Formatter_print_12.$$arity = 1);\n      return (Opal.defn(self, '$escape', TMP_Formatter_escape_13 = function $$escape(string) {\n        var self = this;\n\n        return string.$to_s().$gsub(/[\"><']|&(?!([a-zA-Z]+|(#\\d+));)/, $hash2([\"&\", \">\", \"<\", \"\\\"\", \"'\"], {\"&\": \"&amp;\", \">\": \"&gt;\", \"<\": \"&lt;\", \"\\\"\": \"&quot;\", \"'\": \"&#39;\"}))\n      }, TMP_Formatter_escape_13.$$arity = 1), nil) && 'escape';\n    })($nesting[0], null, $nesting);\n    $send(Opal.const_get_relative($nesting, 'Formatter'), 'for', [Opal.const_get_relative($nesting, 'HTML')], (TMP_Paggio_14 = function(f, item){var self = TMP_Paggio_14.$$s || this, TMP_15, $case = nil;\nif (f == null) f = nil;if (item == null) item = nil;\n    \n      $case = item.$version();\n      if ((5)['$===']($case)) {f.$print(\"<!DOCTYPE html>\")};\n      f.$print(\"<html>\");\n      $send(f, 'indent', [], (TMP_15 = function(){var self = TMP_15.$$s || this, TMP_16;\n\n      return $send(item, 'each', [], (TMP_16 = function(root){var self = TMP_16.$$s || this;\nif (root == null) root = nil;\n        return f.$format(root)}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16))}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15));\n      return f.$print(\"</html>\");}, TMP_Paggio_14.$$s = self, TMP_Paggio_14.$$arity = 2, TMP_Paggio_14));\n    $send(Opal.const_get_relative($nesting, 'Formatter'), 'for', [Opal.const_get_qualified(Opal.const_get_relative($nesting, 'HTML'), 'Element')], (TMP_Paggio_17 = function(f, item){var self = TMP_Paggio_17.$$s || this, $a, $b, TMP_18, TMP_19, TMP_20, name = nil, attributes = nil, class_names = nil, attrs = nil;\nif (f == null) f = nil;if (item == null) item = nil;\n    \n      $b = $send(item, 'instance_eval', [], (TMP_18 = function(){var self = TMP_18.$$s || this;\n        if (self.name == null) self.name = nil;\n        if (self.attributes == null) self.attributes = nil;\n        if (self.class_names == null) self.class_names = nil;\n\n      return [self.name, self.attributes, self.class_names]}, TMP_18.$$s = self, TMP_18.$$arity = 0, TMP_18)), $a = Opal.to_ary($b), (name = ($a[0] == null ? nil : $a[0])), (attributes = ($a[1] == null ? nil : $a[1])), (class_names = ($a[2] == null ? nil : $a[2])), $b;\n      if ($truthy(($truthy($a = attributes['$empty?']()) ? class_names['$empty?']() : $a))) {\n        f.$print(\"\" + \"<\" + (name) + \">\")\n        } else {\n        \n        attrs = $send(attributes, 'map', [], (TMP_19 = function(key, value){var self = TMP_19.$$s || this;\nif (key == null) key = nil;if (value == null) value = nil;\n        return \"\" + (f.$escape(key)) + \"=\\\"\" + (f.$escape(value)) + \"\\\"\"}, TMP_19.$$s = self, TMP_19.$$arity = 2, TMP_19));\n        if ($truthy(class_names['$empty?']())) {\n          } else {\n          attrs['$<<'](\"\" + \"class=\\\"\" + (f.$escape(class_names.$join(\" \"))) + \"\\\"\")\n        };\n        f.$print(\"\" + \"<\" + (name) + \" \" + (attrs.$join(\" \")) + \">\");\n      };\n      if ($truthy([\"area\", \"base\", \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"]['$include?'](name.$to_s().$downcase()))) {\n        return nil;};\n      $send(f, 'indent', [], (TMP_20 = function(){var self = TMP_20.$$s || this, TMP_21, TMP_22, inner = nil;\n\n      if ($truthy((inner = $send(item, 'instance_eval', [], (TMP_21 = function(){var self = TMP_21.$$s || this;\n          if (self.inner_html == null) self.inner_html = nil;\n\n        return self.inner_html}, TMP_21.$$s = self, TMP_21.$$arity = 0, TMP_21))))) {\n          return f.$print(inner)\n          } else {\n          return $send(item, 'each', [], (TMP_22 = function(child){var self = TMP_22.$$s || this, TMP_23, $case = nil;\nif (child == null) child = nil;\n          return (function() {$case = child;\n            if (Opal.const_get_relative($nesting, 'String')['$===']($case)) {return f.$print(f.$escape(child))}\n            else if (Opal.const_get_relative($nesting, 'CSS')['$===']($case)) {\n            f.$print(\"<style>\");\n            $send(f, 'indent', [], (TMP_23 = function(){var self = TMP_23.$$s || this;\n\n            return f.$format(child)}, TMP_23.$$s = self, TMP_23.$$arity = 0, TMP_23));\n            return f.$print(\"</style>\");}\n            else {return f.$format(child)}})()}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22))\n        }}, TMP_20.$$s = self, TMP_20.$$arity = 0, TMP_20));\n      return f.$print(\"\" + \"</\" + (name) + \">\");}, TMP_Paggio_17.$$s = self, TMP_Paggio_17.$$arity = 2, TMP_Paggio_17));\n    $send(Opal.const_get_relative($nesting, 'Formatter'), 'for', [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'CSS'), 'Definition'), 'Style')], (TMP_Paggio_24 = function(f, style){var self = TMP_Paggio_24.$$s || this;\nif (f == null) f = nil;if (style == null) style = nil;\n    return f.$print(\"\" + (style.$name()) + \": \" + (style.$value()) + ((function() {if ($truthy(style.$important())) {\n        return \" !important\"\n        } else {\n        return nil\n      }; return nil; })()) + \";\")}, TMP_Paggio_24.$$s = self, TMP_Paggio_24.$$arity = 2, TMP_Paggio_24));\n    return $send(Opal.const_get_relative($nesting, 'Formatter'), 'for', [Opal.const_get_relative($nesting, 'CSS')], (TMP_Paggio_25 = function(f, item){var self = TMP_Paggio_25.$$s || this, TMP_26, TMP_29, TMP_33;\nif (f == null) f = nil;if (item == null) item = nil;\n    \n      $send(item.$fonts(), 'each', [], (TMP_26 = function(font){var self = TMP_26.$$s || this, TMP_27;\nif (font == null) font = nil;\n      \n        f.$print(\"@font-face {\");\n        $send(f, 'indent', [], (TMP_27 = function(){var self = TMP_27.$$s || this, TMP_28;\n\n        return $send(font, 'each', [], (TMP_28 = function(style){var self = TMP_28.$$s || this;\nif (style == null) style = nil;\n          return f.$format(style)}, TMP_28.$$s = self, TMP_28.$$arity = 1, TMP_28))}, TMP_27.$$s = self, TMP_27.$$arity = 0, TMP_27));\n        return f.$print(\"}\");}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26));\n      $send(item.$animations(), 'each', [], (TMP_29 = function(animation){var self = TMP_29.$$s || this, TMP_30;\nif (animation == null) animation = nil;\n      return $send([\"\", \"-webkit-\", \"-moz-\", \"-o-\"], 'each', [], (TMP_30 = function(platform){var self = TMP_30.$$s || this, TMP_31;\nif (platform == null) platform = nil;\n        \n          f.$print(\"\" + \"@\" + (platform) + \"keyframes \" + (animation.$name()) + \" {\");\n          $send(animation.$steps(), 'each', [], (TMP_31 = function(step){var self = TMP_31.$$s || this, TMP_32;\nif (step == null) step = nil;\n          \n            f.$print(\"\" + (step.$value()) + \" {\");\n            $send(step, 'each', [], (TMP_32 = function(style){var self = TMP_32.$$s || this;\nif (style == null) style = nil;\n            return f.$format(style)}, TMP_32.$$s = self, TMP_32.$$arity = 1, TMP_32));\n            return f.$print(\"}\");}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31));\n          return f.$print(\"}\");}, TMP_30.$$s = self, TMP_30.$$arity = 1, TMP_30))}, TMP_29.$$s = self, TMP_29.$$arity = 1, TMP_29));\n      return $send(item.$rules().$reverse(), 'each', [], (TMP_33 = function(rule){var self = TMP_33.$$s || this, TMP_34, m = nil;\nif (rule == null) rule = nil;\n      \n        if ($truthy(rule['$empty?']())) {\n          return nil;};\n        if ($truthy((m = rule.$media()))) {\n          \n          f.$print(\"\" + \"@media \" + (m) + \" {\");\n          f.$indent();};\n        f.$print(\"\" + (rule.$selector()) + \" {\");\n        $send(f, 'indent', [], (TMP_34 = function(){var self = TMP_34.$$s || this, TMP_35;\n\n        return $send(rule, 'each', [], (TMP_35 = function(style){var self = TMP_35.$$s || this;\nif (style == null) style = nil;\n          return f.$format(style)}, TMP_35.$$s = self, TMP_35.$$arity = 1, TMP_35))}, TMP_34.$$s = self, TMP_34.$$arity = 0, TMP_34));\n        f.$print(\"}\");\n        if ($truthy(rule.$media())) {\n          \n          f.$print(\"}\");\n          return f.$deindent();\n          } else {\n          return nil\n        };}, TMP_33.$$s = self, TMP_33.$$arity = 1, TMP_33));}, TMP_Paggio_25.$$s = self, TMP_Paggio_25.$$arity = 2, TMP_Paggio_25));\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"paggio\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$options', '$to_proc', '$to_s', '$format', '$new', '$tap', '$each']);\n  \n  self.$require(\"paggio/utils\");\n  self.$require(\"paggio/html\");\n  self.$require(\"paggio/css\");\n  self.$require(\"paggio/formatter\");\n  return (function($base, $super, $parent_nesting) {\n    function $Paggio(){};\n    var self = $Paggio = $klass($base, $super, 'Paggio', $Paggio);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Paggio_options_1, TMP_Paggio_indent_2, TMP_Paggio_css_3, TMP_Paggio_html_4, TMP_Paggio_html$B_5;\n\n    \n    Opal.defs(self, '$options', TMP_Paggio_options_1 = function $$options(options) {\n      var self = this, $iter = TMP_Paggio_options_1.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Paggio_options_1.$$p = null;\n      return $send(Opal.const_get_relative($nesting, 'Formatter'), 'options', [options], block.$to_proc())\n    }, TMP_Paggio_options_1.$$arity = 1);\n    Opal.defs(self, '$indent', TMP_Paggio_indent_2 = function $$indent(options) {\n      var self = this, $iter = TMP_Paggio_indent_2.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Paggio_indent_2.$$p = null;\n      return $send(self, 'options', [$hash2([\"indent\"], {\"indent\": options})], block.$to_proc())\n    }, TMP_Paggio_indent_2.$$arity = 1);\n    Opal.defs(self, '$css', TMP_Paggio_css_3 = function $$css($a_rest) {\n      var self = this, args, $iter = TMP_Paggio_css_3.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Paggio_css_3.$$p = null;\n      return Opal.const_get_relative($nesting, 'Formatter').$new().$format($send(Opal.const_get_relative($nesting, 'CSS'), 'new', Opal.to_a(args), block.$to_proc())).$to_s()\n    }, TMP_Paggio_css_3.$$arity = -1);\n    Opal.defs(self, '$html', TMP_Paggio_html_4 = function $$html($a_rest) {\n      var self = this, args, $iter = TMP_Paggio_html_4.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Paggio_html_4.$$p = null;\n      return Opal.const_get_relative($nesting, 'Formatter').$new().$format($send(Opal.const_get_relative($nesting, 'HTML'), 'new', Opal.to_a(args), block.$to_proc())).$to_s()\n    }, TMP_Paggio_html_4.$$arity = -1);\n    return Opal.defs(self, '$html!', TMP_Paggio_html$B_5 = function() {\n      var TMP_6, self = this, $iter = TMP_Paggio_html$B_5.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Paggio_html$B_5.$$p = null;\n      return $send(Opal.const_get_relative($nesting, 'Formatter').$new(), 'tap', [], (TMP_6 = function(f){var self = TMP_6.$$s || this, TMP_7;\nif (f == null) f = nil;\n      return $send($send(Opal.const_get_relative($nesting, 'HTML'), 'new', [], block.$to_proc()), 'each', [], (TMP_7 = function(root){var self = TMP_7.$$s || this;\nif (root == null) root = nil;\n        return f.$format(root)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7))}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6)).$to_s()\n    }, TMP_Paggio_html$B_5.$$arity = 0);\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/version\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;\n\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    Opal.const_set($nesting[0], 'VERSION', \"0.2.0\")\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/utils\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$new', '$encode_uri', '$to_s', '$encode_uri_component', '$[]', '$map', '$split', '$decode_uri_component', '$join']);\n  \n  (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    Opal.const_set($nesting[0], 'Size', Opal.const_get_relative($nesting, 'Struct').$new(\"width\", \"height\"));\n    Opal.const_set($nesting[0], 'Position', Opal.const_get_relative($nesting, 'Struct').$new(\"x\", \"y\"));\n  })($nesting[0], $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Object(){};\n    var self = $Object = $klass($base, $super, 'Object', $Object);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Object_encode_uri_1, TMP_Object_encode_uri_component_2;\n\n    \n    \n    Opal.defn(self, '$encode_uri', TMP_Object_encode_uri_1 = function $$encode_uri() {\n      var self = this;\n\n      return self.$to_s().$encode_uri()\n    }, TMP_Object_encode_uri_1.$$arity = 0);\n    return (Opal.defn(self, '$encode_uri_component', TMP_Object_encode_uri_component_2 = function $$encode_uri_component() {\n      var self = this;\n\n      return self.$to_s().$encode_uri_component()\n    }, TMP_Object_encode_uri_component_2.$$arity = 0), nil) && 'encode_uri_component';\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_encode_uri_component_3, TMP_String_encode_uri_4, TMP_String_decode_uri_component_5, TMP_String_decode_uri_6;\n\n    \n    \n    Opal.defn(self, '$encode_uri_component', TMP_String_encode_uri_component_3 = function $$encode_uri_component() {\n      var self = this;\n\n      return encodeURIComponent(self)\n    }, TMP_String_encode_uri_component_3.$$arity = 0);\n    \n    Opal.defn(self, '$encode_uri', TMP_String_encode_uri_4 = function $$encode_uri() {\n      var self = this;\n\n      return encodeURI(self)\n    }, TMP_String_encode_uri_4.$$arity = 0);\n    \n    Opal.defn(self, '$decode_uri_component', TMP_String_decode_uri_component_5 = function $$decode_uri_component() {\n      var self = this;\n\n      return decodeURIComponent(self)\n    }, TMP_String_decode_uri_component_5.$$arity = 0);\n    return (Opal.defn(self, '$decode_uri', TMP_String_decode_uri_6 = function $$decode_uri() {\n      var self = this;\n\n      return decodeURI(self)\n    }, TMP_String_decode_uri_6.$$arity = 0), nil) && 'decode_uri';\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $Hash(){};\n    var self = $Hash = $klass($base, $super, 'Hash', $Hash);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hash_decode_uri_8, TMP_Hash_encode_uri_10;\n\n    \n    Opal.defs(self, '$decode_uri', TMP_Hash_decode_uri_8 = function $$decode_uri(string) {\n      var TMP_7, self = this;\n\n      return self['$[]']($send(string.$split(\"&\"), 'map', [], (TMP_7 = function(part){var self = TMP_7.$$s || this, $a, $b, name = nil, value = nil;\nif (part == null) part = nil;\n      \n        $b = part.$split(\"=\"), $a = Opal.to_ary($b), (name = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $b;\n        return [name.$decode_uri_component(), value.$decode_uri_component()];}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7)))\n    }, TMP_Hash_decode_uri_8.$$arity = 1);\n    return (Opal.defn(self, '$encode_uri', TMP_Hash_encode_uri_10 = function $$encode_uri() {\n      var TMP_9, self = this;\n\n      return $send(self, 'map', [], (TMP_9 = function(name, value){var self = TMP_9.$$s || this;\nif (name == null) name = nil;if (value == null) value = nil;\n      return \"\" + (name.$to_s().$encode_uri_component()) + \"=\" + (value.$to_s().$encode_uri_component())}, TMP_9.$$s = self, TMP_9.$$arity = 2, TMP_9)).$join(\"&\")\n    }, TMP_Hash_encode_uri_10.$$arity = 0), nil) && 'encode_uri';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/support\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$downcase', '$===', '$!', '$supports?']);\n  \n  Opal.const_set($nesting[0], 'BROWSER_ENGINE', (function() { try {\n    return (/MSIE|WebKit|Presto|Gecko/.exec(navigator.userAgent)[0]).$downcase()\n  } catch ($err) {\n    if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {\n      try {\n        return \"unknown\"\n      } finally { Opal.pop_exception() }\n    } else { throw $err; }\n  }})());\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Browser_supports$q_1, TMP_Browser_loaded$q_2;\n\n    \n    self.support = {};\n    Opal.defs(self, '$supports?', TMP_Browser_supports$q_1 = function(feature) {\n      var $a, self = this, support = nil, $case = nil;\n      if (self.support == null) self.support = nil;\n\n      \n      if ($truthy((typeof(self.support[feature]) !== \"undefined\"))) {\n        return self.support[feature]};\n      support = (function() {$case = feature;\n      if (\"MutationObserver\"['$===']($case)) {return (typeof(window.MutationObserver) !== \"undefined\")}\n      else if (\"WebSocket\"['$===']($case)) {return (typeof(window.WebSocket) !== \"undefined\")}\n      else if (\"EventSource\"['$===']($case)) {return (typeof(window.EventSource) !== \"undefined\")}\n      else if (\"XHR\"['$===']($case)) {return (typeof(window.XMLHttpRequest) !== \"undefined\")}\n      else if (\"ActiveX\"['$===']($case)) {return (typeof(window.ActiveXObject) !== \"undefined\")}\n      else if (\"WebSQL\"['$===']($case)) {return (typeof(window.openDatabase) !== \"undefined\")}\n      else if (\"Query.css\"['$===']($case)) {return (typeof(document.querySelectorAll) !== \"undefined\")}\n      else if (\"Query.xpath\"['$===']($case)) {return (typeof(document.evaluate) !== \"undefined\")}\n      else if (\"Storage.local\"['$===']($case)) {return (typeof(window.localStorage) !== \"undefined\")}\n      else if (\"Storage.global\"['$===']($case)) {return (typeof(window.globalStorage) !== \"undefined\")}\n      else if (\"Storage.session\"['$===']($case)) {return (typeof(window.sessionStorage) !== \"undefined\")}\n      else if (\"Immediate\"['$===']($case)) {return (typeof(window.setImmediate) !== \"undefined\")}\n      else if (\"Immediate (Internet Explorer)\"['$===']($case)) {return (typeof(window.msSetImmediate) !== \"undefined\")}\n      else if (\"Immediate (Firefox)\"['$===']($case)) {return (typeof(window.mozSetImmediate) !== \"undefined\")}\n      else if (\"Immediate (Opera)\"['$===']($case)) {return (typeof(window.oSetImmediate) !== \"undefined\")}\n      else if (\"Immediate (Chrome)\"['$===']($case) || \"setImmediate (Safari)\"['$===']($case)) {return (typeof(window.webkitSetImmediate) !== \"undefined\")}\n      else if (\"CSS.computed\"['$===']($case)) {return (typeof(window.getComputedStyle) !== \"undefined\")}\n      else if (\"CSS.current\"['$===']($case)) {return (typeof(document.documentElement.currentStyle) !== \"undefined\")}\n      else if (\"Window.send\"['$===']($case)) {return (typeof(window.postMessage) !== \"undefined\")}\n      else if (\"Window.send (Asynchronous)\"['$===']($case)) {if ($truthy(($truthy($a = (typeof(window.postMessage) !== \"undefined\")) ? (typeof(window.importScripts) !== \"undefined\")['$!']() : $a))) {\n        \n            var ok  = true,\n                old = window.onmessage;\n\n            window.onmessage = function() { ok = false; };\n            window.postMessage(\"\", \"*\")\n            window.onmessage = old;\n\n            return ok;\n          \n        } else {\n        return nil\n      }}\n      else if (\"Window.send (Synchronous)\"['$===']($case)) {return self['$supports?'](\"Window.send (Asynchronous)\")['$!']()}\n      else if (\"Window.innerSize\"['$===']($case)) {return (typeof(window.innerHeight) !== \"undefined\")}\n      else if (\"Window.outerSize\"['$===']($case)) {return (typeof(window.outerHeight) !== \"undefined\")}\n      else if (\"Window.scroll\"['$===']($case)) {return (typeof(document.documentElement.scrollLeft) !== \"undefined\")}\n      else if (\"Window.pageOffset\"['$===']($case)) {return (typeof(window.pageXOffset) !== \"undefined\")}\n      else if (\"Attr.isId\"['$===']($case)) {\n          var div = document.createElement('div');\n              div.setAttribute('id', 'xxxxxxxxxxxxx');\n\n          return typeof(div.attributes['id'].isId) !== \"undefined\";\n        }\n      else if (\"Element.addBehavior\"['$===']($case)) {return (typeof(document.documentElement.addBehavior) !== \"undefined\")}\n      else if (\"Element.className\"['$===']($case)) {\n          var div = document.createElement(\"div\");\n              div.setAttribute('className', 'x');\n\n          return div.className === 'x';\n        }\n      else if (\"Element.class\"['$===']($case)) {\n          var div = document.createElement(\"div\");\n              div.setAttribute('class', 'x');\n\n          return div.className === 'x';\n        }\n      else if (\"Element.for\"['$===']($case)) {\n          var label = document.createElement(\"label\");\n              label.setAttribute('for', 'x');\n\n          return label.htmlFor === 'x';\n        }\n      else if (\"Element.htmlFor\"['$===']($case)) {\n          var label = document.createElement(\"label\");\n              label.setAttribute('htmlFor', 'x');\n\n          return label.htmlFor === 'x';\n        }\n      else if (\"Element.clientSize\"['$===']($case)) {return (typeof(document.documentElement.clientHeight) !== \"undefined\")}\n      else if (\"Element.scroll\"['$===']($case)) {return (typeof(document.documentElement.scrollLeft) !== \"undefined\")}\n      else if (\"Element.textContent\"['$===']($case)) {return (typeof(document.documentElement.textContent) !== \"undefined\")}\n      else if (\"Element.innerText\"['$===']($case)) {return (typeof(document.documentElement.innerText) !== \"undefined\")}\n      else if (\"Element.matches\"['$===']($case)) {return (typeof(document.documentElement.matches) !== \"undefined\")}\n      else if (\"Element.matches (Internet Explorer)\"['$===']($case)) {return (typeof(document.documentElement.msMatchesSelector) !== \"undefined\")}\n      else if (\"Element.matches (Firefox)\"['$===']($case)) {return (typeof(document.documentElement.mozMatchesSelector) !== \"undefined\")}\n      else if (\"Element.matches (Opera)\"['$===']($case)) {return (typeof(document.documentElement.oMatchesSelector) !== \"undefined\")}\n      else if (\"Element.matches (Chrome)\"['$===']($case) || \"Element.matches (Safari)\"['$===']($case)) {return (typeof(document.documentElement.webkitMatchesSelector) !== \"undefined\")}\n      else if (\"Element.getBoundingClientRect\"['$===']($case)) {return (typeof(document.documentElement.getBoundingClientRect) !== \"undefined\")}\n      else if (\"Event.readystatechange\"['$===']($case)) {return \"onreadystatechange\" in window.document.createElement(\"script\")}\n      else if (\"Event.constructor\"['$===']($case)) {\n      try {\n        \n        new MouseEvent(\"click\");\n        return true;\n      } catch ($err) {\n        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {\n          try {\n            return false\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      };}\n      else if (\"Event.create\"['$===']($case)) {return (typeof(document.createEvent) !== \"undefined\")}\n      else if (\"Event.createObject\"['$===']($case)) {return (typeof(document.createEventObject) !== \"undefined\")}\n      else if (\"Event.addListener\"['$===']($case)) {return (typeof(document.addEventListener) !== \"undefined\")}\n      else if (\"Event.attach\"['$===']($case)) {return (typeof(document.attachEvent) !== \"undefined\")}\n      else if (\"Event.removeListener\"['$===']($case)) {return (typeof(document.removeEventListener) !== \"undefined\")}\n      else if (\"Event.detach\"['$===']($case)) {return (typeof(document.detachEvent) !== \"undefined\")}\n      else if (\"Event.dispatch\"['$===']($case)) {return (typeof(document.dispatchEvent) !== \"undefined\")}\n      else if (\"Event.fire\"['$===']($case)) {return (typeof(document.fireEvent) !== \"undefined\")}\n      else if (/^Event\\.([A-Z].*?)$/['$===']($case)) {return ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)) + \"Event\") in window}\n      else if (\"Document.view\"['$===']($case)) {return (typeof(document.defaultView) !== \"undefined\")}\n      else if (\"Document.window\"['$===']($case)) {return (typeof(document.parentWindow) !== \"undefined\")}\n      else if (\"History\"['$===']($case)) {return (typeof(window.history.pushState) !== \"undefined\")}\n      else if (\"History.state\"['$===']($case)) {return (typeof(window.history.state) !== \"undefined\")}\n      else if (\"Animation.request\"['$===']($case)) {return (typeof(window.requestAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.request (Internet Explorer)\"['$===']($case)) {return (typeof(window.msRequestAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.request (Firefox)\"['$===']($case)) {return (typeof(window.mozRequestAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.request (Opera)\"['$===']($case)) {return (typeof(window.oRequestAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.request (Chrome)\"['$===']($case) || \"Animation.request (Safari)\"['$===']($case)) {return (typeof(window.webkitRequestAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.cancel\"['$===']($case)) {return (typeof(window.cancelAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.cancel (Internet Explorer)\"['$===']($case)) {return (typeof(window.msCancelAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.cancel (Firefox)\"['$===']($case)) {return (typeof(window.mozCancelAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.cancel (Opera)\"['$===']($case)) {return (typeof(window.oCancelAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.cancel (Chrome)\"['$===']($case) || \"Animation.cancel (Safari)\"['$===']($case)) {return (typeof(window.webkitCancelAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.cancelRequest\"['$===']($case)) {return (typeof(window.cancelRequestAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.cancelRequest (Internet Explorer)\"['$===']($case)) {return (typeof(window.msCancelRequestAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.cancelRequest (Firefox)\"['$===']($case)) {return (typeof(window.mozCancelRequestAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.cancelRequest (Opera)\"['$===']($case)) {return (typeof(window.oCancelRequestAnimationFrame) !== \"undefined\")}\n      else if (\"Animation.cancelRequest (Chrome)\"['$===']($case) || \"Animation.cancelRequest (Safari)\"['$===']($case)) {return (typeof(window.webkitCancelRequestAnimationFrame) !== \"undefined\")}\n      else { return nil }})();\n      return self.support[feature] = support;\n    }, TMP_Browser_supports$q_1.$$arity = 1);\n    Opal.defs(self, '$loaded?', TMP_Browser_loaded$q_2 = function(name) {\n      var self = this, $case = nil;\n\n      return (function() {$case = name;\n      if (\"Sizzle\"['$===']($case)) {return (typeof(window.Sizzle) !== \"undefined\")}\n      else if (\"wicked-good-xpath\"['$===']($case)) {return (typeof(window.wgxpath) !== \"undefined\")}\n      else { return nil }})()\n    }, TMP_Browser_loaded$q_2.$$arity = 1);\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/base\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$include', '$call', '$to_n', '$<<', '$converters', '$native?', '$each', '$instance_eval', '$register', '$to_proc', '$attr_reader', '$lambda', '$new', '$stopped?', '$arguments', '$!', '$prevented?', '$class_for', '$off', '$target', '$[]', '$delegated', '$delete', '$last', '$empty?', '$first', '$raise', '$name_for', '$handlers', '$[]=', '$-', '$include?', '$on!', '$delegate', '$callback=', '$on', '$handlers=', '$push', '$callbacks', '$attach', '$attach!', '$supports?', '$name', '$==', '$event', '$===', '$warn', '$detach', '$gsub', '$delete_if', '$=~', '$clear', '$none?', '$is_a?', '$create', '$dispatch', '$trigger', '$bubbles=', '$private', '$nil?', '$dup', '$on=', '$parent']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$include(Opal.const_get_relative($nesting, 'Native'));\n      (function($base, $super, $parent_nesting) {\n        function $Definition(){};\n        var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_new_1, TMP_Definition_bubbles$eq_2, TMP_Definition_cancelable$eq_3;\n\n        def[\"native\"] = nil;\n        \n        self.$include(Opal.const_get_relative($nesting, 'Native'));\n        Opal.defs(self, '$new', TMP_Definition_new_1 = function() {\n          var self = this, $iter = TMP_Definition_new_1.$$p, block = $iter || nil, data = nil;\n\n          if ($iter) TMP_Definition_new_1.$$p = null;\n          \n          data = $send(self, Opal.find_super_dispatcher(self, 'new', TMP_Definition_new_1, false, $Definition), [{ bubbles: true, cancelable: true }], null);\n          if ($truthy(block)) {\n            block.$call(data)};\n          return data.$to_n();\n        }, TMP_Definition_new_1.$$arity = 0);\n        \n        Opal.defn(self, '$bubbles=', TMP_Definition_bubbles$eq_2 = function(value) {\n          var self = this;\n\n          return self[\"native\"].bubbles = value\n        }, TMP_Definition_bubbles$eq_2.$$arity = 1);\n        return (Opal.defn(self, '$cancelable=', TMP_Definition_cancelable$eq_3 = function(value) {\n          var self = this;\n\n          return self[\"native\"].cancelable = value\n        }, TMP_Definition_cancelable$eq_3.$$arity = 1), nil) && 'cancelable=';\n      })($nesting[0], null, $nesting);\n      return (function($base, $parent_nesting) {\n        var $Target, self = $Target = $module($base, 'Target');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Target_converters_4, TMP_Target_register_5, TMP_Target_convert_7, TMP_Target_included_10, TMP_Target_on_19, TMP_Target_on$B_22, TMP_Target_attach_23, TMP_Target_attach$B_24, TMP_Target_attach_25, TMP_Target_attach$B_26, TMP_Target_attach_27, TMP_Target_attach$B_28, TMP_Target_off_32, TMP_Target_detach_33, TMP_Target_detach_35, TMP_Target_detach_36, TMP_Target_trigger_37, TMP_Target_trigger$B_38, TMP_Target_dispatch_40, TMP_Target_dispatch_41, TMP_Target_dispatch_42, TMP_Target_callbacks_43, TMP_Target_delegated_44, TMP_Target_delegate_46;\n\n        \n        Opal.defs(self, '$converters', TMP_Target_converters_4 = function $$converters() {\n          var $a, self = this;\n          if (self.converters == null) self.converters = nil;\n\n          return (self.converters = ($truthy($a = self.converters) ? $a : []))\n        }, TMP_Target_converters_4.$$arity = 0);\n        Opal.defs(self, '$register', TMP_Target_register_5 = function $$register() {\n          var self = this, $iter = TMP_Target_register_5.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Target_register_5.$$p = null;\n          return self.$converters()['$<<'](block)\n        }, TMP_Target_register_5.$$arity = 0);\n        Opal.defs(self, '$convert', TMP_Target_convert_7 = function $$convert(value) {try {\n\n          var TMP_6, self = this;\n\n          \n          if ($truthy(self['$native?'](value))) {\n            } else {\n            return value\n          };\n          $send(self.$converters(), 'each', [], (TMP_6 = function(block){var self = TMP_6.$$s || this, result = nil;\nif (block == null) block = nil;\n          if ($truthy((result = block.$call(value)))) {\n              Opal.ret(result)\n              } else {\n              return nil\n            }}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));\n          return nil;\n          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n        }, TMP_Target_convert_7.$$arity = 1);\n        Opal.defs(self, '$included', TMP_Target_included_10 = function $$included(klass) {\n          var TMP_8, self = this;\n\n          return $send(klass, 'instance_eval', [], (TMP_8 = function(){var self = TMP_8.$$s || this, TMP_target_9;\n\n          return Opal.defs(self, '$target', TMP_target_9 = function $$target() {\n              var self = this, $iter = TMP_target_9.$$p, block = $iter || nil;\n\n              if ($iter) TMP_target_9.$$p = null;\n              return $send(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Event'), 'Target'), 'register', [], block.$to_proc())\n            }, TMP_target_9.$$arity = 0)}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8))\n        }, TMP_Target_included_10.$$arity = 1);\n        (function($base, $super, $parent_nesting) {\n          function $Callback(){};\n          var self = $Callback = $klass($base, $super, 'Callback', $Callback);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Callback_initialize_11, TMP_Callback_call_12, TMP_Callback_to_proc_14, TMP_Callback_event_15, TMP_Callback_off_16;\n\n          def.proc = def.name = nil;\n          \n          self.$attr_reader(\"target\", \"name\", \"selector\");\n          \n          Opal.defn(self, '$initialize', TMP_Callback_initialize_11 = function $$initialize(target, name, selector) {\n            var self = this, $iter = TMP_Callback_initialize_11.$$p, block = $iter || nil;\n\n            if (selector == null) {\n              selector = nil;\n            }\n            if ($iter) TMP_Callback_initialize_11.$$p = null;\n            \n            self.target = target;\n            self.name = name;\n            self.selector = selector;\n            return (self.block = block);\n          }, TMP_Callback_initialize_11.$$arity = -3);\n          \n          Opal.defn(self, '$call', TMP_Callback_call_12 = function $$call(event) {\n            var self = this;\n\n            return self.$to_proc().$call(event)\n          }, TMP_Callback_call_12.$$arity = 1);\n          \n          Opal.defn(self, '$to_proc', TMP_Callback_to_proc_14 = function $$to_proc() {\n            var $a, TMP_13, self = this;\n\n            return (self.proc = ($truthy($a = self.proc) ? $a : $send(self, 'lambda', [], (TMP_13 = function(event){var self = TMP_13.$$s || this;\n              if (self.block == null) self.block = nil;\nif (event == null) event = nil;\n            \n              \n            if (!event.currentTarget) {\n              event.currentTarget = self.target.native;\n            }\n          ;\n              event = Opal.const_get_relative($nesting, 'Event').$new(event, self);\n              if ($truthy(event['$stopped?']())) {\n                } else {\n                $send(self.block, 'call', [event].concat(Opal.to_a(event.$arguments())))\n              };\n              return event['$prevented?']()['$!']();}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13))))\n          }, TMP_Callback_to_proc_14.$$arity = 0);\n          \n          Opal.defn(self, '$event', TMP_Callback_event_15 = function $$event() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Event').$class_for(self.name)\n          }, TMP_Callback_event_15.$$arity = 0);\n          return (Opal.defn(self, '$off', TMP_Callback_off_16 = function $$off() {\n            var self = this;\n\n            return self.$target().$off(self)\n          }, TMP_Callback_off_16.$$arity = 0), nil) && 'off';\n        })($nesting[0], null, $nesting);\n        (function($base, $super, $parent_nesting) {\n          function $Delegate(){};\n          var self = $Delegate = $klass($base, $super, 'Delegate', $Delegate);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Delegate_initialize_17, TMP_Delegate_off_18;\n\n          def.target = def.name = def.pair = nil;\n          \n          \n          Opal.defn(self, '$initialize', TMP_Delegate_initialize_17 = function $$initialize(target, name, pair) {\n            var self = this;\n\n            \n            self.target = target;\n            self.name = name;\n            return (self.pair = pair);\n          }, TMP_Delegate_initialize_17.$$arity = 3);\n          return (Opal.defn(self, '$off', TMP_Delegate_off_18 = function $$off() {\n            var self = this, delegate = nil;\n\n            \n            delegate = self.target.$delegated()['$[]'](self.name);\n            delegate.$last().$delete(self.pair);\n            if ($truthy(delegate.$last()['$empty?']())) {\n              \n              delegate.$first().$off();\n              return delegate.$delete(self.name);\n              } else {\n              return nil\n            };\n          }, TMP_Delegate_off_18.$$arity = 0), nil) && 'off';\n        })($nesting[0], null, $nesting);\n        Opal.const_set($nesting[0], 'Delegates', Opal.const_get_relative($nesting, 'Struct').$new(\"callback\", \"handlers\"));\n        \n        Opal.defn(self, '$on', TMP_Target_on_19 = function $$on(name, selector) {\n          var TMP_20, TMP_21, self = this, $iter = TMP_Target_on_19.$$p, block = $iter || nil, delegate = nil, pair = nil, $writer = nil, callback = nil;\n\n          if (selector == null) {\n            selector = nil;\n          }\n          if ($iter) TMP_Target_on_19.$$p = null;\n          \n          if ($truthy(block)) {\n            } else {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"no block has been given\")\n          };\n          name = Opal.const_get_relative($nesting, 'Event').$name_for(name);\n          if ($truthy(selector)) {\n            if ($truthy((delegate = self.$delegated()['$[]'](name)))) {\n              \n              pair = [selector, block];\n              delegate.$handlers()['$<<'](pair);\n              return Opal.const_get_relative($nesting, 'Delegate').$new(self, name, pair);\n              } else {\n              \n              delegate = (($writer = [name, Opal.const_get_relative($nesting, 'Delegates').$new()]), $send(self.$delegated(), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]);\n              if ($truthy([\"blur\", \"focus\"]['$include?'](name))) {\n                \n                $writer = [$send(self, 'on!', [name], (TMP_20 = function(e){var self = TMP_20.$$s || this;\nif (e == null) e = nil;\n                return self.$delegate(delegate, e)}, TMP_20.$$s = self, TMP_20.$$arity = 1, TMP_20))];\n                $send(delegate, 'callback=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];\n                } else {\n                \n                $writer = [$send(self, 'on', [name], (TMP_21 = function(e){var self = TMP_21.$$s || this;\nif (e == null) e = nil;\n                return self.$delegate(delegate, e)}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21))];\n                $send(delegate, 'callback=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];\n              };\n              pair = [selector, block];\n              \n              $writer = [[pair]];\n              $send(delegate, 'handlers=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              return Opal.const_get_relative($nesting, 'Delegate').$new(self, name, pair);\n            }\n            } else {\n            \n            callback = $send(Opal.const_get_relative($nesting, 'Callback'), 'new', [self, name, selector], block.$to_proc());\n            self.$callbacks().$push(callback);\n            return self.$attach(callback);\n          };\n        }, TMP_Target_on_19.$$arity = -2);\n        \n        Opal.defn(self, '$on!', TMP_Target_on$B_22 = function(name) {\n          var self = this, $iter = TMP_Target_on$B_22.$$p, block = $iter || nil, callback = nil;\n\n          if ($iter) TMP_Target_on$B_22.$$p = null;\n          \n          if ($truthy(block)) {\n            } else {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"no block has been given\")\n          };\n          name = Opal.const_get_relative($nesting, 'Event').$name_for(name);\n          callback = $send(Opal.const_get_relative($nesting, 'Callback'), 'new', [self, name], block.$to_proc());\n          self.$callbacks().$push(callback);\n          return self['$attach!'](callback);\n        }, TMP_Target_on$B_22.$$arity = 1);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.addListener\"))) {\n          \n          \n          Opal.defn(self, '$attach', TMP_Target_attach_23 = function $$attach(callback) {\n            var self = this;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\n\n            \n            self[\"native\"].addEventListener(callback.$name(), callback.$to_proc());\n            return callback;\n          }, TMP_Target_attach_23.$$arity = 1);\n          \n          Opal.defn(self, '$attach!', TMP_Target_attach$B_24 = function(callback) {\n            var self = this;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\n\n            \n            self[\"native\"].addEventListener(callback.$name(), callback.$to_proc(), true);\n            return callback;\n          }, TMP_Target_attach$B_24.$$arity = 1);\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.attach\"))) {\n          \n          \n          Opal.defn(self, '$attach', TMP_Target_attach_25 = function $$attach(callback) {\n            var self = this;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\n\n            \n            if (callback.$event()['$=='](Opal.const_get_relative($nesting, 'Custom'))) {\n              \n            if (!self[\"native\"].$custom) {\n              self[\"native\"].$custom = function(event) {\n                for (var i = 0, length = self[\"native\"].$callbacks.length; i < length; i++) {\n                  var callback = self[\"native\"].$callbacks[i];\n\n                  if ((callback).$event()['$=='](Opal.const_get_relative($nesting, 'Custom'))) {\n                    event.type = callback.name;\n\n                    (callback).$call(event);\n                  }\n                }\n              };\n\n              self[\"native\"].attachEvent(\"ondataavailable\", self[\"native\"].$custom);\n            }\n          \n              } else {\n              self[\"native\"].attachEvent(\"on\" + callback.$name(), callback.$to_proc())\n            };\n            return callback;\n          }, TMP_Target_attach_25.$$arity = 1);\n          \n          Opal.defn(self, '$attach!', TMP_Target_attach$B_26 = function(callback) {\n            var self = this, $case = nil;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\n\n            \n            $case = callback.$name();\n            if (\"blur\"['$===']($case)) {self[\"native\"].attachEvent(\"onfocusout\", callback.$to_proc())}\n            else if (\"focus\"['$===']($case)) {self[\"native\"].attachEvent(\"onfocusin\", callback.$to_proc())}\n            else {\n            self.$warn(\"attach: capture doesn't work on this browser\");\n            self.$attach(callback);};\n            return callback;\n          }, TMP_Target_attach$B_26.$$arity = 1);\n          } else {\n          \n          \n          Opal.defn(self, '$attach', TMP_Target_attach_27 = function $$attach($a_rest) {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n          }, TMP_Target_attach_27.$$arity = -1);\n          \n          Opal.defn(self, '$attach!', TMP_Target_attach$B_28 = function($a_rest) {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n          }, TMP_Target_attach$B_28.$$arity = -1);\n        };\n        \n        Opal.defn(self, '$off', TMP_Target_off_32 = function $$off(what) {\n          var $a, TMP_29, TMP_30, TMP_31, self = this, $case = nil;\n\n          if (what == null) {\n            what = nil;\n          }\n          return (function() {$case = what;\n          if (Opal.const_get_relative($nesting, 'Callback')['$===']($case)) {\n          self.$callbacks().$delete(what);\n          return self.$detach(what);}\n          else if (Opal.const_get_relative($nesting, 'String')['$===']($case)) {if ($truthy(($truthy($a = what['$include?'](\"*\")) ? $a : what['$include?'](\"?\")))) {\n            return self.$off(Opal.const_get_relative($nesting, 'Regexp').$new(what.$gsub(/\\*/, \".*?\").$gsub(/\\?/, \".\")))\n            } else {\n            \n            what = Opal.const_get_relative($nesting, 'Event').$name_for(what);\n            return $send(self.$callbacks(), 'delete_if', [], (TMP_29 = function(callback){var self = TMP_29.$$s || this;\nif (callback == null) callback = nil;\n            if (callback.$name()['$=='](what)) {\n                \n                self.$detach(callback);\n                return true;\n                } else {\n                return nil\n              }}, TMP_29.$$s = self, TMP_29.$$arity = 1, TMP_29));\n          }}\n          else if (Opal.const_get_relative($nesting, 'Regexp')['$===']($case)) {return $send(self.$callbacks(), 'delete_if', [], (TMP_30 = function(callback){var self = TMP_30.$$s || this;\nif (callback == null) callback = nil;\n          if ($truthy(callback.$name()['$=~'](what))) {\n              \n              self.$detach(callback);\n              return true;\n              } else {\n              return nil\n            }}, TMP_30.$$s = self, TMP_30.$$arity = 1, TMP_30))}\n          else {\n          $send(self.$callbacks(), 'each', [], (TMP_31 = function(callback){var self = TMP_31.$$s || this;\nif (callback == null) callback = nil;\n          return self.$detach(callback)}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31));\n          return self.$callbacks().$clear();}})()\n        }, TMP_Target_off_32.$$arity = -1);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.removeListener\"))) {\n          \n          Opal.defn(self, '$detach', TMP_Target_detach_33 = function $$detach(callback) {\n            var self = this;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\n\n            return self[\"native\"].removeEventListener(callback.$name(), callback.$to_proc(), false)\n          }, TMP_Target_detach_33.$$arity = 1)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.detach\"))) {\n          \n          Opal.defn(self, '$detach', TMP_Target_detach_35 = function $$detach(callback) {\n            var TMP_34, self = this;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\n\n            if (callback.$event()['$=='](Opal.const_get_relative($nesting, 'Custom'))) {\n              if ($truthy($send(self.$callbacks(), 'none?', [], (TMP_34 = function(c){var self = TMP_34.$$s || this;\nif (c == null) c = nil;\n              return c.$event()['$=='](Opal.const_get_relative($nesting, 'Custom'))}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34)))) {\n                \n              self[\"native\"].detachEvent(\"ondataavailable\", self[\"native\"].$custom);\n\n              delete self[\"native\"].$custom;\n            \n                } else {\n                return nil\n              }\n              } else {\n              return self[\"native\"].detachEvent(\"on\" + callback.$name(), callback.$to_proc())\n            }\n          }, TMP_Target_detach_35.$$arity = 1)\n          } else {\n          \n          Opal.defn(self, '$detach', TMP_Target_detach_36 = function $$detach(callback) {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n          }, TMP_Target_detach_36.$$arity = 1)\n        };\n        \n        Opal.defn(self, '$trigger', TMP_Target_trigger_37 = function $$trigger(event, $a_rest) {\n          var self = this, args, $iter = TMP_Target_trigger_37.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Target_trigger_37.$$p = null;\n          \n          if ($truthy(event['$is_a?'](Opal.const_get_relative($nesting, 'String')))) {\n            event = $send(Opal.const_get_relative($nesting, 'Event'), 'create', [event].concat(Opal.to_a(args)), block.$to_proc())};\n          return self.$dispatch(event);\n        }, TMP_Target_trigger_37.$$arity = -2);\n        \n        Opal.defn(self, '$trigger!', TMP_Target_trigger$B_38 = function(event, $a_rest) {\n          var TMP_39, self = this, args, $iter = TMP_Target_trigger$B_38.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Target_trigger$B_38.$$p = null;\n          return $send(self, 'trigger', [event].concat(Opal.to_a(args)), (TMP_39 = function(e){var self = TMP_39.$$s || this, $writer = nil;\nif (e == null) e = nil;\n          \n            if ($truthy(block)) {\n              block.$call(e)};\n            \n            $writer = [false];\n            $send(e, 'bubbles=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];;}, TMP_39.$$s = self, TMP_39.$$arity = 1, TMP_39))\n        }, TMP_Target_trigger$B_38.$$arity = -2);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.dispatch\"))) {\n          \n          Opal.defn(self, '$dispatch', TMP_Target_dispatch_40 = function $$dispatch(event) {\n            var self = this;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\n\n            return self[\"native\"].dispatchEvent(event.$to_n())\n          }, TMP_Target_dispatch_40.$$arity = 1)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.fire\"))) {\n          \n          Opal.defn(self, '$dispatch', TMP_Target_dispatch_41 = function $$dispatch(event) {\n            var self = this;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\n\n            if ($truthy(Opal.const_get_relative($nesting, 'Custom')['$==='](event))) {\n              return self[\"native\"].fireEvent(\"ondataavailable\", event.$to_n())\n              } else {\n              return self[\"native\"].fireEvent(\"on\" + event.$name(), event.$to_n())\n            }\n          }, TMP_Target_dispatch_41.$$arity = 1)\n          } else {\n          \n          Opal.defn(self, '$dispatch', TMP_Target_dispatch_42 = function $$dispatch($a_rest) {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n          }, TMP_Target_dispatch_42.$$arity = -1)\n        };\n        self.$private();\n        \n        Opal.defn(self, '$callbacks', TMP_Target_callbacks_43 = function $$callbacks() {\n          var self = this;\n          if (self[\"native\"] == null) self[\"native\"] = nil;\n\n          \n        if (!self[\"native\"].$callbacks) {\n          self[\"native\"].$callbacks = [];\n        }\n\n        return self[\"native\"].$callbacks;\n      \n        }, TMP_Target_callbacks_43.$$arity = 0);\n        \n        Opal.defn(self, '$delegated', TMP_Target_delegated_44 = function $$delegated() {\n          var self = this;\n          if (self[\"native\"] == null) self[\"native\"] = nil;\n\n          \n        if (!self[\"native\"].$delegated) {\n          self[\"native\"].$delegated = $hash2([], {});\n        }\n\n        return self[\"native\"].$delegated;\n      \n        }, TMP_Target_delegated_44.$$arity = 0);\n        \n        Opal.defn(self, '$delegate', TMP_Target_delegate_46 = function $$delegate(delegates, event, element) {\n          var $a, TMP_45, self = this;\n\n          if (element == null) {\n            element = event.$target();\n          }\n          \n          if ($truthy(($truthy($a = element['$nil?']()) ? $a : element['$=='](event.$on())))) {\n            return nil};\n          $send(delegates.$handlers(), 'each', [], (TMP_45 = function(selector, block){var self = TMP_45.$$s || this, new$ = nil, $writer = nil;\nif (selector == null) selector = nil;if (block == null) block = nil;\n          if ($truthy(element['$=~'](selector))) {\n              \n              new$ = event.$dup();\n              \n              $writer = [element];\n              $send(new$, 'on=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              return $send(block, 'call', [new$].concat(Opal.to_a(new$.$arguments())));\n              } else {\n              return nil\n            }}, TMP_45.$$s = self, TMP_45.$$arity = 2, TMP_45));\n          return self.$delegate(delegates, event, element.$parent());\n        }, TMP_Target_delegate_46.$$arity = -3);\n      })($nesting[0], $nesting);\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/ui\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $UI(){};\n        var self = $UI = $klass($base, $super, 'UI', $UI);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_UI_supported$q_1, TMP_UI_construct_4, TMP_UI_construct_5;\n\n        \n        Opal.defs(self, '$supported?', TMP_UI_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.UI\")\n        }, TMP_UI_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_detail$eq_2, TMP_Definition_view$eq_3;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$detail=', TMP_Definition_detail$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].detail = value\n          }, TMP_Definition_detail$eq_2.$$arity = 1);\n          return (Opal.defn(self, '$view=', TMP_Definition_view$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].view = value\n          }, TMP_Definition_view$eq_3.$$arity = 1), nil) && 'view=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_UI_construct_4 = function $$construct(name, desc) {\n              var self = this;\n\n              return new UIEvent(name, desc)\n            }, TMP_UI_construct_4.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_UI_construct_5 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent(\"UIEvent\");\n            event.initUIEvent(name, desc.bubbles, desc.cancelable,\n              desc.view || window, desc.detail || 0);\n\n        return event;\n      \n            }, TMP_UI_construct_5.$$arity = 2)}};\n        self.$alias_native(\"detail\");\n        return self.$alias_native(\"view\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/mouse\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$!', '$nil?', '$[]', '$include', '$new', '$try_convert', '$supported?', '$supports?', '$alias_native', '$x', '$screen', '$y', '$DOM', '$==', '$downcase', '$name']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Mouse(){};\n        var self = $Mouse = $klass($base, $super, 'Mouse', $Mouse);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Mouse_supported$q_1, TMP_Mouse_construct_29, TMP_Mouse_construct_30, TMP_Mouse_client_31, TMP_Mouse_layer_32, TMP_Mouse_offset_33, TMP_Mouse_page_34, TMP_Mouse_screen_35, TMP_Mouse_ancestor_36, TMP_Mouse_x_37, TMP_Mouse_y_38, TMP_Mouse_related_39, TMP_Mouse_from_40, TMP_Mouse_to_41, TMP_Mouse_click$q_42, TMP_Mouse_double_click$q_43, TMP_Mouse_down$q_44, TMP_Mouse_enter$q_45, TMP_Mouse_leave$q_46, TMP_Mouse_move$q_47, TMP_Mouse_out$q_48, TMP_Mouse_over$q_49, TMP_Mouse_up$q_50, TMP_Mouse_show$q_51;\n\n        def[\"native\"] = nil;\n        \n        Opal.defs(self, '$supported?', TMP_Mouse_supported$q_1 = function() {\n          var self = this;\n          if ($gvars.$ == null) $gvars.$ = nil;\n\n          return $gvars.$['$[]'](\"MouseEvent\")['$nil?']()['$!']()\n        }, TMP_Mouse_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_x$eq_14, TMP_Definition_y$eq_15, TMP_Definition_alt$B_16, TMP_Definition_ctrl$B_17, TMP_Definition_meta$B_18, TMP_Definition_button$eq_19, TMP_Definition_client_20, TMP_Definition_layer_21, TMP_Definition_offset_22, TMP_Definition_page_23, TMP_Definition_screen_24, TMP_Definition_ancestor_25, TMP_Definition_related$eq_26, TMP_Definition_from$eq_27, TMP_Definition_to$eq_28;\n\n          def[\"native\"] = nil;\n          \n          (function($base, $super, $parent_nesting) {\n            function $Client(){};\n            var self = $Client = $klass($base, $super, 'Client', $Client);\n\n            var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Client_x$eq_2, TMP_Client_y$eq_3;\n\n            def[\"native\"] = nil;\n            \n            self.$include(Opal.const_get_relative($nesting, 'Native'));\n            \n            Opal.defn(self, '$x=', TMP_Client_x$eq_2 = function(value) {\n              var self = this;\n\n              return self[\"native\"].clientX = value\n            }, TMP_Client_x$eq_2.$$arity = 1);\n            return (Opal.defn(self, '$y=', TMP_Client_y$eq_3 = function(value) {\n              var self = this;\n\n              return self[\"native\"].clientY = value\n            }, TMP_Client_y$eq_3.$$arity = 1), nil) && 'y=';\n          })($nesting[0], null, $nesting);\n          (function($base, $super, $parent_nesting) {\n            function $Layer(){};\n            var self = $Layer = $klass($base, $super, 'Layer', $Layer);\n\n            var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Layer_x$eq_4, TMP_Layer_y$eq_5;\n\n            def[\"native\"] = nil;\n            \n            self.$include(Opal.const_get_relative($nesting, 'Native'));\n            \n            Opal.defn(self, '$x=', TMP_Layer_x$eq_4 = function(value) {\n              var self = this;\n\n              return self[\"native\"].layerX = value\n            }, TMP_Layer_x$eq_4.$$arity = 1);\n            return (Opal.defn(self, '$y=', TMP_Layer_y$eq_5 = function(value) {\n              var self = this;\n\n              return self[\"native\"].layerY = value\n            }, TMP_Layer_y$eq_5.$$arity = 1), nil) && 'y=';\n          })($nesting[0], null, $nesting);\n          (function($base, $super, $parent_nesting) {\n            function $Offset(){};\n            var self = $Offset = $klass($base, $super, 'Offset', $Offset);\n\n            var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Offset_x$eq_6, TMP_Offset_y$eq_7;\n\n            def[\"native\"] = nil;\n            \n            self.$include(Opal.const_get_relative($nesting, 'Native'));\n            \n            Opal.defn(self, '$x=', TMP_Offset_x$eq_6 = function(value) {\n              var self = this;\n\n              return self[\"native\"].offsetX = value\n            }, TMP_Offset_x$eq_6.$$arity = 1);\n            return (Opal.defn(self, '$y=', TMP_Offset_y$eq_7 = function(value) {\n              var self = this;\n\n              return self[\"native\"].offsetY= value\n            }, TMP_Offset_y$eq_7.$$arity = 1), nil) && 'y=';\n          })($nesting[0], null, $nesting);\n          (function($base, $super, $parent_nesting) {\n            function $Page(){};\n            var self = $Page = $klass($base, $super, 'Page', $Page);\n\n            var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Page_x$eq_8, TMP_Page_y$eq_9;\n\n            def[\"native\"] = nil;\n            \n            self.$include(Opal.const_get_relative($nesting, 'Native'));\n            \n            Opal.defn(self, '$x=', TMP_Page_x$eq_8 = function(value) {\n              var self = this;\n\n              return self[\"native\"].pageX = value\n            }, TMP_Page_x$eq_8.$$arity = 1);\n            return (Opal.defn(self, '$y=', TMP_Page_y$eq_9 = function(value) {\n              var self = this;\n\n              return self[\"native\"].pageY = value\n            }, TMP_Page_y$eq_9.$$arity = 1), nil) && 'y=';\n          })($nesting[0], null, $nesting);\n          (function($base, $super, $parent_nesting) {\n            function $Screen(){};\n            var self = $Screen = $klass($base, $super, 'Screen', $Screen);\n\n            var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Screen_x$eq_10, TMP_Screen_y$eq_11;\n\n            def[\"native\"] = nil;\n            \n            self.$include(Opal.const_get_relative($nesting, 'Native'));\n            \n            Opal.defn(self, '$x=', TMP_Screen_x$eq_10 = function(value) {\n              var self = this;\n\n              return self[\"native\"].screenX = value\n            }, TMP_Screen_x$eq_10.$$arity = 1);\n            return (Opal.defn(self, '$y=', TMP_Screen_y$eq_11 = function(value) {\n              var self = this;\n\n              return self[\"native\"].screenY = value\n            }, TMP_Screen_y$eq_11.$$arity = 1), nil) && 'y=';\n          })($nesting[0], null, $nesting);\n          (function($base, $super, $parent_nesting) {\n            function $Ancestor(){};\n            var self = $Ancestor = $klass($base, $super, 'Ancestor', $Ancestor);\n\n            var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Ancestor_x$eq_12, TMP_Ancestor_y$eq_13;\n\n            def[\"native\"] = nil;\n            \n            self.$include(Opal.const_get_relative($nesting, 'Native'));\n            \n            Opal.defn(self, '$x=', TMP_Ancestor_x$eq_12 = function(value) {\n              var self = this;\n\n              return self[\"native\"].x = value\n            }, TMP_Ancestor_x$eq_12.$$arity = 1);\n            return (Opal.defn(self, '$y=', TMP_Ancestor_y$eq_13 = function(value) {\n              var self = this;\n\n              return self[\"native\"].y = value\n            }, TMP_Ancestor_y$eq_13.$$arity = 1), nil) && 'y=';\n          })($nesting[0], null, $nesting);\n          \n          Opal.defn(self, '$x=', TMP_Definition_x$eq_14 = function(value) {\n            var self = this;\n\n            return self[\"native\"].screenX = value\n          }, TMP_Definition_x$eq_14.$$arity = 1);\n          \n          Opal.defn(self, '$y=', TMP_Definition_y$eq_15 = function(value) {\n            var self = this;\n\n            return self[\"native\"].screenY = value\n          }, TMP_Definition_y$eq_15.$$arity = 1);\n          \n          Opal.defn(self, '$alt!', TMP_Definition_alt$B_16 = function() {\n            var self = this;\n\n            return self[\"native\"].altKey = true\n          }, TMP_Definition_alt$B_16.$$arity = 0);\n          \n          Opal.defn(self, '$ctrl!', TMP_Definition_ctrl$B_17 = function() {\n            var self = this;\n\n            return self[\"native\"].ctrlKey = true\n          }, TMP_Definition_ctrl$B_17.$$arity = 0);\n          \n          Opal.defn(self, '$meta!', TMP_Definition_meta$B_18 = function() {\n            var self = this;\n\n            return self[\"native\"].metaKey = true\n          }, TMP_Definition_meta$B_18.$$arity = 0);\n          \n          Opal.defn(self, '$button=', TMP_Definition_button$eq_19 = function(value) {\n            var self = this;\n\n            return self[\"native\"].button = value\n          }, TMP_Definition_button$eq_19.$$arity = 1);\n          \n          Opal.defn(self, '$client', TMP_Definition_client_20 = function $$client() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Client').$new(self[\"native\"])\n          }, TMP_Definition_client_20.$$arity = 0);\n          \n          Opal.defn(self, '$layer', TMP_Definition_layer_21 = function $$layer() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Layer').$new(self[\"native\"])\n          }, TMP_Definition_layer_21.$$arity = 0);\n          \n          Opal.defn(self, '$offset', TMP_Definition_offset_22 = function $$offset() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Offset').$new(self[\"native\"])\n          }, TMP_Definition_offset_22.$$arity = 0);\n          \n          Opal.defn(self, '$page', TMP_Definition_page_23 = function $$page() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Page').$new(self[\"native\"])\n          }, TMP_Definition_page_23.$$arity = 0);\n          \n          Opal.defn(self, '$screen', TMP_Definition_screen_24 = function $$screen() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Screen').$new(self[\"native\"])\n          }, TMP_Definition_screen_24.$$arity = 0);\n          \n          Opal.defn(self, '$ancestor', TMP_Definition_ancestor_25 = function $$ancestor() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Ancestor').$new(self[\"native\"])\n          }, TMP_Definition_ancestor_25.$$arity = 0);\n          \n          Opal.defn(self, '$related=', TMP_Definition_related$eq_26 = function(elem) {\n            var self = this;\n\n            return self[\"native\"].relatedTarget = Opal.const_get_relative($nesting, 'Native').$try_convert(elem)\n          }, TMP_Definition_related$eq_26.$$arity = 1);\n          \n          Opal.defn(self, '$from=', TMP_Definition_from$eq_27 = function(elem) {\n            var self = this;\n\n            return self[\"native\"].fromElement = Opal.const_get_relative($nesting, 'Native').$try_convert(elem)\n          }, TMP_Definition_from$eq_27.$$arity = 1);\n          return (Opal.defn(self, '$to=', TMP_Definition_to$eq_28 = function(elem) {\n            var self = this;\n\n            return self[\"native\"].toElement = Opal.const_get_relative($nesting, 'Native').$try_convert(elem)\n          }, TMP_Definition_to$eq_28.$$arity = 1), nil) && 'to=';\n        })($nesting[0], Opal.const_get_qualified(Opal.const_get_relative($nesting, 'UI'), 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Mouse_construct_29 = function $$construct(name, desc) {\n              var self = this;\n\n              return new MouseEvent(name, desc)\n            }, TMP_Mouse_construct_29.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_Mouse_construct_30 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent(\"MouseEvent\");\n            event.initMouseEvent(name, desc.bubbles, desc.cancelable,\n              desc.view || window, desc.detail || 0,\n              desc.screenX || 0, desc.screenY || 0,\n              desc.clientX || 0, desc.clientY || 0,\n              desc.ctrlKey || false, desc.altKey || false,\n              desc.shiftKey || false, desc.metaKey || false,\n              desc.button || 0, desc.relatedTarget || null);\n\n        return event;\n      \n            }, TMP_Mouse_construct_30.$$arity = 2)}};\n        self.$alias_native(\"alt?\", \"altKey\");\n        self.$alias_native(\"ctrl?\", \"ctrlKey\");\n        self.$alias_native(\"meta?\", \"metaKey\");\n        self.$alias_native(\"shift?\", \"shiftKey\");\n        self.$alias_native(\"button\");\n        \n        Opal.defn(self, '$client', TMP_Mouse_client_31 = function $$client() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Position').$new(self[\"native\"].clientX, self[\"native\"].clientY)\n        }, TMP_Mouse_client_31.$$arity = 0);\n        \n        Opal.defn(self, '$layer', TMP_Mouse_layer_32 = function $$layer() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].layerX == null)) {\n            return nil\n            } else {\n            return Opal.const_get_relative($nesting, 'Position').$new(self[\"native\"].layerX, self[\"native\"].layerY)\n          }\n        }, TMP_Mouse_layer_32.$$arity = 0);\n        \n        Opal.defn(self, '$offset', TMP_Mouse_offset_33 = function $$offset() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].offsetX == null)) {\n            return nil\n            } else {\n            return Opal.const_get_relative($nesting, 'Position').$new(self[\"native\"].offsetX, self[\"native\"].offsetY)\n          }\n        }, TMP_Mouse_offset_33.$$arity = 0);\n        \n        Opal.defn(self, '$page', TMP_Mouse_page_34 = function $$page() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].pageX == null)) {\n            return nil\n            } else {\n            return Opal.const_get_relative($nesting, 'Position').$new(self[\"native\"].pageX, self[\"native\"].pageY)\n          }\n        }, TMP_Mouse_page_34.$$arity = 0);\n        \n        Opal.defn(self, '$screen', TMP_Mouse_screen_35 = function $$screen() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].screenX == null)) {\n            return nil\n            } else {\n            return Opal.const_get_relative($nesting, 'Position').$new(self[\"native\"].screenX, self[\"native\"].screenY)\n          }\n        }, TMP_Mouse_screen_35.$$arity = 0);\n        \n        Opal.defn(self, '$ancestor', TMP_Mouse_ancestor_36 = function $$ancestor() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].x == null)) {\n            return nil\n            } else {\n            return Opal.const_get_relative($nesting, 'Position').$new(self[\"native\"].x, self[\"native\"].y)\n          }\n        }, TMP_Mouse_ancestor_36.$$arity = 0);\n        \n        Opal.defn(self, '$x', TMP_Mouse_x_37 = function $$x() {\n          var self = this;\n\n          return self.$screen().$x()\n        }, TMP_Mouse_x_37.$$arity = 0);\n        \n        Opal.defn(self, '$y', TMP_Mouse_y_38 = function $$y() {\n          var self = this;\n\n          return self.$screen().$y()\n        }, TMP_Mouse_y_38.$$arity = 0);\n        \n        Opal.defn(self, '$related', TMP_Mouse_related_39 = function $$related() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].relatedTarget == null)) {\n            return nil\n            } else {\n            return self.$DOM(self[\"native\"].relatedTarget)\n          }\n        }, TMP_Mouse_related_39.$$arity = 0);\n        \n        Opal.defn(self, '$from', TMP_Mouse_from_40 = function $$from() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].fromElement == null)) {\n            return nil\n            } else {\n            return self.$DOM(self[\"native\"].fromElement)\n          }\n        }, TMP_Mouse_from_40.$$arity = 0);\n        \n        Opal.defn(self, '$to', TMP_Mouse_to_41 = function $$to() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].toElement == null)) {\n            return nil\n            } else {\n            return self.$DOM(self[\"native\"].toElement)\n          }\n        }, TMP_Mouse_to_41.$$arity = 0);\n        \n        Opal.defn(self, '$click?', TMP_Mouse_click$q_42 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"click\")\n        }, TMP_Mouse_click$q_42.$$arity = 0);\n        \n        Opal.defn(self, '$double_click?', TMP_Mouse_double_click$q_43 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"dblclick\")\n        }, TMP_Mouse_double_click$q_43.$$arity = 0);\n        \n        Opal.defn(self, '$down?', TMP_Mouse_down$q_44 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"mousedown\")\n        }, TMP_Mouse_down$q_44.$$arity = 0);\n        \n        Opal.defn(self, '$enter?', TMP_Mouse_enter$q_45 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"mouseenter\")\n        }, TMP_Mouse_enter$q_45.$$arity = 0);\n        \n        Opal.defn(self, '$leave?', TMP_Mouse_leave$q_46 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"mouseleave\")\n        }, TMP_Mouse_leave$q_46.$$arity = 0);\n        \n        Opal.defn(self, '$move?', TMP_Mouse_move$q_47 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"mousemove\")\n        }, TMP_Mouse_move$q_47.$$arity = 0);\n        \n        Opal.defn(self, '$out?', TMP_Mouse_out$q_48 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"mouseout\")\n        }, TMP_Mouse_out$q_48.$$arity = 0);\n        \n        Opal.defn(self, '$over?', TMP_Mouse_over$q_49 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"mouseover\")\n        }, TMP_Mouse_over$q_49.$$arity = 0);\n        \n        Opal.defn(self, '$up?', TMP_Mouse_up$q_50 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"mouseup\")\n        }, TMP_Mouse_up$q_50.$$arity = 0);\n        return (Opal.defn(self, '$show?', TMP_Mouse_show$q_51 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"show\")\n        }, TMP_Mouse_show$q_51.$$arity = 0), nil) && 'show?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'UI'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/keyboard\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native', '$code', '$chr', '$==', '$downcase', '$name']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Keyboard(){};\n        var self = $Keyboard = $klass($base, $super, 'Keyboard', $Keyboard);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Keyboard_supported$q_1, TMP_Keyboard_construct_11, TMP_Keyboard_construct_12, TMP_Keyboard_key_13, TMP_Keyboard_code_14, TMP_Keyboard_char_15, TMP_Keyboard_down$q_16, TMP_Keyboard_press$q_17, TMP_Keyboard_up$q_18;\n\n        def[\"native\"] = nil;\n        \n        Opal.defs(self, '$supported?', TMP_Keyboard_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Keyboard\")\n        }, TMP_Keyboard_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_alt$B_2, TMP_Definition_ctrl$B_3, TMP_Definition_meta$B_4, TMP_Definition_shift$B_5, TMP_Definition_code$eq_6, TMP_Definition_key$eq_7, TMP_Definition_char$eq_8, TMP_Definition_repeat$B_9, TMP_Definition_locale$eq_10;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$alt!', TMP_Definition_alt$B_2 = function() {\n            var self = this;\n\n            return self[\"native\"].altKey = true\n          }, TMP_Definition_alt$B_2.$$arity = 0);\n          \n          Opal.defn(self, '$ctrl!', TMP_Definition_ctrl$B_3 = function() {\n            var self = this;\n\n            return self[\"native\"].ctrlKey = true\n          }, TMP_Definition_ctrl$B_3.$$arity = 0);\n          \n          Opal.defn(self, '$meta!', TMP_Definition_meta$B_4 = function() {\n            var self = this;\n\n            return self[\"native\"].metaKey = true\n          }, TMP_Definition_meta$B_4.$$arity = 0);\n          \n          Opal.defn(self, '$shift!', TMP_Definition_shift$B_5 = function() {\n            var self = this;\n\n            return self[\"native\"].shiftKey = true\n          }, TMP_Definition_shift$B_5.$$arity = 0);\n          \n          Opal.defn(self, '$code=', TMP_Definition_code$eq_6 = function(code) {\n            var self = this;\n\n            return self[\"native\"].keyCode = self[\"native\"].which = code\n          }, TMP_Definition_code$eq_6.$$arity = 1);\n          \n          Opal.defn(self, '$key=', TMP_Definition_key$eq_7 = function(key) {\n            var self = this;\n\n            return self[\"native\"].key = key\n          }, TMP_Definition_key$eq_7.$$arity = 1);\n          \n          Opal.defn(self, '$char=', TMP_Definition_char$eq_8 = function(char$) {\n            var self = this;\n\n            return self[\"native\"].char = self[\"native\"].charCode = char$\n          }, TMP_Definition_char$eq_8.$$arity = 1);\n          \n          Opal.defn(self, '$repeat!', TMP_Definition_repeat$B_9 = function() {\n            var self = this;\n\n            return self[\"native\"].repeat = true\n          }, TMP_Definition_repeat$B_9.$$arity = 0);\n          return (Opal.defn(self, '$locale=', TMP_Definition_locale$eq_10 = function(value) {\n            var self = this;\n\n            return self[\"native\"].locale = value\n          }, TMP_Definition_locale$eq_10.$$arity = 1), nil) && 'locale=';\n        })($nesting[0], Opal.const_get_qualified(Opal.const_get_relative($nesting, 'UI'), 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Keyboard_construct_11 = function $$construct(name, desc) {\n              var self = this;\n\n              return new KeyboardEvent(name, desc)\n            }, TMP_Keyboard_construct_11.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_Keyboard_construct_12 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var modifiers = \"\";\n\n        if (desc.altKey) {\n          modifiers += \"Alt \";\n        }\n\n        if (desc.ctrlKey) {\n          modifiers += \"Ctrl \";\n        }\n\n        if (desc.shiftKey) {\n          modifiers += \"Shift\" ;\n        }\n\n        if (desc.metaKey) {\n          modifiers += \"Meta \";\n        }\n\n        var event = document.createEvent(\"KeyboardEvent\");\n            event.initKeyboardEvent(name, desc.bubbles, desc.cancelable,\n              desc.view || window, desc.which, 0,\n              modifiers, desc.repeat, desc.locale);\n\n        return event;\n      \n            }, TMP_Keyboard_construct_12.$$arity = 2)}};\n        self.$alias_native(\"alt?\", \"altKey\");\n        self.$alias_native(\"ctrl?\", \"ctrlKey\");\n        self.$alias_native(\"meta?\", \"metaKey\");\n        self.$alias_native(\"shift?\", \"shiftKey\");\n        self.$alias_native(\"locale\");\n        self.$alias_native(\"repeat?\", \"repeat\");\n        \n        Opal.defn(self, '$key', TMP_Keyboard_key_13 = function $$key() {\n          var self = this;\n\n          return self[\"native\"].key || self[\"native\"].keyIdentifier || nil\n        }, TMP_Keyboard_key_13.$$arity = 0);\n        \n        Opal.defn(self, '$code', TMP_Keyboard_code_14 = function $$code() {\n          var self = this;\n\n          return self[\"native\"].keyCode || self[\"native\"].which || nil\n        }, TMP_Keyboard_code_14.$$arity = 0);\n        \n        Opal.defn(self, '$char', TMP_Keyboard_char_15 = function() {\n          var self = this;\n\n          return self[\"native\"].char || self[\"native\"].charCode || (function() {if ($truthy(self.$code())) {\n            return self.$code().$chr()\n            } else {\n            return nil\n          }; return nil; })()\n        }, TMP_Keyboard_char_15.$$arity = 0);\n        Opal.alias(self, \"to_i\", \"key\");\n        \n        Opal.defn(self, '$down?', TMP_Keyboard_down$q_16 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"keydown\")\n        }, TMP_Keyboard_down$q_16.$$arity = 0);\n        \n        Opal.defn(self, '$press?', TMP_Keyboard_press$q_17 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"keypress\")\n        }, TMP_Keyboard_press$q_17.$$arity = 0);\n        return (Opal.defn(self, '$up?', TMP_Keyboard_up$q_18 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"keyup\")\n        }, TMP_Keyboard_up$q_18.$$arity = 0), nil) && 'up?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'UI'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/focus\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$convert', '$supported?', '$DOM']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Focus(){};\n        var self = $Focus = $klass($base, $super, 'Focus', $Focus);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Focus_supported$q_1, TMP_Focus_construct_4, TMP_Focus_construct_5, TMP_Focus_related_6;\n\n        def[\"native\"] = nil;\n        \n        Opal.defs(self, '$supported?', TMP_Focus_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Focus\")\n        }, TMP_Focus_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_view$eq_2, TMP_Definition_related$eq_3;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$view=', TMP_Definition_view$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].view = Opal.const_get_relative($nesting, 'Native').$convert(value)\n          }, TMP_Definition_view$eq_2.$$arity = 1);\n          return (Opal.defn(self, '$related=', TMP_Definition_related$eq_3 = function(elem) {\n            var self = this;\n\n            return self[\"native\"].relatedTarget = Opal.const_get_relative($nesting, 'Native').$convert(elem)\n          }, TMP_Definition_related$eq_3.$$arity = 1), nil) && 'related=';\n        })($nesting[0], Opal.const_get_qualified(Opal.const_get_relative($nesting, 'UI'), 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Focus_construct_4 = function $$construct(name, desc) {\n              var self = this;\n\n              return new FocusEvent(name, desc)\n            }, TMP_Focus_construct_4.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_Focus_construct_5 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent(\"FocusEvent\");\n            event.initFocusEvent(name, desc.bubbles, desc.cancelable,\n              desc.view || window, 0, desc.relatedTarget);\n\n        return event;\n      \n            }, TMP_Focus_construct_5.$$arity = 2)}};\n        return (Opal.defn(self, '$related', TMP_Focus_related_6 = function $$related() {\n          var self = this;\n\n          return self.$DOM(self[\"native\"].relatedTarget)\n        }, TMP_Focus_related_6.$$arity = 0), nil) && 'related';\n      })($nesting[0], Opal.const_get_relative($nesting, 'UI'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/wheel\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$!', '$nil?', '$[]', '$===', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Wheel(){};\n        var self = $Wheel = $klass($base, $super, 'Wheel', $Wheel);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Wheel_supported$q_1, TMP_Wheel_construct_6, TMP_Wheel_mode_7;\n\n        def[\"native\"] = nil;\n        \n        Opal.defs(self, '$supported?', TMP_Wheel_supported$q_1 = function() {\n          var self = this;\n          if ($gvars.$ == null) $gvars.$ = nil;\n\n          return $gvars.$['$[]'](\"WheelEvent\")['$nil?']()['$!']()\n        }, TMP_Wheel_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_x$eq_2, TMP_Definition_y$eq_3, TMP_Definition_z$eq_4, TMP_Definition_mode$eq_5;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$x=', TMP_Definition_x$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].deltaX = value\n          }, TMP_Definition_x$eq_2.$$arity = 1);\n          \n          Opal.defn(self, '$y=', TMP_Definition_y$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].deltaY = value\n          }, TMP_Definition_y$eq_3.$$arity = 1);\n          \n          Opal.defn(self, '$z=', TMP_Definition_z$eq_4 = function(value) {\n            var self = this;\n\n            return self[\"native\"].deltaZ = value\n          }, TMP_Definition_z$eq_4.$$arity = 1);\n          return (Opal.defn(self, '$mode=', TMP_Definition_mode$eq_5 = function(value) {\n            var self = this, $case = nil;\n\n            \n            value = (function() {$case = value;\n            if (\"pixel\"['$===']($case)) {return WheelEvent.DOM_DELTA_PIXEL}\n            else if (\"line\"['$===']($case)) {return WheelEvent.DOM_DELTA_LINE}\n            else if (\"page\"['$===']($case)) {return WheelEvent.DOM_DELTA_PAGE}\n            else { return nil }})();\n            return self[\"native\"].deltaMode = value;\n          }, TMP_Definition_mode$eq_5.$$arity = 1), nil) && 'mode=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        Opal.defs(self, '$construct', TMP_Wheel_construct_6 = function $$construct(name, desc) {\n          var self = this;\n\n          return new WheelEvent(name, desc)\n        }, TMP_Wheel_construct_6.$$arity = 2);\n        self.$alias_native(\"x\", \"deltaX\");\n        self.$alias_native(\"y\", \"deltaY\");\n        self.$alias_native(\"z\", \"deltaZ\");\n        return (Opal.defn(self, '$mode', TMP_Wheel_mode_7 = function $$mode() {\n          var self = this, $case = nil;\n\n          return (function() {$case = self[\"native\"].deltaMode;\n          if ((WheelEvent.DOM_DELTA_PIXEL)['$===']($case)) {return \"pixel\"}\n          else if ((WheelEvent.DOM_DELTA_LINE)['$===']($case)) {return \"line\"}\n          else if ((WheelEvent.DOM_DELTA_PAGE)['$===']($case)) {return \"page\"}\n          else { return nil }})()\n        }, TMP_Wheel_mode_7.$$arity = 0), nil) && 'mode';\n      })($nesting[0], Opal.const_get_relative($nesting, 'UI'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/composition\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native', '$==', '$downcase', '$name']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Composition(){};\n        var self = $Composition = $klass($base, $super, 'Composition', $Composition);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Composition_supported$q_1, TMP_Composition_construct_4, TMP_Composition_construct_5, TMP_Composition_start$q_6, TMP_Composition_update$q_7, TMP_Composition_end$q_8;\n\n        \n        Opal.defs(self, '$supported?', TMP_Composition_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Composition\")\n        }, TMP_Composition_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_data$eq_2, TMP_Definition_locale$eq_3;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$data=', TMP_Definition_data$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].data = value\n          }, TMP_Definition_data$eq_2.$$arity = 1);\n          return (Opal.defn(self, '$locale=', TMP_Definition_locale$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].locale = value\n          }, TMP_Definition_locale$eq_3.$$arity = 1), nil) && 'locale=';\n        })($nesting[0], Opal.const_get_qualified(Opal.const_get_relative($nesting, 'UI'), 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Composition_construct_4 = function $$construct(name, desc) {\n              var self = this;\n\n              return new CompositionEvent(name, desc)\n            }, TMP_Composition_construct_4.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_Composition_construct_5 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent(\"CompositionEvent\");\n            event.initCompositionEvent(name, desc.bubbles, desc.cancelable,\n              desc.view || window, desc.data, desc.locale);\n\n        return event;\n      \n            }, TMP_Composition_construct_5.$$arity = 2)}};\n        self.$alias_native(\"data\");\n        self.$alias_native(\"locale\");\n        \n        Opal.defn(self, '$start?', TMP_Composition_start$q_6 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"compositionstart\")\n        }, TMP_Composition_start$q_6.$$arity = 0);\n        \n        Opal.defn(self, '$update?', TMP_Composition_update$q_7 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"compositionupdate\")\n        }, TMP_Composition_update$q_7.$$arity = 0);\n        return (Opal.defn(self, '$end?', TMP_Composition_end$q_8 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"compositionend\")\n        }, TMP_Composition_end$q_8.$$arity = 0), nil) && 'end?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'UI'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/animation\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Animation(){};\n        var self = $Animation = $klass($base, $super, 'Animation', $Animation);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Animation_supported$q_1, TMP_Animation_construct_4, TMP_Animation_construct_5;\n\n        \n        Opal.defs(self, '$supported?', TMP_Animation_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Animation\")\n        }, TMP_Animation_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_animation$eq_2, TMP_Definition_elapsed$eq_3;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$animation=', TMP_Definition_animation$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].animationName = value\n          }, TMP_Definition_animation$eq_2.$$arity = 1);\n          return (Opal.defn(self, '$elapsed=', TMP_Definition_elapsed$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].elapsedTime = value\n          }, TMP_Definition_elapsed$eq_3.$$arity = 1), nil) && 'elapsed=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Animation_construct_4 = function $$construct(name, desc) {\n              var self = this;\n\n              return new AnimationEvent(name, desc)\n            }, TMP_Animation_construct_4.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_Animation_construct_5 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent(\"AnimationEvent\");\n            event.initAnimationEvent(name, desc.bubbles, desc.cancelable,\n              desc.animationName, desc.elapsedTime);\n\n        return event;\n      \n            }, TMP_Animation_construct_5.$$arity = 2)}};\n        self.$alias_native(\"name\", \"animationName\");\n        return self.$alias_native(\"elapsed\", \"elapsedTime\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/audio_processing\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $AudioProcessing(){};\n        var self = $AudioProcessing = $klass($base, $super, 'AudioProcessing', $AudioProcessing);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_AudioProcessing_supported$q_1, TMP_AudioProcessing_construct_5;\n\n        \n        Opal.defs(self, '$supported?', TMP_AudioProcessing_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.AudioProcessing\")\n        }, TMP_AudioProcessing_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_time$eq_2, TMP_Definition_input$eq_3, TMP_Definition_output$eq_4;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$time=', TMP_Definition_time$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].playbackTime = value\n          }, TMP_Definition_time$eq_2.$$arity = 1);\n          \n          Opal.defn(self, '$input=', TMP_Definition_input$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].inputBuffer = value\n          }, TMP_Definition_input$eq_3.$$arity = 1);\n          return (Opal.defn(self, '$output=', TMP_Definition_output$eq_4 = function(value) {\n            var self = this;\n\n            return self[\"native\"].outputBuffer = value\n          }, TMP_Definition_output$eq_4.$$arity = 1), nil) && 'output=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_AudioProcessing_construct_5 = function $$construct(name, desc) {\n              var self = this;\n\n              return new AudioProcessingEvent(name, desc)\n            }, TMP_AudioProcessing_construct_5.$$arity = 2)}};\n        self.$alias_native(\"time\", \"playbackTime\");\n        self.$alias_native(\"input\", \"inputBuffer\");\n        return self.$alias_native(\"output\", \"outputBuffer\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/before_unload\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $BeforeUnload(){};\n        var self = $BeforeUnload = $klass($base, $super, 'BeforeUnload', $BeforeUnload);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BeforeUnload_supported$q_1, TMP_BeforeUnload_construct_2;\n\n        \n        Opal.defs(self, '$supported?', TMP_BeforeUnload_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.BeforeUnload\")\n        }, TMP_BeforeUnload_supported$q_1.$$arity = 0);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            return Opal.defs(self, '$construct', TMP_BeforeUnload_construct_2 = function $$construct(name, desc) {\n              var self = this;\n\n              return new BeforeUnloadEvent(name, desc)\n            }, TMP_BeforeUnload_construct_2.$$arity = 2)\n            } else {\n            return nil\n          }\n          } else {\n          return nil\n        };\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/clipboard\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Clipboard(){};\n        var self = $Clipboard = $klass($base, $super, 'Clipboard', $Clipboard);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Clipboard_supported$q_1, TMP_Clipboard_construct_4;\n\n        \n        Opal.defs(self, '$supported?', TMP_Clipboard_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Clipboard\")\n        }, TMP_Clipboard_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_data$eq_2, TMP_Definition_type$eq_3;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$data=', TMP_Definition_data$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].data = value\n          }, TMP_Definition_data$eq_2.$$arity = 1);\n          return (Opal.defn(self, '$type=', TMP_Definition_type$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].dataType = value\n          }, TMP_Definition_type$eq_3.$$arity = 1), nil) && 'type=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Clipboard_construct_4 = function $$construct(name, desc) {\n              var self = this;\n\n              return new ClipboardEvent(name, desc)\n            }, TMP_Clipboard_construct_4.$$arity = 2)}};\n        self.$alias_native(\"data\");\n        return self.$alias_native(\"type\", \"dataType\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/device_light\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $DeviceLight(){};\n        var self = $DeviceLight = $klass($base, $super, 'DeviceLight', $DeviceLight);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DeviceLight_supported$q_1, TMP_DeviceLight_construct_3;\n\n        \n        Opal.defs(self, '$supported?', TMP_DeviceLight_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.DeviceLight\")\n        }, TMP_DeviceLight_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_value$eq_2;\n\n          def[\"native\"] = nil;\n          return (Opal.defn(self, '$value=', TMP_Definition_value$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].value = value\n          }, TMP_Definition_value$eq_2.$$arity = 1), nil) && 'value='\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_DeviceLight_construct_3 = function $$construct(name, desc) {\n              var self = this;\n\n              return new DeviceLightEvent(name, desc)\n            }, TMP_DeviceLight_construct_3.$$arity = 2)}};\n        return self.$alias_native(\"value\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/device_motion\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$new', '$to_n', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $DeviceMotion(){};\n        var self = $DeviceMotion = $klass($base, $super, 'DeviceMotion', $DeviceMotion);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DeviceMotion_supported$q_1, TMP_DeviceMotion_construct_6, TMP_DeviceMotion_construct_7;\n\n        \n        Opal.defs(self, '$supported?', TMP_DeviceMotion_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.DeviceMotion\")\n        }, TMP_DeviceMotion_supported$q_1.$$arity = 0);\n        Opal.const_set($nesting[0], 'Acceleration', Opal.const_get_relative($nesting, 'Struct').$new(\"x\", \"y\", \"z\"));\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_acceleration$eq_2, TMP_Definition_acceleration_with_gravity$eq_3, TMP_Definition_rotation$eq_4, TMP_Definition_interval$eq_5;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$acceleration=', TMP_Definition_acceleration$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].acceleration = value.$to_n()\n          }, TMP_Definition_acceleration$eq_2.$$arity = 1);\n          \n          Opal.defn(self, '$acceleration_with_gravity=', TMP_Definition_acceleration_with_gravity$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].accelerationIncludingGravity = value.$to_n()\n          }, TMP_Definition_acceleration_with_gravity$eq_3.$$arity = 1);\n          \n          Opal.defn(self, '$rotation=', TMP_Definition_rotation$eq_4 = function(value) {\n            var self = this;\n\n            return self[\"native\"].rotationRate = value\n          }, TMP_Definition_rotation$eq_4.$$arity = 1);\n          return (Opal.defn(self, '$interval=', TMP_Definition_interval$eq_5 = function(value) {\n            var self = this;\n\n            return self[\"native\"].interval = value\n          }, TMP_Definition_interval$eq_5.$$arity = 1), nil) && 'interval=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_DeviceMotion_construct_6 = function $$construct(name, desc) {\n              var self = this;\n\n              return new DeviceMotionEvent(name, desc)\n            }, TMP_DeviceMotion_construct_6.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_DeviceMotion_construct_7 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent(\"DeviceMotionEvent\");\n            event.initDeviceMotionEvent(name, desc.bubbles, desc.cancelable,\n              desc.acceleration, desc.accelerationIncludingGravity,\n              desc.rotationRate, desc.interval);\n\n        return event;\n      \n            }, TMP_DeviceMotion_construct_7.$$arity = 2)}};\n        self.$alias_native(\"acceleration\");\n        self.$alias_native(\"acceleration_with_gravity\", \"accelerationIncludingGravity\");\n        self.$alias_native(\"rotation\", \"rotationRate\");\n        return self.$alias_native(\"interval\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/device_orientation\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $DeviceOrientation(){};\n        var self = $DeviceOrientation = $klass($base, $super, 'DeviceOrientation', $DeviceOrientation);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DeviceOrientation_supported$q_1, TMP_DeviceOrientation_construct_6, TMP_DeviceOrientation_construct_7;\n\n        \n        Opal.defs(self, '$supported?', TMP_DeviceOrientation_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.DeviceOrientation\")\n        }, TMP_DeviceOrientation_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_absolute$eq_2, TMP_Definition_alpha$eq_3, TMP_Definition_beta$eq_4, TMP_Definition_gamma$eq_5;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$absolute=', TMP_Definition_absolute$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].absolute = value\n          }, TMP_Definition_absolute$eq_2.$$arity = 1);\n          \n          Opal.defn(self, '$alpha=', TMP_Definition_alpha$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].alpha = value\n          }, TMP_Definition_alpha$eq_3.$$arity = 1);\n          \n          Opal.defn(self, '$beta=', TMP_Definition_beta$eq_4 = function(value) {\n            var self = this;\n\n            return self[\"native\"].beta = value\n          }, TMP_Definition_beta$eq_4.$$arity = 1);\n          return (Opal.defn(self, '$gamma=', TMP_Definition_gamma$eq_5 = function(value) {\n            var self = this;\n\n            return self[\"native\"].gamma = value\n          }, TMP_Definition_gamma$eq_5.$$arity = 1), nil) && 'gamma=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_DeviceOrientation_construct_6 = function $$construct(name, desc) {\n              var self = this;\n\n              return new DeviceOrientationEvent(name, desc)\n            }, TMP_DeviceOrientation_construct_6.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_DeviceOrientation_construct_7 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent(\"DeviceOrientationEvent\");\n            event.initDeviceOrientationEvent(name, desc.bubbles, desc.cancelable,\n              desc.alpha, desc.beta, desc.gamma, desc.absolute);\n\n        return event;\n      \n            }, TMP_DeviceOrientation_construct_7.$$arity = 2)}};\n        self.$alias_native(\"absolute\");\n        self.$alias_native(\"alpha\");\n        self.$alias_native(\"beta\");\n        return self.$alias_native(\"gamma\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/device_proximity\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $DeviceProximity(){};\n        var self = $DeviceProximity = $klass($base, $super, 'DeviceProximity', $DeviceProximity);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DeviceProximity_supported$q_1, TMP_DeviceProximity_construct_5;\n\n        \n        Opal.defs(self, '$supported?', TMP_DeviceProximity_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.DeviceProximity\")\n        }, TMP_DeviceProximity_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_value$eq_2, TMP_Definition_min$eq_3, TMP_Definition_max$eq_4;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$value=', TMP_Definition_value$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].value = value\n          }, TMP_Definition_value$eq_2.$$arity = 1);\n          \n          Opal.defn(self, '$min=', TMP_Definition_min$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].min = value\n          }, TMP_Definition_min$eq_3.$$arity = 1);\n          return (Opal.defn(self, '$max=', TMP_Definition_max$eq_4 = function(value) {\n            var self = this;\n\n            return self[\"native\"].max = value\n          }, TMP_Definition_max$eq_4.$$arity = 1), nil) && 'max=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_DeviceProximity_construct_5 = function $$construct(name, desc) {\n              var self = this;\n\n              return new DeviceProximityEvent(name, desc)\n            }, TMP_DeviceProximity_construct_5.$$arity = 2)}};\n        self.$alias_native(\"value\");\n        self.$alias_native(\"min\");\n        return self.$alias_native(\"max\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/drag\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$include', '$new', '$convert', '$elem', '$supported?', '$alias_native', '$x', '$screen', '$y', '$DOM', '$raise']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Drag(){};\n        var self = $Drag = $klass($base, $super, 'Drag', $Drag);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Drag_supported$q_1, TMP_Drag_construct_14, TMP_Drag_construct_15, TMP_Drag_client_16, TMP_Drag_screen_17, TMP_Drag_x_18, TMP_Drag_y_19, TMP_Drag_related_20, TMP_Drag_transfer_21;\n\n        def[\"native\"] = nil;\n        \n        Opal.defs(self, '$supported?', TMP_Drag_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Drag\")\n        }, TMP_Drag_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_alt$B_6, TMP_Definition_ctrl$B_7, TMP_Definition_meta$B_8, TMP_Definition_button$eq_9, TMP_Definition_client_10, TMP_Definition_screen_11, TMP_Definition_related$eq_12, TMP_Definition_transfer$eq_13;\n\n          def[\"native\"] = nil;\n          \n          (function($base, $super, $parent_nesting) {\n            function $Client(){};\n            var self = $Client = $klass($base, $super, 'Client', $Client);\n\n            var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Client_x$eq_2, TMP_Client_y$eq_3;\n\n            def[\"native\"] = nil;\n            \n            self.$include(Opal.const_get_relative($nesting, 'Native'));\n            \n            Opal.defn(self, '$x=', TMP_Client_x$eq_2 = function(value) {\n              var self = this;\n\n              return self[\"native\"].clientX = value\n            }, TMP_Client_x$eq_2.$$arity = 1);\n            return (Opal.defn(self, '$y=', TMP_Client_y$eq_3 = function(value) {\n              var self = this;\n\n              return self[\"native\"].clientY = value\n            }, TMP_Client_y$eq_3.$$arity = 1), nil) && 'y=';\n          })($nesting[0], null, $nesting);\n          (function($base, $super, $parent_nesting) {\n            function $Screen(){};\n            var self = $Screen = $klass($base, $super, 'Screen', $Screen);\n\n            var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Screen_x$eq_4, TMP_Screen_y$eq_5;\n\n            def[\"native\"] = nil;\n            \n            self.$include(Opal.const_get_relative($nesting, 'Native'));\n            \n            Opal.defn(self, '$x=', TMP_Screen_x$eq_4 = function(value) {\n              var self = this;\n\n              return self[\"native\"].screenX = value\n            }, TMP_Screen_x$eq_4.$$arity = 1);\n            return (Opal.defn(self, '$y=', TMP_Screen_y$eq_5 = function(value) {\n              var self = this;\n\n              return self[\"native\"].screenY = value\n            }, TMP_Screen_y$eq_5.$$arity = 1), nil) && 'y=';\n          })($nesting[0], null, $nesting);\n          \n          Opal.defn(self, '$alt!', TMP_Definition_alt$B_6 = function() {\n            var self = this;\n\n            return self[\"native\"].altKey = true\n          }, TMP_Definition_alt$B_6.$$arity = 0);\n          \n          Opal.defn(self, '$ctrl!', TMP_Definition_ctrl$B_7 = function() {\n            var self = this;\n\n            return self[\"native\"].ctrlKey = true\n          }, TMP_Definition_ctrl$B_7.$$arity = 0);\n          \n          Opal.defn(self, '$meta!', TMP_Definition_meta$B_8 = function() {\n            var self = this;\n\n            return self[\"native\"].metaKey = true\n          }, TMP_Definition_meta$B_8.$$arity = 0);\n          \n          Opal.defn(self, '$button=', TMP_Definition_button$eq_9 = function(value) {\n            var self = this;\n\n            return self[\"native\"].button = value\n          }, TMP_Definition_button$eq_9.$$arity = 1);\n          \n          Opal.defn(self, '$client', TMP_Definition_client_10 = function $$client() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Client').$new(self[\"native\"])\n          }, TMP_Definition_client_10.$$arity = 0);\n          \n          Opal.defn(self, '$screen', TMP_Definition_screen_11 = function $$screen() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Screen').$new(self[\"native\"])\n          }, TMP_Definition_screen_11.$$arity = 0);\n          \n          Opal.defn(self, '$related=', TMP_Definition_related$eq_12 = function(elem) {\n            var self = this;\n\n            return self[\"native\"].relatedTarget = Opal.const_get_relative($nesting, 'Native').$convert(elem)\n          }, TMP_Definition_related$eq_12.$$arity = 1);\n          return (Opal.defn(self, '$transfer=', TMP_Definition_transfer$eq_13 = function(value) {\n            var self = this;\n\n            return self[\"native\"].dataTransfer = Opal.const_get_relative($nesting, 'Native').$convert(self.$elem())\n          }, TMP_Definition_transfer$eq_13.$$arity = 1), nil) && 'transfer=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Drag_construct_14 = function $$construct(name, desc) {\n              var self = this;\n\n              return new DragEvent(name, desc)\n            }, TMP_Drag_construct_14.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_Drag_construct_15 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent(\"DragEvent\");\n            event.initDragEvent(name, desc.bubbles, desc.cancelable,\n              desc.view || window, 0,\n              desc.screenX || 0, desc.screenY || 0,\n              desc.clientX || 0, desc.clientY || 0,\n              desc.ctrlKey, desc.altKey, desc.shiftKey, desc.metaKey,\n              desc.button || 0, desc.relatedTarget, desc.dataTransfer);\n\n        return event;\n      \n            }, TMP_Drag_construct_15.$$arity = 2)}};\n        self.$alias_native(\"alt?\", \"altKey\");\n        self.$alias_native(\"ctrl?\", \"ctrlKey\");\n        self.$alias_native(\"meta?\", \"metaKey\");\n        self.$alias_native(\"shift?\", \"shiftKey\");\n        self.$alias_native(\"button\");\n        \n        Opal.defn(self, '$client', TMP_Drag_client_16 = function $$client() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Position').$new(self[\"native\"].clientX, self[\"native\"].clientY)\n        }, TMP_Drag_client_16.$$arity = 0);\n        \n        Opal.defn(self, '$screen', TMP_Drag_screen_17 = function $$screen() {\n          var self = this;\n\n          if ($truthy((typeof(self[\"native\"].screenX) !== \"undefined\"))) {\n            return Opal.const_get_relative($nesting, 'Position').$new(self[\"native\"].screenX, self[\"native\"].screenY)\n            } else {\n            return nil\n          }\n        }, TMP_Drag_screen_17.$$arity = 0);\n        \n        Opal.defn(self, '$x', TMP_Drag_x_18 = function $$x() {\n          var self = this;\n\n          return self.$screen().$x()\n        }, TMP_Drag_x_18.$$arity = 0);\n        \n        Opal.defn(self, '$y', TMP_Drag_y_19 = function $$y() {\n          var self = this;\n\n          return self.$screen().$y()\n        }, TMP_Drag_y_19.$$arity = 0);\n        \n        Opal.defn(self, '$related', TMP_Drag_related_20 = function $$related() {\n          var self = this;\n\n          return self.$DOM(self[\"native\"].relatedTarget)\n        }, TMP_Drag_related_20.$$arity = 0);\n        return (Opal.defn(self, '$transfer', TMP_Drag_transfer_21 = function $$transfer() {\n          var self = this;\n\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n        }, TMP_Drag_transfer_21.$$arity = 0), nil) && 'transfer';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/gamepad\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Gamepad(){};\n        var self = $Gamepad = $klass($base, $super, 'Gamepad', $Gamepad);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Gamepad_supported$q_1, TMP_Gamepad_construct_7, TMP_Gamepad_id_8, TMP_Gamepad_index_9, TMP_Gamepad_at_10, TMP_Gamepad_axes_11, TMP_Gamepad_buttons_12;\n\n        def[\"native\"] = nil;\n        \n        Opal.defs(self, '$supported?', TMP_Gamepad_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Gamepad\")\n        }, TMP_Gamepad_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_id$eq_2, TMP_Definition_index$eq_3, TMP_Definition_at$eq_4, TMP_Definition_axes$eq_5, TMP_Definition_buttons$eq_6;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$id=', TMP_Definition_id$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].id = value\n          }, TMP_Definition_id$eq_2.$$arity = 1);\n          \n          Opal.defn(self, '$index=', TMP_Definition_index$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].index = value\n          }, TMP_Definition_index$eq_3.$$arity = 1);\n          \n          Opal.defn(self, '$at=', TMP_Definition_at$eq_4 = function(value) {\n            var self = this;\n\n            return self[\"native\"].timestamp = value\n          }, TMP_Definition_at$eq_4.$$arity = 1);\n          \n          Opal.defn(self, '$axes=', TMP_Definition_axes$eq_5 = function(value) {\n            var self = this;\n\n            return self[\"native\"].axes = value\n          }, TMP_Definition_axes$eq_5.$$arity = 1);\n          return (Opal.defn(self, '$buttons=', TMP_Definition_buttons$eq_6 = function(value) {\n            var self = this;\n\n            return self[\"native\"].buttons = value\n          }, TMP_Definition_buttons$eq_6.$$arity = 1), nil) && 'buttons=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Gamepad_construct_7 = function $$construct(name, desc) {\n              var self = this;\n\n              return new GamepadEvent(name, {\n        bubbles:    desc.bubbles,\n        cancelable: desc.cancelable,\n        gamepad:    desc })\n            }, TMP_Gamepad_construct_7.$$arity = 2)}};\n        \n        Opal.defn(self, '$id', TMP_Gamepad_id_8 = function $$id() {\n          var self = this;\n\n          return self[\"native\"].gamepad.id\n        }, TMP_Gamepad_id_8.$$arity = 0);\n        \n        Opal.defn(self, '$index', TMP_Gamepad_index_9 = function $$index() {\n          var self = this;\n\n          return self[\"native\"].gamepad.index\n        }, TMP_Gamepad_index_9.$$arity = 0);\n        \n        Opal.defn(self, '$at', TMP_Gamepad_at_10 = function $$at() {\n          var self = this;\n\n          return self[\"native\"].gamepad.timestamp\n        }, TMP_Gamepad_at_10.$$arity = 0);\n        \n        Opal.defn(self, '$axes', TMP_Gamepad_axes_11 = function $$axes() {\n          var self = this;\n\n          return self[\"native\"].gamepad.axes\n        }, TMP_Gamepad_axes_11.$$arity = 0);\n        return (Opal.defn(self, '$buttons', TMP_Gamepad_buttons_12 = function $$buttons() {\n          var self = this;\n\n          return self[\"native\"].gamepad.buttons\n        }, TMP_Gamepad_buttons_12.$$arity = 0), nil) && 'buttons';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/hash_change\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $HashChange(){};\n        var self = $HashChange = $klass($base, $super, 'HashChange', $HashChange);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_HashChange_supported$q_1, TMP_HashChange_construct_4;\n\n        \n        Opal.defs(self, '$supported?', TMP_HashChange_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.HashChange\")\n        }, TMP_HashChange_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_old$eq_2, TMP_Definition_new$eq_3;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$old=', TMP_Definition_old$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].oldURL = value\n          }, TMP_Definition_old$eq_2.$$arity = 1);\n          return (Opal.defn(self, '$new=', TMP_Definition_new$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].newURL = value\n          }, TMP_Definition_new$eq_3.$$arity = 1), nil) && 'new=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_HashChange_construct_4 = function $$construct(name, desc) {\n              var self = this;\n\n              return new HashChangeEvent(name, desc)\n            }, TMP_HashChange_construct_4.$$arity = 2)}};\n        self.$alias_native(\"old\", \"oldURL\");\n        return self.$alias_native(\"new\", \"newURL\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/progress\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Progress(){};\n        var self = $Progress = $klass($base, $super, 'Progress', $Progress);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Progress_supported$q_1, TMP_Progress_construct_5, TMP_Progress_construct_6;\n\n        \n        Opal.defs(self, '$supported?', TMP_Progress_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Progress\")\n        }, TMP_Progress_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_computable$eq_2, TMP_Definition_loaded$eq_3, TMP_Definition_total$eq_4;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$computable=', TMP_Definition_computable$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].computableLength = value\n          }, TMP_Definition_computable$eq_2.$$arity = 1);\n          \n          Opal.defn(self, '$loaded=', TMP_Definition_loaded$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].loaded = value\n          }, TMP_Definition_loaded$eq_3.$$arity = 1);\n          return (Opal.defn(self, '$total=', TMP_Definition_total$eq_4 = function(value) {\n            var self = this;\n\n            return self[\"native\"].total = value\n          }, TMP_Definition_total$eq_4.$$arity = 1), nil) && 'total=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Progress_construct_5 = function $$construct(name, desc) {\n              var self = this;\n\n              return new ProgressEvent(name, desc)\n            }, TMP_Progress_construct_5.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_Progress_construct_6 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent(\"ProgressEvent\");\n            event.initProgressEvent(name, desc.bubbles, desc.cancelable,\n              desc.computable, desc.loaded, desc.total);\n\n        return event;\n      \n            }, TMP_Progress_construct_6.$$arity = 2)}};\n        self.$alias_native(\"computable?\", \"computableLength\");\n        self.$alias_native(\"loaded\");\n        return self.$alias_native(\"total\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/page_transition\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $PageTransition(){};\n        var self = $PageTransition = $klass($base, $super, 'PageTransition', $PageTransition);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_PageTransition_supported$q_1, TMP_PageTransition_construct_3;\n\n        \n        Opal.defs(self, '$supported?', TMP_PageTransition_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.PageTransition\")\n        }, TMP_PageTransition_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_persisted$eq_2;\n\n          def[\"native\"] = nil;\n          return (Opal.defn(self, '$persisted=', TMP_Definition_persisted$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].persisted = value\n          }, TMP_Definition_persisted$eq_2.$$arity = 1), nil) && 'persisted='\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.PageTransition\"))) {\n            Opal.defs(self, '$construct', TMP_PageTransition_construct_3 = function $$construct(name, desc) {\n              var self = this;\n\n              return new PageTransitionEvent(name, desc)\n            }, TMP_PageTransition_construct_3.$$arity = 2)}};\n        return self.$alias_native(\"persisted?\", \"persisted\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/pop_state\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $PopState(){};\n        var self = $PopState = $klass($base, $super, 'PopState', $PopState);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_PopState_supported$q_1, TMP_PopState_construct_3, TMP_PopState_construct_4;\n\n        \n        Opal.defs(self, '$supported?', TMP_PopState_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.PopState\")\n        }, TMP_PopState_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_state$eq_2;\n\n          def[\"native\"] = nil;\n          return (Opal.defn(self, '$state=', TMP_Definition_state$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].state = value\n          }, TMP_Definition_state$eq_2.$$arity = 1), nil) && 'state='\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_PopState_construct_3 = function $$construct(name, desc) {\n              var self = this;\n\n              return new PopStateEvent(name, desc)\n            }, TMP_PopState_construct_3.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_PopState_construct_4 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent('PopStateEvent');\n            event.initPopStateEvent(name, desc.bubbles, desc.cancelable,\n              desc.state);\n\n        return event;\n      \n            }, TMP_PopState_construct_4.$$arity = 2)}};\n        return self.$alias_native(\"state\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/storage\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Storage(){};\n        var self = $Storage = $klass($base, $super, 'Storage', $Storage);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Storage_supported$q_1, TMP_Storage_construct_7;\n\n        \n        Opal.defs(self, '$supported?', TMP_Storage_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Storage\")\n        }, TMP_Storage_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_key$eq_2, TMP_Definition_new$eq_3, TMP_Definition_old$eq_4, TMP_Definition_area$eq_5, TMP_Definition_url$eq_6;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$key=', TMP_Definition_key$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].key = value\n          }, TMP_Definition_key$eq_2.$$arity = 1);\n          \n          Opal.defn(self, '$new=', TMP_Definition_new$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].newValue = value\n          }, TMP_Definition_new$eq_3.$$arity = 1);\n          \n          Opal.defn(self, '$old=', TMP_Definition_old$eq_4 = function(value) {\n            var self = this;\n\n            return self[\"native\"].oldValue = value\n          }, TMP_Definition_old$eq_4.$$arity = 1);\n          \n          Opal.defn(self, '$area=', TMP_Definition_area$eq_5 = function(value) {\n            var self = this;\n\n            return self[\"native\"].storageArea = value\n          }, TMP_Definition_area$eq_5.$$arity = 1);\n          return (Opal.defn(self, '$url=', TMP_Definition_url$eq_6 = function(value) {\n            var self = this;\n\n            return self[\"native\"].url = value\n          }, TMP_Definition_url$eq_6.$$arity = 1), nil) && 'url=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Storage_construct_7 = function $$construct(name, desc) {\n              var self = this;\n\n              return new StorageEvent(name, desc)\n            }, TMP_Storage_construct_7.$$arity = 2)}};\n        self.$alias_native(\"key\");\n        self.$alias_native(\"new\", \"newValue\");\n        self.$alias_native(\"old\", \"oldValue\");\n        self.$alias_native(\"area\", \"storageArea\");\n        return self.$alias_native(\"url\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/touch\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native', '$==', '$downcase', '$name']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Touch(){};\n        var self = $Touch = $klass($base, $super, 'Touch', $Touch);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Touch_supported$q_1, TMP_Touch_construct_6, TMP_Touch_cancel$q_7, TMP_Touch_end$q_8, TMP_Touch_leave$q_9, TMP_Touch_move$q_10, TMP_Touch_start$q_11;\n\n        \n        Opal.defs(self, '$supported?', TMP_Touch_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Touch\")\n        }, TMP_Touch_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_alt$B_2, TMP_Definition_ctrl$B_3, TMP_Definition_meta$B_4, TMP_Definition_shift$B_5;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$alt!', TMP_Definition_alt$B_2 = function() {\n            var self = this;\n\n            return self[\"native\"].altKey = true\n          }, TMP_Definition_alt$B_2.$$arity = 0);\n          \n          Opal.defn(self, '$ctrl!', TMP_Definition_ctrl$B_3 = function() {\n            var self = this;\n\n            return self[\"native\"].ctrlKey = true\n          }, TMP_Definition_ctrl$B_3.$$arity = 0);\n          \n          Opal.defn(self, '$meta!', TMP_Definition_meta$B_4 = function() {\n            var self = this;\n\n            return self[\"native\"].metaKey = true\n          }, TMP_Definition_meta$B_4.$$arity = 0);\n          return (Opal.defn(self, '$shift!', TMP_Definition_shift$B_5 = function() {\n            var self = this;\n\n            return self[\"native\"].shiftKey = true\n          }, TMP_Definition_shift$B_5.$$arity = 0), nil) && 'shift!';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Touch_construct_6 = function $$construct(name, desc) {\n              var self = this;\n\n              return new TouchEvent(name, desc)\n            }, TMP_Touch_construct_6.$$arity = 2)}};\n        self.$alias_native(\"alt?\", \"altKey\");\n        self.$alias_native(\"ctrl?\", \"ctrlKey\");\n        self.$alias_native(\"meta?\", \"metaKey\");\n        self.$alias_native(\"shift?\", \"shiftKey\");\n        \n        Opal.defn(self, '$cancel?', TMP_Touch_cancel$q_7 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"touchcancel\")\n        }, TMP_Touch_cancel$q_7.$$arity = 0);\n        \n        Opal.defn(self, '$end?', TMP_Touch_end$q_8 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"touchend\")\n        }, TMP_Touch_end$q_8.$$arity = 0);\n        \n        Opal.defn(self, '$leave?', TMP_Touch_leave$q_9 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"touchleave\")\n        }, TMP_Touch_leave$q_9.$$arity = 0);\n        \n        Opal.defn(self, '$move?', TMP_Touch_move$q_10 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"touchmove\")\n        }, TMP_Touch_move$q_10.$$arity = 0);\n        return (Opal.defn(self, '$start?', TMP_Touch_start$q_11 = function() {\n          var self = this;\n\n          return self.$name().$downcase()['$=='](\"touchstart\")\n        }, TMP_Touch_start$q_11.$$arity = 0), nil) && 'start?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/sensor\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Sensor(){};\n        var self = $Sensor = $klass($base, $super, 'Sensor', $Sensor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Sensor_supported$q_1, TMP_Sensor_construct_2;\n\n        \n        Opal.defs(self, '$supported?', TMP_Sensor_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Sensor\")\n        }, TMP_Sensor_supported$q_1.$$arity = 0);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            return Opal.defs(self, '$construct', TMP_Sensor_construct_2 = function $$construct(name, desc) {\n              var self = this;\n\n              return new SensorEvent(name, desc)\n            }, TMP_Sensor_construct_2.$$arity = 2)\n            } else {\n            return nil\n          }\n          } else {\n          return nil\n        };\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"ostruct\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;\n\n  Opal.add_stubs(['$each_pair', '$new_ostruct_member', '$[]=', '$-', '$[]', '$to_sym', '$>', '$length', '$raise', '$new', '$end_with?', '$!=', '$enum_for', '$is_a?', '$==', '$instance_variable_get', '$===', '$eql?', '$dup', '$to_n', '$hash', '$attr_reader', '$__send__', '$singleton_class', '$delete', '$respond_to?', '$define_singleton_method', '$__id__', '$class', '$any?', '$+', '$join', '$map', '$inspect']);\n  return (function($base, $super, $parent_nesting) {\n    function $OpenStruct(){};\n    var self = $OpenStruct = $klass($base, $super, 'OpenStruct', $OpenStruct);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_OpenStruct_initialize_2, TMP_OpenStruct_$$_3, TMP_OpenStruct_$$$eq_4, TMP_OpenStruct_method_missing_5, TMP_OpenStruct_each_pair_6, TMP_OpenStruct_$eq$eq_8, TMP_OpenStruct_$eq$eq$eq_9, TMP_OpenStruct_eql$q_10, TMP_OpenStruct_to_h_11, TMP_OpenStruct_to_n_12, TMP_OpenStruct_hash_13, TMP_OpenStruct_delete_field_14, TMP_OpenStruct_new_ostruct_member_17, TMP_OpenStruct_inspect_19;\n\n    def.table = nil;\n    \n    \n    Opal.defn(self, '$initialize', TMP_OpenStruct_initialize_2 = function $$initialize(hash) {\n      var TMP_1, self = this;\n\n      if (hash == null) {\n        hash = nil;\n      }\n      \n      self.table = $hash2([], {});\n      if ($truthy(hash)) {\n        return $send(hash, 'each_pair', [], (TMP_1 = function(key, value){var self = TMP_1.$$s || this, $writer = nil;\n          if (self.table == null) self.table = nil;\nif (key == null) key = nil;if (value == null) value = nil;\n        \n          $writer = [self.$new_ostruct_member(key), value];\n          $send(self.table, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_1.$$s = self, TMP_1.$$arity = 2, TMP_1))\n        } else {\n        return nil\n      };\n    }, TMP_OpenStruct_initialize_2.$$arity = -1);\n    \n    Opal.defn(self, '$[]', TMP_OpenStruct_$$_3 = function(name) {\n      var self = this;\n\n      return self.table['$[]'](name.$to_sym())\n    }, TMP_OpenStruct_$$_3.$$arity = 1);\n    \n    Opal.defn(self, '$[]=', TMP_OpenStruct_$$$eq_4 = function(name, value) {\n      var self = this, $writer = nil;\n\n      \n      $writer = [self.$new_ostruct_member(name), value];\n      $send(self.table, '[]=', Opal.to_a($writer));\n      return $writer[$rb_minus($writer[\"length\"], 1)];\n    }, TMP_OpenStruct_$$$eq_4.$$arity = 2);\n    \n    Opal.defn(self, '$method_missing', TMP_OpenStruct_method_missing_5 = function $$method_missing(name, $a_rest) {\n      var self = this, args, $writer = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      if ($truthy($rb_gt(args.$length(), 2))) {\n        self.$raise(Opal.const_get_relative($nesting, 'NoMethodError').$new(\"\" + \"undefined method `\" + (name) + \"' for #<OpenStruct>\", name))};\n      if ($truthy(name['$end_with?'](\"=\"))) {\n        \n        if ($truthy(args.$length()['$!='](1))) {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError').$new(\"wrong number of arguments (0 for 1)\"))};\n        \n        $writer = [self.$new_ostruct_member(name['$[]']($range(0, -2, false))), args['$[]'](0)];\n        $send(self.table, '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];;\n        } else {\n        return self.table['$[]'](name.$to_sym())\n      };\n    }, TMP_OpenStruct_method_missing_5.$$arity = -2);\n    \n    Opal.defn(self, '$each_pair', TMP_OpenStruct_each_pair_6 = function $$each_pair() {\n      var TMP_7, self = this, $iter = TMP_OpenStruct_each_pair_6.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_OpenStruct_each_pair_6.$$p = null;\n      \n      if (($yield !== nil)) {\n        } else {\n        return self.$enum_for(\"each_pair\")\n      };\n      return $send(self.table, 'each_pair', [], (TMP_7 = function(pair){var self = TMP_7.$$s || this;\nif (pair == null) pair = nil;\n      return Opal.yield1($yield, pair);}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));\n    }, TMP_OpenStruct_each_pair_6.$$arity = 0);\n    \n    Opal.defn(self, '$==', TMP_OpenStruct_$eq$eq_8 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$is_a?'](Opal.const_get_relative($nesting, 'OpenStruct')))) {\n        } else {\n        return false\n      };\n      return self.table['$=='](other.$instance_variable_get(\"@table\"));\n    }, TMP_OpenStruct_$eq$eq_8.$$arity = 1);\n    \n    Opal.defn(self, '$===', TMP_OpenStruct_$eq$eq$eq_9 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$is_a?'](Opal.const_get_relative($nesting, 'OpenStruct')))) {\n        } else {\n        return false\n      };\n      return self.table['$==='](other.$instance_variable_get(\"@table\"));\n    }, TMP_OpenStruct_$eq$eq$eq_9.$$arity = 1);\n    \n    Opal.defn(self, '$eql?', TMP_OpenStruct_eql$q_10 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$is_a?'](Opal.const_get_relative($nesting, 'OpenStruct')))) {\n        } else {\n        return false\n      };\n      return self.table['$eql?'](other.$instance_variable_get(\"@table\"));\n    }, TMP_OpenStruct_eql$q_10.$$arity = 1);\n    \n    Opal.defn(self, '$to_h', TMP_OpenStruct_to_h_11 = function $$to_h() {\n      var self = this;\n\n      return self.table.$dup()\n    }, TMP_OpenStruct_to_h_11.$$arity = 0);\n    \n    Opal.defn(self, '$to_n', TMP_OpenStruct_to_n_12 = function $$to_n() {\n      var self = this;\n\n      return self.table.$to_n()\n    }, TMP_OpenStruct_to_n_12.$$arity = 0);\n    \n    Opal.defn(self, '$hash', TMP_OpenStruct_hash_13 = function $$hash() {\n      var self = this;\n\n      return self.table.$hash()\n    }, TMP_OpenStruct_hash_13.$$arity = 0);\n    self.$attr_reader(\"table\");\n    \n    Opal.defn(self, '$delete_field', TMP_OpenStruct_delete_field_14 = function $$delete_field(name) {\n      var self = this, sym = nil;\n\n      \n      sym = name.$to_sym();\n      \n      try {\n        self.$singleton_class().$__send__(\"remove_method\", sym, \"\" + (sym) + \"=\")\n      } catch ($err) {\n        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'NameError')])) {\n          try {\n            nil\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      };;\n      return self.table.$delete(sym);\n    }, TMP_OpenStruct_delete_field_14.$$arity = 1);\n    \n    Opal.defn(self, '$new_ostruct_member', TMP_OpenStruct_new_ostruct_member_17 = function $$new_ostruct_member(name) {\n      var TMP_15, TMP_16, self = this;\n\n      \n      name = name.$to_sym();\n      if ($truthy(self['$respond_to?'](name))) {\n        } else {\n        \n        $send(self, 'define_singleton_method', [name], (TMP_15 = function(){var self = TMP_15.$$s || this;\n          if (self.table == null) self.table = nil;\n\n        return self.table['$[]'](name)}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15));\n        $send(self, 'define_singleton_method', [\"\" + (name) + \"=\"], (TMP_16 = function(x){var self = TMP_16.$$s || this, $writer = nil;\n          if (self.table == null) self.table = nil;\nif (x == null) x = nil;\n        \n          $writer = [name, x];\n          $send(self.table, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16));\n      };\n      return name;\n    }, TMP_OpenStruct_new_ostruct_member_17.$$arity = 1);\n    var ostruct_ids;;\n    \n    Opal.defn(self, '$inspect', TMP_OpenStruct_inspect_19 = function $$inspect() {\n      var TMP_18, self = this, result = nil;\n\n      \n      \n      var top = (ostruct_ids === undefined),\n          ostruct_id = self.$__id__();\n    ;\n      \n      return (function() { try {\n      \n      result = \"\" + \"#<\" + (self.$class());\n      \n        if (top) {\n          ostruct_ids = {};\n        }\n        if (ostruct_ids.hasOwnProperty(ostruct_id)) {\n          return result + ' ...>';\n        }\n        ostruct_ids[ostruct_id] = true;\n      ;\n      if ($truthy(self.table['$any?']())) {\n        result = $rb_plus(result, \" \")};\n      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], (TMP_18 = function(name, value){var self = TMP_18.$$s || this;\nif (name == null) name = nil;if (value == null) value = nil;\n      return \"\" + (name) + \"=\" + (value.$inspect())}, TMP_18.$$s = self, TMP_18.$$arity = 2, TMP_18)).$join(\", \"));\n      result = $rb_plus(result, \">\");\n      return result;\n      } finally {\n        \n        if (top) {\n          ostruct_ids = undefined;\n        }\n      \n      }; })();;\n    }, TMP_OpenStruct_inspect_19.$$arity = 0);\n    return Opal.alias(self, \"to_s\", \"inspect\");\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/custom\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$supports?', '$end_with?', '$[]', '$to_n', '$merge!', '$Native', '$new', '$has_key?']);\n  \n  self.$require(\"ostruct\");\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Custom(){};\n        var self = $Custom = $klass($base, $super, 'Custom', $Custom);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Custom_supported$q_1, TMP_Custom_construct_3, TMP_Custom_construct_4, TMP_Custom_construct_5, TMP_Custom_construct_6, TMP_Custom_initialize_7, TMP_Custom_method_missing_8;\n\n        def.detail = nil;\n        \n        Opal.defs(self, '$supported?', TMP_Custom_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Custom\")\n        }, TMP_Custom_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_method_missing_2;\n\n          def[\"native\"] = nil;\n          return (Opal.defn(self, '$method_missing', TMP_Definition_method_missing_2 = function $$method_missing(name, value) {\n            var self = this;\n\n            if ($truthy(name['$end_with?'](\"=\"))) {\n              return self[\"native\"][name['$[]']($range(0, -2, false))] = value\n              } else {\n              return nil\n            }\n          }, TMP_Definition_method_missing_2.$$arity = 2), nil) && 'method_missing'\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n          Opal.defs(self, '$construct', TMP_Custom_construct_3 = function $$construct(name, desc) {\n            var self = this;\n\n            return new CustomEvent(name, {\n        bubbles:    desc.bubbles,\n        cancelable: desc.cancelable,\n        detail:     desc })\n          }, TMP_Custom_construct_3.$$arity = 2)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n          Opal.defs(self, '$construct', TMP_Custom_construct_4 = function $$construct(name, desc) {\n            var self = this;\n\n            \n        var event = document.createEvent(\"CustomEvent\");\n            event.initCustomEvent(name, desc.bubbles, desc.cancelable, desc);\n\n        return event;\n      \n          }, TMP_Custom_construct_4.$$arity = 2)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.createObject\"))) {\n          Opal.defs(self, '$construct', TMP_Custom_construct_5 = function $$construct(name, desc) {\n            var self = this;\n\n            return self.$Native(document.createEventObject())['$merge!']({\n        type:       name,\n        bubbles:    desc.bubbles,\n        cancelable: desc.cancelable,\n        detail:     desc }).$to_n()\n          }, TMP_Custom_construct_5.$$arity = 2)\n          } else {\n          Opal.defs(self, '$construct', TMP_Custom_construct_6 = function $$construct(name, desc) {\n            var self = this;\n\n            return self.$Native(desc)['$merge!']({\n        type:       name,\n        bubbles:    desc.bubbles,\n        cancelable: desc.cancelable,\n        detail:     desc }).$to_n()\n          }, TMP_Custom_construct_6.$$arity = 2)\n        };\n        \n        Opal.defn(self, '$initialize', TMP_Custom_initialize_7 = function $$initialize(event, callback) {\n          var self = this, $iter = TMP_Custom_initialize_7.$$p, $yield = $iter || nil;\n\n          if (callback == null) {\n            callback = nil;\n          }\n          if ($iter) TMP_Custom_initialize_7.$$p = null;\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Custom_initialize_7, false), [event, callback], null);\n          return (self.detail = Opal.const_get_relative($nesting, 'Hash').$new(event.detail));\n        }, TMP_Custom_initialize_7.$$arity = -2);\n        return (Opal.defn(self, '$method_missing', TMP_Custom_method_missing_8 = function $$method_missing(id, $a_rest) {\n          var self = this, $iter = TMP_Custom_method_missing_8.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_Custom_method_missing_8.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          if ($truthy(self.detail['$has_key?'](id))) {\n            return self.detail['$[]'](id)};\n          return $send(self, Opal.find_super_dispatcher(self, 'method_missing', TMP_Custom_method_missing_8, false), $zuper, $iter);\n        }, TMP_Custom_method_missing_8.$$arity = -2), nil) && 'method_missing';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"buffer/array\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $gvars = Opal.gvars, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$include', '$[]', '$name_for', '$attr_reader', '$==', '$for', '$to_n', '$enum_for']);\n  return (function($base, $super, $parent_nesting) {\n    function $Buffer(){};\n    var self = $Buffer = $klass($base, $super, 'Buffer', $Buffer);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $Array(){};\n      var self = $Array = $klass($base, $super, 'Array', $Array);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_for_1, TMP_Array_initialize_2, TMP_Array_bits_3, TMP_Array_$$_4, TMP_Array_$$$eq_5, TMP_Array_bytesize_6, TMP_Array_each_7, TMP_Array_length_8, TMP_Array_merge$B_9;\n\n      def[\"native\"] = nil;\n      \n      self.$include(Opal.const_get_relative($nesting, 'Native'));\n      Opal.defs(self, '$for', TMP_Array_for_1 = function(bits, type) {\n        var self = this;\n        if ($gvars.$ == null) $gvars.$ = nil;\n\n        return $gvars.$['$[]'](\"\" + (Opal.const_get_relative($nesting, 'Buffer').$name_for(bits, type)) + \"Array\")\n      }, TMP_Array_for_1.$$arity = 2);\n      self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n      self.$attr_reader(\"buffer\", \"type\");\n      \n      Opal.defn(self, '$initialize', TMP_Array_initialize_2 = function $$initialize(buffer, bits, type) {\n        var self = this, $iter = TMP_Array_initialize_2.$$p, $yield = $iter || nil;\n\n        if (bits == null) {\n          bits = nil;\n        }\n        if (type == null) {\n          type = nil;\n        }\n        if ($iter) TMP_Array_initialize_2.$$p = null;\n        \n        if (Opal.const_get_relative($nesting, 'Native')['$=='](buffer)) {\n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Array_initialize_2, false), [buffer], null)\n          } else {\n          \n        var klass = Opal.const_get_relative($nesting, 'Array').$for(bits, type);\n\n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Array_initialize_2, false), [new klass(buffer.$to_n())], null)\n      \n        };\n        self.buffer = buffer;\n        return (self.type = type);\n      }, TMP_Array_initialize_2.$$arity = -2);\n      \n      Opal.defn(self, '$bits', TMP_Array_bits_3 = function $$bits() {\n        var self = this;\n\n        return self[\"native\"].BYTES_PER_ELEMENT * 8\n      }, TMP_Array_bits_3.$$arity = 0);\n      \n      Opal.defn(self, '$[]', TMP_Array_$$_4 = function(index, offset) {\n        var self = this;\n\n        if (offset == null) {\n          offset = nil;\n        }\n        if ($truthy(offset)) {\n          return self[\"native\"].subarray(index, offset)\n          } else {\n          return self[\"native\"][index]\n        }\n      }, TMP_Array_$$_4.$$arity = -2);\n      \n      Opal.defn(self, '$[]=', TMP_Array_$$$eq_5 = function(index, value) {\n        var self = this;\n\n        return self[\"native\"][index] = value\n      }, TMP_Array_$$$eq_5.$$arity = 2);\n      \n      Opal.defn(self, '$bytesize', TMP_Array_bytesize_6 = function $$bytesize() {\n        var self = this;\n\n        return self[\"native\"].byteLength\n      }, TMP_Array_bytesize_6.$$arity = 0);\n      \n      Opal.defn(self, '$each', TMP_Array_each_7 = function $$each() {\n        var self = this, $iter = TMP_Array_each_7.$$p, $yield = $iter || nil;\n\n        if ($iter) TMP_Array_each_7.$$p = null;\n        \n        if (($yield !== nil)) {\n          } else {\n          return self.$enum_for(\"each\")\n        };\n        \n      for (var i = 0, length = self[\"native\"].length; i < length; i++) {\n        Opal.yield1($yield, self[\"native\"][i])\n      }\n    ;\n        return self;\n      }, TMP_Array_each_7.$$arity = 0);\n      \n      Opal.defn(self, '$length', TMP_Array_length_8 = function $$length() {\n        var self = this;\n\n        return self[\"native\"].length\n      }, TMP_Array_length_8.$$arity = 0);\n      \n      Opal.defn(self, '$merge!', TMP_Array_merge$B_9 = function(other, offset) {\n        var self = this;\n\n        return self[\"native\"].set(other.$to_n(), offset)\n      }, TMP_Array_merge$B_9.$$arity = -2);\n      return Opal.alias(self, \"size\", \"length\");\n    })($nesting[0], null, $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"buffer/view\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $gvars = Opal.gvars, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$include', '$!', '$nil?', '$[]', '$attr_reader', '$native?', '$to_n', '$name_for']);\n  return (function($base, $super, $parent_nesting) {\n    function $Buffer(){};\n    var self = $Buffer = $klass($base, $super, 'Buffer', $Buffer);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function($base, $super, $parent_nesting) {\n      function $View(){};\n      var self = $View = $klass($base, $super, 'View', $View);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_View_supported$q_1, TMP_View_initialize_2, TMP_View_length_3, TMP_View_get_4, TMP_View_set_5, TMP_View_get_int8_6, TMP_View_set_int8_7, TMP_View_get_uint8_8, TMP_View_set_uint8_9, TMP_View_get_int16_10, TMP_View_set_int16_11, TMP_View_get_uint16_12, TMP_View_set_uint16_13, TMP_View_get_int32_14, TMP_View_set_int32_15, TMP_View_get_uint32_16, TMP_View_set_uint32_17, TMP_View_get_float32_18, TMP_View_set_float32_19, TMP_View_get_float64_20, TMP_View_set_float64_21;\n\n      def[\"native\"] = nil;\n      \n      self.$include(Opal.const_get_relative($nesting, 'Native'));\n      Opal.defs(self, '$supported?', TMP_View_supported$q_1 = function() {\n        var self = this;\n        if ($gvars.$ == null) $gvars.$ = nil;\n\n        return $gvars.$['$[]'](\"DataView\")['$nil?']()['$!']()\n      }, TMP_View_supported$q_1.$$arity = 0);\n      self.$attr_reader(\"buffer\", \"offset\");\n      \n      Opal.defn(self, '$initialize', TMP_View_initialize_2 = function $$initialize(buffer, offset, length) {\n        var $a, self = this, $iter = TMP_View_initialize_2.$$p, $yield = $iter || nil;\n\n        if (offset == null) {\n          offset = nil;\n        }\n        if (length == null) {\n          length = nil;\n        }\n        if ($iter) TMP_View_initialize_2.$$p = null;\n        \n        if ($truthy(self['$native?'](buffer))) {\n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_View_initialize_2, false), [buffer], null)\n        } else if ($truthy(($truthy($a = offset) ? length : $a))) {\n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_View_initialize_2, false), [new DataView(buffer.$to_n(), offset.$to_n(), length.$to_n())], null)\n        } else if ($truthy(offset)) {\n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_View_initialize_2, false), [new DataView(buffer.$to_n(), offset.$to_n())], null)\n          } else {\n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_View_initialize_2, false), [new DataView(buffer.$to_n())], null)\n        };\n        self.buffer = buffer;\n        return (self.offset = offset);\n      }, TMP_View_initialize_2.$$arity = -2);\n      \n      Opal.defn(self, '$length', TMP_View_length_3 = function $$length() {\n        var self = this;\n\n        return self[\"native\"].byteLength\n      }, TMP_View_length_3.$$arity = 0);\n      Opal.alias(self, \"size\", \"length\");\n      \n      Opal.defn(self, '$get', TMP_View_get_4 = function $$get(offset, bits, type, little) {\n        var self = this;\n\n        if (bits == null) {\n          bits = 8;\n        }\n        if (type == null) {\n          type = \"unsigned\";\n        }\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"][\"get\" + Opal.const_get_relative($nesting, 'Buffer').$name_for(bits, type)](offset, little)\n      }, TMP_View_get_4.$$arity = -2);\n      Opal.alias(self, \"[]\", \"get\");\n      \n      Opal.defn(self, '$set', TMP_View_set_5 = function $$set(offset, value, bits, type, little) {\n        var self = this;\n\n        if (bits == null) {\n          bits = 8;\n        }\n        if (type == null) {\n          type = \"unsigned\";\n        }\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"][\"set\" + Opal.const_get_relative($nesting, 'Buffer').$name_for(bits, type)](offset, value, little)\n      }, TMP_View_set_5.$$arity = -3);\n      Opal.alias(self, \"[]=\", \"set\");\n      \n      Opal.defn(self, '$get_int8', TMP_View_get_int8_6 = function $$get_int8(offset, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].getInt8(offset, little)\n      }, TMP_View_get_int8_6.$$arity = -2);\n      \n      Opal.defn(self, '$set_int8', TMP_View_set_int8_7 = function $$set_int8(offset, value, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].setInt8(offset, value, little)\n      }, TMP_View_set_int8_7.$$arity = -3);\n      \n      Opal.defn(self, '$get_uint8', TMP_View_get_uint8_8 = function $$get_uint8(offset, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].getUint8(offset, little)\n      }, TMP_View_get_uint8_8.$$arity = -2);\n      \n      Opal.defn(self, '$set_uint8', TMP_View_set_uint8_9 = function $$set_uint8(offset, value, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].setUint8(offset, value, little)\n      }, TMP_View_set_uint8_9.$$arity = -3);\n      \n      Opal.defn(self, '$get_int16', TMP_View_get_int16_10 = function $$get_int16(offset, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].getInt16(offset, little)\n      }, TMP_View_get_int16_10.$$arity = -2);\n      \n      Opal.defn(self, '$set_int16', TMP_View_set_int16_11 = function $$set_int16(offset, value, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].setInt16(offset, value, little)\n      }, TMP_View_set_int16_11.$$arity = -3);\n      \n      Opal.defn(self, '$get_uint16', TMP_View_get_uint16_12 = function $$get_uint16(offset, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].getUint16(offset, little)\n      }, TMP_View_get_uint16_12.$$arity = -2);\n      \n      Opal.defn(self, '$set_uint16', TMP_View_set_uint16_13 = function $$set_uint16(offset, value, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].setUint16(offset, value, little)\n      }, TMP_View_set_uint16_13.$$arity = -3);\n      \n      Opal.defn(self, '$get_int32', TMP_View_get_int32_14 = function $$get_int32(offset, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].getInt32(offset, little)\n      }, TMP_View_get_int32_14.$$arity = -2);\n      \n      Opal.defn(self, '$set_int32', TMP_View_set_int32_15 = function $$set_int32(offset, value, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].setInt32(offset, value, little)\n      }, TMP_View_set_int32_15.$$arity = -3);\n      \n      Opal.defn(self, '$get_uint32', TMP_View_get_uint32_16 = function $$get_uint32(offset, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].getUint32(offset, little)\n      }, TMP_View_get_uint32_16.$$arity = -2);\n      \n      Opal.defn(self, '$set_uint32', TMP_View_set_uint32_17 = function $$set_uint32(offset, value, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].setUint32(offset, value, little)\n      }, TMP_View_set_uint32_17.$$arity = -3);\n      \n      Opal.defn(self, '$get_float32', TMP_View_get_float32_18 = function $$get_float32(offset, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].getFloat32(offset, little)\n      }, TMP_View_get_float32_18.$$arity = -2);\n      \n      Opal.defn(self, '$set_float32', TMP_View_set_float32_19 = function $$set_float32(offset, value, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].setFloat32(offset, value, little)\n      }, TMP_View_set_float32_19.$$arity = -3);\n      \n      Opal.defn(self, '$get_float64', TMP_View_get_float64_20 = function $$get_float64(offset, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].getFloat64(offset, little)\n      }, TMP_View_get_float64_20.$$arity = -2);\n      return (Opal.defn(self, '$set_float64', TMP_View_set_float64_21 = function $$set_float64(offset, value, little) {\n        var self = this;\n\n        if (little == null) {\n          little = false;\n        }\n        return self[\"native\"].setFloat64(offset, value, little)\n      }, TMP_View_set_float64_21.$$arity = -3), nil) && 'set_float64';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"buffer\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $gvars = Opal.gvars, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$include', '$!', '$nil?', '$[]', '$===', '$native?', '$new']);\n  \n  self.$require(\"native\");\n  self.$require(\"buffer/array\");\n  self.$require(\"buffer/view\");\n  return (function($base, $super, $parent_nesting) {\n    function $Buffer(){};\n    var self = $Buffer = $klass($base, $super, 'Buffer', $Buffer);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Buffer_supported$q_1, TMP_Buffer_name_for_2, TMP_Buffer_initialize_3, TMP_Buffer_length_4, TMP_Buffer_to_a_5, TMP_Buffer_view_6;\n\n    def[\"native\"] = nil;\n    \n    self.$include(Opal.const_get_relative($nesting, 'Native'));\n    Opal.defs(self, '$supported?', TMP_Buffer_supported$q_1 = function() {\n      var self = this;\n      if ($gvars.$ == null) $gvars.$ = nil;\n\n      return $gvars.$['$[]'](\"ArrayBuffer\")['$nil?']()['$!']()\n    }, TMP_Buffer_supported$q_1.$$arity = 0);\n    Opal.defs(self, '$name_for', TMP_Buffer_name_for_2 = function $$name_for(bits, type) {\n      var self = this, $case = nil;\n\n      return \"\" + ((function() {$case = type;\n      if (\"unsigned\"['$===']($case)) {return \"Uint\"}\n      else if (\"signed\"['$===']($case)) {return \"Int\"}\n      else if (\"float\"['$===']($case)) {return \"Float\"}\n      else { return nil }})()) + (bits)\n    }, TMP_Buffer_name_for_2.$$arity = 2);\n    \n    Opal.defn(self, '$initialize', TMP_Buffer_initialize_3 = function $$initialize(size, bits) {\n      var self = this, $iter = TMP_Buffer_initialize_3.$$p, $yield = $iter || nil;\n\n      if (bits == null) {\n        bits = 8;\n      }\n      if ($iter) TMP_Buffer_initialize_3.$$p = null;\n      if ($truthy(self['$native?'](size))) {\n        return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Buffer_initialize_3, false), [size], null)\n        } else {\n        return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Buffer_initialize_3, false), [new ArrayBuffer(size * (bits / 8))], null)\n      }\n    }, TMP_Buffer_initialize_3.$$arity = -2);\n    \n    Opal.defn(self, '$length', TMP_Buffer_length_4 = function $$length() {\n      var self = this;\n\n      return self[\"native\"].byteLength\n    }, TMP_Buffer_length_4.$$arity = 0);\n    Opal.alias(self, \"size\", \"length\");\n    \n    Opal.defn(self, '$to_a', TMP_Buffer_to_a_5 = function $$to_a(bits, type) {\n      var self = this;\n\n      if (bits == null) {\n        bits = 8;\n      }\n      if (type == null) {\n        type = \"unsigned\";\n      }\n      return Opal.const_get_relative($nesting, 'Array').$new(self, bits, type)\n    }, TMP_Buffer_to_a_5.$$arity = -1);\n    return (Opal.defn(self, '$view', TMP_Buffer_view_6 = function $$view(offset, length) {\n      var self = this;\n\n      if (offset == null) {\n        offset = nil;\n      }\n      if (length == null) {\n        length = nil;\n      }\n      return Opal.const_get_relative($nesting, 'View').$new(self, offset, length)\n    }, TMP_Buffer_view_6.$$arity = -1), nil) && 'view';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/message\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$supports?', '$convert', '$supported?', '$new', '$alias_native']);\n  \n  self.$require(\"buffer\");\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Message(){};\n        var self = $Message = $klass($base, $super, 'Message', $Message);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Message_supported$q_1, TMP_Message_construct_5, TMP_Message_construct_6, TMP_Message_data_7, TMP_Message_source_8;\n\n        def[\"native\"] = nil;\n        \n        Opal.defs(self, '$supported?', TMP_Message_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Message\")\n        }, TMP_Message_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_data$eq_2, TMP_Definition_origin$eq_3, TMP_Definition_source$eq_4;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$data=', TMP_Definition_data$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].data = value\n          }, TMP_Definition_data$eq_2.$$arity = 1);\n          \n          Opal.defn(self, '$origin=', TMP_Definition_origin$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].origin = value\n          }, TMP_Definition_origin$eq_3.$$arity = 1);\n          return (Opal.defn(self, '$source=', TMP_Definition_source$eq_4 = function(value) {\n            var self = this;\n\n            return self[\"native\"].source = Opal.const_get_relative($nesting, 'Native').$convert(value)\n          }, TMP_Definition_source$eq_4.$$arity = 1), nil) && 'source=';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Message_construct_5 = function $$construct(name, desc) {\n              var self = this;\n\n              return new MessageEvent(name, desc)\n            }, TMP_Message_construct_5.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_Message_construct_6 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent(\"MessageEvent\");\n            event.initMessageEvent(name, desc.bubbles, desc.cancelable,\n              desc.data, desc.origin, \"\", desc.source || window);\n\n        return event;\n      \n            }, TMP_Message_construct_6.$$arity = 2)}};\n        \n        Opal.defn(self, '$data', TMP_Message_data_7 = function $$data() {\n          var self = this;\n\n          \n      if (window.ArrayBuffer && self[\"native\"].data instanceof ArrayBuffer) {\n        return Opal.const_get_relative($nesting, 'Buffer').$new(self[\"native\"].data);\n      }\n      else if (window.Blob && self[\"native\"].data instanceof Blob) {\n        return Opal.const_get_relative($nesting, 'Blob').$new(self[\"native\"].data);\n      }\n      else {\n        return self[\"native\"].data;\n      }\n    \n        }, TMP_Message_data_7.$$arity = 0);\n        self.$alias_native(\"origin\");\n        return (Opal.defn(self, '$source', TMP_Message_source_8 = function $$source() {\n          var self = this;\n\n          \n      var source = self[\"native\"].source;\n\n      if (window.Window && source instanceof window.Window) {\n        return Opal.const_get_relative($nesting, 'Window').$new(source);\n      }\n      else {\n        return nil;\n      }\n    \n        }, TMP_Message_source_8.$$arity = 0), nil) && 'source';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event/close\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Close(){};\n        var self = $Close = $klass($base, $super, 'Close', $Close);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Close_supported$q_1, TMP_Close_construct_6, TMP_Close_construct_7;\n\n        \n        Opal.defs(self, '$supported?', TMP_Close_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.Close\")\n        }, TMP_Close_supported$q_1.$$arity = 0);\n        (function($base, $super, $parent_nesting) {\n          function $Definition(){};\n          var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_code$eq_2, TMP_Definition_reason$eq_3, TMP_Definition_clean$B_4, TMP_Definition_not_clean$B_5;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$code=', TMP_Definition_code$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].code = value\n          }, TMP_Definition_code$eq_2.$$arity = 1);\n          \n          Opal.defn(self, '$reason=', TMP_Definition_reason$eq_3 = function(value) {\n            var self = this;\n\n            return self[\"native\"].reason = value\n          }, TMP_Definition_reason$eq_3.$$arity = 1);\n          \n          Opal.defn(self, '$clean!', TMP_Definition_clean$B_4 = function(value) {\n            var self = this;\n\n            return self[\"native\"].wasClean = true\n          }, TMP_Definition_clean$B_4.$$arity = 1);\n          return (Opal.defn(self, '$not_clean!', TMP_Definition_not_clean$B_5 = function(value) {\n            var self = this;\n\n            return self[\"native\"].wasClean = false\n          }, TMP_Definition_not_clean$B_5.$$arity = 1), nil) && 'not_clean!';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Definition'), $nesting);\n        if ($truthy(self['$supported?']())) {\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n            Opal.defs(self, '$construct', TMP_Close_construct_6 = function $$construct(name, desc) {\n              var self = this;\n\n              return new CloseEvent(name, desc)\n            }, TMP_Close_construct_6.$$arity = 2)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n            Opal.defs(self, '$construct', TMP_Close_construct_7 = function $$construct(name, desc) {\n              var self = this;\n\n              \n        var event = document.createEvent(\"CloseEvent\");\n            event.initCloseEvent(name, desc.bubbles, desc.cancelable,\n              desc.wasClean, desc.code, desc.reason);\n\n        return event;\n      \n            }, TMP_Close_construct_7.$$arity = 2)}};\n        self.$alias_native(\"code\");\n        self.$alias_native(\"reason\");\n        return self.$alias_native(\"clean?\", \"wasClean\");\n      })($nesting[0], Opal.const_get_relative($nesting, 'Event'), $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/event\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$gsub', '$[]', '$aliases', '$name_for', '$===', '$class_for', '$new', '$construct', '$const_get', '$to_proc', '$arguments=', '$-', '$supports?', '$merge!', '$Native', '$to_n', '$==', '$name', '$attr_reader', '$attr_writer', '$convert', '$alias_native', '$off', '$prevent', '$stop']);\n  \n  self.$require(\"browser/event/base\");\n  self.$require(\"browser/event/ui\");\n  self.$require(\"browser/event/mouse\");\n  self.$require(\"browser/event/keyboard\");\n  self.$require(\"browser/event/focus\");\n  self.$require(\"browser/event/wheel\");\n  self.$require(\"browser/event/composition\");\n  self.$require(\"browser/event/animation\");\n  self.$require(\"browser/event/audio_processing\");\n  self.$require(\"browser/event/before_unload\");\n  self.$require(\"browser/event/composition\");\n  self.$require(\"browser/event/clipboard\");\n  self.$require(\"browser/event/device_light\");\n  self.$require(\"browser/event/device_motion\");\n  self.$require(\"browser/event/device_orientation\");\n  self.$require(\"browser/event/device_proximity\");\n  self.$require(\"browser/event/drag\");\n  self.$require(\"browser/event/gamepad\");\n  self.$require(\"browser/event/hash_change\");\n  self.$require(\"browser/event/progress\");\n  self.$require(\"browser/event/page_transition\");\n  self.$require(\"browser/event/pop_state\");\n  self.$require(\"browser/event/storage\");\n  self.$require(\"browser/event/touch\");\n  self.$require(\"browser/event/sensor\");\n  self.$require(\"browser/event/custom\");\n  self.$require(\"browser/event/message\");\n  self.$require(\"browser/event/close\");\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Event(){};\n      var self = $Event = $klass($base, $super, 'Event', $Event);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Event_aliases_1, TMP_Event_name_for_2, TMP_Event_class_for_3, TMP_Event_supported$q_4, TMP_Event_create_5, TMP_Event_construct_6, TMP_Event_construct_7, TMP_Event_construct_8, TMP_Event_construct_9, TMP_Event_new_10, TMP_Event_initialize_11, TMP_Event_name_12, TMP_Event_on_13, TMP_Event_target_14, TMP_Event_arguments_15, TMP_Event_arguments$eq_16, TMP_Event_off_17, TMP_Event_stopped$q_18, TMP_Event_stop_19, TMP_Event_prevent_20, TMP_Event_prevented$q_21, TMP_Event_stop$B_22;\n\n      def[\"native\"] = def.on = def.callback = nil;\n      \n      Opal.defs(self, '$aliases', TMP_Event_aliases_1 = function $$aliases() {\n        var $a, self = this;\n        if (self.aliases == null) self.aliases = nil;\n\n        return (self.aliases = ($truthy($a = self.aliases) ? $a : $hash2([\"dom:load\", \"hover\"], {\"dom:load\": \"DOMContentLoaded\", \"hover\": \"mouse:over\"})))\n      }, TMP_Event_aliases_1.$$arity = 0);\n      Opal.defs(self, '$name_for', TMP_Event_name_for_2 = function $$name_for(name) {\n        var $a, self = this;\n\n        return ($truthy($a = self.$aliases()['$[]'](name)) ? $a : name).$gsub(\":\", \"\")\n      }, TMP_Event_name_for_2.$$arity = 1);\n      Opal.defs(self, '$class_for', TMP_Event_class_for_3 = function $$class_for(name) {\n        var self = this, $case = nil;\n\n        return (function() {$case = self.$name_for(name);\n        if (\"animationend\"['$===']($case) || \"animationiteration\"['$===']($case) || \"animationstart\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Animation')}\n        else if (\"audioprocess\"['$===']($case)) {return Opal.const_get_relative($nesting, 'AudioProcessing')}\n        else if (\"beforeunload\"['$===']($case)) {return Opal.const_get_relative($nesting, 'BeforeUnload')}\n        else if (\"compositionend\"['$===']($case) || \"compositionstart\"['$===']($case) || \"compositionupdate\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Composition')}\n        else if (\"copy\"['$===']($case) || \"cut\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Clipboard')}\n        else if (\"devicelight\"['$===']($case)) {return Opal.const_get_relative($nesting, 'DeviceLight')}\n        else if (\"devicemotion\"['$===']($case)) {return Opal.const_get_relative($nesting, 'DeviceMotion')}\n        else if (\"deviceorientation\"['$===']($case)) {return Opal.const_get_relative($nesting, 'DeviceOrientation')}\n        else if (\"deviceproximity\"['$===']($case)) {return Opal.const_get_relative($nesting, 'DeviceProximity')}\n        else if (\"drag\"['$===']($case) || \"dragend\"['$===']($case) || \"dragleave\"['$===']($case) || \"dragover\"['$===']($case) || \"dragstart\"['$===']($case) || \"drop\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Drag')}\n        else if (\"gamepadconnected\"['$===']($case) || \"gamepaddisconnected\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Gamepad')}\n        else if (\"hashchange\"['$===']($case)) {return Opal.const_get_relative($nesting, 'HashChange')}\n        else if (\"load\"['$===']($case) || \"loadend\"['$===']($case) || \"loadstart\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Progress')}\n        else if (\"pagehide\"['$===']($case) || \"pageshow\"['$===']($case)) {return Opal.const_get_relative($nesting, 'PageTransition')}\n        else if (\"popstate\"['$===']($case)) {return Opal.const_get_relative($nesting, 'PopState')}\n        else if (\"storage\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Storage')}\n        else if (\"touchcancel\"['$===']($case) || \"touchend\"['$===']($case) || \"touchleave\"['$===']($case) || \"touchmove\"['$===']($case) || \"touchstart\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Touch')}\n        else if (\"compassneedscalibration\"['$===']($case) || \"userproximity\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Sensor')}\n        else if (\"message\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Message')}\n        else if (\"close\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Close')}\n        else if (\"click\"['$===']($case) || \"contextmenu\"['$===']($case) || \"dblclick\"['$===']($case) || \"mousedown\"['$===']($case) || \"mouseenter\"['$===']($case) || \"mouseleave\"['$===']($case) || \"mousemove\"['$===']($case) || \"mouseout\"['$===']($case) || \"mouseover\"['$===']($case) || \"mouseup\"['$===']($case) || \"show\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Mouse')}\n        else if (\"keydown\"['$===']($case) || \"keypress\"['$===']($case) || \"keyup\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Keyboard')}\n        else if (\"blur\"['$===']($case) || \"focus\"['$===']($case) || \"focusin\"['$===']($case) || \"focusout\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Focus')}\n        else if (\"wheel\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Wheel')}\n        else if (\"abort\"['$===']($case) || \"afterprint\"['$===']($case) || \"beforeprint\"['$===']($case) || \"cached\"['$===']($case) || \"canplay\"['$===']($case) || \"canplaythrough\"['$===']($case) || \"change\"['$===']($case) || \"chargingchange\"['$===']($case) || \"chargingtimechange\"['$===']($case) || \"checking\"['$===']($case) || \"close\"['$===']($case) || \"dischargingtimechange\"['$===']($case) || \"DOMContentLoaded\"['$===']($case) || \"downloading\"['$===']($case) || \"durationchange\"['$===']($case) || \"emptied\"['$===']($case) || \"ended\"['$===']($case) || \"error\"['$===']($case) || \"fullscreenchange\"['$===']($case) || \"fullscreenerror\"['$===']($case) || \"input\"['$===']($case) || \"invalid\"['$===']($case) || \"levelchange\"['$===']($case) || \"loadeddata\"['$===']($case) || \"loadedmetadata\"['$===']($case) || \"noupdate\"['$===']($case) || \"obsolete\"['$===']($case) || \"offline\"['$===']($case) || \"online\"['$===']($case) || \"open\"['$===']($case) || \"orientationchange\"['$===']($case) || \"pause\"['$===']($case) || \"pointerlockchange\"['$===']($case) || \"pointerlockerror\"['$===']($case) || \"play\"['$===']($case) || \"playing\"['$===']($case) || \"ratechange\"['$===']($case) || \"readystatechange\"['$===']($case) || \"reset\"['$===']($case) || \"seeked\"['$===']($case) || \"seeking\"['$===']($case) || \"stalled\"['$===']($case) || \"submit\"['$===']($case) || \"success\"['$===']($case) || \"suspend\"['$===']($case) || \"timeupdate\"['$===']($case) || \"updateready\"['$===']($case) || \"visibilitychange\"['$===']($case) || \"volumechange\"['$===']($case) || \"waiting\"['$===']($case)) {return Opal.const_get_relative($nesting, 'Event')}\n        else {return Opal.const_get_relative($nesting, 'Custom')}})()\n      }, TMP_Event_class_for_3.$$arity = 1);\n      Opal.defs(self, '$supported?', TMP_Event_supported$q_4 = function() {\n        var self = this;\n\n        return true\n      }, TMP_Event_supported$q_4.$$arity = 0);\n      Opal.defs(self, '$create', TMP_Event_create_5 = function $$create(name, $a_rest) {\n        var self = this, args, $iter = TMP_Event_create_5.$$p, block = $iter || nil, klass = nil, event = nil, $writer = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 1] = arguments[$arg_idx];\n        }\n        if ($iter) TMP_Event_create_5.$$p = null;\n        \n        name = self.$name_for(name);\n        klass = self.$class_for(name);\n        event = klass.$new(klass.$construct(name, $send(klass.$const_get(\"Definition\"), 'new', [], block.$to_proc())));\n        \n        $writer = [args];\n        $send(event, 'arguments=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return event;\n      }, TMP_Event_create_5.$$arity = -2);\n      if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.constructor\"))) {\n        Opal.defs(self, '$construct', TMP_Event_construct_6 = function $$construct(name, desc) {\n          var self = this;\n\n          return new Event(name, desc)\n        }, TMP_Event_construct_6.$$arity = 2)\n      } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.create\"))) {\n        Opal.defs(self, '$construct', TMP_Event_construct_7 = function $$construct(name, desc) {try {\n\n          var self = this;\n\n          \n        var event = document.createEvent(\"HTMLEvents\");\n            event.initEvent(name, desc.bubbles, desc.cancelable);\n\n        Opal.ret(self.$Native(event)['$merge!'](desc));\n      \n          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n        }, TMP_Event_construct_7.$$arity = 2)\n      } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.createObject\"))) {\n        Opal.defs(self, '$construct', TMP_Event_construct_8 = function $$construct(name, desc) {\n          var self = this;\n\n          return self.$Native(document.createEventObject())['$merge!'](desc)['$merge!']({ type: name }).$to_n()\n        }, TMP_Event_construct_8.$$arity = 2)\n        } else {\n        Opal.defs(self, '$construct', TMP_Event_construct_9 = function $$construct(name, desc) {\n          var self = this;\n\n          return self.$Native(desc)['$merge!']({ type: name }).$to_n()\n        }, TMP_Event_construct_9.$$arity = 2)\n      };\n      Opal.defs(self, '$new', TMP_Event_new_10 = function(value, callback) {\n        var self = this, $iter = TMP_Event_new_10.$$p, $yield = $iter || nil, klass = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if (callback == null) {\n          callback = nil;\n        }\n        if ($iter) TMP_Event_new_10.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        \n        if (self['$=='](Opal.const_get_relative($nesting, 'Event'))) {\n          } else {\n          return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_Event_new_10, false, $Event), $zuper, $iter)\n        };\n        klass = self.$class_for((function() {if ($truthy(callback)) {\n          return callback.$name()\n          } else {\n          return value.type\n        }; return nil; })());\n        if (klass['$=='](Opal.const_get_relative($nesting, 'Event'))) {\n          return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_Event_new_10, false, $Event), $zuper, $iter)\n          } else {\n          return klass.$new(value, callback)\n        };\n      }, TMP_Event_new_10.$$arity = -2);\n      self.$attr_reader(\"callback\");\n      self.$attr_writer(\"on\");\n      \n      Opal.defn(self, '$initialize', TMP_Event_initialize_11 = function $$initialize(event, callback) {\n        var self = this, $iter = TMP_Event_initialize_11.$$p, $yield = $iter || nil;\n\n        if (callback == null) {\n          callback = nil;\n        }\n        if ($iter) TMP_Event_initialize_11.$$p = null;\n        \n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Event_initialize_11, false), [event], null);\n        return (self.callback = callback);\n      }, TMP_Event_initialize_11.$$arity = -2);\n      \n      Opal.defn(self, '$name', TMP_Event_name_12 = function $$name() {\n        var self = this;\n\n        return self[\"native\"].type\n      }, TMP_Event_name_12.$$arity = 0);\n      \n      Opal.defn(self, '$on', TMP_Event_on_13 = function $$on() {\n        var $a, self = this;\n\n        return ($truthy($a = self.on) ? $a : Opal.const_get_relative($nesting, 'Target').$convert(self[\"native\"].currentTarget))\n      }, TMP_Event_on_13.$$arity = 0);\n      \n      Opal.defn(self, '$target', TMP_Event_target_14 = function $$target() {\n        var self = this;\n\n        return Opal.const_get_relative($nesting, 'Target').$convert(self[\"native\"].srcElement || self[\"native\"].target)\n      }, TMP_Event_target_14.$$arity = 0);\n      \n      Opal.defn(self, '$arguments', TMP_Event_arguments_15 = function() {\n        var self = this;\n\n        return self[\"native\"].arguments || []\n      }, TMP_Event_arguments_15.$$arity = 0);\n      \n      Opal.defn(self, '$arguments=', TMP_Event_arguments$eq_16 = function(args) {\n        var self = this;\n\n        return self[\"native\"].arguments = args\n      }, TMP_Event_arguments$eq_16.$$arity = 1);\n      self.$alias_native(\"bubbles?\", \"bubbles\");\n      self.$alias_native(\"cancelable?\", \"cancelable\");\n      self.$alias_native(\"data\");\n      self.$alias_native(\"phase\", \"eventPhase\");\n      self.$alias_native(\"at\", \"timeStamp\");\n      \n      Opal.defn(self, '$off', TMP_Event_off_17 = function $$off() {\n        var self = this;\n\n        if ($truthy(self.callback)) {\n          return self.callback.$off()\n          } else {\n          return nil\n        }\n      }, TMP_Event_off_17.$$arity = 0);\n      \n      Opal.defn(self, '$stopped?', TMP_Event_stopped$q_18 = function() {\n        var self = this;\n\n        return !!self[\"native\"].stopped\n      }, TMP_Event_stopped$q_18.$$arity = 0);\n      \n      Opal.defn(self, '$stop', TMP_Event_stop_19 = function $$stop() {\n        var self = this;\n\n        \n        if ($truthy((typeof(self[\"native\"].stopPropagation) !== \"undefined\"))) {\n          self[\"native\"].stopPropagation()};\n        return self[\"native\"].stopped = true;\n      }, TMP_Event_stop_19.$$arity = 0);\n      \n      Opal.defn(self, '$prevent', TMP_Event_prevent_20 = function $$prevent() {\n        var self = this;\n\n        \n        if ($truthy((typeof(self[\"native\"].preventDefault) !== \"undefined\"))) {\n          self[\"native\"].preventDefault()};\n        return self[\"native\"].prevented = true;\n      }, TMP_Event_prevent_20.$$arity = 0);\n      \n      Opal.defn(self, '$prevented?', TMP_Event_prevented$q_21 = function() {\n        var self = this;\n\n        return !!self[\"native\"].prevented\n      }, TMP_Event_prevented$q_21.$$arity = 0);\n      return (Opal.defn(self, '$stop!', TMP_Event_stop$B_22 = function() {\n        var self = this;\n\n        \n        self.$prevent();\n        return self.$stop();\n      }, TMP_Event_stop$B_22.$$arity = 0), nil) && 'stop!';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/window/view\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$to_n', '$supports?', '$raise']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Window(){};\n      var self = $Window = $klass($base, $super, 'Window', $Window);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $View(){};\n        var self = $View = $klass($base, $super, 'View', $View);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_View_initialize_1, TMP_View_width_2, TMP_View_height_3, TMP_View_height_4, TMP_View_width_5, TMP_View_width_6, TMP_View_height_7;\n\n        def[\"native\"] = nil;\n        \n        \n        Opal.defn(self, '$initialize', TMP_View_initialize_1 = function $$initialize(window) {\n          var self = this;\n\n          \n          self.window = window;\n          return (self[\"native\"] = window.$to_n());\n        }, TMP_View_initialize_1.$$arity = 1);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Window.innerSize\"))) {\n          \n          \n          Opal.defn(self, '$width', TMP_View_width_2 = function $$width() {\n            var self = this;\n\n            return self[\"native\"].innerWidth\n          }, TMP_View_width_2.$$arity = 0);\n          return (Opal.defn(self, '$height', TMP_View_height_3 = function $$height() {\n            var self = this;\n\n            return self[\"native\"].innerHeight\n          }, TMP_View_height_3.$$arity = 0), nil) && 'height';\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.clientSize\"))) {\n          \n          \n          Opal.defn(self, '$height', TMP_View_height_4 = function $$height() {\n            var self = this;\n\n            return self[\"native\"].document.documentElement.clientHeight\n          }, TMP_View_height_4.$$arity = 0);\n          return (Opal.defn(self, '$width', TMP_View_width_5 = function $$width() {\n            var self = this;\n\n            return self[\"native\"].document.documentElement.clientWidth\n          }, TMP_View_width_5.$$arity = 0), nil) && 'width';\n          } else {\n          \n          \n          Opal.defn(self, '$width', TMP_View_width_6 = function $$width() {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"window size unsupported\")\n          }, TMP_View_width_6.$$arity = 0);\n          return (Opal.defn(self, '$height', TMP_View_height_7 = function $$height() {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"window size unsupported\")\n          }, TMP_View_height_7.$$arity = 0), nil) && 'height';\n        };\n      })($nesting[0], null, $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/window/size\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$to_n', '$===', '$first', '$values_at', '$width', '$height', '$supports?', '$raise', '$set']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Window(){};\n      var self = $Window = $klass($base, $super, 'Window', $Window);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Size(){};\n        var self = $Size = $klass($base, $super, 'Size', $Size);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Size_initialize_1, TMP_Size_set_2, TMP_Size_width_3, TMP_Size_height_4, TMP_Size_width_5, TMP_Size_height_6, TMP_Size_width$eq_7, TMP_Size_height$eq_8;\n\n        def[\"native\"] = nil;\n        \n        \n        Opal.defn(self, '$initialize', TMP_Size_initialize_1 = function $$initialize(window) {\n          var self = this;\n\n          \n          self.window = window;\n          return (self[\"native\"] = window.$to_n());\n        }, TMP_Size_initialize_1.$$arity = 1);\n        \n        Opal.defn(self, '$set', TMP_Size_set_2 = function $$set($a_rest) {\n          var $b, $c, self = this, args, width = nil, height = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](args.$first()))) {\n            $c = args.$first().$values_at(\"width\", \"height\"), $b = Opal.to_ary($c), (width = ($b[0] == null ? nil : $b[0])), (height = ($b[1] == null ? nil : $b[1])), $c\n            } else {\n            $c = args, $b = Opal.to_ary($c), (width = ($b[0] == null ? nil : $b[0])), (height = ($b[1] == null ? nil : $b[1])), $c\n          };\n          width = ($truthy($b = width) ? $b : self.$width());\n          height = ($truthy($b = height) ? $b : self.$height());\n          self[\"native\"].resizeTo(width, height);\n          return self;\n        }, TMP_Size_set_2.$$arity = -1);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Window.outerSize\"))) {\n          \n          \n          Opal.defn(self, '$width', TMP_Size_width_3 = function $$width() {\n            var self = this;\n\n            return self[\"native\"].outerWidth\n          }, TMP_Size_width_3.$$arity = 0);\n          \n          Opal.defn(self, '$height', TMP_Size_height_4 = function $$height() {\n            var self = this;\n\n            return self[\"native\"].outerHeight\n          }, TMP_Size_height_4.$$arity = 0);\n          } else {\n          \n          \n          Opal.defn(self, '$width', TMP_Size_width_5 = function $$width() {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"window outer size not supported\")\n          }, TMP_Size_width_5.$$arity = 0);\n          \n          Opal.defn(self, '$height', TMP_Size_height_6 = function $$height() {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"window outer size not supported\")\n          }, TMP_Size_height_6.$$arity = 0);\n        };\n        \n        Opal.defn(self, '$width=', TMP_Size_width$eq_7 = function(value) {\n          var self = this;\n\n          return self.$set($hash2([\"width\"], {\"width\": value}))\n        }, TMP_Size_width$eq_7.$$arity = 1);\n        return (Opal.defn(self, '$height=', TMP_Size_height$eq_8 = function(value) {\n          var self = this;\n\n          return self.$set($hash2([\"height\"], {\"height\": value}))\n        }, TMP_Size_height$eq_8.$$arity = 1), nil) && 'height=';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/window/scroll\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$to_n', '$supports?', '$new', '$raise', '$x', '$position', '$y', '$[]']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Window(){};\n      var self = $Window = $klass($base, $super, 'Window', $Window);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $super, $parent_nesting) {\n        function $Scroll(){};\n        var self = $Scroll = $klass($base, $super, 'Scroll', $Scroll);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Scroll_initialize_1, TMP_Scroll_position_2, TMP_Scroll_position_3, TMP_Scroll_position_4, TMP_Scroll_x_5, TMP_Scroll_y_6, TMP_Scroll_to_7, TMP_Scroll_by_8;\n\n        def[\"native\"] = nil;\n        \n        \n        Opal.defn(self, '$initialize', TMP_Scroll_initialize_1 = function $$initialize(window) {\n          var self = this;\n\n          \n          self.window = window;\n          return (self[\"native\"] = window.$to_n());\n        }, TMP_Scroll_initialize_1.$$arity = 1);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Window.scroll\"))) {\n          \n          Opal.defn(self, '$position', TMP_Scroll_position_2 = function $$position() {\n            var self = this;\n\n            \n            \n        var doc  = self[\"native\"].document,\n            root = doc.documentElement,\n            body = doc.body;\n\n        var x = root.scrollLeft || body.scrollLeft,\n            y = root.scrollTop  || body.scrollTop;\n      ;\n            return Opal.const_get_relative($nesting, 'Position').$new(x, y);\n          }, TMP_Scroll_position_2.$$arity = 0)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Window.pageOffset\"))) {\n          \n          Opal.defn(self, '$position', TMP_Scroll_position_3 = function $$position() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Position').$new(self[\"native\"].pageXOffset, self[\"native\"].pageYOffset)\n          }, TMP_Scroll_position_3.$$arity = 0)\n          } else {\n          \n          Opal.defn(self, '$position', TMP_Scroll_position_4 = function $$position() {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"window scroll unsupported\")\n          }, TMP_Scroll_position_4.$$arity = 0)\n        };\n        \n        Opal.defn(self, '$x', TMP_Scroll_x_5 = function $$x() {\n          var self = this;\n\n          return self.$position().$x()\n        }, TMP_Scroll_x_5.$$arity = 0);\n        \n        Opal.defn(self, '$y', TMP_Scroll_y_6 = function $$y() {\n          var self = this;\n\n          return self.$position().$y()\n        }, TMP_Scroll_y_6.$$arity = 0);\n        \n        Opal.defn(self, '$to', TMP_Scroll_to_7 = function $$to(what) {\n          var $a, self = this, x = nil, y = nil;\n\n          \n          x = ($truthy($a = what['$[]'](\"x\")) ? $a : self.$x());\n          y = ($truthy($a = what['$[]'](\"y\")) ? $a : self.$y());\n          self[\"native\"].scrollTo(x, y);\n          return self;\n        }, TMP_Scroll_to_7.$$arity = 1);\n        return (Opal.defn(self, '$by', TMP_Scroll_by_8 = function $$by(what) {\n          var $a, self = this, x = nil, y = nil;\n\n          \n          x = ($truthy($a = what['$[]'](\"x\")) ? $a : 0);\n          y = ($truthy($a = what['$[]'](\"y\")) ? $a : 0);\n          self[\"native\"].scrollBy(x, y);\n          return self;\n        }, TMP_Scroll_by_8.$$arity = 1), nil) && 'by';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/window\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$delete', '$join', '$map', '$===', '$new', '$include', '$target', '$supports?', '$[]', '$raise', '$alert', '$prompt', '$confirm']);\n  \n  self.$require(\"browser/window/view\");\n  self.$require(\"browser/window/size\");\n  self.$require(\"browser/window/scroll\");\n  (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Window(){};\n      var self = $Window = $klass($base, $super, 'Window', $Window);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Window_open_2, TMP_Window_3, TMP_Window_alert_4, TMP_Window_prompt_5, TMP_Window_confirm_6, TMP_Window_view_7, TMP_Window_size_8, TMP_Window_scroll_9, TMP_Window_send_10, TMP_Window_send_11, TMP_Window_close_12;\n\n      def[\"native\"] = nil;\n      \n      Opal.defs(self, '$open', TMP_Window_open_2 = function $$open(url, options) {\n        var TMP_1, self = this, name = nil, features = nil;\n\n        \n        name = options.$delete(\"name\");\n        features = $send(options, 'map', [], (TMP_1 = function(key, value){var self = TMP_1.$$s || this, $case = nil;\nif (key == null) key = nil;if (value == null) value = nil;\n        \n          value = (function() {$case = value;\n          if (true['$===']($case)) {return \"yes\"}\n          else if (false['$===']($case)) {return \"no\"}\n          else {return value}})();\n          return \"\" + (key) + \"=\" + (value);}, TMP_1.$$s = self, TMP_1.$$arity = 2, TMP_1)).$join(\",\");\n        \n      var win = window.open(url, name, features);\n\n      if (win == null) {\n        return nil;\n      }\n\n      return self.$new(win);\n    ;\n      }, TMP_Window_open_2.$$arity = 2);\n      self.$include(Opal.const_get_relative($nesting, 'Native'));\n      self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Event'), 'Target'));\n      $send(self, 'target', [], (TMP_Window_3 = function(value){var self = TMP_Window_3.$$s || this;\n        if ($gvars.window == null) $gvars.window = nil;\nif (value == null) value = nil;\n      if ($truthy(value == window)) {\n          return $gvars.window\n          } else {\n          return nil\n        }}, TMP_Window_3.$$s = self, TMP_Window_3.$$arity = 1, TMP_Window_3));\n      \n      Opal.defn(self, '$alert', TMP_Window_alert_4 = function $$alert(value) {\n        var self = this;\n\n        \n        self[\"native\"].alert(value);\n        return value;\n      }, TMP_Window_alert_4.$$arity = 1);\n      \n      Opal.defn(self, '$prompt', TMP_Window_prompt_5 = function $$prompt(value) {\n        var self = this;\n\n        return self[\"native\"].prompt(value) || nil\n      }, TMP_Window_prompt_5.$$arity = 1);\n      \n      Opal.defn(self, '$confirm', TMP_Window_confirm_6 = function $$confirm(value) {\n        var self = this;\n\n        return self[\"native\"].confirm(value) || false\n      }, TMP_Window_confirm_6.$$arity = 1);\n      \n      Opal.defn(self, '$view', TMP_Window_view_7 = function $$view() {\n        var self = this;\n\n        return Opal.const_get_relative($nesting, 'View').$new(self)\n      }, TMP_Window_view_7.$$arity = 0);\n      \n      Opal.defn(self, '$size', TMP_Window_size_8 = function $$size() {\n        var self = this;\n\n        return Opal.const_get_relative($nesting, 'Size').$new(self)\n      }, TMP_Window_size_8.$$arity = 0);\n      \n      Opal.defn(self, '$scroll', TMP_Window_scroll_9 = function $$scroll() {\n        var self = this;\n\n        return Opal.const_get_relative($nesting, 'Scroll').$new(self)\n      }, TMP_Window_scroll_9.$$arity = 0);\n      if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Window.send\"))) {\n        \n        Opal.defn(self, '$send', TMP_Window_send_10 = function $$send(message, options) {\n          var $a, self = this;\n\n          if (options == null) {\n            options = $hash2([], {});\n          }\n          return self[\"native\"].postMessage(message, ($truthy($a = options['$[]'](\"to\")) ? $a : \"*\"))\n        }, TMP_Window_send_10.$$arity = -2)\n        } else {\n        \n        Opal.defn(self, '$send', TMP_Window_send_11 = function $$send(message, options) {\n          var self = this;\n\n          if (options == null) {\n            options = $hash2([], {});\n          }\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"message sending unsupported\")\n        }, TMP_Window_send_11.$$arity = -2)\n      };\n      return (Opal.defn(self, '$close', TMP_Window_close_12 = function $$close() {\n        var self = this;\n\n        \n      return (window.open('', '_self', '') && window.close()) ||\n             (window.opener = null && window.close()) ||\n             (window.opener = '' && window.close());\n    \n      }, TMP_Window_close_12.$$arity = 0), nil) && 'close';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting);\n  $gvars.window = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'Window').$new(window);\n  return (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_alert_13, TMP_Kernel_prompt_14, TMP_Kernel_confirm_15;\n\n    \n    \n    Opal.defn(self, '$alert', TMP_Kernel_alert_13 = function $$alert(value) {\n      var self = this;\n      if ($gvars.window == null) $gvars.window = nil;\n\n      return $gvars.window.$alert(value)\n    }, TMP_Kernel_alert_13.$$arity = 1);\n    \n    Opal.defn(self, '$prompt', TMP_Kernel_prompt_14 = function $$prompt(value) {\n      var self = this;\n      if ($gvars.window == null) $gvars.window = nil;\n\n      return $gvars.window.$prompt(value)\n    }, TMP_Kernel_prompt_14.$$arity = 1);\n    \n    Opal.defn(self, '$confirm', TMP_Kernel_confirm_15 = function $$confirm(value) {\n      var self = this;\n      if ($gvars.window == null) $gvars.window = nil;\n\n      return $gvars.window.$confirm(value)\n    }, TMP_Kernel_confirm_15.$$arity = 1);\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/node_set\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$new', '$uniq', '$map', '$flatten', '$DOM', '$convert', '$respond_to?', '$each', '$__send__', '$to_proc', '$===', '$at_css', '$at_xpath', '$[]', '$css', '$select', '$=~', '$search', '$xpath']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $NodeSet(){};\n        var self = $NodeSet = $klass($base, $super, 'NodeSet', $NodeSet);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NodeSet_$$_2, TMP_NodeSet_initialize_3, TMP_NodeSet_method_missing_4, TMP_NodeSet_at_css_7, TMP_NodeSet_at_xpath_9, TMP_NodeSet_css_11, TMP_NodeSet_filter_13, TMP_NodeSet_search_15, TMP_NodeSet_xpath_17, TMP_NodeSet_to_ary_18;\n\n        def.literal = nil;\n        \n        Opal.defs(self, '$[]', TMP_NodeSet_$$_2 = function($a_rest) {\n          var TMP_1, self = this, nodes;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          nodes = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            nodes[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return self.$new($send(nodes.$flatten(), 'map', [], (TMP_1 = function(x){var self = TMP_1.$$s || this;\nif (x == null) x = nil;\n          return self.$DOM(Opal.const_get_relative($nesting, 'Native').$convert(x))}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1)).$uniq())\n        }, TMP_NodeSet_$$_2.$$arity = -1);\n        \n        Opal.defn(self, '$initialize', TMP_NodeSet_initialize_3 = function $$initialize(literal) {\n          var self = this;\n\n          return (self.literal = literal)\n        }, TMP_NodeSet_initialize_3.$$arity = 1);\n        \n        Opal.defn(self, '$method_missing', TMP_NodeSet_method_missing_4 = function $$method_missing(name, $a_rest) {\n          var TMP_5, self = this, args, $iter = TMP_NodeSet_method_missing_4.$$p, block = $iter || nil, result = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_NodeSet_method_missing_4.$$p = null;\n          \n          if ($truthy(self.literal['$respond_to?'](name))) {\n            } else {\n            \n            $send(self, 'each', [], (TMP_5 = function(el){var self = TMP_5.$$s || this;\nif (el == null) el = nil;\n            return $send(el, '__send__', [name].concat(Opal.to_a(args)), block.$to_proc())}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));\n            return self;\n          };\n          result = $send(self.literal, '__send__', [name].concat(Opal.to_a(args)), block.$to_proc());\n          if ($truthy(result === self.literal)) {\n            return self\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](result))) {\n            return Opal.const_get_relative($nesting, 'NodeSet').$new(result)\n            } else {\n            return result\n          };\n        }, TMP_NodeSet_method_missing_4.$$arity = -2);\n        \n        Opal.defn(self, '$at_css', TMP_NodeSet_at_css_7 = function $$at_css($a_rest) {try {\n\n          var TMP_6, self = this, rules;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          rules = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            rules[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          $send(self, 'each', [], (TMP_6 = function(node){var self = TMP_6.$$s || this;\nif (node == null) node = nil;\n          if ($truthy((node = $send(node, 'at_css', Opal.to_a(rules))))) {\n              Opal.ret(node)\n              } else {\n              return nil\n            }}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));\n          return nil;\n          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n        }, TMP_NodeSet_at_css_7.$$arity = -1);\n        \n        Opal.defn(self, '$at_xpath', TMP_NodeSet_at_xpath_9 = function $$at_xpath($a_rest) {try {\n\n          var TMP_8, self = this, paths;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          paths = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            paths[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          $send(self, 'each', [], (TMP_8 = function(node){var self = TMP_8.$$s || this;\nif (node == null) node = nil;\n          if ($truthy((node = $send(node, 'at_xpath', Opal.to_a(paths))))) {\n              Opal.ret(node)\n              } else {\n              return nil\n            }}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8));\n          return nil;\n          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n        }, TMP_NodeSet_at_xpath_9.$$arity = -1);\n        \n        Opal.defn(self, '$css', TMP_NodeSet_css_11 = function $$css(path) {\n          var TMP_10, self = this;\n\n          return Opal.const_get_relative($nesting, 'NodeSet')['$[]']($send(self.literal, 'map', [], (TMP_10 = function(node){var self = TMP_10.$$s || this;\nif (node == null) node = nil;\n          return node.$css(path)}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10)))\n        }, TMP_NodeSet_css_11.$$arity = 1);\n        \n        Opal.defn(self, '$filter', TMP_NodeSet_filter_13 = function $$filter(expression) {\n          var TMP_12, self = this;\n\n          return $send(self.literal, 'select', [], (TMP_12 = function(node){var self = TMP_12.$$s || this;\nif (node == null) node = nil;\n          return node['$=~'](expression)}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12))\n        }, TMP_NodeSet_filter_13.$$arity = 1);\n        \n        Opal.defn(self, '$search', TMP_NodeSet_search_15 = function $$search($a_rest) {\n          var TMP_14, self = this, what;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          what = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            what[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return Opal.const_get_relative($nesting, 'NodeSet')['$[]']($send(self.literal, 'map', [], (TMP_14 = function(node){var self = TMP_14.$$s || this;\nif (node == null) node = nil;\n          return $send(node, 'search', Opal.to_a(what))}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14)))\n        }, TMP_NodeSet_search_15.$$arity = -1);\n        \n        Opal.defn(self, '$xpath', TMP_NodeSet_xpath_17 = function $$xpath(path) {\n          var TMP_16, self = this;\n\n          return Opal.const_get_relative($nesting, 'NodeSet')['$[]']($send(self.literal, 'map', [], (TMP_16 = function(node){var self = TMP_16.$$s || this;\nif (node == null) node = nil;\n          return node.$xpath(path)}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16)))\n        }, TMP_NodeSet_xpath_17.$$arity = 1);\n        return (Opal.defn(self, '$to_ary', TMP_NodeSet_to_ary_18 = function $$to_ary() {\n          var self = this;\n\n          return self.literal\n        }, TMP_NodeSet_to_ary_18.$$arity = 0), nil) && 'to_ary';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/node\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$include', '$==', '$[]', '$new', '$raise', '$convert', '$respond_to?', '$each', '$<<', '$native?', '$===', '$>>', '$DOM', '$to_proc', '$parent', '$last', '$pop', '$select!', '$=~', '$remove_child', '$remove', '$children', '$supports?', '$node_type', '$first', '$select', '$element_children', '$to_s', '$next', '$!', '$element?', '$previous', '$try_convert', '$name']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Node(){};\n        var self = $Node = $klass($base, $super, 'Node', $Node);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Node_new_1, TMP_Node_$eq$eq_2, TMP_Node_$lt$lt_4, TMP_Node_$gt$gt_6, TMP_Node_add_child_7, TMP_Node_add_next_sibling_8, TMP_Node_add_previous_sibling_9, TMP_Node_append_to_10, TMP_Node_ancestors_12, TMP_Node_remove_13, TMP_Node_clear_14, TMP_Node_content_15, TMP_Node_content$eq_16, TMP_Node_content_17, TMP_Node_content$eq_18, TMP_Node_content_19, TMP_Node_content$eq_20, TMP_Node_blank$q_21, TMP_Node_cdata$q_22, TMP_Node_child_23, TMP_Node_children_24, TMP_Node_children$eq_25, TMP_Node_comment$q_26, TMP_Node_document_27, TMP_Node_document$q_28, TMP_Node_elem$q_29, TMP_Node_element_children_30, TMP_Node_first_element_child_31, TMP_Node_fragment$q_32, TMP_Node_inner_html_33, TMP_Node_inner_html$eq_34, TMP_Node_last_element_child_35, TMP_Node_name_36, TMP_Node_name$eq_37, TMP_Node_namespace_38, TMP_Node_next_39, TMP_Node_next_element_40, TMP_Node_node_type_41, TMP_Node_parent_42, TMP_Node_parent$eq_43, TMP_Node_parse_44, TMP_Node_path_45, TMP_Node_prepend_to_46, TMP_Node_previous_47, TMP_Node_previous_element_48, TMP_Node_remove_child_49, TMP_Node_replace_50, TMP_Node_text$q_51, TMP_Node_traverse_52, TMP_Node_value_53, TMP_Node_value$eq_54, TMP_Node_inspect_55;\n\n        def[\"native\"] = nil;\n        \n        self.$include(Opal.const_get_relative($nesting, 'Native'));\n        Opal.const_set($nesting[0], 'ELEMENT_NODE', 1);\n        Opal.const_set($nesting[0], 'ATTRIBUTE_NODE', 2);\n        Opal.const_set($nesting[0], 'TEXT_NODE', 3);\n        Opal.const_set($nesting[0], 'CDATA_SECTION_NODE', 4);\n        Opal.const_set($nesting[0], 'ENTITY_REFERENCE_NOCE', 5);\n        Opal.const_set($nesting[0], 'ENTITY_NODE', 6);\n        Opal.const_set($nesting[0], 'PROCESSING_INSTRUCTION_NODE', 7);\n        Opal.const_set($nesting[0], 'COMMENT_NODE', 8);\n        Opal.const_set($nesting[0], 'DOCUMENT_NODE', 9);\n        Opal.const_set($nesting[0], 'DOCUMENT_TYPE_NODE', 10);\n        Opal.const_set($nesting[0], 'DOCUMENT_FRAGMENT_NODE', 11);\n        Opal.const_set($nesting[0], 'NOTATION_NODE', 12);\n        Opal.defs(self, '$new', TMP_Node_new_1 = function(value) {\n          var $a, self = this, $iter = TMP_Node_new_1.$$p, $yield = $iter || nil, klass = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n          if (self.classes == null) self.classes = nil;\n\n          if ($iter) TMP_Node_new_1.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          if (self['$=='](Opal.const_get_relative($nesting, 'Node'))) {\n            \n            self.classes = ($truthy($a = self.classes) ? $a : [nil, Opal.const_get_relative($nesting, 'Element'), Opal.const_get_relative($nesting, 'Attribute'), Opal.const_get_relative($nesting, 'Text'), Opal.const_get_relative($nesting, 'CDATA'), nil, nil, nil, Opal.const_get_relative($nesting, 'Comment'), Opal.const_get_relative($nesting, 'Document'), nil, Opal.const_get_relative($nesting, 'DocumentFragment')]);\n            if ($truthy((klass = self.classes['$[]'](value.nodeType)))) {\n              return klass.$new(value)\n              } else {\n              return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"cannot instantiate a non derived Node object\")\n            };\n            } else {\n            return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_Node_new_1, false, $Node), $zuper, $iter)\n          }\n        }, TMP_Node_new_1.$$arity = 1);\n        \n        Opal.defn(self, '$==', TMP_Node_$eq$eq_2 = function(other) {\n          var self = this;\n\n          return self[\"native\"] === Opal.const_get_relative($nesting, 'Native').$convert(other)\n        }, TMP_Node_$eq$eq_2.$$arity = 1);\n        \n        Opal.defn(self, '$<<', TMP_Node_$lt$lt_4 = function(node) {\n          var TMP_3, self = this;\n\n          \n          if ($truthy(Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](node, \"each\"))) {\n            \n            $send(node, 'each', [], (TMP_3 = function(n){var self = TMP_3.$$s || this;\nif (n == null) n = nil;\n            return self['$<<'](n)}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3));\n            return self;};\n          if ($truthy(self['$native?'](node))) {\n          } else if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](node))) {\n            node = self[\"native\"].ownerDocument.createTextNode(node)\n            } else {\n            node = Opal.const_get_relative($nesting, 'Native').$convert(node)\n          };\n          self[\"native\"].appendChild(node);\n          return self;\n        }, TMP_Node_$lt$lt_4.$$arity = 1);\n        \n        Opal.defn(self, '$>>', TMP_Node_$gt$gt_6 = function(node) {\n          var TMP_5, self = this;\n\n          \n          if ($truthy(Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](node, \"each\"))) {\n            \n            $send(node, 'each', [], (TMP_5 = function(n){var self = TMP_5.$$s || this;\nif (n == null) n = nil;\n            return self['$>>'](n)}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));\n            return self;};\n          if ($truthy(self['$native?'](node))) {\n          } else if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](node))) {\n            node = self[\"native\"].ownerDocument.createTextNode(node)\n            } else {\n            node = Opal.const_get_relative($nesting, 'Native').$convert(node)\n          };\n          if ($truthy(self[\"native\"].firstChild == null)) {\n            self[\"native\"].appendChild(node)\n            } else {\n            self[\"native\"].insertBefore(node, self[\"native\"].firstChild)\n          };\n          return self;\n        }, TMP_Node_$gt$gt_6.$$arity = 1);\n        \n        Opal.defn(self, '$add_child', TMP_Node_add_child_7 = function $$add_child(node) {\n          var self = this, $iter = TMP_Node_add_child_7.$$p, block = $iter || nil;\n\n          if (node == null) {\n            node = nil;\n          }\n          if ($iter) TMP_Node_add_child_7.$$p = null;\n          \n          if ($truthy(node)) {\n            } else {\n            node = $send(self, 'DOM', [], block.$to_proc())\n          };\n          return self['$<<'](node);\n        }, TMP_Node_add_child_7.$$arity = -1);\n        \n        Opal.defn(self, '$add_next_sibling', TMP_Node_add_next_sibling_8 = function $$add_next_sibling(node) {\n          var self = this, $iter = TMP_Node_add_next_sibling_8.$$p, block = $iter || nil;\n\n          if (node == null) {\n            node = nil;\n          }\n          if ($iter) TMP_Node_add_next_sibling_8.$$p = null;\n          \n          if ($truthy(node)) {\n            } else {\n            node = $send(self, 'DOM', [], block.$to_proc())\n          };\n          if ($truthy(self['$native?'](node))) {\n          } else if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](node))) {\n            node = self[\"native\"].ownerDocument.createTextNode(node)\n            } else {\n            node = Opal.const_get_relative($nesting, 'Native').$convert(node)\n          };\n          return self[\"native\"].parentNode.insertBefore(node, self[\"native\"].nextSibling);\n        }, TMP_Node_add_next_sibling_8.$$arity = -1);\n        \n        Opal.defn(self, '$add_previous_sibling', TMP_Node_add_previous_sibling_9 = function $$add_previous_sibling(node) {\n          var self = this, $iter = TMP_Node_add_previous_sibling_9.$$p, block = $iter || nil;\n\n          if (node == null) {\n            node = nil;\n          }\n          if ($iter) TMP_Node_add_previous_sibling_9.$$p = null;\n          \n          if ($truthy(node)) {\n            } else {\n            node = $send(self, 'DOM', [], block.$to_proc())\n          };\n          if ($truthy(self['$native?'](node))) {\n          } else if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](node))) {\n            node = self[\"native\"].ownerDocument.createTextNode(node)\n            } else {\n            node = Opal.const_get_relative($nesting, 'Native').$convert(node)\n          };\n          return self[\"native\"].parentNode.insertBefore(node, self[\"native\"]);\n        }, TMP_Node_add_previous_sibling_9.$$arity = -1);\n        Opal.alias(self, \"after\", \"add_next_sibling\");\n        \n        Opal.defn(self, '$append_to', TMP_Node_append_to_10 = function $$append_to(node) {\n          var self = this;\n\n          return node['$<<'](self)\n        }, TMP_Node_append_to_10.$$arity = 1);\n        \n        Opal.defn(self, '$ancestors', TMP_Node_ancestors_12 = function $$ancestors(expression) {\n          var $a, TMP_11, self = this, parents = nil, parent = nil;\n\n          if (expression == null) {\n            expression = nil;\n          }\n          \n          if ($truthy(self.$parent())) {\n            } else {\n            return Opal.const_get_relative($nesting, 'NodeSet')['$[]']()\n          };\n          parents = [self.$parent()];\n          while ($truthy((parent = parents.$last().$parent()))) {\n            parents['$<<'](parent)\n          };\n          if ($truthy(Opal.const_get_relative($nesting, 'Document')['$==='](parents.$last()))) {\n            parents.$pop()};\n          if ($truthy(expression)) {\n            $send(parents, 'select!', [], (TMP_11 = function(p){var self = TMP_11.$$s || this;\nif (p == null) p = nil;\n            return p['$=~'](expression)}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11))};\n          return Opal.const_get_relative($nesting, 'NodeSet').$new(parents);\n        }, TMP_Node_ancestors_12.$$arity = -1);\n        Opal.alias(self, \"before\", \"add_previous_sibling\");\n        \n        Opal.defn(self, '$remove', TMP_Node_remove_13 = function $$remove() {\n          var self = this;\n\n          if ($truthy(self.$parent())) {\n            return self.$parent().$remove_child(self)\n            } else {\n            return nil\n          }\n        }, TMP_Node_remove_13.$$arity = 0);\n        \n        Opal.defn(self, '$clear', TMP_Node_clear_14 = function $$clear() {\n          var self = this;\n\n          return self.$children().$remove()\n        }, TMP_Node_clear_14.$$arity = 0);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.textContent\"))) {\n          \n          \n          Opal.defn(self, '$content', TMP_Node_content_15 = function $$content() {\n            var self = this;\n\n            return self[\"native\"].textContent\n          }, TMP_Node_content_15.$$arity = 0);\n          \n          Opal.defn(self, '$content=', TMP_Node_content$eq_16 = function(value) {\n            var self = this;\n\n            return self[\"native\"].textContent = value\n          }, TMP_Node_content$eq_16.$$arity = 1);\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.innerText\"))) {\n          \n          \n          Opal.defn(self, '$content', TMP_Node_content_17 = function $$content() {\n            var self = this;\n\n            return self[\"native\"].innerText\n          }, TMP_Node_content_17.$$arity = 0);\n          \n          Opal.defn(self, '$content=', TMP_Node_content$eq_18 = function(value) {\n            var self = this;\n\n            return self[\"native\"].innerText = value\n          }, TMP_Node_content$eq_18.$$arity = 1);\n          } else {\n          \n          \n          Opal.defn(self, '$content', TMP_Node_content_19 = function $$content() {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"node text content unsupported\")\n          }, TMP_Node_content_19.$$arity = 0);\n          \n          Opal.defn(self, '$content=', TMP_Node_content$eq_20 = function(value) {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"node text content unsupported\")\n          }, TMP_Node_content$eq_20.$$arity = 1);\n        };\n        \n        Opal.defn(self, '$blank?', TMP_Node_blank$q_21 = function() {\n          var self = this;\n\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n        }, TMP_Node_blank$q_21.$$arity = 0);\n        \n        Opal.defn(self, '$cdata?', TMP_Node_cdata$q_22 = function() {\n          var self = this;\n\n          return self.$node_type()['$=='](Opal.const_get_relative($nesting, 'CDATA_SECTION_NODE'))\n        }, TMP_Node_cdata$q_22.$$arity = 0);\n        \n        Opal.defn(self, '$child', TMP_Node_child_23 = function $$child() {\n          var self = this;\n\n          return self.$children().$first()\n        }, TMP_Node_child_23.$$arity = 0);\n        \n        Opal.defn(self, '$children', TMP_Node_children_24 = function $$children() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'NodeSet')['$[]'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array').$new(self[\"native\"].childNodes))\n        }, TMP_Node_children_24.$$arity = 0);\n        \n        Opal.defn(self, '$children=', TMP_Node_children$eq_25 = function(node) {\n          var self = this;\n\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n        }, TMP_Node_children$eq_25.$$arity = 1);\n        \n        Opal.defn(self, '$comment?', TMP_Node_comment$q_26 = function() {\n          var self = this;\n\n          return self.$node_type()['$=='](Opal.const_get_relative($nesting, 'COMMENT_NODE'))\n        }, TMP_Node_comment$q_26.$$arity = 0);\n        \n        Opal.defn(self, '$document', TMP_Node_document_27 = function $$document() {\n          var self = this;\n\n          if ($truthy((typeof(self[\"native\"].ownerDocument) !== \"undefined\"))) {\n            return self.$DOM(self[\"native\"].ownerDocument)\n            } else {\n            return nil\n          }\n        }, TMP_Node_document_27.$$arity = 0);\n        \n        Opal.defn(self, '$document?', TMP_Node_document$q_28 = function() {\n          var self = this;\n\n          return self.$node_type()['$=='](Opal.const_get_relative($nesting, 'DOCUMENT_NODE'))\n        }, TMP_Node_document$q_28.$$arity = 0);\n        \n        Opal.defn(self, '$elem?', TMP_Node_elem$q_29 = function() {\n          var self = this;\n\n          return self.$node_type()['$=='](Opal.const_get_relative($nesting, 'ELEMENT_NODE'))\n        }, TMP_Node_elem$q_29.$$arity = 0);\n        Opal.alias(self, \"element?\", \"elem?\");\n        \n        Opal.defn(self, '$element_children', TMP_Node_element_children_30 = function $$element_children() {\n          var self = this;\n\n          return $send(self.$children(), 'select', [], \"element?\".$to_proc())\n        }, TMP_Node_element_children_30.$$arity = 0);\n        Opal.alias(self, \"elements\", \"element_children\");\n        \n        Opal.defn(self, '$first_element_child', TMP_Node_first_element_child_31 = function $$first_element_child() {\n          var self = this;\n\n          return self.$element_children().$first()\n        }, TMP_Node_first_element_child_31.$$arity = 0);\n        \n        Opal.defn(self, '$fragment?', TMP_Node_fragment$q_32 = function() {\n          var self = this;\n\n          return self.$node_type()['$=='](Opal.const_get_relative($nesting, 'DOCUMENT_FRAGMENT_NODE'))\n        }, TMP_Node_fragment$q_32.$$arity = 0);\n        \n        Opal.defn(self, '$inner_html', TMP_Node_inner_html_33 = function $$inner_html() {\n          var self = this;\n\n          return self[\"native\"].innerHTML\n        }, TMP_Node_inner_html_33.$$arity = 0);\n        \n        Opal.defn(self, '$inner_html=', TMP_Node_inner_html$eq_34 = function(value) {\n          var self = this;\n\n          return self[\"native\"].innerHTML = value\n        }, TMP_Node_inner_html$eq_34.$$arity = 1);\n        Opal.alias(self, \"inner_text\", \"content\");\n        Opal.alias(self, \"inner_text=\", \"content=\");\n        \n        Opal.defn(self, '$last_element_child', TMP_Node_last_element_child_35 = function $$last_element_child() {\n          var self = this;\n\n          return self.$element_children().$last()\n        }, TMP_Node_last_element_child_35.$$arity = 0);\n        \n        Opal.defn(self, '$name', TMP_Node_name_36 = function $$name() {\n          var self = this;\n\n          return self[\"native\"].nodeName || nil\n        }, TMP_Node_name_36.$$arity = 0);\n        \n        Opal.defn(self, '$name=', TMP_Node_name$eq_37 = function(value) {\n          var self = this;\n\n          return self[\"native\"].nodeName = value.$to_s()\n        }, TMP_Node_name$eq_37.$$arity = 1);\n        \n        Opal.defn(self, '$namespace', TMP_Node_namespace_38 = function $$namespace() {\n          var self = this;\n\n          return self[\"native\"].namespaceURI || nil\n        }, TMP_Node_namespace_38.$$arity = 0);\n        \n        Opal.defn(self, '$next', TMP_Node_next_39 = function $$next() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].nextSibling != null)) {\n            return self.$DOM(self[\"native\"].nextSibling)\n            } else {\n            return nil\n          }\n        }, TMP_Node_next_39.$$arity = 0);\n        Opal.alias(self, \"next=\", \"add_next_sibling\");\n        \n        Opal.defn(self, '$next_element', TMP_Node_next_element_40 = function $$next_element() {\n          var $a, $b, self = this, current = nil;\n\n          \n          current = self.$next();\n          while ($truthy(($truthy($b = current) ? current['$element?']()['$!']() : $b))) {\n            current = current.$next()\n          };\n          return current;\n        }, TMP_Node_next_element_40.$$arity = 0);\n        Opal.alias(self, \"next_sibling\", \"next\");\n        Opal.alias(self, \"node_name\", \"name\");\n        Opal.alias(self, \"node_name=\", \"name=\");\n        \n        Opal.defn(self, '$node_type', TMP_Node_node_type_41 = function $$node_type() {\n          var self = this;\n\n          return self[\"native\"].nodeType\n        }, TMP_Node_node_type_41.$$arity = 0);\n        \n        Opal.defn(self, '$parent', TMP_Node_parent_42 = function $$parent() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].parentNode != null)) {\n            return self.$DOM(self[\"native\"].parentNode)\n            } else {\n            return nil\n          }\n        }, TMP_Node_parent_42.$$arity = 0);\n        \n        Opal.defn(self, '$parent=', TMP_Node_parent$eq_43 = function(node) {\n          var self = this;\n\n          return self[\"native\"].parentNode = Opal.const_get_relative($nesting, 'Native').$convert(node)\n        }, TMP_Node_parent$eq_43.$$arity = 1);\n        \n        Opal.defn(self, '$parse', TMP_Node_parse_44 = function $$parse(text, options) {\n          var self = this;\n\n          if (options == null) {\n            options = $hash2([], {});\n          }\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n        }, TMP_Node_parse_44.$$arity = -2);\n        \n        Opal.defn(self, '$path', TMP_Node_path_45 = function $$path() {\n          var self = this;\n\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n        }, TMP_Node_path_45.$$arity = 0);\n        \n        Opal.defn(self, '$prepend_to', TMP_Node_prepend_to_46 = function $$prepend_to(node) {\n          var self = this;\n\n          return node['$>>'](self)\n        }, TMP_Node_prepend_to_46.$$arity = 1);\n        \n        Opal.defn(self, '$previous', TMP_Node_previous_47 = function $$previous() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].previousSibling != null)) {\n            return self.$DOM(self[\"native\"].previousSibling)\n            } else {\n            return nil\n          }\n        }, TMP_Node_previous_47.$$arity = 0);\n        Opal.alias(self, \"previous=\", \"add_previous_sibling\");\n        \n        Opal.defn(self, '$previous_element', TMP_Node_previous_element_48 = function $$previous_element() {\n          var $a, $b, self = this, current = nil;\n\n          \n          current = self.$previous();\n          while ($truthy(($truthy($b = current) ? current['$element?']()['$!']() : $b))) {\n            current = current.$previous()\n          };\n          return current;\n        }, TMP_Node_previous_element_48.$$arity = 0);\n        Opal.alias(self, \"previous_sibling\", \"previous\");\n        \n        Opal.defn(self, '$remove_child', TMP_Node_remove_child_49 = function $$remove_child(node) {\n          var self = this;\n\n          return self[\"native\"].removeChild(Opal.const_get_relative($nesting, 'Native').$try_convert(node))\n        }, TMP_Node_remove_child_49.$$arity = 1);\n        \n        Opal.defn(self, '$replace', TMP_Node_replace_50 = function $$replace(node) {\n          var self = this;\n\n          \n          if ($truthy(self['$native?'](node))) {\n          } else if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](node))) {\n            node = self[\"native\"].ownerDocument.createTextNode(node)\n            } else {\n            node = Opal.const_get_relative($nesting, 'Native').$convert(node)\n          };\n          self[\"native\"].parentNode.replaceChild(node, self[\"native\"]);\n          return node;\n        }, TMP_Node_replace_50.$$arity = 1);\n        Opal.alias(self, \"replace_with\", \"replace\");\n        Opal.alias(self, \"text\", \"content\");\n        Opal.alias(self, \"text=\", \"content=\");\n        \n        Opal.defn(self, '$text?', TMP_Node_text$q_51 = function() {\n          var self = this;\n\n          return self.$node_type()['$=='](Opal.const_get_relative($nesting, 'TEXT_NODE'))\n        }, TMP_Node_text$q_51.$$arity = 0);\n        \n        Opal.defn(self, '$traverse', TMP_Node_traverse_52 = function $$traverse() {\n          var self = this, $iter = TMP_Node_traverse_52.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Node_traverse_52.$$p = null;\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n        }, TMP_Node_traverse_52.$$arity = 0);\n        Opal.alias(self, \"type\", \"node_type\");\n        \n        Opal.defn(self, '$value', TMP_Node_value_53 = function $$value() {\n          var self = this;\n\n          return self[\"native\"].nodeValue || nil\n        }, TMP_Node_value_53.$$arity = 0);\n        \n        Opal.defn(self, '$value=', TMP_Node_value$eq_54 = function(value) {\n          var self = this;\n\n          return self[\"native\"].nodeValue = value\n        }, TMP_Node_value$eq_54.$$arity = 1);\n        return (Opal.defn(self, '$inspect', TMP_Node_inspect_55 = function $$inspect() {\n          var self = this;\n\n          return \"\" + \"#<DOM::Node: \" + (self.$name()) + \">\"\n        }, TMP_Node_inspect_55.$$arity = 0), nil) && 'inspect';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/attribute\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$include', '$alias_native', '$supports?', '$==', '$name']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Attribute(){};\n        var self = $Attribute = $klass($base, $super, 'Attribute', $Attribute);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Attribute_id$q_1;\n\n        \n        self.$include(Opal.const_get_relative($nesting, 'Native'));\n        self.$alias_native(\"name\");\n        self.$alias_native(\"value\");\n        self.$alias_native(\"value=\");\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Attr.isId\"))) {\n          return self.$alias_native(\"id?\", \"isId\")\n          } else {\n          return (Opal.defn(self, '$id?', TMP_Attribute_id$q_1 = function() {\n            var self = this;\n\n            return self.$name()['$=='](\"id\")\n          }, TMP_Attribute_id$q_1.$$arity = 0), nil) && 'id?'\n        };\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/character_data\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $CharacterData(){};\n        var self = $CharacterData = $klass($base, $super, 'CharacterData', $CharacterData);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_CharacterData_append_1, TMP_CharacterData_data_2, TMP_CharacterData_delete_3, TMP_CharacterData_insert_4, TMP_CharacterData_replace_5, TMP_CharacterData_substring_6;\n\n        def[\"native\"] = nil;\n        \n        \n        Opal.defn(self, '$append', TMP_CharacterData_append_1 = function $$append(string) {\n          var self = this;\n\n          \n          self[\"native\"].appendData(string);\n          return self;\n        }, TMP_CharacterData_append_1.$$arity = 1);\n        \n        Opal.defn(self, '$data', TMP_CharacterData_data_2 = function $$data() {\n          var self = this;\n\n          return self[\"native\"].data\n        }, TMP_CharacterData_data_2.$$arity = 0);\n        \n        Opal.defn(self, '$delete', TMP_CharacterData_delete_3 = function(count, offset) {\n          var self = this;\n\n          if (offset == null) {\n            offset = 0;\n          }\n          \n          self[\"native\"].deleteData(offset, count);\n          return self;\n        }, TMP_CharacterData_delete_3.$$arity = -2);\n        \n        Opal.defn(self, '$insert', TMP_CharacterData_insert_4 = function $$insert(string, offset) {\n          var self = this;\n\n          if (offset == null) {\n            offset = 0;\n          }\n          \n          self[\"native\"].insertData(offset, string);\n          return self;\n        }, TMP_CharacterData_insert_4.$$arity = -2);\n        self.$alias_native(\"length\");\n        \n        Opal.defn(self, '$replace', TMP_CharacterData_replace_5 = function $$replace(string, offset, count) {\n          var self = this;\n\n          if (offset == null) {\n            offset = 0;\n          }\n          if (count == null) {\n            count = self[\"native\"].length;\n          }\n          \n          self[\"native\"].replaceData(offset, count, string);\n          return self;\n        }, TMP_CharacterData_replace_5.$$arity = -2);\n        return (Opal.defn(self, '$substring', TMP_CharacterData_substring_6 = function $$substring(count, offset) {\n          var self = this;\n\n          if (offset == null) {\n            offset = 0;\n          }\n          return self[\"native\"].substringData(offset, count)\n        }, TMP_CharacterData_substring_6.$$arity = -2), nil) && 'substring';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/text\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$create_text', '$DOM', '$data']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Text(){};\n        var self = $Text = $klass($base, $super, 'Text', $Text);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Text_create_1, TMP_Text_whole_2, TMP_Text_split_3, TMP_Text_inspect_4;\n\n        def[\"native\"] = nil;\n        \n        Opal.defs(self, '$create', TMP_Text_create_1 = function $$create($a_rest) {\n          var self = this, args;\n          if ($gvars.document == null) $gvars.document = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return $send($gvars.document, 'create_text', Opal.to_a(args))\n        }, TMP_Text_create_1.$$arity = -1);\n        \n        Opal.defn(self, '$whole', TMP_Text_whole_2 = function $$whole() {\n          var self = this;\n\n          return self[\"native\"].wholeText\n        }, TMP_Text_whole_2.$$arity = 0);\n        \n        Opal.defn(self, '$split', TMP_Text_split_3 = function $$split(offset) {\n          var self = this;\n\n          return self.$DOM(self[\"native\"].splitText(offset))\n        }, TMP_Text_split_3.$$arity = 1);\n        return (Opal.defn(self, '$inspect', TMP_Text_inspect_4 = function $$inspect() {\n          var self = this;\n\n          return \"\" + \"#<DOM::Text: \" + (self.$data()) + \">\"\n        }, TMP_Text_inspect_4.$$arity = 0), nil) && 'inspect';\n      })($nesting[0], Opal.const_get_relative($nesting, 'CharacterData'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/cdata\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$value']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $CDATA(){};\n        var self = $CDATA = $klass($base, $super, 'CDATA', $CDATA);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_CDATA_inspect_1;\n\n        return (Opal.defn(self, '$inspect', TMP_CDATA_inspect_1 = function $$inspect() {\n          var self = this;\n\n          return \"\" + \"#<DOM::CDATA: \" + (self.$value()) + \">\"\n        }, TMP_CDATA_inspect_1.$$arity = 0), nil) && 'inspect'\n      })($nesting[0], Opal.const_get_relative($nesting, 'Text'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/comment\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$value']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Comment(){};\n        var self = $Comment = $klass($base, $super, 'Comment', $Comment);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Comment_inspect_1;\n\n        return (Opal.defn(self, '$inspect', TMP_Comment_inspect_1 = function $$inspect() {\n          var self = this;\n\n          return \"\" + \"#<DOM::Comment: \" + (self.$value()) + \">\"\n        }, TMP_Comment_inspect_1.$$arity = 0), nil) && 'inspect'\n      })($nesting[0], Opal.const_get_relative($nesting, 'CharacterData'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element/attributes\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$to_n', '$[]', '$supports?', '$==', '$to_s', '$include', '$enum_for', '$each', '$attribute_nodes', '$name', '$value', '$!', '$[]=', '$-']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Attributes(){};\n          var self = $Attributes = $klass($base, $super, 'Attributes', $Attributes);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Attributes_initialize_1, $a, TMP_Attributes_$$_2, TMP_Attributes_$$$eq_3, TMP_Attributes_$$_4, TMP_Attributes_$$$eq_5, TMP_Attributes_each_6, TMP_Attributes_has_key$q_8, TMP_Attributes_merge$B_10;\n\n          def.namespace = def[\"native\"] = def.element = nil;\n          \n          self.$attr_reader(\"namespace\");\n          \n          Opal.defn(self, '$initialize', TMP_Attributes_initialize_1 = function $$initialize(element, options) {\n            var self = this;\n\n            \n            self.element = element;\n            self[\"native\"] = element.$to_n();\n            return (self.namespace = options['$[]'](\"namespace\"));\n          }, TMP_Attributes_initialize_1.$$arity = 2);\n          if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.className\")) ? $a : Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.htmlFor\")))) {\n            \n            \n            Opal.defn(self, '$[]', TMP_Attributes_$$_2 = function(name, options) {\n              var $a, self = this, namespace = nil;\n\n              if (options == null) {\n                options = $hash2([], {});\n              }\n              \n              if ($truthy((($a = name['$=='](\"class\")) ? Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.className\") : name['$=='](\"class\")))) {\n                name = \"className\"\n              } else if ($truthy((($a = name['$=='](\"for\")) ? Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.htmlFor\") : name['$=='](\"for\")))) {\n                name = \"htmlFor\"};\n              if ($truthy((namespace = ($truthy($a = options['$[]'](\"namespace\")) ? $a : self.namespace)))) {\n                return self[\"native\"].getAttributeNS(namespace.$to_s(), name.$to_s()) || nil\n                } else {\n                return self[\"native\"].getAttribute(name.$to_s()) || nil\n              };\n            }, TMP_Attributes_$$_2.$$arity = -2);\n            \n            Opal.defn(self, '$[]=', TMP_Attributes_$$$eq_3 = function(name, value, options) {\n              var $a, self = this, namespace = nil;\n\n              if (options == null) {\n                options = $hash2([], {});\n              }\n              \n              if ($truthy((($a = name['$=='](\"class\")) ? Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.className\") : name['$=='](\"class\")))) {\n                name = \"className\"\n              } else if ($truthy((($a = name['$=='](\"for\")) ? Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.htmlFor\") : name['$=='](\"for\")))) {\n                name = \"htmlFor\"};\n              if ($truthy((namespace = ($truthy($a = options['$[]'](\"namespace\")) ? $a : self.namespace)))) {\n                return self[\"native\"].setAttributeNS(namespace.$to_s(), name.$to_s(), value)\n                } else {\n                return self[\"native\"].setAttribute(name.$to_s(), value.$to_s())\n              };\n            }, TMP_Attributes_$$$eq_3.$$arity = -3);\n            } else {\n            \n            \n            Opal.defn(self, '$[]', TMP_Attributes_$$_4 = function(name, options) {\n              var $a, self = this, namespace = nil;\n\n              if (options == null) {\n                options = $hash2([], {});\n              }\n              if ($truthy((namespace = ($truthy($a = options['$[]'](\"namespace\")) ? $a : self.namespace)))) {\n                return self[\"native\"].getAttributeNS(namespace.$to_s(), name.$to_s()) || nil\n                } else {\n                return self[\"native\"].getAttribute(name.$to_s()) || nil\n              }\n            }, TMP_Attributes_$$_4.$$arity = -2);\n            \n            Opal.defn(self, '$[]=', TMP_Attributes_$$$eq_5 = function(name, value, options) {\n              var $a, self = this, namespace = nil;\n\n              if (options == null) {\n                options = $hash2([], {});\n              }\n              if ($truthy((namespace = ($truthy($a = options['$[]'](\"namespace\")) ? $a : self.namespace)))) {\n                return self[\"native\"].setAttributeNS(namespace.$to_s(), name.$to_s(), value)\n                } else {\n                return self[\"native\"].setAttribute(name.$to_s(), value.$to_s())\n              }\n            }, TMP_Attributes_$$$eq_5.$$arity = -3);\n          };\n          self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n          \n          Opal.defn(self, '$each', TMP_Attributes_each_6 = function $$each() {\n            var TMP_7, self = this, $iter = TMP_Attributes_each_6.$$p, block = $iter || nil;\n\n            if ($iter) TMP_Attributes_each_6.$$p = null;\n            \n            if ((block !== nil)) {\n              } else {\n              return self.$enum_for(\"each\")\n            };\n            $send(self.element.$attribute_nodes(), 'each', [], (TMP_7 = function(attr){var self = TMP_7.$$s || this;\nif (attr == null) attr = nil;\n            return Opal.yieldX(block, [attr.$name(), attr.$value()]);}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));\n            return self;\n          }, TMP_Attributes_each_6.$$arity = 0);\n          Opal.alias(self, \"get\", \"[]\");\n          \n          Opal.defn(self, '$has_key?', TMP_Attributes_has_key$q_8 = function(name) {\n            var self = this;\n\n            return self['$[]'](name)['$!']()['$!']()\n          }, TMP_Attributes_has_key$q_8.$$arity = 1);\n          \n          Opal.defn(self, '$merge!', TMP_Attributes_merge$B_10 = function(hash) {\n            var TMP_9, self = this;\n\n            \n            $send(hash, 'each', [], (TMP_9 = function(name, value){var self = TMP_9.$$s || this, $writer = nil;\nif (name == null) name = nil;if (value == null) value = nil;\n            \n              $writer = [name, value];\n              $send(self, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_9.$$s = self, TMP_9.$$arity = 2, TMP_9));\n            return self;\n          }, TMP_Attributes_merge$B_10.$$arity = 1);\n          return Opal.alias(self, \"set\", \"[]=\");\n        })($nesting[0], null, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element/data\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$attr_reader', '$to_n', '$include', '$enum_for', '$call', '$each', '$attributes', '$=~', '$[]']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Data(){};\n          var self = $Data = $klass($base, $super, 'Data', $Data);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Data_initialize_1, TMP_Data_each_2, TMP_Data_assign_5, TMP_Data_$$_6, TMP_Data_$$$eq_7;\n\n          def[\"native\"] = def.element = nil;\n          \n          self.$attr_reader(\"element\");\n          \n          Opal.defn(self, '$initialize', TMP_Data_initialize_1 = function $$initialize(element) {\n            var self = this;\n\n            \n            self.element = element;\n            self[\"native\"] = element.$to_n();\n            if ($truthy((typeof(self[\"native\"].$data) !== \"undefined\"))) {\n              return nil\n              } else {\n              return self[\"native\"].$data = {}\n            };\n          }, TMP_Data_initialize_1.$$arity = 1);\n          self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n          \n          Opal.defn(self, '$each', TMP_Data_each_2 = function $$each() {\n            var TMP_3, self = this, $iter = TMP_Data_each_2.$$p, block = $iter || nil;\n\n            if ($iter) TMP_Data_each_2.$$p = null;\n            \n            if ($truthy(block)) {\n              } else {\n              return self.$enum_for(\"each\")\n            };\n            \n      var data = self[\"native\"].$data;\n\n      for (var key in data) {\n        block.$call(key, data[key]);\n      }\n    ;\n            $send(self.element.$attributes(), 'each', [], (TMP_3 = function(name, value){var self = TMP_3.$$s || this, $a;\nif (name == null) name = nil;if (value == null) value = nil;\n            if ($truthy(name['$=~'](/^data-(.*)$/))) {\n                return block.$call((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), value)\n                } else {\n                return nil\n              }}, TMP_3.$$s = self, TMP_3.$$arity = 2, TMP_3));\n            return self;\n          }, TMP_Data_each_2.$$arity = 0);\n          \n          Opal.defn(self, '$assign', TMP_Data_assign_5 = function $$assign(data) {\n            var TMP_4, self = this;\n\n            \n            $send(data, 'each', [], (TMP_4 = function(name, value){var self = TMP_4.$$s || this;\n              if (self[\"native\"] == null) self[\"native\"] = nil;\nif (name == null) name = nil;if (value == null) value = nil;\n            return self[\"native\"].$data[name] = value}, TMP_4.$$s = self, TMP_4.$$arity = 2, TMP_4));\n            return self;\n          }, TMP_Data_assign_5.$$arity = 1);\n          \n          Opal.defn(self, '$[]', TMP_Data_$$_6 = function(name) {\n            var self = this, data = nil;\n\n            \n            if ($truthy((data = self.element['$[]'](\"\" + \"data-\" + (name))))) {\n              return data};\n            \n      var value = self[\"native\"].$data[name];\n\n      if (value === undefined) {\n        return nil;\n      }\n      else {\n        return value;\n      }\n    ;\n          }, TMP_Data_$$_6.$$arity = 1);\n          return (Opal.defn(self, '$[]=', TMP_Data_$$$eq_7 = function(name, value) {\n            var self = this;\n\n            return self[\"native\"].$data[name] = value\n          }, TMP_Data_$$$eq_7.$$arity = 2), nil) && '[]=';\n        })($nesting[0], null, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element/position\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$to_n', '$offset', '$get', '$parent', '$new', '$==', '$[]', '$style', '$=~', '$+', '$x', '$to_i', '$x=', '$-', '$y', '$y=']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Position(){};\n          var self = $Position = $klass($base, $super, 'Position', $Position);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Position_initialize_1, TMP_Position_get_2, TMP_Position_x_3, TMP_Position_y_4;\n\n          def.element = nil;\n          \n          self.$attr_reader(\"element\");\n          \n          Opal.defn(self, '$initialize', TMP_Position_initialize_1 = function $$initialize(element) {\n            var self = this;\n\n            \n            self.element = element;\n            return (self[\"native\"] = element.$to_n());\n          }, TMP_Position_initialize_1.$$arity = 1);\n          \n          Opal.defn(self, '$get', TMP_Position_get_2 = function $$get() {\n            var self = this, offset = nil, position = nil, parent = nil, parent_offset = nil, $writer = nil;\n\n            \n            offset = self.element.$offset();\n            position = offset.$get();\n            parent = offset.$parent();\n            parent_offset = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'Position').$new(0, 0);\n            if (self.element.$style()['$[]'](\"position\")['$=='](\"fixed\")) {\n              \n              if ($truthy(parent['$=~'](\"html\"))) {\n                } else {\n                parent_offset = parent.$offset()\n              };\n              \n              $writer = [$rb_plus(parent_offset.$x(), parent.$style()['$[]'](\"border-top-width\").$to_i())];\n              $send(parent_offset, 'x=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              \n              $writer = [$rb_plus(parent_offset.$y(), parent.$style()['$[]'](\"border-left-width\").$to_i())];\n              $send(parent_offset, 'y=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;};\n            return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'Position').$new($rb_minus($rb_minus(position.$x(), parent_offset.$x()), self.element.$style()['$[]'](\"margin-left\").$to_i()), $rb_minus($rb_minus(position.$y(), parent_offset.$y()), self.element.$style()['$[]'](\"margin-top\").$to_i()));\n          }, TMP_Position_get_2.$$arity = 0);\n          \n          Opal.defn(self, '$x', TMP_Position_x_3 = function $$x() {\n            var self = this;\n\n            return self.$get().$x()\n          }, TMP_Position_x_3.$$arity = 0);\n          return (Opal.defn(self, '$y', TMP_Position_y_4 = function $$y() {\n            var self = this;\n\n            return self.$get().$y()\n          }, TMP_Position_y_4.$$arity = 0), nil) && 'y';\n        })($nesting[0], null, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element/offset\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$to_n', '$DOM', '$root', '$document', '$x', '$get', '$set', '$y', '$supports?', '$window', '$new', '$[]', '$style!', '$==', '$[]=', '$style', '$-', '$to_u', '$===', '$first', '$+', '$px']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Offset(){};\n          var self = $Offset = $klass($base, $super, 'Offset', $Offset);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Offset_initialize_1, TMP_Offset_parent_2, TMP_Offset_x_3, TMP_Offset_x$eq_4, TMP_Offset_y_5, TMP_Offset_y$eq_6, TMP_Offset_get_7, TMP_Offset_get_8, TMP_Offset_set_9;\n\n          def[\"native\"] = def.element = nil;\n          \n          self.$attr_reader(\"element\");\n          \n          Opal.defn(self, '$initialize', TMP_Offset_initialize_1 = function $$initialize(element) {\n            var self = this;\n\n            \n            self.element = element;\n            return (self[\"native\"] = element.$to_n());\n          }, TMP_Offset_initialize_1.$$arity = 1);\n          \n          Opal.defn(self, '$parent', TMP_Offset_parent_2 = function $$parent() {\n            var self = this;\n\n            return self.$DOM(self[\"native\"].offsetParent || self.element.$document().$root().$to_n())\n          }, TMP_Offset_parent_2.$$arity = 0);\n          \n          Opal.defn(self, '$x', TMP_Offset_x_3 = function $$x() {\n            var self = this;\n\n            return self.$get().$x()\n          }, TMP_Offset_x_3.$$arity = 0);\n          \n          Opal.defn(self, '$x=', TMP_Offset_x$eq_4 = function(value) {\n            var self = this;\n\n            return self.$set(value, nil)\n          }, TMP_Offset_x$eq_4.$$arity = 1);\n          \n          Opal.defn(self, '$y', TMP_Offset_y_5 = function $$y() {\n            var self = this;\n\n            return self.$get().$y()\n          }, TMP_Offset_y_5.$$arity = 0);\n          \n          Opal.defn(self, '$y=', TMP_Offset_y$eq_6 = function(value) {\n            var self = this;\n\n            return self.$set(nil, value)\n          }, TMP_Offset_y$eq_6.$$arity = 1);\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.getBoundingClientRect\"))) {\n            \n            Opal.defn(self, '$get', TMP_Offset_get_7 = function $$get() {\n              var self = this, doc = nil, root = nil, win = nil;\n\n              \n              doc = self.element.$document();\n              root = doc.$root().$to_n();\n              win = doc.$window().$to_n();\n              \n        var box = self[\"native\"].getBoundingClientRect(),\n            y   = box.top + (win.pageYOffset || root.scrollTop) - (root.clientTop || 0),\n            x   = box.left + (win.pageXOffset || root.scrollLeft) - (root.clientLeft || 0);\n      ;\n              return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'Position').$new(x, y);\n            }, TMP_Offset_get_7.$$arity = 0)\n            } else {\n            \n            Opal.defn(self, '$get', TMP_Offset_get_8 = function $$get() {\n              var self = this, doc = nil, root = nil, win = nil;\n\n              \n              doc = self.$document();\n              root = doc.$root().$to_n();\n              win = doc.$window().$to_n();\n              \n        var y = (win.pageYOffset || root.scrollTop) - (root.clientTop || 0),\n            x = (win.pageXOffset || root.scrollLeft) - (root.clientLeft || 0);\n      ;\n              return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'Position').$new(x, y);\n            }, TMP_Offset_get_8.$$arity = 0)\n          };\n          return (Opal.defn(self, '$set', TMP_Offset_set_9 = function $$set($a_rest) {\n            var $b, $c, self = this, value, position = nil, $writer = nil, offset = nil, top = nil, left = nil, x = nil, y = nil;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            value = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              value[$arg_idx - 0] = arguments[$arg_idx];\n            }\n            \n            position = self.element['$style!']()['$[]'](\"position\");\n            if (position['$=='](\"static\")) {\n              \n              $writer = [\"position\", \"relative\"];\n              $send(self.element.$style(), '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n            offset = self.$get();\n            top = self.element['$style!']()['$[]'](\"top\").$to_u();\n            left = self.element['$style!']()['$[]'](\"left\").$to_u();\n            if ($truthy(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'Position')['$==='](value.$first()))) {\n              $b = [value.$first().$x(), value.$first().$y()], (x = $b[0]), (y = $b[1]), $b\n            } else if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](value.$first()))) {\n              $b = [value.$first()['$[]'](\"x\"), value.$first()['$[]'](\"y\")], (x = $b[0]), (y = $b[1]), $b\n              } else {\n              $c = value, $b = Opal.to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c\n            };\n            if ($truthy(x)) {\n              \n              $writer = [\"left\", $rb_plus($rb_minus(x.$px(), offset.$x()), left)];\n              $send(self.element.$style(), '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n            if ($truthy(y)) {\n              \n              $writer = [\"top\", $rb_plus($rb_minus(y.$px(), offset.$y()), top)];\n              $send(self.element.$style(), '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];\n              } else {\n              return nil\n            };\n          }, TMP_Offset_set_9.$$arity = -1), nil) && 'set';\n        })($nesting[0], null, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element/scroll\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$attr_reader', '$to_n', '$supports?', '$===', '$first', '$[]', '$x', '$y', '$new', '$raise', '$position']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Scroll(){};\n          var self = $Scroll = $klass($base, $super, 'Scroll', $Scroll);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Scroll_initialize_1, TMP_Scroll_to_2, TMP_Scroll_position_3, TMP_Scroll_to_4, TMP_Scroll_position_5, TMP_Scroll_to_6, TMP_Scroll_position_7, TMP_Scroll_x_8, TMP_Scroll_y_9, TMP_Scroll_height_10, TMP_Scroll_width_11, TMP_Scroll_by_12, TMP_Scroll_to_13, TMP_Scroll_to_14, TMP_Scroll_to$B_15;\n\n          def[\"native\"] = nil;\n          \n          self.$attr_reader(\"element\");\n          \n          Opal.defn(self, '$initialize', TMP_Scroll_initialize_1 = function $$initialize(element) {\n            var self = this;\n\n            \n            self.element = element;\n            return (self[\"native\"] = element.$to_n());\n          }, TMP_Scroll_initialize_1.$$arity = 1);\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.scroll\"))) {\n            \n            \n            Opal.defn(self, '$to', TMP_Scroll_to_2 = function $$to($a_rest) {\n              var $b, $c, self = this, args, x = nil, y = nil;\n\n              var $args_len = arguments.length, $rest_len = $args_len - 0;\n              if ($rest_len < 0) { $rest_len = 0; }\n              args = new Array($rest_len);\n              for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n                args[$arg_idx - 0] = arguments[$arg_idx];\n              }\n              \n              if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](args.$first()))) {\n                \n                x = ($truthy($b = args.$first()['$[]'](\"x\")) ? $b : self.$x());\n                y = ($truthy($b = args.$first()['$[]'](\"y\")) ? $b : self.$y());\n                } else {\n                $c = args, $b = Opal.to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c\n              };\n              self[\"native\"].scrollTop  = y;\n              return self[\"native\"].scrollLeft = x;\n            }, TMP_Scroll_to_2.$$arity = -1);\n            \n            Opal.defn(self, '$position', TMP_Scroll_position_3 = function $$position() {\n              var self = this;\n\n              return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'Position').$new(self[\"native\"].scrollLeft, self[\"native\"].scrollTop)\n            }, TMP_Scroll_position_3.$$arity = 0);\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.pageOffset\"))) {\n            \n            \n            Opal.defn(self, '$to', TMP_Scroll_to_4 = function $$to($a_rest) {\n              var $b, $c, self = this, args, x = nil, y = nil;\n\n              var $args_len = arguments.length, $rest_len = $args_len - 0;\n              if ($rest_len < 0) { $rest_len = 0; }\n              args = new Array($rest_len);\n              for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n                args[$arg_idx - 0] = arguments[$arg_idx];\n              }\n              \n              if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](args.$first()))) {\n                \n                x = ($truthy($b = args.$first()['$[]'](\"x\")) ? $b : self.$x());\n                y = ($truthy($b = args.$first()['$[]'](\"y\")) ? $b : self.$y());\n                } else {\n                $c = args, $b = Opal.to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c\n              };\n              self[\"native\"].pageYOffset = y;\n              return self[\"native\"].pageXOffset = x;\n            }, TMP_Scroll_to_4.$$arity = -1);\n            \n            Opal.defn(self, '$position', TMP_Scroll_position_5 = function $$position() {\n              var self = this;\n\n              return Opal.const_get_relative($nesting, 'Position').$new(self[\"native\"].pageXOffset, self[\"native\"].pageYOffset)\n            }, TMP_Scroll_position_5.$$arity = 0);\n            } else {\n            \n            \n            Opal.defn(self, '$to', TMP_Scroll_to_6 = function $$to($a_rest) {\n              var self = this, args;\n\n              var $args_len = arguments.length, $rest_len = $args_len - 0;\n              if ($rest_len < 0) { $rest_len = 0; }\n              args = new Array($rest_len);\n              for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n                args[$arg_idx - 0] = arguments[$arg_idx];\n              }\n              return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"scroll on element unsupported\")\n            }, TMP_Scroll_to_6.$$arity = -1);\n            \n            Opal.defn(self, '$position', TMP_Scroll_position_7 = function $$position() {\n              var self = this;\n\n              return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"scroll on element unsupported\")\n            }, TMP_Scroll_position_7.$$arity = 0);\n          };\n          \n          Opal.defn(self, '$x', TMP_Scroll_x_8 = function $$x() {\n            var self = this;\n\n            return self.$position().$x()\n          }, TMP_Scroll_x_8.$$arity = 0);\n          \n          Opal.defn(self, '$y', TMP_Scroll_y_9 = function $$y() {\n            var self = this;\n\n            return self.$position().$y()\n          }, TMP_Scroll_y_9.$$arity = 0);\n          \n          Opal.defn(self, '$height', TMP_Scroll_height_10 = function $$height() {\n            var self = this;\n\n            return self[\"native\"].scrollHeight\n          }, TMP_Scroll_height_10.$$arity = 0);\n          \n          Opal.defn(self, '$width', TMP_Scroll_width_11 = function $$width() {\n            var self = this;\n\n            return self[\"native\"].scrollWidth\n          }, TMP_Scroll_width_11.$$arity = 0);\n          \n          Opal.defn(self, '$by', TMP_Scroll_by_12 = function $$by($a_rest) {\n            var $b, $c, self = this, args, x = nil, y = nil;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n            \n            if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](args.$first()))) {\n              \n              x = ($truthy($b = args.$first()['$[]'](\"x\")) ? $b : 0);\n              y = ($truthy($b = args.$first()['$[]'](\"y\")) ? $b : 0);\n              } else {\n              $c = args, $b = Opal.to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c\n            };\n            self[\"native\"].scrollBy(x, y);\n            return self;\n          }, TMP_Scroll_by_12.$$arity = -1);\n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.scrollIntoViewIfNeeded\"))) {\n            \n            Opal.defn(self, '$to', TMP_Scroll_to_13 = function $$to(align) {\n              var self = this;\n\n              if (align == null) {\n                align = true;\n              }\n              return self[\"native\"].scrollIntoViewIfNeeded(align)\n            }, TMP_Scroll_to_13.$$arity = -1)\n            } else {\n            \n            Opal.defn(self, '$to', TMP_Scroll_to_14 = function $$to(align) {\n              var self = this;\n\n              if (align == null) {\n                align = true;\n              }\n              return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n            }, TMP_Scroll_to_14.$$arity = -1)\n          };\n          return (Opal.defn(self, '$to!', TMP_Scroll_to$B_15 = function(align) {\n            var self = this;\n\n            if (align == null) {\n              align = true;\n            }\n            return self[\"native\"].scrollIntoView(align)\n          }, TMP_Scroll_to$B_15.$$arity = -1), nil) && 'to!';\n        })($nesting[0], null, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element/size\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$to_n', '$[]=', '$style', '$-']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Size(){};\n          var self = $Size = $klass($base, $super, 'Size', $Size);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Size_initialize_1, TMP_Size_width_2, TMP_Size_width$eq_3, TMP_Size_height_4, TMP_Size_height$eq_5;\n\n          def[\"native\"] = def.element = nil;\n          \n          self.$attr_reader(\"element\");\n          \n          Opal.defn(self, '$initialize', TMP_Size_initialize_1 = function $$initialize(element, $a_rest) {\n            var self = this, inc;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 1;\n            if ($rest_len < 0) { $rest_len = 0; }\n            inc = new Array($rest_len);\n            for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n              inc[$arg_idx - 1] = arguments[$arg_idx];\n            }\n            \n            self.element = element;\n            self[\"native\"] = element.$to_n();\n            return (self.include = inc);\n          }, TMP_Size_initialize_1.$$arity = -2);\n          \n          Opal.defn(self, '$width', TMP_Size_width_2 = function $$width() {\n            var self = this;\n\n            return self[\"native\"].offsetWidth\n          }, TMP_Size_width_2.$$arity = 0);\n          \n          Opal.defn(self, '$width=', TMP_Size_width$eq_3 = function(value) {\n            var self = this, $writer = nil;\n\n            \n            $writer = [\"width\", value];\n            $send(self.element.$style(), '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          }, TMP_Size_width$eq_3.$$arity = 1);\n          \n          Opal.defn(self, '$height', TMP_Size_height_4 = function $$height() {\n            var self = this;\n\n            return self[\"native\"].offsetHeight\n          }, TMP_Size_height_4.$$arity = 0);\n          return (Opal.defn(self, '$height=', TMP_Size_height$eq_5 = function(value) {\n            var self = this, $writer = nil;\n\n            \n            $writer = [\"height\", value];\n            $send(self.element.$style(), '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          }, TMP_Size_height$eq_5.$$arity = 1), nil) && 'height=';\n        })($nesting[0], null, $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element/input\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Input(){};\n          var self = $Input = $klass($base, $super, 'Input', $Input);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Input_value_1, TMP_Input_value$eq_2, TMP_Input_checked$q_3, TMP_Input_clear_4;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$value', TMP_Input_value_1 = function $$value() {\n            var self = this;\n\n            \n      if (self[\"native\"].value == \"\") {\n        return nil;\n      }\n      else {\n        return self[\"native\"].value;\n      }\n    \n          }, TMP_Input_value_1.$$arity = 0);\n          \n          Opal.defn(self, '$value=', TMP_Input_value$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].value = value\n          }, TMP_Input_value$eq_2.$$arity = 1);\n          \n          Opal.defn(self, '$checked?', TMP_Input_checked$q_3 = function() {\n            var self = this;\n\n            return self[\"native\"].checked\n          }, TMP_Input_checked$q_3.$$arity = 0);\n          return (Opal.defn(self, '$clear', TMP_Input_clear_4 = function $$clear() {\n            var self = this;\n\n            return self[\"native\"].value = ''\n          }, TMP_Input_clear_4.$$arity = 0), nil) && 'clear';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Element'), $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element/select\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$[]', '$new', '$DOM', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Select(){};\n          var self = $Select = $klass($base, $super, 'Select', $Select);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Select_value_1, TMP_Select_labels_2, TMP_Select_options_3, TMP_Select_option_4, TMP_Select_index_5;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$value', TMP_Select_value_1 = function $$value() {\n            var self = this;\n\n            \n      if (self[\"native\"].value == \"\") {\n        return nil;\n      }\n      else {\n        return self[\"native\"].value;\n      }\n    \n          }, TMP_Select_value_1.$$arity = 0);\n          \n          Opal.defn(self, '$labels', TMP_Select_labels_2 = function $$labels() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'NodeSet')['$[]'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array').$new(self[\"native\"].labels))\n          }, TMP_Select_labels_2.$$arity = 0);\n          \n          Opal.defn(self, '$options', TMP_Select_options_3 = function $$options() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'NodeSet')['$[]'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array').$new(self[\"native\"].options))\n          }, TMP_Select_options_3.$$arity = 0);\n          \n          Opal.defn(self, '$option', TMP_Select_option_4 = function $$option() {\n            var self = this;\n\n            return self.$DOM(self[\"native\"].options[self[\"native\"].selectedIndex])\n          }, TMP_Select_option_4.$$arity = 0);\n          \n          Opal.defn(self, '$index', TMP_Select_index_5 = function $$index() {\n            var self = this;\n\n            return self[\"native\"].selectedIndex\n          }, TMP_Select_index_5.$$arity = 0);\n          self.$alias_native(\"multiple?\", \"multiple\");\n          self.$alias_native(\"required?\", \"required\");\n          return self.$alias_native(\"length\");\n        })($nesting[0], Opal.const_get_relative($nesting, 'Element'), $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element/image\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        \n        (function($base, $super, $parent_nesting) {\n          function $Image(){};\n          var self = $Image = $klass($base, $super, 'Image', $Image);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Image_complete$q_1, TMP_Image_cross$q_2, TMP_Image_height_3, TMP_Image_width_4;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$complete?', TMP_Image_complete$q_1 = function() {\n            var self = this;\n\n            return self[\"native\"].complete\n          }, TMP_Image_complete$q_1.$$arity = 0);\n          \n          Opal.defn(self, '$cross?', TMP_Image_cross$q_2 = function() {\n            var self = this;\n\n            return self[\"native\"].crossOrigin\n          }, TMP_Image_cross$q_2.$$arity = 0);\n          \n          Opal.defn(self, '$height', TMP_Image_height_3 = function $$height() {\n            var self = this;\n\n            return self[\"native\"].naturalHeight\n          }, TMP_Image_height_3.$$arity = 0);\n          return (Opal.defn(self, '$width', TMP_Image_width_4 = function $$width() {\n            var self = this;\n\n            return self[\"native\"].naturalWidth\n          }, TMP_Image_width_4.$$arity = 0), nil) && 'width';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Element'), $nesting);\n        return Opal.const_set($nesting[0], 'Img', Opal.const_get_relative($nesting, 'Image'));\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element/template\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$DOM']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Template(){};\n          var self = $Template = $klass($base, $super, 'Template', $Template);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Template_content_1;\n\n          def[\"native\"] = nil;\n          return (Opal.defn(self, '$content', TMP_Template_content_1 = function $$content() {\n            var self = this;\n\n            return self.$DOM(self[\"native\"].content)\n          }, TMP_Template_content_1.$$arity = 0), nil) && 'content'\n        })($nesting[0], Opal.const_get_relative($nesting, 'Element'), $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element/textarea\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Textarea(){};\n          var self = $Textarea = $klass($base, $super, 'Textarea', $Textarea);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Textarea_value_1, TMP_Textarea_value$eq_2, TMP_Textarea_clear_3;\n\n          def[\"native\"] = nil;\n          \n          \n          Opal.defn(self, '$value', TMP_Textarea_value_1 = function $$value() {\n            var self = this;\n\n            \n      if (self[\"native\"].value == \"\") {\n        return nil;\n      }\n      else {\n        return self[\"native\"].value;\n      }\n    \n          }, TMP_Textarea_value_1.$$arity = 0);\n          \n          Opal.defn(self, '$value=', TMP_Textarea_value$eq_2 = function(value) {\n            var self = this;\n\n            return self[\"native\"].value = value\n          }, TMP_Textarea_value$eq_2.$$arity = 1);\n          return (Opal.defn(self, '$clear', TMP_Textarea_clear_3 = function $$clear() {\n            var self = this;\n\n            return self[\"native\"].value = ''\n          }, TMP_Textarea_clear_3.$$arity = 0), nil) && 'clear';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Element'), $nesting)\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/element\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$create_element', '$==', '$capitalize', '$include?', '$constants', '$new', '$const_get', '$include', '$target', '$DOM', '$supports?', '$loaded?', '$raise', '$[]', '$map', '$xpath', '$get', '$attributes', '$set', '$+', '$class_names', '$empty?', '$join', '$uniq', '$first', '$css', '$each', '$alias_native', '$reject', '$split', '$to_proc', '$===', '$assign', '$height', '$size', '$height=', '$-', '$to_s', '$clear', '$document', '$<<', '$to_a', '$downcase', '$name', '$id', '$offset', '$flatten', '$concat', '$replace', '$apply', '$to_n', '$window', '$width', '$width=']);\n  \n  self.$require(\"browser/dom/element/attributes\");\n  self.$require(\"browser/dom/element/data\");\n  self.$require(\"browser/dom/element/position\");\n  self.$require(\"browser/dom/element/offset\");\n  self.$require(\"browser/dom/element/scroll\");\n  self.$require(\"browser/dom/element/size\");\n  self.$require(\"browser/dom/element/input\");\n  self.$require(\"browser/dom/element/select\");\n  self.$require(\"browser/dom/element/image\");\n  self.$require(\"browser/dom/element/template\");\n  self.$require(\"browser/dom/element/textarea\");\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Element_create_1, TMP_Element_new_2, TMP_Element_3, TMP_Element_$eq$_4, TMP_Element_$eq$_5, TMP_Element_$eq$_6, TMP_Element_$eq$_7, TMP_Element_$eq$_8, TMP_Element_$eq$_9, TMP_Element_$eq$_10, TMP_Element_$_12, TMP_Element_$$_13, TMP_Element_$$$eq_14, TMP_Element_add_class_15, TMP_Element_at_16, TMP_Element_at_css_18, TMP_Element_at_xpath_20, TMP_Element_attributes_21, TMP_Element_attribute_nodes_22, TMP_Element_class_names_23, TMP_Element_css_24, TMP_Element_css_25, TMP_Element_css_26, TMP_Element_data_27, TMP_Element_height_28, TMP_Element_height$eq_29, TMP_Element_id_30, TMP_Element_id$eq_31, TMP_Element_inner_dom_32, TMP_Element_inner_dom$eq_33, TMP_Element_inspect_34, TMP_Element_offset_35, TMP_Element_offset$eq_36, TMP_Element_position_37, TMP_Element_scroll_38, TMP_Element_search_40, TMP_Element_style_41, TMP_Element_style$B_42, TMP_Element_style$B_43, TMP_Element_style$B_44, TMP_Element_remove_attribute_45, TMP_Element_remove_class_46, TMP_Element_size_47, TMP_Element_width_48, TMP_Element_width$eq_49, TMP_Element_window_50, $a, TMP_Element_xpath_51, TMP_Element_xpath_52;\n\n        def[\"native\"] = nil;\n        \n        Opal.defs(self, '$create', TMP_Element_create_1 = function $$create($a_rest) {\n          var self = this, args;\n          if ($gvars.document == null) $gvars.document = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return $send($gvars.document, 'create_element', Opal.to_a(args))\n        }, TMP_Element_create_1.$$arity = -1);\n        Opal.defs(self, '$new', TMP_Element_new_2 = function(node) {\n          var self = this, $iter = TMP_Element_new_2.$$p, $yield = $iter || nil, name = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_Element_new_2.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          if (self['$=='](Opal.const_get_relative($nesting, 'Element'))) {\n            \n            name = (node.nodeName).$capitalize();\n            if ($truthy(Opal.const_get_relative($nesting, 'Element').$constants()['$include?'](name))) {\n              return Opal.const_get_relative($nesting, 'Element').$const_get(name).$new(node)\n              } else {\n              return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_Element_new_2, false, $Element), $zuper, $iter)\n            };\n            } else {\n            return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_Element_new_2, false, $Element), $zuper, $iter)\n          }\n        }, TMP_Element_new_2.$$arity = 1);\n        self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Event'), 'Target'));\n        $send(self, 'target', [], (TMP_Element_3 = function(value){var self = TMP_Element_3.$$s || this;\nif (value == null) value = nil;\n        try {\n            return self.$DOM(value)\n          } catch ($err) {\n            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {\n              try {\n                return nil\n              } finally { Opal.pop_exception() }\n            } else { throw $err; }\n          }}, TMP_Element_3.$$s = self, TMP_Element_3.$$arity = 1, TMP_Element_3));\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.matches\"))) {\n          \n          Opal.defn(self, '$=~', TMP_Element_$eq$_4 = function(selector) {\n            var self = this;\n\n            return self[\"native\"].matches(selector)\n          }, TMP_Element_$eq$_4.$$arity = 1)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.matches (Opera)\"))) {\n          \n          Opal.defn(self, '$=~', TMP_Element_$eq$_5 = function(selector) {\n            var self = this;\n\n            return self[\"native\"].oMatchesSelector(selector)\n          }, TMP_Element_$eq$_5.$$arity = 1)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.matches (Internet Explorer)\"))) {\n          \n          Opal.defn(self, '$=~', TMP_Element_$eq$_6 = function(selector) {\n            var self = this;\n\n            return self[\"native\"].msMatchesSelector(selector)\n          }, TMP_Element_$eq$_6.$$arity = 1)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.matches (Firefox)\"))) {\n          \n          Opal.defn(self, '$=~', TMP_Element_$eq$_7 = function(selector) {\n            var self = this;\n\n            return self[\"native\"].mozMatchesSelector(selector)\n          }, TMP_Element_$eq$_7.$$arity = 1)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Element.matches (Chrome)\"))) {\n          \n          Opal.defn(self, '$=~', TMP_Element_$eq$_8 = function(selector) {\n            var self = this;\n\n            return self[\"native\"].webkitMatchesSelector(selector)\n          }, TMP_Element_$eq$_8.$$arity = 1)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$loaded?'](\"Sizzle\"))) {\n          \n          Opal.defn(self, '$=~', TMP_Element_$eq$_9 = function(selector) {\n            var self = this;\n\n            return Sizzle.matchesSelector(self[\"native\"], selector)\n          }, TMP_Element_$eq$_9.$$arity = 1)\n          } else {\n          \n          Opal.defn(self, '$=~', TMP_Element_$eq$_10 = function(selector) {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"selector matching unsupported\")\n          }, TMP_Element_$eq$_10.$$arity = 1)\n        };\n        \n        Opal.defn(self, '$/', TMP_Element_$_12 = function($a_rest) {\n          var TMP_11, self = this, paths;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          paths = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            paths[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return Opal.const_get_relative($nesting, 'NodeSet')['$[]']($send(paths, 'map', [], (TMP_11 = function(path){var self = TMP_11.$$s || this;\nif (path == null) path = nil;\n          return self.$xpath(path)}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11)))\n        }, TMP_Element_$_12.$$arity = -1);\n        \n        Opal.defn(self, '$[]', TMP_Element_$$_13 = function(name, options) {\n          var self = this;\n\n          if (options == null) {\n            options = $hash2([], {});\n          }\n          return self.$attributes().$get(name, options)\n        }, TMP_Element_$$_13.$$arity = -2);\n        \n        Opal.defn(self, '$[]=', TMP_Element_$$$eq_14 = function(name, value, options) {\n          var self = this;\n\n          if (options == null) {\n            options = $hash2([], {});\n          }\n          return self.$attributes().$set(name, value, options)\n        }, TMP_Element_$$$eq_14.$$arity = -3);\n        \n        Opal.defn(self, '$add_class', TMP_Element_add_class_15 = function $$add_class($a_rest) {\n          var self = this, names, classes = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          names = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            names[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          classes = $rb_plus(self.$class_names(), names);\n          if ($truthy(classes['$empty?']())) {\n            } else {\n            self[\"native\"].className = classes.$uniq().$join(\" \")\n          };\n          return self;\n        }, TMP_Element_add_class_15.$$arity = -1);\n        \n        Opal.defn(self, '$at', TMP_Element_at_16 = function $$at(path_or_selector) {\n          var $a, self = this;\n\n          return ($truthy($a = self.$xpath(path_or_selector).$first()) ? $a : self.$css(path_or_selector).$first())\n        }, TMP_Element_at_16.$$arity = 1);\n        \n        Opal.defn(self, '$at_css', TMP_Element_at_css_18 = function $$at_css($a_rest) {\n          var TMP_17, self = this, rules, result = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          rules = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            rules[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          result = nil;\n          (function(){var $brk = Opal.new_brk(); try {return $send(rules, 'each', [], (TMP_17 = function(rule){var self = TMP_17.$$s || this;\nif (rule == null) rule = nil;\n          if ($truthy((result = self.$css(rule).$first()))) {\n              \n              Opal.brk(nil, $brk)\n              } else {\n              return nil\n            }}, TMP_17.$$s = self, TMP_17.$$brk = $brk, TMP_17.$$arity = 1, TMP_17))\n          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();\n          return result;\n        }, TMP_Element_at_css_18.$$arity = -1);\n        \n        Opal.defn(self, '$at_xpath', TMP_Element_at_xpath_20 = function $$at_xpath($a_rest) {\n          var TMP_19, self = this, paths, result = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          paths = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            paths[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          result = nil;\n          (function(){var $brk = Opal.new_brk(); try {return $send(paths, 'each', [], (TMP_19 = function(path){var self = TMP_19.$$s || this;\nif (path == null) path = nil;\n          if ($truthy((result = self.$xpath(path).$first()))) {\n              \n              Opal.brk(nil, $brk)\n              } else {\n              return nil\n            }}, TMP_19.$$s = self, TMP_19.$$brk = $brk, TMP_19.$$arity = 1, TMP_19))\n          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();\n          return result;\n        }, TMP_Element_at_xpath_20.$$arity = -1);\n        Opal.alias(self, \"attr\", \"[]\");\n        Opal.alias(self, \"attribute\", \"[]\");\n        \n        Opal.defn(self, '$attributes', TMP_Element_attributes_21 = function $$attributes(options) {\n          var self = this;\n\n          if (options == null) {\n            options = $hash2([], {});\n          }\n          return Opal.const_get_relative($nesting, 'Attributes').$new(self, options)\n        }, TMP_Element_attributes_21.$$arity = -1);\n        \n        Opal.defn(self, '$attribute_nodes', TMP_Element_attribute_nodes_22 = function $$attribute_nodes() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'NodeSet')['$[]'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array').$new(self[\"native\"].attributes, $hash2([\"get\"], {\"get\": \"item\"})))\n        }, TMP_Element_attribute_nodes_22.$$arity = 0);\n        self.$alias_native(\"class_name\", \"className\");\n        \n        Opal.defn(self, '$class_names', TMP_Element_class_names_23 = function $$class_names() {\n          var self = this;\n\n          return $send((self[\"native\"].className).$split(/\\s+/), 'reject', [], \"empty?\".$to_proc())\n        }, TMP_Element_class_names_23.$$arity = 0);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Query.css\"))) {\n          \n          Opal.defn(self, '$css', TMP_Element_css_24 = function $$css(path) {\n            var self = this;\n\n            try {\n              return Opal.const_get_relative($nesting, 'NodeSet')['$[]'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array').$new(self[\"native\"].querySelectorAll(path)))\n            } catch ($err) {\n              if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {\n                try {\n                  return Opal.const_get_relative($nesting, 'NodeSet')['$[]']()\n                } finally { Opal.pop_exception() }\n              } else { throw $err; }\n            }\n          }, TMP_Element_css_24.$$arity = 1)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$loaded?'](\"Sizzle\"))) {\n          \n          Opal.defn(self, '$css', TMP_Element_css_25 = function $$css(path) {\n            var self = this;\n\n            try {\n              return Opal.const_get_relative($nesting, 'NodeSet')['$[]'](Sizzle(path, self[\"native\"]))\n            } catch ($err) {\n              if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {\n                try {\n                  return Opal.const_get_relative($nesting, 'NodeSet')['$[]']()\n                } finally { Opal.pop_exception() }\n              } else { throw $err; }\n            }\n          }, TMP_Element_css_25.$$arity = 1)\n          } else {\n          \n          Opal.defn(self, '$css', TMP_Element_css_26 = function $$css(selector) {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"query by CSS selector unsupported\")\n          }, TMP_Element_css_26.$$arity = 1)\n        };\n        \n        Opal.defn(self, '$data', TMP_Element_data_27 = function $$data(value) {\n          var self = this, data = nil;\n\n          if (value == null) {\n            value = nil;\n          }\n          \n          data = Opal.const_get_relative($nesting, 'Data').$new(self);\n          if ($truthy(value)) {\n            } else {\n            return data\n          };\n          if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](value))) {\n            data.$assign(value)\n            } else {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"unknown data type\")\n          };\n          return self;\n        }, TMP_Element_data_27.$$arity = -1);\n        Opal.alias(self, \"get_attribute\", \"[]\");\n        Opal.alias(self, \"get\", \"[]\");\n        \n        Opal.defn(self, '$height', TMP_Element_height_28 = function $$height() {\n          var self = this;\n\n          return self.$size().$height()\n        }, TMP_Element_height_28.$$arity = 0);\n        \n        Opal.defn(self, '$height=', TMP_Element_height$eq_29 = function(value) {\n          var self = this, $writer = nil;\n\n          \n          $writer = [value];\n          $send(self.$size(), 'height=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        }, TMP_Element_height$eq_29.$$arity = 1);\n        \n        Opal.defn(self, '$id', TMP_Element_id_30 = function $$id() {\n          var self = this;\n\n          \n      var id = self[\"native\"].id;\n\n      if (id === \"\") {\n        return nil;\n      }\n      else {\n        return id;\n      }\n    \n        }, TMP_Element_id_30.$$arity = 0);\n        \n        Opal.defn(self, '$id=', TMP_Element_id$eq_31 = function(value) {\n          var self = this;\n\n          return self[\"native\"].id = value.$to_s()\n        }, TMP_Element_id$eq_31.$$arity = 1);\n        \n        Opal.defn(self, '$inner_dom', TMP_Element_inner_dom_32 = function $$inner_dom() {\n          var self = this, $iter = TMP_Element_inner_dom_32.$$p, block = $iter || nil, doc = nil;\n\n          if ($iter) TMP_Element_inner_dom_32.$$p = null;\n          \n          self.$clear();\n          doc = self.$document();\n          return self['$<<']($send(Opal.const_get_relative($nesting, 'Builder'), 'new', [doc, self], block.$to_proc()).$to_a());\n        }, TMP_Element_inner_dom_32.$$arity = 0);\n        \n        Opal.defn(self, '$inner_dom=', TMP_Element_inner_dom$eq_33 = function(node) {\n          var self = this;\n\n          \n          self.$clear();\n          return self['$<<'](node);\n        }, TMP_Element_inner_dom$eq_33.$$arity = 1);\n        \n        Opal.defn(self, '$inspect', TMP_Element_inspect_34 = function $$inspect() {\n          var self = this, inspect = nil;\n\n          \n          inspect = self.$name().$downcase();\n          if ($truthy(self.$id())) {\n            inspect = $rb_plus(inspect, $rb_plus($rb_plus(\".\", self.$id()), \"!\"))};\n          if ($truthy(self.$class_names()['$empty?']())) {\n            } else {\n            inspect = $rb_plus(inspect, $rb_plus(\".\", self.$class_names().$join(\".\")))\n          };\n          return \"\" + \"#<DOM::Element: \" + (inspect) + \">\";\n        }, TMP_Element_inspect_34.$$arity = 0);\n        \n        Opal.defn(self, '$offset', TMP_Element_offset_35 = function $$offset($a_rest) {\n          var self = this, values, off = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          values = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            values[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          off = Opal.const_get_relative($nesting, 'Offset').$new(self);\n          if ($truthy(values['$empty?']())) {\n            } else {\n            $send(off, 'set', Opal.to_a(values))\n          };\n          return off;\n        }, TMP_Element_offset_35.$$arity = -1);\n        \n        Opal.defn(self, '$offset=', TMP_Element_offset$eq_36 = function(value) {\n          var self = this;\n\n          return $send(self.$offset(), 'set', Opal.to_a(value))\n        }, TMP_Element_offset$eq_36.$$arity = 1);\n        \n        Opal.defn(self, '$position', TMP_Element_position_37 = function $$position() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Position').$new(self)\n        }, TMP_Element_position_37.$$arity = 0);\n        \n        Opal.defn(self, '$scroll', TMP_Element_scroll_38 = function $$scroll() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Scroll').$new(self)\n        }, TMP_Element_scroll_38.$$arity = 0);\n        \n        Opal.defn(self, '$search', TMP_Element_search_40 = function $$search($a_rest) {\n          var TMP_39, self = this, selectors;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          selectors = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            selectors[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return Opal.const_get_relative($nesting, 'NodeSet').$new($send(selectors, 'map', [], (TMP_39 = function(selector){var self = TMP_39.$$s || this;\nif (selector == null) selector = nil;\n          return self.$xpath(selector).$to_a().$concat(self.$css(selector).$to_a())}, TMP_39.$$s = self, TMP_39.$$arity = 1, TMP_39)).$flatten().$uniq())\n        }, TMP_Element_search_40.$$arity = -1);\n        Opal.alias(self, \"set\", \"[]=\");\n        Opal.alias(self, \"set_attribute\", \"[]=\");\n        \n        Opal.defn(self, '$style', TMP_Element_style_41 = function $$style(data) {\n          var $a, self = this, $iter = TMP_Element_style_41.$$p, block = $iter || nil, style = nil;\n\n          if (data == null) {\n            data = nil;\n          }\n          if ($iter) TMP_Element_style_41.$$p = null;\n          \n          style = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'CSS'), 'Declaration').$new(self[\"native\"].style);\n          if ($truthy(($truthy($a = data) ? $a : block))) {\n            } else {\n            return style\n          };\n          if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](data))) {\n            style.$replace(data)\n          } else if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](data))) {\n            style.$assign(data)\n          } else if ($truthy(block)) {\n            $send(style, 'apply', [], block.$to_proc())\n            } else {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"unknown data type\")\n          };\n          return self;\n        }, TMP_Element_style_41.$$arity = -1);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"CSS.computed\"))) {\n          \n          Opal.defn(self, '$style!', TMP_Element_style$B_42 = function() {\n            var self = this;\n\n            return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'CSS'), 'Declaration').$new(self.$window().$to_n().getComputedStyle(self[\"native\"], null))\n          }, TMP_Element_style$B_42.$$arity = 0)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"CSS.current\"))) {\n          \n          Opal.defn(self, '$style!', TMP_Element_style$B_43 = function() {\n            var self = this;\n\n            return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'CSS'), 'Declaration').$new(self[\"native\"].currentStyle)\n          }, TMP_Element_style$B_43.$$arity = 0)\n          } else {\n          \n          Opal.defn(self, '$style!', TMP_Element_style$B_44 = function() {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"computed style unsupported\")\n          }, TMP_Element_style$B_44.$$arity = 0)\n        };\n        \n        Opal.defn(self, '$remove_attribute', TMP_Element_remove_attribute_45 = function $$remove_attribute(name) {\n          var self = this;\n\n          return self[\"native\"].removeAttribute(name)\n        }, TMP_Element_remove_attribute_45.$$arity = 1);\n        \n        Opal.defn(self, '$remove_class', TMP_Element_remove_class_46 = function $$remove_class($a_rest) {\n          var self = this, names, classes = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          names = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            names[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          classes = $rb_minus(self.$class_names(), names);\n          if ($truthy(classes['$empty?']())) {\n            self[\"native\"].removeAttribute('class')\n            } else {\n            self[\"native\"].className = classes.$join(\" \")\n          };\n          return self;\n        }, TMP_Element_remove_class_46.$$arity = -1);\n        \n        Opal.defn(self, '$size', TMP_Element_size_47 = function $$size($a_rest) {\n          var self = this, inc;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          inc = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            inc[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return $send(Opal.const_get_relative($nesting, 'Size'), 'new', [self].concat(Opal.to_a(inc)))\n        }, TMP_Element_size_47.$$arity = -1);\n        \n        Opal.defn(self, '$width', TMP_Element_width_48 = function $$width() {\n          var self = this;\n\n          return self.$size().$width()\n        }, TMP_Element_width_48.$$arity = 0);\n        \n        Opal.defn(self, '$width=', TMP_Element_width$eq_49 = function(value) {\n          var self = this, $writer = nil;\n\n          \n          $writer = [value];\n          $send(self.$size(), 'width=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        }, TMP_Element_width$eq_49.$$arity = 1);\n        \n        Opal.defn(self, '$window', TMP_Element_window_50 = function $$window() {\n          var self = this;\n\n          return self.$document().$window()\n        }, TMP_Element_window_50.$$arity = 0);\n        if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Query.xpath\")) ? $a : Opal.const_get_relative($nesting, 'Browser')['$loaded?'](\"wicked-good-xpath\")))) {\n          \n          if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$loaded?'](\"wicked-good-xpath\"))) {\n            wgxpath.install()};\n          return (Opal.defn(self, '$xpath', TMP_Element_xpath_51 = function $$xpath(path) {\n            var self = this;\n\n            try {\n              return Opal.const_get_relative($nesting, 'NodeSet')['$[]'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array').$new((self[\"native\"].ownerDocument || self[\"native\"]).evaluate(path,\n           self[\"native\"], null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null), $hash2([\"get\", \"length\"], {\"get\": \"snapshotItem\", \"length\": \"snapshotLength\"})))\n            } catch ($err) {\n              if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {\n                try {\n                  return Opal.const_get_relative($nesting, 'NodeSet')['$[]']()\n                } finally { Opal.pop_exception() }\n              } else { throw $err; }\n            }\n          }, TMP_Element_xpath_51.$$arity = 1), nil) && 'xpath';\n          } else {\n          return (Opal.defn(self, '$xpath', TMP_Element_xpath_52 = function $$xpath(path) {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"query by XPath unsupported\")\n          }, TMP_Element_xpath_52.$$arity = 1), nil) && 'xpath'\n        };\n      })($nesting[0], Opal.const_get_relative($nesting, 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/document\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$DOM', '$first', '$css', '$xpath', '$[]', '$supports?', '$raise', '$ready?', '$call', '$on', '$off', '$convert', '$new']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Document(){};\n        var self = $Document = $klass($base, $super, 'Document', $Document);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Document_$$_1, TMP_Document_body_2, TMP_Document_create_element_3, TMP_Document_create_text_4, TMP_Document_document_5, TMP_Document_head_6, TMP_Document_inspect_7, TMP_Document_ready_8, TMP_Document_ready_10, TMP_Document_ready_12, TMP_Document_ready$q_13, TMP_Document_root_14, TMP_Document_root$eq_15, TMP_Document_style_sheets_17, TMP_Document_title_18, TMP_Document_title$eq_19, TMP_Document_window_20, TMP_Document_window_21, TMP_Document_window_22;\n\n        def[\"native\"] = nil;\n        \n        \n        Opal.defn(self, '$[]', TMP_Document_$$_1 = function(what) {\n          var $a, self = this;\n\n          \n          \n      var result = self[\"native\"].getElementById(what);\n\n      if (result) {\n        return self.$DOM(result);\n      }\n    ;\n          return ($truthy($a = self.$css(what).$first()) ? $a : self.$xpath(what).$first());\n        }, TMP_Document_$$_1.$$arity = 1);\n        Opal.alias(self, \"at\", \"[]\");\n        \n        Opal.defn(self, '$body', TMP_Document_body_2 = function $$body() {\n          var self = this;\n\n          return self.$DOM(self[\"native\"].body)\n        }, TMP_Document_body_2.$$arity = 0);\n        \n        Opal.defn(self, '$create_element', TMP_Document_create_element_3 = function $$create_element(name, options) {\n          var self = this, ns = nil;\n\n          if (options == null) {\n            options = $hash2([], {});\n          }\n          if ($truthy((ns = options['$[]'](\"namespace\")))) {\n            return self.$DOM(self[\"native\"].createElementNS(ns, name))\n            } else {\n            return self.$DOM(self[\"native\"].createElement(name))\n          }\n        }, TMP_Document_create_element_3.$$arity = -2);\n        \n        Opal.defn(self, '$create_text', TMP_Document_create_text_4 = function $$create_text(content) {\n          var self = this;\n\n          return self.$DOM(self[\"native\"].createTextNode(content))\n        }, TMP_Document_create_text_4.$$arity = 1);\n        \n        Opal.defn(self, '$document', TMP_Document_document_5 = function $$document() {\n          var self = this;\n\n          return self\n        }, TMP_Document_document_5.$$arity = 0);\n        \n        Opal.defn(self, '$head', TMP_Document_head_6 = function $$head() {\n          var self = this;\n\n          return self.$DOM(self[\"native\"].getElementsByTagName(\"head\")[0])\n        }, TMP_Document_head_6.$$arity = 0);\n        \n        Opal.defn(self, '$inspect', TMP_Document_inspect_7 = function $$inspect() {\n          var self = this;\n\n          return \"#<DOM::Document>\"\n        }, TMP_Document_inspect_7.$$arity = 0);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.addListener\"))) {\n          \n          Opal.defn(self, '$ready', TMP_Document_ready_8 = function $$ready() {\n            var TMP_9, self = this, $iter = TMP_Document_ready_8.$$p, block = $iter || nil;\n\n            if ($iter) TMP_Document_ready_8.$$p = null;\n            \n            if ($truthy(block)) {\n              } else {\n              self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"no block given\")\n            };\n            if ($truthy(self['$ready?']())) {\n              return block.$call()};\n            return $send(self, 'on', [\"dom:load\"], (TMP_9 = function(e){var self = TMP_9.$$s || this;\nif (e == null) e = nil;\n            \n              e.$off();\n              return block.$call();}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9));\n          }, TMP_Document_ready_8.$$arity = 0)\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Event.attach\"))) {\n          \n          Opal.defn(self, '$ready', TMP_Document_ready_10 = function $$ready() {\n            var TMP_11, self = this, $iter = TMP_Document_ready_10.$$p, block = $iter || nil;\n\n            if ($iter) TMP_Document_ready_10.$$p = null;\n            \n            if ($truthy(block)) {\n              } else {\n              self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"no block given\")\n            };\n            if ($truthy(self['$ready?']())) {\n              return block.$call()};\n            return $send(self, 'on', [\"ready:state:change\"], (TMP_11 = function(e){var self = TMP_11.$$s || this;\nif (e == null) e = nil;\n            if ($truthy(self['$ready?']())) {\n                \n                e.$off();\n                return block.$call();\n                } else {\n                return nil\n              }}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11));\n          }, TMP_Document_ready_10.$$arity = 0)\n          } else {\n          \n          Opal.defn(self, '$ready', TMP_Document_ready_12 = function $$ready() {\n            var self = this, $iter = TMP_Document_ready_12.$$p, block = $iter || nil;\n\n            if ($iter) TMP_Document_ready_12.$$p = null;\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"document ready unsupported\")\n          }, TMP_Document_ready_12.$$arity = 0)\n        };\n        \n        Opal.defn(self, '$ready?', TMP_Document_ready$q_13 = function() {\n          var self = this;\n\n          return self[\"native\"].readyState === \"complete\"\n        }, TMP_Document_ready$q_13.$$arity = 0);\n        \n        Opal.defn(self, '$root', TMP_Document_root_14 = function $$root() {\n          var self = this;\n\n          return self.$DOM(self[\"native\"].documentElement)\n        }, TMP_Document_root_14.$$arity = 0);\n        \n        Opal.defn(self, '$root=', TMP_Document_root$eq_15 = function(element) {\n          var self = this;\n\n          return self[\"native\"].documentElement = Opal.const_get_relative($nesting, 'Native').$convert(element)\n        }, TMP_Document_root$eq_15.$$arity = 1);\n        \n        Opal.defn(self, '$style_sheets', TMP_Document_style_sheets_17 = function $$style_sheets() {\n          var TMP_16, self = this;\n\n          return $send(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array'), 'new', [self[\"native\"].styleSheets], (TMP_16 = function(e){var self = TMP_16.$$s || this;\nif (e == null) e = nil;\n          return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'CSS'), 'StyleSheet').$new(e)}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16))\n        }, TMP_Document_style_sheets_17.$$arity = 0);\n        \n        Opal.defn(self, '$title', TMP_Document_title_18 = function $$title() {\n          var self = this;\n\n          return self[\"native\"].title\n        }, TMP_Document_title_18.$$arity = 0);\n        \n        Opal.defn(self, '$title=', TMP_Document_title$eq_19 = function(value) {\n          var self = this;\n\n          return self[\"native\"].title = value\n        }, TMP_Document_title$eq_19.$$arity = 1);\n        if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Document.view\"))) {\n          return (Opal.defn(self, '$window', TMP_Document_window_20 = function $$window() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Window').$new(self[\"native\"].defaultView)\n          }, TMP_Document_window_20.$$arity = 0), nil) && 'window'\n        } else if ($truthy(Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"Document.window\"))) {\n          return (Opal.defn(self, '$window', TMP_Document_window_21 = function $$window() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Window').$new(self[\"native\"].parentWindow)\n          }, TMP_Document_window_21.$$arity = 0), nil) && 'window'\n          } else {\n          return (Opal.defn(self, '$window', TMP_Document_window_22 = function $$window() {\n            var self = this;\n\n            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"window from document unsupported\")\n          }, TMP_Document_window_22.$$arity = 0), nil) && 'window'\n        };\n      })($nesting[0], Opal.const_get_relative($nesting, 'Element'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/document_fragment\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $DocumentFragment(){};\n        var self = $DocumentFragment = $klass($base, $super, 'DocumentFragment', $DocumentFragment);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return nil\n      })($nesting[0], Opal.const_get_relative($nesting, 'Element'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/builder\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$<<', '$[]=', '$to_h', '$-', '$[]', '$each', '$===', '$call', '$raise', '$attr_reader', '$new', '$to_proc', '$map', '$build', '$for', '$create_text', '$document', '$create_element', '$merge!', '$attributes', '$add_class', '$on', '$inner_html=']);\n  \n  (function($base, $parent_nesting) {\n    var $Utils, self = $Utils = $module($base, 'Utils');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Utils_heredoc_1;\n\n    Opal.defs(self, '$heredoc', TMP_Utils_heredoc_1 = function $$heredoc(string) {\n      var self = this;\n\n      return string\n    }, TMP_Utils_heredoc_1.$$arity = 1)\n  })(Opal.const_get_relative($nesting, 'Paggio'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Element(){};\n    var self = $Element = $klass($base, $super, 'Element', $Element);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Element_on_2;\n\n    def.on = nil;\n    return (Opal.defn(self, '$on', TMP_Element_on_2 = function $$on($a_rest) {\n      var $b, self = this, args, $iter = TMP_Element_on_2.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Element_on_2.$$p = null;\n      return (self.on = ($truthy($b = self.on) ? $b : []))['$<<']([args, block])\n    }, TMP_Element_on_2.$$arity = -1), nil) && 'on'\n  })(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Paggio'), 'HTML'), Opal.const_get_relative($nesting, 'BasicObject'), $nesting);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DOM_10, TMP_DOM_11, TMP_DOM_15;\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $Builder(){};\n        var self = $Builder = $klass($base, $super, 'Builder', $Builder);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Builder_to_h_3, TMP_Builder_for_4, TMP_Builder_build_6, TMP_Builder_initialize_7, TMP_Builder_to_a_9;\n\n        def.builder = def.roots = nil;\n        \n        Opal.defs(self, '$to_h', TMP_Builder_to_h_3 = function $$to_h() {\n          var $a, self = this;\n          if (self.builders == null) self.builders = nil;\n\n          return (self.builders = ($truthy($a = self.builders) ? $a : $hash2([], {})))\n        }, TMP_Builder_to_h_3.$$arity = 0);\n        Opal.defs(self, '$for', TMP_Builder_for_4 = function(klass) {\n          var self = this, $iter = TMP_Builder_for_4.$$p, block = $iter || nil, $writer = nil;\n\n          if ($iter) TMP_Builder_for_4.$$p = null;\n          if ($truthy(block)) {\n            \n            $writer = [klass, block];\n            $send(self.$to_h(), '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n            } else {\n            return self.$to_h()['$[]'](klass)\n          }\n        }, TMP_Builder_for_4.$$arity = 1);\n        Opal.defs(self, '$build', TMP_Builder_build_6 = function $$build(builder, item) {try {\n\n          var TMP_5, self = this;\n\n          \n          $send(self.$to_h(), 'each', [], (TMP_5 = function(klass, block){var self = TMP_5.$$s || this;\nif (klass == null) klass = nil;if (block == null) block = nil;\n          if ($truthy(klass['$==='](item))) {\n              Opal.ret(block.$call(builder, item))\n              } else {\n              return nil\n            }}, TMP_5.$$s = self, TMP_5.$$arity = 2, TMP_5));\n          return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"cannot build unknown item \" + (item));\n          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n        }, TMP_Builder_build_6.$$arity = 2);\n        self.$attr_reader(\"document\", \"element\");\n        \n        Opal.defn(self, '$initialize', TMP_Builder_initialize_7 = function $$initialize(document) {\n          var TMP_8, self = this, $iter = TMP_Builder_initialize_7.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Builder_initialize_7.$$p = null;\n          \n          self.document = document;\n          self.builder = $send(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Paggio'), 'HTML'), 'new', [], block.$to_proc());\n          return (self.roots = $send(self.builder.$each(), 'map', [], (TMP_8 = function(e){var self = TMP_8.$$s || this;\nif (e == null) e = nil;\n          return Opal.const_get_relative($nesting, 'Builder').$build(self, e)}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8)));\n        }, TMP_Builder_initialize_7.$$arity = 1);\n        return (Opal.defn(self, '$to_a', TMP_Builder_to_a_9 = function $$to_a() {\n          var self = this;\n\n          return self.roots\n        }, TMP_Builder_to_a_9.$$arity = 0), nil) && 'to_a';\n      })($nesting[0], null, $nesting);\n      $send(Opal.const_get_relative($nesting, 'Builder'), 'for', [Opal.const_get_relative($nesting, 'String')], (TMP_DOM_10 = function(b, item){var self = TMP_DOM_10.$$s || this;\nif (b == null) b = nil;if (item == null) item = nil;\n      return b.$document().$create_text(item)}, TMP_DOM_10.$$s = self, TMP_DOM_10.$$arity = 2, TMP_DOM_10));\n      $send(Opal.const_get_relative($nesting, 'Builder'), 'for', [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Paggio'), 'HTML'), 'Element')], (TMP_DOM_11 = function(b, item){var self = TMP_DOM_11.$$s || this, TMP_12, TMP_13, TMP_14, dom = nil, on = nil, inner = nil, $writer = nil;\nif (b == null) b = nil;if (item == null) item = nil;\n      \n        dom = b.$document().$create_element(item.name);\n        if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](item.attributes))) {\n          dom.$attributes()['$merge!'](item.attributes)};\n        $send((item.class_names), 'each', [], (TMP_12 = function(value){var self = TMP_12.$$s || this;\nif (value == null) value = nil;\n        return dom.$add_class(value)}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));\n        if ($truthy((on = item.on || nil))) {\n          $send(on, 'each', [], (TMP_13 = function(args, block){var self = TMP_13.$$s || this;\nif (args == null) args = nil;if (block == null) block = nil;\n          return $send(dom, 'on', Opal.to_a(args), block.$to_proc())}, TMP_13.$$s = self, TMP_13.$$arity = 2, TMP_13))};\n        if ($truthy((inner = item.inner_html || nil))) {\n          \n          $writer = [inner];\n          $send(dom, 'inner_html=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n          $send(item, 'each', [], (TMP_14 = function(child){var self = TMP_14.$$s || this;\nif (child == null) child = nil;\n          return dom['$<<'](Opal.const_get_relative($nesting, 'Builder').$build(b, child))}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14))\n        };\n        return dom;}, TMP_DOM_11.$$s = self, TMP_DOM_11.$$arity = 2, TMP_DOM_11));\n      $send(Opal.const_get_relative($nesting, 'Builder'), 'for', [Opal.const_get_qualified(Opal.const_get_relative($nesting, 'DOM'), 'Node')], (TMP_DOM_15 = function(b, item){var self = TMP_DOM_15.$$s || this;\nif (b == null) b = nil;if (item == null) item = nil;\n      return item}, TMP_DOM_15.$$s = self, TMP_DOM_15.$$arity = 2, TMP_DOM_15));\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom/mutation_observer\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$supports?', '$include', '$===', '$==', '$type', '$new', '$[]', '$DOM', '$alias_native', '$call', '$map', '$convert', '$private', '$Native', '$[]=', '$-', '$to_n']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $MutationObserver(){};\n        var self = $MutationObserver = $klass($base, $super, 'MutationObserver', $MutationObserver);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MutationObserver_supported$q_1, TMP_MutationObserver_initialize_9, TMP_MutationObserver_observe_11, TMP_MutationObserver_take_13, TMP_MutationObserver_disconnect_14, TMP_MutationObserver_convert_15;\n\n        def[\"native\"] = nil;\n        \n        Opal.defs(self, '$supported?', TMP_MutationObserver_supported$q_1 = function() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Browser')['$supports?'](\"MutationObserver\")\n        }, TMP_MutationObserver_supported$q_1.$$arity = 0);\n        self.$include(Opal.const_get_relative($nesting, 'Native'));\n        (function($base, $super, $parent_nesting) {\n          function $Record(){};\n          var self = $Record = $klass($base, $super, 'Record', $Record);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Record_type_2, TMP_Record_attribute$q_3, TMP_Record_tree$q_4, TMP_Record_cdata$q_5, TMP_Record_added_6, TMP_Record_removed_7, TMP_Record_target_8;\n\n          def[\"native\"] = nil;\n          \n          self.$include(Opal.const_get_relative($nesting, 'Native'));\n          \n          Opal.defn(self, '$type', TMP_Record_type_2 = function $$type() {\n            var self = this, $case = nil;\n\n            return (function() {$case = self[\"native\"].type;\n            if (\"attributes\"['$===']($case)) {return \"attribute\"}\n            else if (\"childList\"['$===']($case)) {return \"tree\"}\n            else if (\"characterData\"['$===']($case)) {return \"cdata\"}\n            else { return nil }})()\n          }, TMP_Record_type_2.$$arity = 0);\n          \n          Opal.defn(self, '$attribute?', TMP_Record_attribute$q_3 = function() {\n            var self = this;\n\n            return self.$type()['$=='](\"attribute\")\n          }, TMP_Record_attribute$q_3.$$arity = 0);\n          \n          Opal.defn(self, '$tree?', TMP_Record_tree$q_4 = function() {\n            var self = this;\n\n            return self.$type()['$=='](\"tree\")\n          }, TMP_Record_tree$q_4.$$arity = 0);\n          \n          Opal.defn(self, '$cdata?', TMP_Record_cdata$q_5 = function() {\n            var self = this;\n\n            return self.$type()['$=='](\"cdata\")\n          }, TMP_Record_cdata$q_5.$$arity = 0);\n          \n          Opal.defn(self, '$added', TMP_Record_added_6 = function $$added() {\n            var self = this, array = nil;\n\n            \n            array = (function() {if ($truthy(self[\"native\"].addedNodes != null)) {\n              return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array').$new(self[\"native\"].addedNodes)\n              } else {\n              return []\n            }; return nil; })();\n            return Opal.const_get_relative($nesting, 'NodeSet')['$[]'](array);\n          }, TMP_Record_added_6.$$arity = 0);\n          \n          Opal.defn(self, '$removed', TMP_Record_removed_7 = function $$removed() {\n            var self = this, array = nil;\n\n            \n            array = (function() {if ($truthy(self[\"native\"].removedNodes != null)) {\n              return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array').$new(self[\"native\"].removedNodes)\n              } else {\n              return []\n            }; return nil; })();\n            return Opal.const_get_relative($nesting, 'NodeSet')['$[]'](array);\n          }, TMP_Record_removed_7.$$arity = 0);\n          \n          Opal.defn(self, '$target', TMP_Record_target_8 = function $$target() {\n            var self = this;\n\n            return self.$DOM(self[\"native\"].target)\n          }, TMP_Record_target_8.$$arity = 0);\n          self.$alias_native(\"old\", \"oldValue\");\n          self.$alias_native(\"name\", \"attributeName\");\n          return self.$alias_native(\"namespace\", \"attributeNamespace\");\n        })($nesting[0], null, $nesting);\n        \n        Opal.defn(self, '$initialize', TMP_MutationObserver_initialize_9 = function $$initialize() {\n          var TMP_10, self = this, $iter = TMP_MutationObserver_initialize_9.$$p, block = $iter || nil;\n\n          if ($iter) TMP_MutationObserver_initialize_9.$$p = null;\n          \n          \n      var func = function(records) {\n        return block.$call($send((records), 'map', [], (TMP_10 = function(r){var self = TMP_10.$$s || this;\nif (r == null) r = nil;\n          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'DOM'), 'MutationObserver'), 'Record').$new(r)}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10)));\n      }\n    ;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_MutationObserver_initialize_9, false), [new window.MutationObserver(func)], null);\n        }, TMP_MutationObserver_initialize_9.$$arity = 0);\n        \n        Opal.defn(self, '$observe', TMP_MutationObserver_observe_11 = function $$observe(target, options) {\n          var self = this;\n\n          if (options == null) {\n            options = nil;\n          }\n          \n          if ($truthy(options)) {\n            } else {\n            options = $hash2([\"children\", \"tree\", \"attributes\", \"cdata\"], {\"children\": true, \"tree\": true, \"attributes\": \"old\", \"cdata\": \"old\"})\n          };\n          self[\"native\"].observe(Opal.const_get_relative($nesting, 'Native').$convert(target), self.$convert(options));\n          return self;\n        }, TMP_MutationObserver_observe_11.$$arity = -2);\n        \n        Opal.defn(self, '$take', TMP_MutationObserver_take_13 = function $$take() {\n          var TMP_12, self = this;\n\n          return $send((self[\"native\"].takeRecords()), 'map', [], (TMP_12 = function(r){var self = TMP_12.$$s || this;\nif (r == null) r = nil;\n          return Opal.const_get_relative($nesting, 'Record').$new(r)}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12))\n        }, TMP_MutationObserver_take_13.$$arity = 0);\n        \n        Opal.defn(self, '$disconnect', TMP_MutationObserver_disconnect_14 = function $$disconnect() {\n          var self = this;\n\n          return self[\"native\"].disconnect()\n        }, TMP_MutationObserver_disconnect_14.$$arity = 0);\n        self.$private();\n        return (Opal.defn(self, '$convert', TMP_MutationObserver_convert_15 = function $$convert(hash) {\n          var self = this, options = nil, $writer = nil, attrs = nil, filter = nil, cdata = nil;\n\n          \n          options = self.$Native({});\n          if ($truthy(hash['$[]'](\"children\"))) {\n            \n            $writer = [\"childList\", true];\n            $send(options, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          if ($truthy(hash['$[]'](\"tree\"))) {\n            \n            $writer = [\"subtree\", true];\n            $send(options, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          if ($truthy((attrs = hash['$[]'](\"attributes\")))) {\n            \n            \n            $writer = [\"attributes\", true];\n            $send(options, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            if (attrs['$=='](\"old\")) {\n              \n              $writer = [\"attributeOldValue\", true];\n              $send(options, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};};\n          if ($truthy((filter = hash['$[]'](\"filter\")))) {\n            \n            $writer = [\"attributeFilter\", filter];\n            $send(options, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          if ($truthy((cdata = hash['$[]'](\"cdata\")))) {\n            \n            \n            $writer = [\"characterData\", true];\n            $send(options, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            if (cdata['$=='](\"old\")) {\n              \n              $writer = [\"characterDataOldValue\", true];\n              $send(options, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};};\n          return options.$to_n();\n        }, TMP_MutationObserver_convert_15.$$arity = 1), nil) && 'convert';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/dom\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send, $klass = Opal.klass;\n  if ($gvars.window == null) $gvars.window = nil;\n\n  Opal.add_stubs(['$require', '$DOM', '$shift', '$to_a', '$new', '$to_proc', '$==', '$length', '$first', '$native?', '$===', '$try_convert', '$raise', '$document']);\n  \n  self.$require(\"browser/dom/node_set\");\n  self.$require(\"browser/dom/node\");\n  self.$require(\"browser/dom/attribute\");\n  self.$require(\"browser/dom/character_data\");\n  self.$require(\"browser/dom/text\");\n  self.$require(\"browser/dom/cdata\");\n  self.$require(\"browser/dom/comment\");\n  self.$require(\"browser/dom/element\");\n  self.$require(\"browser/dom/document\");\n  self.$require(\"browser/dom/document_fragment\");\n  self.$require(\"browser/dom/builder\");\n  self.$require(\"browser/dom/mutation_observer\");\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_XML_1, TMP_Kernel_DOM_2;\n\n    \n    \n    Opal.defn(self, '$XML', TMP_Kernel_XML_1 = function $$XML(what) {\n      var self = this;\n\n      \n      \n      var doc;\n\n      if (window.DOMParser) {\n        doc = new DOMParser().parseFromString(what, 'text/xml');\n      }\n      else {\n        doc       = new ActiveXObject('Microsoft.XMLDOM');\n        doc.async = 'false';\n        doc.loadXML(what);\n      }\n    ;\n      return self.$DOM(doc);\n    }, TMP_Kernel_XML_1.$$arity = 1);\n    \n    Opal.defn(self, '$DOM', TMP_Kernel_DOM_2 = function $$DOM($a_rest) {\n      var $b, self = this, args, $iter = TMP_Kernel_DOM_2.$$p, block = $iter || nil, document = nil, roots = nil, what = nil;\n      if ($gvars.document == null) $gvars.document = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Kernel_DOM_2.$$p = null;\n      if ($truthy(block)) {\n        \n        document = ($truthy($b = args.$shift()) ? $b : $gvars.document);\n        roots = $send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'DOM'), 'Builder'), 'new', [document], block.$to_proc()).$to_a();\n        if (roots.$length()['$=='](1)) {\n          return roots.$first()\n          } else {\n          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'DOM'), 'NodeSet').$new(roots)\n        };\n        } else {\n        \n        what = args.$shift();\n        document = ($truthy($b = args.$shift()) ? $b : $gvars.document);\n        if ($truthy(self['$native?'](what))) {\n          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'DOM'), 'Node').$new(what)\n        } else if ($truthy(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Browser'), 'DOM'), 'Node')['$==='](what))) {\n          return what\n        } else if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](what))) {\n          \n          var doc = Opal.const_get_relative($nesting, 'Native').$try_convert(document).createElement('div');\n          doc.innerHTML = what;\n\n          return self.$DOM(doc.childNodes.length == 1 ? doc.childNodes[0] : doc);\n        \n          } else {\n          return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"argument not DOM convertible\")\n        };\n      }\n    }, TMP_Kernel_DOM_2.$$arity = -1);\n  })($nesting[0], $nesting);\n  (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Window(){};\n      var self = $Window = $klass($base, $super, 'Window', $Window);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Window_document_3;\n\n      def[\"native\"] = nil;\n      return (Opal.defn(self, '$document', TMP_Window_document_3 = function $$document() {\n        var self = this;\n\n        return self.$DOM(self[\"native\"].document)\n      }, TMP_Window_document_3.$$arity = 0), nil) && 'document'\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting);\n  return ($gvars.document = $gvars.window.$document());\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/css/declaration\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;\n\n  Opal.add_stubs(['$include', '$new', '$each', '$[]=', '$-', '$to_proc', '$important', '$name', '$value', '$to_s', '$enum_for', '$[]', '$alias_native', '$end_with?']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $CSS, self = $CSS = $module($base, 'CSS');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Declaration(){};\n        var self = $Declaration = $klass($base, $super, 'Declaration', $Declaration);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Declaration_rule_1, TMP_Declaration_assign_3, TMP_Declaration_replace_4, TMP_Declaration_apply_5, TMP_Declaration_delete_7, TMP_Declaration_$$_8, TMP_Declaration_$$$eq_9, TMP_Declaration_important$q_10, TMP_Declaration_each_11, TMP_Declaration_method_missing_12;\n\n        def[\"native\"] = nil;\n        \n        self.$include(Opal.const_get_relative($nesting, 'Native'));\n        self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n        \n        Opal.defn(self, '$rule', TMP_Declaration_rule_1 = function $$rule() {\n          var self = this;\n\n          if ($truthy((typeof(self[\"native\"].parentRule) !== \"undefined\"))) {\n            return Opal.const_get_relative($nesting, 'Rule').$new(self[\"native\"].parentRule)\n            } else {\n            return nil\n          }\n        }, TMP_Declaration_rule_1.$$arity = 0);\n        \n        Opal.defn(self, '$assign', TMP_Declaration_assign_3 = function $$assign(data) {\n          var TMP_2, self = this;\n\n          \n          $send(data, 'each', [], (TMP_2 = function(name, value){var self = TMP_2.$$s || this, $writer = nil;\nif (name == null) name = nil;if (value == null) value = nil;\n          \n            $writer = [name, value];\n            $send(self, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 2, TMP_2));\n          return self;\n        }, TMP_Declaration_assign_3.$$arity = 1);\n        \n        Opal.defn(self, '$replace', TMP_Declaration_replace_4 = function $$replace(string) {\n          var self = this;\n\n          return self[\"native\"].cssText = string\n        }, TMP_Declaration_replace_4.$$arity = 1);\n        \n        Opal.defn(self, '$apply', TMP_Declaration_apply_5 = function $$apply() {\n          var TMP_6, self = this, $iter = TMP_Declaration_apply_5.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Declaration_apply_5.$$p = null;\n          return $send($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Paggio'), 'CSS'), 'Definition'), 'new', [], block.$to_proc()), 'each', [], (TMP_6 = function(style){var self = TMP_6.$$s || this;\n            if (self[\"native\"] == null) self[\"native\"] = nil;\nif (style == null) style = nil;\n          if ($truthy(style.$important())) {\n              return self[\"native\"].setProperty(style.$name(), style.$value(), \"important\")\n              } else {\n              return self[\"native\"].setProperty(style.$name(), style.$value(), \"\")\n            }}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6))\n        }, TMP_Declaration_apply_5.$$arity = 0);\n        \n        Opal.defn(self, '$delete', TMP_Declaration_delete_7 = function(name) {\n          var self = this;\n\n          return self[\"native\"].removeProperty(name)\n        }, TMP_Declaration_delete_7.$$arity = 1);\n        \n        Opal.defn(self, '$[]', TMP_Declaration_$$_8 = function(name) {\n          var self = this;\n\n          \n      var result = self[\"native\"].getPropertyValue(name);\n\n      if (result == null || result === \"\") {\n        return nil;\n      }\n\n      return result;\n    \n        }, TMP_Declaration_$$_8.$$arity = 1);\n        \n        Opal.defn(self, '$[]=', TMP_Declaration_$$$eq_9 = function(name, value) {\n          var self = this;\n\n          return self[\"native\"].setProperty(name, value.$to_s(), \"\")\n        }, TMP_Declaration_$$$eq_9.$$arity = 2);\n        \n        Opal.defn(self, '$important?', TMP_Declaration_important$q_10 = function(name) {\n          var self = this;\n\n          return self[\"native\"].getPropertyPriority(name) == \"important\"\n        }, TMP_Declaration_important$q_10.$$arity = 1);\n        \n        Opal.defn(self, '$each', TMP_Declaration_each_11 = function $$each() {\n          var self = this, $iter = TMP_Declaration_each_11.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Declaration_each_11.$$p = null;\n          \n          if ((block !== nil)) {\n            } else {\n            return self.$enum_for(\"each\")\n          };\n          \n      for (var i = 0, length = self[\"native\"].length; i < length; i++) {\n        var name  = self[\"native\"].item(i);\n\n        Opal.yieldX(block, [name, self['$[]'](name)])\n      }\n    ;\n          return self;\n        }, TMP_Declaration_each_11.$$arity = 0);\n        self.$alias_native(\"length\");\n        self.$alias_native(\"to_s\", \"cssText\");\n        return (Opal.defn(self, '$method_missing', TMP_Declaration_method_missing_12 = function $$method_missing(name, value) {\n          var self = this, $writer = nil;\n\n          if (value == null) {\n            value = nil;\n          }\n          if ($truthy(name['$end_with?'](\"=\"))) {\n            \n            $writer = [name['$[]']($range(0, -2, false)), value];\n            $send(self, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n            } else {\n            return self['$[]'](name)\n          }\n        }, TMP_Declaration_method_missing_12.$$arity = -2), nil) && 'method_missing';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/css/style_sheet\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$include', '$is_a?', '$to_n', '$alias_native', '$new', '$DOM', '$===', '$join', '$map', '$insert', '$length', '$find', '$rules', '$log', '$==', '$id', '$__send__', '$to_proc']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $CSS, self = $CSS = $module($base, 'CSS');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $StyleSheet(){};\n        var self = $StyleSheet = $klass($base, $super, 'StyleSheet', $StyleSheet);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_StyleSheet_initialize_1, TMP_StyleSheet_media_2, TMP_StyleSheet_owner_3, TMP_StyleSheet_parent_4, TMP_StyleSheet_rules_6, TMP_StyleSheet_delete_7, TMP_StyleSheet_insert_8, TMP_StyleSheet_rule_10, TMP_StyleSheet_$$_12, TMP_StyleSheet_method_missing_13;\n\n        def[\"native\"] = nil;\n        \n        self.$include(Opal.const_get_relative($nesting, 'Native'));\n        \n        Opal.defn(self, '$initialize', TMP_StyleSheet_initialize_1 = function $$initialize(what) {\n          var self = this, $iter = TMP_StyleSheet_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_StyleSheet_initialize_1.$$p = null;\n          if ($truthy(what['$is_a?'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'DOM'), 'Element')))) {\n            return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_StyleSheet_initialize_1, false), [what.$to_n().sheet], null)\n            } else {\n            return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_StyleSheet_initialize_1, false), [what], null)\n          }\n        }, TMP_StyleSheet_initialize_1.$$arity = 1);\n        self.$alias_native(\"disabled?\", \"disabled\");\n        self.$alias_native(\"href\");\n        self.$alias_native(\"title\");\n        self.$alias_native(\"type\");\n        \n        Opal.defn(self, '$media', TMP_StyleSheet_media_2 = function $$media() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].media != null)) {\n            return Opal.const_get_relative($nesting, 'Media').$new(self[\"native\"].media)\n            } else {\n            return nil\n          }\n        }, TMP_StyleSheet_media_2.$$arity = 0);\n        \n        Opal.defn(self, '$owner', TMP_StyleSheet_owner_3 = function $$owner() {\n          var self = this;\n\n          return self.$DOM(self[\"native\"].ownerNode)\n        }, TMP_StyleSheet_owner_3.$$arity = 0);\n        \n        Opal.defn(self, '$parent', TMP_StyleSheet_parent_4 = function $$parent() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].parentStyleSheet != null)) {\n            return Opal.const_get_relative($nesting, 'Sheet').$new(self[\"native\"].parentStyleSheet)\n            } else {\n            return nil\n          }\n        }, TMP_StyleSheet_parent_4.$$arity = 0);\n        \n        Opal.defn(self, '$rules', TMP_StyleSheet_rules_6 = function $$rules() {\n          var TMP_5, self = this;\n\n          return $send(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array'), 'new', [self[\"native\"].cssRules], (TMP_5 = function(e){var self = TMP_5.$$s || this;\nif (e == null) e = nil;\n          return Opal.const_get_relative($nesting, 'Rule').$new(e)}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5))\n        }, TMP_StyleSheet_rules_6.$$arity = 0);\n        \n        Opal.defn(self, '$delete', TMP_StyleSheet_delete_7 = function(index) {\n          var self = this;\n\n          return self[\"native\"].deleteRule(index)\n        }, TMP_StyleSheet_delete_7.$$arity = 1);\n        \n        Opal.defn(self, '$insert', TMP_StyleSheet_insert_8 = function $$insert(index, rule) {\n          var self = this;\n\n          return self[\"native\"].insertRule(rule, index)\n        }, TMP_StyleSheet_insert_8.$$arity = 2);\n        \n        Opal.defn(self, '$rule', TMP_StyleSheet_rule_10 = function $$rule(selector, body) {\n          var TMP_9, self = this;\n\n          \n          if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](selector))) {\n            } else {\n            selector = selector.$join(\", \")\n          };\n          if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](body))) {\n            } else {\n            body = $send(body, 'map', [], (TMP_9 = function(name, value){var self = TMP_9.$$s || this;\nif (name == null) name = nil;if (value == null) value = nil;\n            return \"\" + (name) + \": \" + (value) + \";\"}, TMP_9.$$s = self, TMP_9.$$arity = 2, TMP_9)).$join(\"\\n\")\n          };\n          return self.$insert(self.$length(), \"\" + (selector) + \" { \" + (body) + \" }\");\n        }, TMP_StyleSheet_rule_10.$$arity = 2);\n        \n        Opal.defn(self, '$[]', TMP_StyleSheet_$$_12 = function(id) {\n          var TMP_11, self = this;\n\n          return $send(self.$rules(), 'find', [], (TMP_11 = function(r){var self = TMP_11.$$s || this;\nif (r == null) r = nil;\n          \n            self.$log(r);\n            return r.$id()['$=='](id);}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11))\n        }, TMP_StyleSheet_$$_12.$$arity = 1);\n        \n        Opal.defn(self, '$method_missing', TMP_StyleSheet_method_missing_13 = function $$method_missing($a_rest) {\n          var self = this, args, $iter = TMP_StyleSheet_method_missing_13.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_StyleSheet_method_missing_13.$$p = null;\n          return $send(self.$rules(), '__send__', Opal.to_a(args), block.$to_proc())\n        }, TMP_StyleSheet_method_missing_13.$$arity = -1);\n        return (function($base, $super, $parent_nesting) {\n          function $Media(){};\n          var self = $Media = $klass($base, $super, 'Media', $Media);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Media_push_14, TMP_Media_delete_15;\n\n          def[\"native\"] = nil;\n          \n          self.$alias_native(\"text\", \"mediaText\");\n          self.$alias_native(\"to_s\", \"mediaText\");\n          \n          Opal.defn(self, '$push', TMP_Media_push_14 = function $$push(medium) {\n            var self = this;\n\n            \n            self[\"native\"].appendMedium(medium);\n            return self;\n          }, TMP_Media_push_14.$$arity = 1);\n          return (Opal.defn(self, '$delete', TMP_Media_delete_15 = function(medium) {\n            var self = this;\n\n            return self[\"native\"].deleteMedium(medium)\n          }, TMP_Media_delete_15.$$arity = 1), nil) && 'delete';\n        })($nesting[0], Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array'), $nesting);\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/css/rule\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$include', '$==', '$[]', '$new', '$raise', '$alias_native']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $CSS, self = $CSS = $module($base, 'CSS');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Rule(){};\n        var self = $Rule = $klass($base, $super, 'Rule', $Rule);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Rule_new_1, TMP_Rule_parent_2, TMP_Rule_style_sheet_3;\n\n        def[\"native\"] = nil;\n        \n        self.$include(Opal.const_get_relative($nesting, 'Native'));\n        Opal.const_set($nesting[0], 'STYLE_RULE', 1);\n        Opal.const_set($nesting[0], 'CHARSET_RULE', 2);\n        Opal.const_set($nesting[0], 'IMPORT_RULE', 3);\n        Opal.const_set($nesting[0], 'MEDIA_RULE', 4);\n        Opal.const_set($nesting[0], 'FONT_FACE_RULE', 5);\n        Opal.const_set($nesting[0], 'PAGE_RULE', 6);\n        Opal.const_set($nesting[0], 'KEYFRAMES_RULE', 7);\n        Opal.const_set($nesting[0], 'KEYFRAME_RULE', 8);\n        Opal.const_set($nesting[0], 'NAMESPACE_RULE', 10);\n        Opal.const_set($nesting[0], 'COUNTER_STYLE_RULE', 11);\n        Opal.const_set($nesting[0], 'SUPPORTS_RULE', 12);\n        Opal.const_set($nesting[0], 'DOCUMENT_RULE', 13);\n        Opal.const_set($nesting[0], 'FONT_FEATURE_VALUES_RULE', 14);\n        Opal.const_set($nesting[0], 'VIEWPORT_RULE', 15);\n        Opal.const_set($nesting[0], 'REGION_STYLE_RULE', 16);\n        Opal.defs(self, '$new', TMP_Rule_new_1 = function(rule) {\n          var $a, self = this, $iter = TMP_Rule_new_1.$$p, $yield = $iter || nil, klass = nil;\n          if (self.classes == null) self.classes = nil;\n\n          if ($iter) TMP_Rule_new_1.$$p = null;\n          if (self['$=='](Opal.const_get_relative($nesting, 'Rule'))) {\n            \n            self.classes = ($truthy($a = self.classes) ? $a : [nil, Opal.const_get_relative($nesting, 'Style')]);\n            if ($truthy((klass = self.classes['$[]'](rule.type)))) {\n              return klass.$new(rule)\n              } else {\n              return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"cannot instantiate a non derived Rule object\")\n            };\n            } else {\n            return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_Rule_new_1, false, $Rule), [rule], null)\n          }\n        }, TMP_Rule_new_1.$$arity = 1);\n        self.$alias_native(\"text\", \"cssText\");\n        self.$alias_native(\"to_s\", \"cssText\");\n        \n        Opal.defn(self, '$parent', TMP_Rule_parent_2 = function $$parent() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].parentRule != null)) {\n            return Opal.const_get_relative($nesting, 'Rule').$new(self[\"native\"].parentRule)\n            } else {\n            return nil\n          }\n        }, TMP_Rule_parent_2.$$arity = 0);\n        return (Opal.defn(self, '$style_sheet', TMP_Rule_style_sheet_3 = function $$style_sheet() {\n          var self = this;\n\n          if ($truthy(self[\"native\"].parentStyleSheet != null)) {\n            return Opal.const_get_relative($nesting, 'StyleSheet').$new(self[\"native\"].parentStyleSheet)\n            } else {\n            return nil\n          }\n        }, TMP_Rule_style_sheet_3.$$arity = 0), nil) && 'style_sheet';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/css/rule/style\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$alias_native', '$new', '$__send__', '$declaration', '$to_proc']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $CSS, self = $CSS = $module($base, 'CSS');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Rule(){};\n        var self = $Rule = $klass($base, $super, 'Rule', $Rule);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return (function($base, $super, $parent_nesting) {\n          function $Style(){};\n          var self = $Style = $klass($base, $super, 'Style', $Style);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Style_declaration_1, TMP_Style_method_missing_2;\n\n          def[\"native\"] = nil;\n          \n          self.$alias_native(\"selector\", \"selectorText\");\n          self.$alias_native(\"id\", \"selectorText\");\n          \n          Opal.defn(self, '$declaration', TMP_Style_declaration_1 = function $$declaration() {\n            var self = this;\n\n            return Opal.const_get_relative($nesting, 'Declaration').$new(self[\"native\"].style)\n          }, TMP_Style_declaration_1.$$arity = 0);\n          return (Opal.defn(self, '$method_missing', TMP_Style_method_missing_2 = function $$method_missing($a_rest) {\n            var self = this, args, $iter = TMP_Style_method_missing_2.$$p, block = $iter || nil;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n            if ($iter) TMP_Style_method_missing_2.$$p = null;\n            return $send(self.$declaration(), '__send__', Opal.to_a(args), block.$to_proc())\n          }, TMP_Style_method_missing_2.$$arity = -1), nil) && 'method_missing';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Rule'), $nesting)\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/css\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $gvars = Opal.gvars, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$create_element', '$[]=', '$-', '$css', '$to_proc', '$inner_text=']);\n  \n  self.$require(\"browser/css/declaration\");\n  self.$require(\"browser/css/style_sheet\");\n  self.$require(\"browser/css/rule\");\n  self.$require(\"browser/css/rule/style\");\n  return (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_CSS_1;\n\n    \n    Opal.defn(self, '$CSS', TMP_Kernel_CSS_1 = function $$CSS(text) {\n      var self = this, $iter = TMP_Kernel_CSS_1.$$p, block = $iter || nil, style = nil, $writer = nil;\n      if ($gvars.document == null) $gvars.document = nil;\n\n      if (text == null) {\n        text = nil;\n      }\n      if ($iter) TMP_Kernel_CSS_1.$$p = null;\n      \n      style = $gvars.document.$create_element(\"style\");\n      \n      $writer = [\"type\", \"text/css\"];\n      $send(style, '[]=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      if ($truthy(block)) {\n        \n        $writer = [$send(Opal.const_get_relative($nesting, 'Paggio'), 'css', [], block.$to_proc())];\n        $send(style, 'inner_text=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];\n        } else {\n        \n        $writer = [text];\n        $send(style, 'inner_text=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];\n      };\n      return style;\n    }, TMP_Kernel_CSS_1.$$arity = -1)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"native\");\n  self.$require(\"paggio\");\n  self.$require(\"browser/version\");\n  self.$require(\"browser/utils\");\n  self.$require(\"browser/support\");\n  self.$require(\"browser/event\");\n  self.$require(\"browser/window\");\n  self.$require(\"browser/dom\");\n  return self.$require(\"browser/css\");\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"set\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $module = Opal.module;\n\n  Opal.add_stubs(['$include', '$new', '$nil?', '$===', '$raise', '$each', '$add', '$call', '$merge', '$class', '$respond_to?', '$subtract', '$dup', '$join', '$to_a', '$equal?', '$instance_of?', '$==', '$instance_variable_get', '$is_a?', '$size', '$all?', '$include?', '$[]=', '$-', '$enum_for', '$[]', '$<<', '$replace', '$delete', '$select', '$each_key', '$to_proc', '$empty?', '$eql?', '$instance_eval', '$clear', '$<', '$<=', '$keys']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Set(){};\n    var self = $Set = $klass($base, $super, 'Set', $Set);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Set_$$_1, TMP_Set_initialize_2, TMP_Set_dup_4, TMP_Set_$_5, TMP_Set_inspect_6, TMP_Set_$eq$eq_8, TMP_Set_add_9, TMP_Set_classify_10, TMP_Set_collect$B_13, TMP_Set_delete_15, TMP_Set_delete$q_16, TMP_Set_delete_if_17, TMP_Set_add$q_20, TMP_Set_each_21, TMP_Set_empty$q_22, TMP_Set_eql$q_24, TMP_Set_clear_25, TMP_Set_include$q_26, TMP_Set_merge_28, TMP_Set_replace_29, TMP_Set_size_30, TMP_Set_subtract_32, TMP_Set_$_33, TMP_Set_superset$q_35, TMP_Set_proper_superset$q_37, TMP_Set_subset$q_39, TMP_Set_proper_subset$q_41, TMP_Set_to_a_42;\n\n    def.hash = nil;\n    \n    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));\n    Opal.defs(self, '$[]', TMP_Set_$$_1 = function($a_rest) {\n      var self = this, ary;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      ary = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        ary[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return self.$new(ary)\n    }, TMP_Set_$$_1.$$arity = -1);\n    \n    Opal.defn(self, '$initialize', TMP_Set_initialize_2 = function $$initialize(enum$) {\n      var TMP_3, self = this, $iter = TMP_Set_initialize_2.$$p, block = $iter || nil;\n\n      if (enum$ == null) {\n        enum$ = nil;\n      }\n      if ($iter) TMP_Set_initialize_2.$$p = null;\n      \n      self.hash = Opal.const_get_relative($nesting, 'Hash').$new();\n      if ($truthy(enum$['$nil?']())) {\n        return nil};\n      if ($truthy(Opal.const_get_relative($nesting, 'Enumerable')['$==='](enum$))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"value must be enumerable\")\n      };\n      if ($truthy(block)) {\n        return $send(enum$, 'each', [], (TMP_3 = function(item){var self = TMP_3.$$s || this;\nif (item == null) item = nil;\n        return self.$add(block.$call(item))}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))\n        } else {\n        return self.$merge(enum$)\n      };\n    }, TMP_Set_initialize_2.$$arity = -1);\n    \n    Opal.defn(self, '$dup', TMP_Set_dup_4 = function $$dup() {\n      var self = this, result = nil;\n\n      \n      result = self.$class().$new();\n      return result.$merge(self);\n    }, TMP_Set_dup_4.$$arity = 0);\n    \n    Opal.defn(self, '$-', TMP_Set_$_5 = function(enum$) {\n      var self = this;\n\n      \n      if ($truthy(enum$['$respond_to?'](\"each\"))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"value must be enumerable\")\n      };\n      return self.$dup().$subtract(enum$);\n    }, TMP_Set_$_5.$$arity = 1);\n    Opal.alias(self, \"difference\", \"-\");\n    \n    Opal.defn(self, '$inspect', TMP_Set_inspect_6 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"#<Set: {\" + (self.$to_a().$join(\",\")) + \"}>\"\n    }, TMP_Set_inspect_6.$$arity = 0);\n    \n    Opal.defn(self, '$==', TMP_Set_$eq$eq_8 = function(other) {\n      var $a, TMP_7, self = this;\n\n      if ($truthy(self['$equal?'](other))) {\n        return true\n      } else if ($truthy(other['$instance_of?'](self.$class()))) {\n        return self.hash['$=='](other.$instance_variable_get(\"@hash\"))\n      } else if ($truthy(($truthy($a = other['$is_a?'](Opal.const_get_relative($nesting, 'Set'))) ? self.$size()['$=='](other.$size()) : $a))) {\n        return $send(other, 'all?', [], (TMP_7 = function(o){var self = TMP_7.$$s || this;\n          if (self.hash == null) self.hash = nil;\nif (o == null) o = nil;\n        return self.hash['$include?'](o)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7))\n        } else {\n        return false\n      }\n    }, TMP_Set_$eq$eq_8.$$arity = 1);\n    \n    Opal.defn(self, '$add', TMP_Set_add_9 = function $$add(o) {\n      var self = this, $writer = nil;\n\n      \n      \n      $writer = [o, true];\n      $send(self.hash, '[]=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      return self;\n    }, TMP_Set_add_9.$$arity = 1);\n    Opal.alias(self, \"<<\", \"add\");\n    \n    Opal.defn(self, '$classify', TMP_Set_classify_10 = function $$classify() {\n      var TMP_11, TMP_12, self = this, $iter = TMP_Set_classify_10.$$p, block = $iter || nil, result = nil;\n\n      if ($iter) TMP_Set_classify_10.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"classify\")\n      };\n      result = $send(Opal.const_get_relative($nesting, 'Hash'), 'new', [], (TMP_11 = function(h, k){var self = TMP_11.$$s || this, $writer = nil;\nif (h == null) h = nil;if (k == null) k = nil;\n      \n        $writer = [k, self.$class().$new()];\n        $send(h, '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_11.$$s = self, TMP_11.$$arity = 2, TMP_11));\n      $send(self, 'each', [], (TMP_12 = function(item){var self = TMP_12.$$s || this;\nif (item == null) item = nil;\n      return result['$[]'](Opal.yield1(block, item)).$add(item)}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));\n      return result;\n    }, TMP_Set_classify_10.$$arity = 0);\n    \n    Opal.defn(self, '$collect!', TMP_Set_collect$B_13 = function() {\n      var TMP_14, self = this, $iter = TMP_Set_collect$B_13.$$p, block = $iter || nil, result = nil;\n\n      if ($iter) TMP_Set_collect$B_13.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"collect!\")\n      };\n      result = self.$class().$new();\n      $send(self, 'each', [], (TMP_14 = function(item){var self = TMP_14.$$s || this;\nif (item == null) item = nil;\n      return result['$<<'](Opal.yield1(block, item))}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14));\n      return self.$replace(result);\n    }, TMP_Set_collect$B_13.$$arity = 0);\n    Opal.alias(self, \"map!\", \"collect!\");\n    \n    Opal.defn(self, '$delete', TMP_Set_delete_15 = function(o) {\n      var self = this;\n\n      \n      self.hash.$delete(o);\n      return self;\n    }, TMP_Set_delete_15.$$arity = 1);\n    \n    Opal.defn(self, '$delete?', TMP_Set_delete$q_16 = function(o) {\n      var self = this;\n\n      if ($truthy(self['$include?'](o))) {\n        \n        self.$delete(o);\n        return self;\n        } else {\n        return nil\n      }\n    }, TMP_Set_delete$q_16.$$arity = 1);\n    \n    Opal.defn(self, '$delete_if', TMP_Set_delete_if_17 = function $$delete_if() {try {\n\n      var $a, TMP_18, TMP_19, self = this, $iter = TMP_Set_delete_if_17.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_Set_delete_if_17.$$p = null;\n      \n      ($truthy($a = ($yield !== nil)) ? $a : Opal.ret(self.$enum_for(\"delete_if\")));\n      $send($send(self, 'select', [], (TMP_18 = function(o){var self = TMP_18.$$s || this;\nif (o == null) o = nil;\n      return Opal.yield1($yield, o);}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18)), 'each', [], (TMP_19 = function(o){var self = TMP_19.$$s || this;\n        if (self.hash == null) self.hash = nil;\nif (o == null) o = nil;\n      return self.hash.$delete(o)}, TMP_19.$$s = self, TMP_19.$$arity = 1, TMP_19));\n      return self;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Set_delete_if_17.$$arity = 0);\n    \n    Opal.defn(self, '$add?', TMP_Set_add$q_20 = function(o) {\n      var self = this;\n\n      if ($truthy(self['$include?'](o))) {\n        return nil\n        } else {\n        return self.$add(o)\n      }\n    }, TMP_Set_add$q_20.$$arity = 1);\n    \n    Opal.defn(self, '$each', TMP_Set_each_21 = function $$each() {\n      var self = this, $iter = TMP_Set_each_21.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Set_each_21.$$p = null;\n      \n      if ((block !== nil)) {\n        } else {\n        return self.$enum_for(\"each\")\n      };\n      $send(self.hash, 'each_key', [], block.$to_proc());\n      return self;\n    }, TMP_Set_each_21.$$arity = 0);\n    \n    Opal.defn(self, '$empty?', TMP_Set_empty$q_22 = function() {\n      var self = this;\n\n      return self.hash['$empty?']()\n    }, TMP_Set_empty$q_22.$$arity = 0);\n    \n    Opal.defn(self, '$eql?', TMP_Set_eql$q_24 = function(other) {\n      var TMP_23, self = this;\n\n      return self.hash['$eql?']($send(other, 'instance_eval', [], (TMP_23 = function(){var self = TMP_23.$$s || this;\n        if (self.hash == null) self.hash = nil;\n\n      return self.hash}, TMP_23.$$s = self, TMP_23.$$arity = 0, TMP_23)))\n    }, TMP_Set_eql$q_24.$$arity = 1);\n    \n    Opal.defn(self, '$clear', TMP_Set_clear_25 = function $$clear() {\n      var self = this;\n\n      \n      self.hash.$clear();\n      return self;\n    }, TMP_Set_clear_25.$$arity = 0);\n    \n    Opal.defn(self, '$include?', TMP_Set_include$q_26 = function(o) {\n      var self = this;\n\n      return self.hash['$include?'](o)\n    }, TMP_Set_include$q_26.$$arity = 1);\n    Opal.alias(self, \"member?\", \"include?\");\n    \n    Opal.defn(self, '$merge', TMP_Set_merge_28 = function $$merge(enum$) {\n      var TMP_27, self = this;\n\n      \n      $send(enum$, 'each', [], (TMP_27 = function(item){var self = TMP_27.$$s || this;\nif (item == null) item = nil;\n      return self.$add(item)}, TMP_27.$$s = self, TMP_27.$$arity = 1, TMP_27));\n      return self;\n    }, TMP_Set_merge_28.$$arity = 1);\n    \n    Opal.defn(self, '$replace', TMP_Set_replace_29 = function $$replace(enum$) {\n      var self = this;\n\n      \n      self.$clear();\n      self.$merge(enum$);\n      return self;\n    }, TMP_Set_replace_29.$$arity = 1);\n    \n    Opal.defn(self, '$size', TMP_Set_size_30 = function $$size() {\n      var self = this;\n\n      return self.hash.$size()\n    }, TMP_Set_size_30.$$arity = 0);\n    Opal.alias(self, \"length\", \"size\");\n    \n    Opal.defn(self, '$subtract', TMP_Set_subtract_32 = function $$subtract(enum$) {\n      var TMP_31, self = this;\n\n      \n      $send(enum$, 'each', [], (TMP_31 = function(item){var self = TMP_31.$$s || this;\nif (item == null) item = nil;\n      return self.$delete(item)}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31));\n      return self;\n    }, TMP_Set_subtract_32.$$arity = 1);\n    \n    Opal.defn(self, '$|', TMP_Set_$_33 = function(enum$) {\n      var self = this;\n\n      \n      if ($truthy(enum$['$respond_to?'](\"each\"))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"value must be enumerable\")\n      };\n      return self.$dup().$merge(enum$);\n    }, TMP_Set_$_33.$$arity = 1);\n    \n    Opal.defn(self, '$superset?', TMP_Set_superset$q_35 = function(set) {\n      var $a, TMP_34, self = this;\n\n      \n      ($truthy($a = set['$is_a?'](Opal.const_get_relative($nesting, 'Set'))) ? $a : self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"value must be a set\"));\n      if ($truthy($rb_lt(self.$size(), set.$size()))) {\n        return false};\n      return $send(set, 'all?', [], (TMP_34 = function(o){var self = TMP_34.$$s || this;\nif (o == null) o = nil;\n      return self['$include?'](o)}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34));\n    }, TMP_Set_superset$q_35.$$arity = 1);\n    Opal.alias(self, \">=\", \"superset?\");\n    \n    Opal.defn(self, '$proper_superset?', TMP_Set_proper_superset$q_37 = function(set) {\n      var $a, TMP_36, self = this;\n\n      \n      ($truthy($a = set['$is_a?'](Opal.const_get_relative($nesting, 'Set'))) ? $a : self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"value must be a set\"));\n      if ($truthy($rb_le(self.$size(), set.$size()))) {\n        return false};\n      return $send(set, 'all?', [], (TMP_36 = function(o){var self = TMP_36.$$s || this;\nif (o == null) o = nil;\n      return self['$include?'](o)}, TMP_36.$$s = self, TMP_36.$$arity = 1, TMP_36));\n    }, TMP_Set_proper_superset$q_37.$$arity = 1);\n    Opal.alias(self, \">\", \"proper_superset?\");\n    \n    Opal.defn(self, '$subset?', TMP_Set_subset$q_39 = function(set) {\n      var $a, TMP_38, self = this;\n\n      \n      ($truthy($a = set['$is_a?'](Opal.const_get_relative($nesting, 'Set'))) ? $a : self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"value must be a set\"));\n      if ($truthy($rb_lt(set.$size(), self.$size()))) {\n        return false};\n      return $send(self, 'all?', [], (TMP_38 = function(o){var self = TMP_38.$$s || this;\nif (o == null) o = nil;\n      return set['$include?'](o)}, TMP_38.$$s = self, TMP_38.$$arity = 1, TMP_38));\n    }, TMP_Set_subset$q_39.$$arity = 1);\n    Opal.alias(self, \"<=\", \"subset?\");\n    \n    Opal.defn(self, '$proper_subset?', TMP_Set_proper_subset$q_41 = function(set) {\n      var $a, TMP_40, self = this;\n\n      \n      ($truthy($a = set['$is_a?'](Opal.const_get_relative($nesting, 'Set'))) ? $a : self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"value must be a set\"));\n      if ($truthy($rb_le(set.$size(), self.$size()))) {\n        return false};\n      return $send(self, 'all?', [], (TMP_40 = function(o){var self = TMP_40.$$s || this;\nif (o == null) o = nil;\n      return set['$include?'](o)}, TMP_40.$$s = self, TMP_40.$$arity = 1, TMP_40));\n    }, TMP_Set_proper_subset$q_41.$$arity = 1);\n    Opal.alias(self, \"<\", \"proper_subset?\");\n    Opal.alias(self, \"+\", \"|\");\n    Opal.alias(self, \"union\", \"|\");\n    return (Opal.defn(self, '$to_a', TMP_Set_to_a_42 = function $$to_a() {\n      var self = this;\n\n      return self.hash.$keys()\n    }, TMP_Set_to_a_42.$$arity = 0), nil) && 'to_a';\n  })($nesting[0], null, $nesting);\n  return (function($base, $parent_nesting) {\n    var $Enumerable, self = $Enumerable = $module($base, 'Enumerable');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Enumerable_to_set_43;\n\n    \n    Opal.defn(self, '$to_set', TMP_Enumerable_to_set_43 = function $$to_set(klass, $a_rest) {\n      var self = this, args, $iter = TMP_Enumerable_to_set_43.$$p, block = $iter || nil;\n\n      if (klass == null) {\n        klass = Opal.const_get_relative($nesting, 'Set');\n      }\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerable_to_set_43.$$p = null;\n      return $send(klass, 'new', [self].concat(Opal.to_a(args)), block.$to_proc())\n    }, TMP_Enumerable_to_set_43.$$arity = -1)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"ast/node\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$to_sym', '$freeze', '$to_a', '$assign_properties', '$hash', '$class', '$eql?', '$type', '$children', '$each', '$instance_variable_set', '$protected', '$private', '$==', '$nil?', '$send', '$original_dup', '$equal?', '$respond_to?', '$to_ast', '$updated', '$+', '$*', '$fancy_type', '$is_a?', '$to_sexp', '$inspect', '$map', '$to_sexp_array', '$gsub', '$to_s']);\n  return (function($base, $parent_nesting) {\n    var $AST, self = $AST = $module($base, 'AST');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Node(){};\n      var self = $Node = $klass($base, $super, 'Node', $Node);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Node_initialize_1, TMP_Node_eql$q_2, TMP_Node_assign_properties_4, TMP_Node_dup_5, TMP_Node_updated_6, TMP_Node_$eq$eq_7, TMP_Node_concat_8, TMP_Node_append_9, TMP_Node_to_sexp_11, TMP_Node_inspect_13, TMP_Node_to_ast_14, TMP_Node_to_sexp_array_16, TMP_Node_fancy_type_17;\n\n      def.type = def.children = nil;\n      \n      self.$attr_reader(\"type\");\n      self.$attr_reader(\"children\");\n      Opal.alias(self, \"to_a\", \"children\");\n      self.$attr_reader(\"hash\");\n      \n      Opal.defn(self, '$initialize', TMP_Node_initialize_1 = function $$initialize(type, children, properties) {\n        var $a, self = this;\n\n        if (children == null) {\n          children = [];\n        }\n        if (properties == null) {\n          properties = $hash2([], {});\n        }\n        \n        $a = [type.$to_sym(), children.$to_a().$freeze()], (self.type = $a[0]), (self.children = $a[1]), $a;\n        self.$assign_properties(properties);\n        self.hash = [self.type, self.children, self.$class()].$hash();\n        return self.$freeze();\n      }, TMP_Node_initialize_1.$$arity = -2);\n      \n      Opal.defn(self, '$eql?', TMP_Node_eql$q_2 = function(other) {\n        var $a, $b, self = this;\n\n        return ($truthy($a = ($truthy($b = self.$class()['$eql?'](other.$class())) ? self.type['$eql?'](other.$type()) : $b)) ? self.children['$eql?'](other.$children()) : $a)\n      }, TMP_Node_eql$q_2.$$arity = 1);\n      \n      Opal.defn(self, '$assign_properties', TMP_Node_assign_properties_4 = function $$assign_properties(properties) {\n        var TMP_3, self = this;\n\n        \n        $send(properties, 'each', [], (TMP_3 = function(name, value){var self = TMP_3.$$s || this;\nif (name == null) name = nil;if (value == null) value = nil;\n        return self.$instance_variable_set(\"\" + \"@\" + (name), value)}, TMP_3.$$s = self, TMP_3.$$arity = 2, TMP_3));\n        return nil;\n      }, TMP_Node_assign_properties_4.$$arity = 1);\n      self.$protected(\"assign_properties\");\n      Opal.alias(self, \"original_dup\", \"dup\");\n      self.$private(\"original_dup\");\n      \n      Opal.defn(self, '$dup', TMP_Node_dup_5 = function $$dup() {\n        var self = this;\n\n        return self\n      }, TMP_Node_dup_5.$$arity = 0);\n      Opal.alias(self, \"clone\", \"dup\");\n      \n      Opal.defn(self, '$updated', TMP_Node_updated_6 = function $$updated(type, children, properties) {\n        var $a, $b, self = this, new_type = nil, new_children = nil, new_properties = nil;\n\n        if (type == null) {\n          type = nil;\n        }\n        if (children == null) {\n          children = nil;\n        }\n        if (properties == null) {\n          properties = nil;\n        }\n        \n        new_type = ($truthy($a = type) ? $a : self.type);\n        new_children = ($truthy($a = children) ? $a : self.children);\n        new_properties = ($truthy($a = properties) ? $a : $hash2([], {}));\n        if ($truthy(($truthy($a = (($b = self.type['$=='](new_type)) ? self.children['$=='](new_children) : self.type['$=='](new_type))) ? properties['$nil?']() : $a))) {\n          return self\n          } else {\n          return self.$original_dup().$send(\"initialize\", new_type, new_children, new_properties)\n        };\n      }, TMP_Node_updated_6.$$arity = -1);\n      \n      Opal.defn(self, '$==', TMP_Node_$eq$eq_7 = function(other) {\n        var $a, self = this;\n\n        if ($truthy(self['$equal?'](other))) {\n          return true\n        } else if ($truthy(other['$respond_to?'](\"to_ast\"))) {\n          \n          other = other.$to_ast();\n          return (($a = other.$type()['$=='](self.$type())) ? other.$children()['$=='](self.$children()) : other.$type()['$=='](self.$type()));\n          } else {\n          return false\n        }\n      }, TMP_Node_$eq$eq_7.$$arity = 1);\n      \n      Opal.defn(self, '$concat', TMP_Node_concat_8 = function $$concat(array) {\n        var self = this;\n\n        return self.$updated(nil, $rb_plus(self.children, array.$to_a()))\n      }, TMP_Node_concat_8.$$arity = 1);\n      Opal.alias(self, \"+\", \"concat\");\n      \n      Opal.defn(self, '$append', TMP_Node_append_9 = function $$append(element) {\n        var self = this;\n\n        return self.$updated(nil, $rb_plus(self.children, [element]))\n      }, TMP_Node_append_9.$$arity = 1);\n      Opal.alias(self, \"<<\", \"append\");\n      \n      Opal.defn(self, '$to_sexp', TMP_Node_to_sexp_11 = function $$to_sexp(indent) {\n        var TMP_10, self = this, indented = nil, sexp = nil;\n\n        if (indent == null) {\n          indent = 0;\n        }\n        \n        indented = $rb_times(\"  \", indent);\n        sexp = \"\" + (indented) + \"(\" + (self.$fancy_type());\n        $send(self.$children(), 'each', [], (TMP_10 = function(child){var self = TMP_10.$$s || this;\nif (child == null) child = nil;\n        if ($truthy(child['$is_a?'](Opal.const_get_relative($nesting, 'Node')))) {\n            return (sexp = $rb_plus(sexp, \"\" + \"\\n\" + (child.$to_sexp($rb_plus(indent, 1)))))\n            } else {\n            return (sexp = $rb_plus(sexp, \"\" + \" \" + (child.$inspect())))\n          }}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10));\n        sexp = $rb_plus(sexp, \")\");\n        return sexp;\n      }, TMP_Node_to_sexp_11.$$arity = -1);\n      Opal.alias(self, \"to_s\", \"to_sexp\");\n      \n      Opal.defn(self, '$inspect', TMP_Node_inspect_13 = function $$inspect(indent) {\n        var TMP_12, self = this, indented = nil, sexp = nil;\n\n        if (indent == null) {\n          indent = 0;\n        }\n        \n        indented = $rb_times(\"  \", indent);\n        sexp = \"\" + (indented) + \"s(:\" + (self.type);\n        $send(self.$children(), 'each', [], (TMP_12 = function(child){var self = TMP_12.$$s || this;\nif (child == null) child = nil;\n        if ($truthy(child['$is_a?'](Opal.const_get_relative($nesting, 'Node')))) {\n            return (sexp = $rb_plus(sexp, \"\" + \",\\n\" + (child.$inspect($rb_plus(indent, 1)))))\n            } else {\n            return (sexp = $rb_plus(sexp, \"\" + \", \" + (child.$inspect())))\n          }}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));\n        sexp = $rb_plus(sexp, \")\");\n        return sexp;\n      }, TMP_Node_inspect_13.$$arity = -1);\n      \n      Opal.defn(self, '$to_ast', TMP_Node_to_ast_14 = function $$to_ast() {\n        var self = this;\n\n        return self\n      }, TMP_Node_to_ast_14.$$arity = 0);\n      \n      Opal.defn(self, '$to_sexp_array', TMP_Node_to_sexp_array_16 = function $$to_sexp_array() {\n        var TMP_15, self = this, children_sexp_arrs = nil;\n\n        \n        children_sexp_arrs = $send(self.$children(), 'map', [], (TMP_15 = function(child){var self = TMP_15.$$s || this;\nif (child == null) child = nil;\n        if ($truthy(child['$is_a?'](Opal.const_get_relative($nesting, 'Node')))) {\n            return child.$to_sexp_array()\n            } else {\n            return child\n          }}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15));\n        return [self.$type()].concat(Opal.to_a(children_sexp_arrs));\n      }, TMP_Node_to_sexp_array_16.$$arity = 0);\n      self.$protected();\n      return (Opal.defn(self, '$fancy_type', TMP_Node_fancy_type_17 = function $$fancy_type() {\n        var self = this;\n\n        return self.type.$to_s().$gsub(\"_\", \"-\")\n      }, TMP_Node_fancy_type_17.$$arity = 0), nil) && 'fancy_type';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"ast/processor/mixin\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$nil?', '$to_ast', '$type', '$respond_to?', '$send', '$handler_missing', '$map', '$to_a', '$process']);\n  return (function($base, $parent_nesting) {\n    var $AST, self = $AST = $module($base, 'AST');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Processor(){};\n      var self = $Processor = $klass($base, $super, 'Processor', $Processor);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return (function($base, $parent_nesting) {\n        var $Mixin, self = $Mixin = $module($base, 'Mixin');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Mixin_process_1, TMP_Mixin_process_all_3, TMP_Mixin_handler_missing_4;\n\n        \n        \n        Opal.defn(self, '$process', TMP_Mixin_process_1 = function $$process(node) {\n          var self = this, on_handler = nil, new_node = nil;\n\n          \n          if ($truthy(node['$nil?']())) {\n            return nil};\n          node = node.$to_ast();\n          on_handler = \"\" + \"on_\" + (node.$type());\n          if ($truthy(self['$respond_to?'](on_handler))) {\n            new_node = self.$send(on_handler, node)\n            } else {\n            new_node = self.$handler_missing(node)\n          };\n          if ($truthy(new_node)) {\n            node = new_node};\n          return node;\n        }, TMP_Mixin_process_1.$$arity = 1);\n        \n        Opal.defn(self, '$process_all', TMP_Mixin_process_all_3 = function $$process_all(nodes) {\n          var TMP_2, self = this;\n\n          return $send(nodes.$to_a(), 'map', [], (TMP_2 = function(node){var self = TMP_2.$$s || this;\nif (node == null) node = nil;\n          return self.$process(node)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))\n        }, TMP_Mixin_process_all_3.$$arity = 1);\n        \n        Opal.defn(self, '$handler_missing', TMP_Mixin_handler_missing_4 = function $$handler_missing(node) {\n          var self = this;\n\n          return nil\n        }, TMP_Mixin_handler_missing_4.$$arity = 1);\n      })($nesting[0], $nesting)\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"ast/processor\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$require', '$include']);\n  return (function($base, $parent_nesting) {\n    var $AST, self = $AST = $module($base, 'AST');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Processor(){};\n      var self = $Processor = $klass($base, $super, 'Processor', $Processor);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$require(\"ast/processor/mixin\");\n      return self.$include(Opal.const_get_relative($nesting, 'Mixin'));\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"ast/sexp\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;\n\n  Opal.add_stubs(['$new']);\n  return (function($base, $parent_nesting) {\n    var $AST, self = $AST = $module($base, 'AST');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Sexp, self = $Sexp = $module($base, 'Sexp');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Sexp_s_1;\n\n      \n      Opal.defn(self, '$s', TMP_Sexp_s_1 = function $$s(type, $a_rest) {\n        var self = this, children;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        children = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          children[$arg_idx - 1] = arguments[$arg_idx];\n        }\n        return Opal.const_get_relative($nesting, 'Node').$new(type, children)\n      }, TMP_Sexp_s_1.$$arity = -2)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"ast\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;\n\n  Opal.add_stubs(['$require']);\n  return (function($base, $parent_nesting) {\n    var $AST, self = $AST = $module($base, 'AST');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    self.$require(\"ast/node\");\n    self.$require(\"ast/processor\");\n    self.$require(\"ast/sexp\");\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/ast/node\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$[]', '$frozen?', '$dup', '$node=', '$-']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $AST, self = $AST = $module($base, 'AST');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Node(){};\n        var self = $Node = $klass($base, $super, 'Node', $Node);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Node_assign_properties_1;\n\n        \n        self.$attr_reader(\"location\");\n        Opal.alias(self, \"loc\", \"location\");\n        return (Opal.defn(self, '$assign_properties', TMP_Node_assign_properties_1 = function $$assign_properties(properties) {\n          var self = this, location = nil, $writer = nil;\n\n          if ($truthy((location = properties['$[]'](\"location\")))) {\n            \n            if ($truthy(location['$frozen?']())) {\n              location = location.$dup()};\n            \n            $writer = [self];\n            $send(location, 'node=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            return (self.location = location);\n            } else {\n            return nil\n          }\n        }, TMP_Node_assign_properties_1.$$arity = 1), nil) && 'assign_properties';\n      })($nesting[0], Opal.const_get_qualified(Opal.const_get_qualified('::', 'AST'), 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/ast/node\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$attr_reader', '$[]', '$frozen?', '$dup', '$merge!', '$loc', '$line', '$column']);\n  \n  self.$require(\"ast\");\n  self.$require(\"parser/ast/node\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $AST, self = $AST = $module($base, 'AST');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Node(){};\n        var self = $Node = $klass($base, $super, 'Node', $Node);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Node_assign_properties_1, TMP_Node_line_2, TMP_Node_column_3;\n\n        def.meta = nil;\n        \n        self.$attr_reader(\"meta\");\n        \n        Opal.defn(self, '$assign_properties', TMP_Node_assign_properties_1 = function $$assign_properties(properties) {\n          var $a, self = this, $iter = TMP_Node_assign_properties_1.$$p, $yield = $iter || nil, meta = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_Node_assign_properties_1.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          if ($truthy((meta = properties['$[]'](\"meta\")))) {\n            \n            if ($truthy(meta['$frozen?']())) {\n              meta = meta.$dup()};\n            self.meta['$merge!'](meta);\n            } else {\n            self.meta = ($truthy($a = self.meta) ? $a : $hash2([], {}))\n          };\n          return $send(self, Opal.find_super_dispatcher(self, 'assign_properties', TMP_Node_assign_properties_1, false), $zuper, $iter);\n        }, TMP_Node_assign_properties_1.$$arity = 1);\n        \n        Opal.defn(self, '$line', TMP_Node_line_2 = function $$line() {\n          var self = this;\n\n          if ($truthy(self.$loc())) {\n            return self.$loc().$line()\n            } else {\n            return nil\n          }\n        }, TMP_Node_line_2.$$arity = 0);\n        return (Opal.defn(self, '$column', TMP_Node_column_3 = function $$column() {\n          var self = this;\n\n          if ($truthy(self.$loc())) {\n            return self.$loc().$column()\n            } else {\n            return nil\n          }\n        }, TMP_Node_column_3.$$arity = 0), nil) && 'column';\n      })($nesting[0], Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Parser'), 'AST'), 'Node'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"racc/parser\"] = function(Opal) {\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  var $a, self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send;\n\n  Opal.add_stubs(['$[]', '$class', '$<', '$size', '$[]=', '$-', '$__send__', '$_racc_setup', '$raise', '$_racc_init_sysvars', '$catch', '$!=', '$next_token', '$racc_read_token', '$+', '$>=', '$==', '$_racc_evalact', '$!', '$>', '$push', '$racc_shift', '$-@', '$_racc_do_reduce', '$===', '$racc_accept', '$throw', '$on_error', '$<=', '$pop', '$racc_e_pop', '$inspect', '$racc_next_state', '$*', '$racc_reduce', '$sprintf', '$token_to_str', '$print', '$racc_token2str', '$puts', '$racc_print_stacks', '$empty?', '$each', '$racc_print_states', '$each_index']);\n  \n  (function($base, $parent_nesting) {\n    var $Racc, self = $Racc = $module($base, 'Racc');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $ParseError(){};\n      var self = $ParseError = $klass($base, $super, 'ParseError', $ParseError);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return nil\n    })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting)\n  })($nesting[0], $nesting);\n  if ($truthy((($a = Opal.const_get_qualified('::', 'ParseError', 'skip_raise')) ? 'constant' : nil))) {\n    } else {\n    Opal.const_set($nesting[0], 'ParseError', Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Racc'), 'ParseError'))\n  };\n  return (function($base, $parent_nesting) {\n    var $Racc, self = $Racc = $module($base, 'Racc');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), $a;\n\n    \n    if ($truthy((($a = Opal.const_get_relative($nesting, 'Racc_No_Extensions', 'skip_raise')) ? 'constant' : nil))) {\n      } else {\n      Opal.const_set($nesting[0], 'Racc_No_Extensions', false)\n    };\n    (function($base, $super, $parent_nesting) {\n      function $Parser(){};\n      var self = $Parser = $klass($base, $super, 'Parser', $Parser);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Parser_racc_runtime_type_1, TMP_Parser__racc_setup_2, TMP_Parser__racc_init_sysvars_3, TMP_Parser_do_parse_4, TMP_Parser_next_token_5, TMP_Parser__racc_do_parse_rb_7, TMP_Parser_yyparse_8, TMP_Parser__racc_yyparse_rb_11, TMP_Parser__racc_evalact_13, TMP_Parser__racc_do_reduce_14, TMP_Parser_on_error_15, TMP_Parser_yyerror_16, TMP_Parser_yyaccept_17, TMP_Parser_yyerrok_18, TMP_Parser_racc_read_token_19, TMP_Parser_racc_shift_20, TMP_Parser_racc_reduce_22, TMP_Parser_racc_accept_23, TMP_Parser_racc_e_pop_24, TMP_Parser_racc_next_state_25, TMP_Parser_racc_print_stacks_27, TMP_Parser_racc_print_states_29, TMP_Parser_racc_token2str_30, TMP_Parser_token_to_str_31;\n\n      def.yydebug = def.racc_debug_out = def.racc_error_status = def.racc_t = def.racc_vstack = def.racc_val = def.racc_state = def.racc_tstack = nil;\n      \n      Opal.const_set($nesting[0], 'Racc_Runtime_Version', \"1.4.6\");\n      Opal.const_set($nesting[0], 'Racc_Runtime_Revision', [\"originalRevision:\", \"1.8\"]['$[]'](1));\n      Opal.const_set($nesting[0], 'Racc_Runtime_Core_Version_R', \"1.4.6\");\n      Opal.const_set($nesting[0], 'Racc_Runtime_Core_Revision_R', [\"originalRevision:\", \"1.8\"]['$[]'](1));\n      Opal.const_set($nesting[0], 'Racc_Main_Parsing_Routine', \"_racc_do_parse_rb\");\n      Opal.const_set($nesting[0], 'Racc_YY_Parse_Method', \"_racc_yyparse_rb\");\n      Opal.const_set($nesting[0], 'Racc_Runtime_Core_Version', Opal.const_get_relative($nesting, 'Racc_Runtime_Core_Version_R'));\n      Opal.const_set($nesting[0], 'Racc_Runtime_Core_Revision', Opal.const_get_relative($nesting, 'Racc_Runtime_Core_Revision_R'));\n      Opal.const_set($nesting[0], 'Racc_Runtime_Type', \"ruby\");\n      Opal.defs(Opal.const_get_relative($nesting, 'Parser'), '$racc_runtime_type', TMP_Parser_racc_runtime_type_1 = function $$racc_runtime_type() {\n        var self = this;\n\n        return Opal.const_get_relative($nesting, 'Racc_Runtime_Type')\n      }, TMP_Parser_racc_runtime_type_1.$$arity = 0);\n      \n      Opal.defn(self, '$_racc_setup', TMP_Parser__racc_setup_2 = function $$_racc_setup() {\n        var $a, $b, $c, self = this, arg = nil, $writer = nil;\n        if ($gvars.stderr == null) $gvars.stderr = nil;\n\n        \n        if ($truthy(Opal.const_get_qualified(self.$class(), 'Racc_debug_parser'))) {\n          } else {\n          self.yydebug = false\n        };\n        if ($truthy((($a = self['yydebug'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {\n          } else {\n          self.yydebug = false\n        };\n        if ($truthy(self.yydebug)) {\n          \n          if ($truthy((($b = self['racc_debug_out'], $b != null && $b !== nil) ? 'instance-variable' : nil))) {\n            } else {\n            self.racc_debug_out = $gvars.stderr\n          };\n          self.racc_debug_out = ($truthy($c = self.racc_debug_out) ? $c : $gvars.stderr);};\n        arg = Opal.const_get_qualified(self.$class(), 'Racc_arg');\n        if ($truthy($rb_lt(arg.$size(), 14))) {\n          \n          $writer = [13, true];\n          $send(arg, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        return arg;\n      }, TMP_Parser__racc_setup_2.$$arity = 0);\n      \n      Opal.defn(self, '$_racc_init_sysvars', TMP_Parser__racc_init_sysvars_3 = function $$_racc_init_sysvars() {\n        var self = this;\n\n        \n        self.racc_state = [0];\n        self.racc_tstack = [];\n        self.racc_vstack = [];\n        self.racc_t = nil;\n        self.racc_val = nil;\n        self.racc_read_next = true;\n        self.racc_user_yyerror = false;\n        return (self.racc_error_status = 0);\n      }, TMP_Parser__racc_init_sysvars_3.$$arity = 0);\n      \n      Opal.defn(self, '$do_parse', TMP_Parser_do_parse_4 = function $$do_parse() {\n        var self = this;\n\n        return self.$__send__(Opal.const_get_relative($nesting, 'Racc_Main_Parsing_Routine'), self.$_racc_setup(), false)\n      }, TMP_Parser_do_parse_4.$$arity = 0);\n      \n      Opal.defn(self, '$next_token', TMP_Parser_next_token_5 = function $$next_token() {\n        var self = this;\n\n        return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), \"\" + (self.$class()) + \"#next_token is not defined\")\n      }, TMP_Parser_next_token_5.$$arity = 0);\n      \n      Opal.defn(self, '$_racc_do_parse_rb', TMP_Parser__racc_do_parse_rb_7 = function $$_racc_do_parse_rb(arg, in_debug) {\n        var $a, $b, TMP_6, self = this, action_table = nil, action_check = nil, action_default = nil, action_pointer = nil, _ = nil, token_table = nil, tok = nil, act = nil, i = nil;\n\n        \n        $b = arg, $a = Opal.to_ary($b), (action_table = ($a[0] == null ? nil : $a[0])), (action_check = ($a[1] == null ? nil : $a[1])), (action_default = ($a[2] == null ? nil : $a[2])), (action_pointer = ($a[3] == null ? nil : $a[3])), (_ = ($a[4] == null ? nil : $a[4])), (_ = ($a[5] == null ? nil : $a[5])), (_ = ($a[6] == null ? nil : $a[6])), (_ = ($a[7] == null ? nil : $a[7])), (_ = ($a[8] == null ? nil : $a[8])), (_ = ($a[9] == null ? nil : $a[9])), (token_table = ($a[10] == null ? nil : $a[10])), (_ = ($a[11] == null ? nil : $a[11])), (_ = ($a[12] == null ? nil : $a[12])), (_ = ($a[13] == null ? nil : $a[13])), $b;\n        self.$_racc_init_sysvars();\n        tok = (act = (i = nil));\n        return $send(self, 'catch', [\"racc_end_parse\"], (TMP_6 = function(){var self = TMP_6.$$s || this, $c, $d, $e;\n          if (self.racc_state == null) self.racc_state = nil;\n          if (self.racc_read_next == null) self.racc_read_next = nil;\n          if (self.racc_t == null) self.racc_t = nil;\n          if (self.yydebug == null) self.yydebug = nil;\n          if (self.racc_val == null) self.racc_val = nil;\n\n        while ($truthy(true)) {\n            \n            if ($truthy((i = action_pointer['$[]'](self.racc_state['$[]'](-1))))) {\n              \n              if ($truthy(self.racc_read_next)) {\n                if ($truthy(self.racc_t['$!='](0))) {\n                  \n                  $e = self.$next_token(), $d = Opal.to_ary($e), (tok = ($d[0] == null ? nil : $d[0])), (self.racc_val = ($d[1] == null ? nil : $d[1])), $e;\n                  if ($truthy(tok)) {\n                    self.racc_t = ($truthy($d = token_table['$[]'](tok)) ? $d : 1)\n                    } else {\n                    self.racc_t = 0\n                  };\n                  if ($truthy(self.yydebug)) {\n                    self.$racc_read_token(self.racc_t, tok, self.racc_val)};\n                  self.racc_read_next = false;}};\n              i = $rb_plus(i, self.racc_t);\n              if ($truthy(($truthy($d = ($truthy($e = $rb_ge(i, 0)) ? (act = action_table['$[]'](i)) : $e)) ? action_check['$[]'](i)['$=='](self.racc_state['$[]'](-1)) : $d))) {\n                } else {\n                act = action_default['$[]'](self.racc_state['$[]'](-1))\n              };\n              } else {\n              act = action_default['$[]'](self.racc_state['$[]'](-1))\n            };\n            while ($truthy((act = self.$_racc_evalact(act, arg)))) {\n              \n            };\n          }}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6));\n      }, TMP_Parser__racc_do_parse_rb_7.$$arity = 2);\n      \n      Opal.defn(self, '$yyparse', TMP_Parser_yyparse_8 = function $$yyparse(recv, mid) {\n        var self = this;\n\n        return self.$__send__(Opal.const_get_relative($nesting, 'Racc_YY_Parse_Method'), recv, mid, self.$_racc_setup(), true)\n      }, TMP_Parser_yyparse_8.$$arity = 2);\n      \n      Opal.defn(self, '$_racc_yyparse_rb', TMP_Parser__racc_yyparse_rb_11 = function $$_racc_yyparse_rb(recv, mid, arg, c_debug) {\n        var $a, $b, TMP_9, self = this, action_table = nil, action_check = nil, action_default = nil, action_pointer = nil, _ = nil, token_table = nil, act = nil, i = nil;\n\n        \n        $b = arg, $a = Opal.to_ary($b), (action_table = ($a[0] == null ? nil : $a[0])), (action_check = ($a[1] == null ? nil : $a[1])), (action_default = ($a[2] == null ? nil : $a[2])), (action_pointer = ($a[3] == null ? nil : $a[3])), (_ = ($a[4] == null ? nil : $a[4])), (_ = ($a[5] == null ? nil : $a[5])), (_ = ($a[6] == null ? nil : $a[6])), (_ = ($a[7] == null ? nil : $a[7])), (_ = ($a[8] == null ? nil : $a[8])), (_ = ($a[9] == null ? nil : $a[9])), (token_table = ($a[10] == null ? nil : $a[10])), (_ = ($a[11] == null ? nil : $a[11])), (_ = ($a[12] == null ? nil : $a[12])), (_ = ($a[13] == null ? nil : $a[13])), $b;\n        self.$_racc_init_sysvars();\n        act = nil;\n        i = nil;\n        return $send(self, 'catch', [\"racc_end_parse\"], (TMP_9 = function(){var self = TMP_9.$$s || this, $c, $d, TMP_10;\n          if (self.racc_state == null) self.racc_state = nil;\n\n        \n          while (!($truthy((i = action_pointer['$[]'](self.racc_state['$[]'](-1)))))) {\n            while ($truthy((act = self.$_racc_evalact(action_default['$[]'](self.racc_state['$[]'](-1)), arg)))) {\n              \n            }\n          };\n          return $send(recv, '__send__', [mid], (TMP_10 = function(tok, val){var self = TMP_10.$$s || this, $e, $f, $g, $h, $i;\n            if (self.racc_t == null) self.racc_t = nil;\n            if (self.racc_state == null) self.racc_state = nil;\n            if (self.racc_read_next == null) self.racc_read_next = nil;\nif (tok == null) tok = nil;if (val == null) val = nil;\n          \n            if ($truthy(tok)) {\n              self.racc_t = ($truthy($e = token_table['$[]'](tok)) ? $e : 1)\n              } else {\n              self.racc_t = 0\n            };\n            self.racc_val = val;\n            self.racc_read_next = false;\n            i = $rb_plus(i, self.racc_t);\n            if ($truthy(($truthy($e = ($truthy($f = $rb_ge(i, 0)) ? (act = action_table['$[]'](i)) : $f)) ? action_check['$[]'](i)['$=='](self.racc_state['$[]'](-1)) : $e))) {\n              } else {\n              act = action_default['$[]'](self.racc_state['$[]'](-1))\n            };\n            while ($truthy((act = self.$_racc_evalact(act, arg)))) {\n              \n            };\n            while ($truthy(($truthy($f = ($truthy($g = (i = action_pointer['$[]'](self.racc_state['$[]'](-1)))['$!']()) ? $g : self.racc_read_next['$!']())) ? $f : self.racc_t['$=='](0)))) {\n              \n              if ($truthy(($truthy($f = ($truthy($g = ($truthy($h = ($truthy($i = i) ? (i = $rb_plus(i, self.racc_t)) : $i)) ? $rb_ge(i, 0) : $h)) ? (act = action_table['$[]'](i)) : $g)) ? action_check['$[]'](i)['$=='](self.racc_state['$[]'](-1)) : $f))) {\n                } else {\n                act = action_default['$[]'](self.racc_state['$[]'](-1))\n              };\n              while ($truthy((act = self.$_racc_evalact(act, arg)))) {\n                \n              };\n            };}, TMP_10.$$s = self, TMP_10.$$arity = 2, TMP_10));}, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9));\n      }, TMP_Parser__racc_yyparse_rb_11.$$arity = 4);\n      \n      Opal.defn(self, '$_racc_evalact', TMP_Parser__racc_evalact_13 = function $$_racc_evalact(act, arg) {\n        var $a, $b, TMP_12, $c, self = this, action_table = nil, action_check = nil, _ = nil, action_pointer = nil, shift_n = nil, reduce_n = nil, code = nil, $case = nil, i = nil;\n\n        \n        $b = arg, $a = Opal.to_ary($b), (action_table = ($a[0] == null ? nil : $a[0])), (action_check = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), (action_pointer = ($a[3] == null ? nil : $a[3])), (_ = ($a[4] == null ? nil : $a[4])), (_ = ($a[5] == null ? nil : $a[5])), (_ = ($a[6] == null ? nil : $a[6])), (_ = ($a[7] == null ? nil : $a[7])), (_ = ($a[8] == null ? nil : $a[8])), (_ = ($a[9] == null ? nil : $a[9])), (_ = ($a[10] == null ? nil : $a[10])), (shift_n = ($a[11] == null ? nil : $a[11])), (reduce_n = ($a[12] == null ? nil : $a[12])), (_ = ($a[13] == null ? nil : $a[13])), (_ = ($a[14] == null ? nil : $a[14])), $b;\n        if ($truthy(($truthy($a = $rb_gt(act, 0)) ? $rb_lt(act, shift_n) : $a))) {\n          \n          if ($truthy($rb_gt(self.racc_error_status, 0))) {\n            if (self.racc_t['$=='](1)) {\n              } else {\n              self.racc_error_status = $rb_minus(self.racc_error_status, 1)\n            }};\n          self.racc_vstack.$push(self.racc_val);\n          self.racc_state.$push(act);\n          self.racc_read_next = true;\n          if ($truthy(self.yydebug)) {\n            \n            self.racc_tstack.$push(self.racc_t);\n            self.$racc_shift(self.racc_t, self.racc_tstack, self.racc_vstack);};\n        } else if ($truthy(($truthy($a = $rb_lt(act, 0)) ? $rb_gt(act, reduce_n['$-@']()) : $a))) {\n          \n          code = $send(self, 'catch', [\"racc_jump\"], (TMP_12 = function(){var self = TMP_12.$$s || this;\n            if (self.racc_state == null) self.racc_state = nil;\n\n          \n            self.racc_state.$push(self.$_racc_do_reduce(arg, act));\n            return false;}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12));\n          if ($truthy(code)) {\n            $case = code;\n            if ((1)['$===']($case)) {\n            self.racc_user_yyerror = true;\n            return reduce_n['$-@']();}\n            else if ((2)['$===']($case)) {return shift_n}\n            else {self.$raise(\"[Racc Bug] unknown jump code\")}};\n        } else if (act['$=='](shift_n)) {\n          \n          if ($truthy(self.yydebug)) {\n            self.$racc_accept()};\n          self.$throw(\"racc_end_parse\", self.racc_vstack['$[]'](0));\n        } else if (act['$=='](reduce_n['$-@']())) {\n          \n          $case = self.racc_error_status;\n          if ((0)['$===']($case)) {if ($truthy(arg['$[]'](21))) {\n            } else {\n            self.$on_error(self.racc_t, self.racc_val, self.racc_vstack)\n          }}\n          else if ((3)['$===']($case)) {\n          if (self.racc_t['$=='](0)) {\n            self.$throw(\"racc_end_parse\", nil)};\n          self.racc_read_next = true;};\n          self.racc_user_yyerror = false;\n          self.racc_error_status = 3;\n          while ($truthy(true)) {\n            \n            if ($truthy((i = action_pointer['$[]'](self.racc_state['$[]'](-1))))) {\n              \n              i = $rb_plus(i, 1);\n              if ($truthy(($truthy($b = ($truthy($c = $rb_ge(i, 0)) ? (act = action_table['$[]'](i)) : $c)) ? action_check['$[]'](i)['$=='](self.racc_state['$[]'](-1)) : $b))) {\n                break;};};\n            if ($truthy($rb_le(self.racc_state.$size(), 1))) {\n              self.$throw(\"racc_end_parse\", nil)};\n            self.racc_state.$pop();\n            self.racc_vstack.$pop();\n            if ($truthy(self.yydebug)) {\n              \n              self.racc_tstack.$pop();\n              self.$racc_e_pop(self.racc_state, self.racc_tstack, self.racc_vstack);};\n          };\n          return act;\n          } else {\n          self.$raise(\"\" + \"[Racc Bug] unknown action \" + (act.$inspect()))\n        };\n        if ($truthy(self.yydebug)) {\n          self.$racc_next_state(self.racc_state['$[]'](-1), self.racc_state)};\n        return nil;\n      }, TMP_Parser__racc_evalact_13.$$arity = 2);\n      \n      Opal.defn(self, '$_racc_do_reduce', TMP_Parser__racc_do_reduce_14 = function $$_racc_do_reduce(arg, act) {\n        var $a, $b, self = this, _ = nil, goto_table = nil, goto_check = nil, goto_default = nil, goto_pointer = nil, nt_base = nil, reduce_table = nil, use_result = nil, state = nil, vstack = nil, tstack = nil, i = nil, len = nil, reduce_to = nil, method_id = nil, void_array = nil, tmp_t = nil, tmp_v = nil, $writer = nil, k1 = nil, curstate = nil;\n\n        \n        $b = arg, $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), (_ = ($a[3] == null ? nil : $a[3])), (goto_table = ($a[4] == null ? nil : $a[4])), (goto_check = ($a[5] == null ? nil : $a[5])), (goto_default = ($a[6] == null ? nil : $a[6])), (goto_pointer = ($a[7] == null ? nil : $a[7])), (nt_base = ($a[8] == null ? nil : $a[8])), (reduce_table = ($a[9] == null ? nil : $a[9])), (_ = ($a[10] == null ? nil : $a[10])), (_ = ($a[11] == null ? nil : $a[11])), (_ = ($a[12] == null ? nil : $a[12])), (use_result = ($a[13] == null ? nil : $a[13])), $b;\n        state = self.racc_state;\n        vstack = self.racc_vstack;\n        tstack = self.racc_tstack;\n        i = $rb_times(act, -3);\n        len = reduce_table['$[]'](i);\n        reduce_to = reduce_table['$[]']($rb_plus(i, 1));\n        method_id = reduce_table['$[]']($rb_plus(i, 2));\n        void_array = [];\n        if ($truthy(self.yydebug)) {\n          tmp_t = tstack['$[]'](len['$-@'](), len)};\n        tmp_v = vstack['$[]'](len['$-@'](), len);\n        if ($truthy(self.yydebug)) {\n          \n          $writer = [len['$-@'](), len, void_array];\n          $send(tstack, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        \n        $writer = [len['$-@'](), len, void_array];\n        $send(vstack, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [len['$-@'](), len, void_array];\n        $send(state, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        if ($truthy(use_result)) {\n          vstack.$push(self.$__send__(method_id, tmp_v, vstack, tmp_v['$[]'](0)))\n          } else {\n          vstack.$push(self.$__send__(method_id, tmp_v, vstack))\n        };\n        tstack.$push(reduce_to);\n        if ($truthy(self.yydebug)) {\n          self.$racc_reduce(tmp_t, reduce_to, tstack, vstack)};\n        k1 = $rb_minus(reduce_to, nt_base);\n        if ($truthy((i = goto_pointer['$[]'](k1)))) {\n          \n          i = $rb_plus(i, state['$[]'](-1));\n          if ($truthy(($truthy($a = ($truthy($b = $rb_ge(i, 0)) ? (curstate = goto_table['$[]'](i)) : $b)) ? goto_check['$[]'](i)['$=='](k1) : $a))) {\n            return curstate};};\n        return goto_default['$[]'](k1);\n      }, TMP_Parser__racc_do_reduce_14.$$arity = 2);\n      \n      Opal.defn(self, '$on_error', TMP_Parser_on_error_15 = function $$on_error(t, val, vstack) {\n        var $a, self = this;\n\n        return self.$raise(Opal.const_get_relative($nesting, 'ParseError'), self.$sprintf(\"\\nparse error on value %s (%s)\", val.$inspect(), ($truthy($a = self.$token_to_str(t)) ? $a : \"?\")))\n      }, TMP_Parser_on_error_15.$$arity = 3);\n      \n      Opal.defn(self, '$yyerror', TMP_Parser_yyerror_16 = function $$yyerror() {\n        var self = this;\n\n        return self.$throw(\"racc_jump\", 1)\n      }, TMP_Parser_yyerror_16.$$arity = 0);\n      \n      Opal.defn(self, '$yyaccept', TMP_Parser_yyaccept_17 = function $$yyaccept() {\n        var self = this;\n\n        return self.$throw(\"racc_jump\", 2)\n      }, TMP_Parser_yyaccept_17.$$arity = 0);\n      \n      Opal.defn(self, '$yyerrok', TMP_Parser_yyerrok_18 = function $$yyerrok() {\n        var self = this;\n\n        return (self.racc_error_status = 0)\n      }, TMP_Parser_yyerrok_18.$$arity = 0);\n      \n      Opal.defn(self, '$racc_read_token', TMP_Parser_racc_read_token_19 = function $$racc_read_token(t, tok, val) {\n        var self = this;\n\n        \n        self.racc_debug_out.$print(\"read    \");\n        self.racc_debug_out.$print(tok.$inspect(), \"(\", self.$racc_token2str(t), \") \");\n        self.racc_debug_out.$puts(val.$inspect());\n        return self.racc_debug_out.$puts();\n      }, TMP_Parser_racc_read_token_19.$$arity = 3);\n      \n      Opal.defn(self, '$racc_shift', TMP_Parser_racc_shift_20 = function $$racc_shift(tok, tstack, vstack) {\n        var self = this;\n\n        \n        self.racc_debug_out.$puts(\"\" + \"shift   \" + (self.$racc_token2str(tok)));\n        self.$racc_print_stacks(tstack, vstack);\n        return self.racc_debug_out.$puts();\n      }, TMP_Parser_racc_shift_20.$$arity = 3);\n      \n      Opal.defn(self, '$racc_reduce', TMP_Parser_racc_reduce_22 = function $$racc_reduce(toks, sim, tstack, vstack) {\n        var TMP_21, self = this, out = nil;\n\n        \n        out = self.racc_debug_out;\n        out.$print(\"reduce \");\n        if ($truthy(toks['$empty?']())) {\n          out.$print(\" <none>\")\n          } else {\n          $send(toks, 'each', [], (TMP_21 = function(t){var self = TMP_21.$$s || this;\nif (t == null) t = nil;\n          return out.$print(\" \", self.$racc_token2str(t))}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21))\n        };\n        out.$puts(\"\" + \" --> \" + (self.$racc_token2str(sim)));\n        self.$racc_print_stacks(tstack, vstack);\n        return self.racc_debug_out.$puts();\n      }, TMP_Parser_racc_reduce_22.$$arity = 4);\n      \n      Opal.defn(self, '$racc_accept', TMP_Parser_racc_accept_23 = function $$racc_accept() {\n        var self = this;\n\n        \n        self.racc_debug_out.$puts(\"accept\");\n        return self.racc_debug_out.$puts();\n      }, TMP_Parser_racc_accept_23.$$arity = 0);\n      \n      Opal.defn(self, '$racc_e_pop', TMP_Parser_racc_e_pop_24 = function $$racc_e_pop(state, tstack, vstack) {\n        var self = this;\n\n        \n        self.racc_debug_out.$puts(\"error recovering mode: pop token\");\n        self.$racc_print_states(state);\n        self.$racc_print_stacks(tstack, vstack);\n        return self.racc_debug_out.$puts();\n      }, TMP_Parser_racc_e_pop_24.$$arity = 3);\n      \n      Opal.defn(self, '$racc_next_state', TMP_Parser_racc_next_state_25 = function $$racc_next_state(curstate, state) {\n        var self = this;\n\n        \n        self.racc_debug_out.$puts(\"\" + \"goto    \" + (curstate));\n        self.$racc_print_states(state);\n        return self.racc_debug_out.$puts();\n      }, TMP_Parser_racc_next_state_25.$$arity = 2);\n      \n      Opal.defn(self, '$racc_print_stacks', TMP_Parser_racc_print_stacks_27 = function $$racc_print_stacks(t, v) {\n        var TMP_26, self = this, out = nil;\n\n        \n        out = self.racc_debug_out;\n        out.$print(\"        [\");\n        $send(t, 'each_index', [], (TMP_26 = function(i){var self = TMP_26.$$s || this;\nif (i == null) i = nil;\n        return out.$print(\" (\", self.$racc_token2str(t['$[]'](i)), \" \", v['$[]'](i).$inspect(), \")\")}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26));\n        return out.$puts(\" ]\");\n      }, TMP_Parser_racc_print_stacks_27.$$arity = 2);\n      \n      Opal.defn(self, '$racc_print_states', TMP_Parser_racc_print_states_29 = function $$racc_print_states(s) {\n        var TMP_28, self = this, out = nil;\n\n        \n        out = self.racc_debug_out;\n        out.$print(\"        [\");\n        $send(s, 'each', [], (TMP_28 = function(st){var self = TMP_28.$$s || this;\nif (st == null) st = nil;\n        return out.$print(\" \", st)}, TMP_28.$$s = self, TMP_28.$$arity = 1, TMP_28));\n        return out.$puts(\" ]\");\n      }, TMP_Parser_racc_print_states_29.$$arity = 1);\n      \n      Opal.defn(self, '$racc_token2str', TMP_Parser_racc_token2str_30 = function $$racc_token2str(tok) {\n        var $a, self = this;\n\n        return ($truthy($a = Opal.const_get_qualified(self.$class(), 'Racc_token_to_s_table')['$[]'](tok)) ? $a : self.$raise(\"\" + \"[Racc Bug] can't convert token \" + (tok) + \" to string\"))\n      }, TMP_Parser_racc_token2str_30.$$arity = 1);\n      return (Opal.defn(self, '$token_to_str', TMP_Parser_token_to_str_31 = function $$token_to_str(t) {\n        var self = this;\n\n        return Opal.const_get_qualified(self.$class(), 'Racc_token_to_s_table')['$[]'](t)\n      }, TMP_Parser_token_to_str_31.$$arity = 1), nil) && 'token_to_str';\n    })($nesting[0], null, $nesting);\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/compatibility/ruby1_8\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$is_a?', '$gsub', '$[]', '$to_sym', '$original_percent']);\n  return (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_$_2;\n\n    \n    Opal.alias(self, \"original_percent\", \"%\");\n    return (Opal.defn(self, '$%', TMP_String_$_2 = function(arg, $a_rest) {\n      var TMP_1, self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($truthy(arg['$is_a?'](Opal.const_get_relative($nesting, 'Hash')))) {\n        return $send(self, 'gsub', [/%\\{(\\w+)\\}/], (TMP_1 = function(){var self = TMP_1.$$s || this, $a;\n\n        return arg['$[]']((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$to_sym())}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1))\n        } else {\n        return $send(self, 'original_percent', [arg].concat(Opal.to_a(args)))\n      }\n    }, TMP_String_$_2.$$arity = -2), nil) && '%';\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/compatibility/ruby1_9\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $truthy = Opal.truthy, $klass = Opal.klass;\n\n  Opal.add_stubs(['$method_defined?', '$to_enum', '$-', '$size', '$<=', '$div', '$+', '$[]', '$===', '$==', '$<', '$fail', '$class']);\n  if ($truthy(Opal.const_get_relative($nesting, 'Array')['$method_defined?'](\"bsearch\"))) {\n    return nil\n    } else {\n    return (function($base, $super, $parent_nesting) {\n      function $Array(){};\n      var self = $Array = $klass($base, $super, 'Array', $Array);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_bsearch_1;\n\n      return (Opal.defn(self, '$bsearch', TMP_Array_bsearch_1 = function $$bsearch() {\n        var $a, self = this, $iter = TMP_Array_bsearch_1.$$p, $yield = $iter || nil, from = nil, to = nil, satisfied = nil, midpoint = nil, result = nil, cur = nil, $case = nil;\n\n        if ($iter) TMP_Array_bsearch_1.$$p = null;\n        \n        if (($yield !== nil)) {\n          } else {\n          return self.$to_enum(\"bsearch\")\n        };\n        from = 0;\n        to = $rb_minus(self.$size(), 1);\n        satisfied = nil;\n        while ($truthy($rb_le(from, to))) {\n          \n          midpoint = $rb_plus(from, to).$div(2);\n          result = Opal.yield1($yield, (cur = self['$[]'](midpoint)));\n          $case = result;\n          if (Opal.const_get_relative($nesting, 'Numeric')['$===']($case)) {\n          if (result['$=='](0)) {\n            return cur};\n          result = $rb_lt(result, 0);}\n          else if (true['$===']($case)) {satisfied = cur}\n          else if (nil['$===']($case) || false['$===']($case)) {nil}\n          else {self.$fail(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"wrong argument type \" + (result.$class()) + \" (must be numeric, true, false or nil)\")};\n          if ($truthy(result)) {\n            to = $rb_minus(midpoint, 1)\n            } else {\n            from = $rb_plus(midpoint, 1)\n          };\n        };\n        return satisfied;\n      }, TMP_Array_bsearch_1.$$arity = 0), nil) && 'bsearch'\n    })($nesting[0], null, $nesting)\n  }\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/version\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;\n\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    Opal.const_set($nesting[0], 'VERSION', \"2.3.3.1\")\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/messages\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$freeze']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    Opal.const_set($nesting[0], 'MESSAGES', $hash2([\"unicode_point_too_large\", \"invalid_escape\", \"incomplete_escape\", \"invalid_hex_escape\", \"invalid_unicode_escape\", \"unterminated_unicode\", \"escape_eof\", \"string_eof\", \"regexp_options\", \"cvar_name\", \"ivar_name\", \"trailing_in_number\", \"empty_numeric\", \"invalid_octal\", \"no_dot_digit_literal\", \"bare_backslash\", \"unexpected\", \"embedded_document\", \"invalid_escape_use\", \"ambiguous_literal\", \"ambiguous_prefix\", \"nth_ref_alias\", \"begin_in_method\", \"backref_assignment\", \"invalid_assignment\", \"module_name_const\", \"unexpected_token\", \"argument_const\", \"argument_ivar\", \"argument_gvar\", \"argument_cvar\", \"duplicate_argument\", \"empty_symbol\", \"odd_hash\", \"singleton_literal\", \"dynamic_const\", \"const_reassignment\", \"module_in_def\", \"class_in_def\", \"unexpected_percent_str\", \"block_and_blockarg\", \"masgn_as_condition\", \"block_given_to_yield\", \"invalid_regexp\", \"useless_else\", \"invalid_encoding\", \"invalid_action\", \"clobbered\"], {\"unicode_point_too_large\": \"invalid Unicode codepoint (too large)\", \"invalid_escape\": \"invalid escape character syntax\", \"incomplete_escape\": \"incomplete character syntax\", \"invalid_hex_escape\": \"invalid hex escape\", \"invalid_unicode_escape\": \"invalid Unicode escape\", \"unterminated_unicode\": \"unterminated Unicode escape\", \"escape_eof\": \"escape sequence meets end of file\", \"string_eof\": \"unterminated string meets end of file\", \"regexp_options\": \"unknown regexp options: %{options}\", \"cvar_name\": \"`%{name}' is not allowed as a class variable name\", \"ivar_name\": \"`%{name}' is not allowed as an instance variable name\", \"trailing_in_number\": \"trailing `%{character}' in number\", \"empty_numeric\": \"numeric literal without digits\", \"invalid_octal\": \"invalid octal digit\", \"no_dot_digit_literal\": \"no .<digit> floating literal anymore; put 0 before dot\", \"bare_backslash\": \"bare backslash only allowed before newline\", \"unexpected\": \"unexpected `%{character}'\", \"embedded_document\": \"embedded document meets end of file (and they embark on a romantic journey)\", \"invalid_escape_use\": \"invalid character syntax; use ?%{escape}\", \"ambiguous_literal\": \"ambiguous first argument; put parentheses or a space even after the operator\", \"ambiguous_prefix\": \"`%{prefix}' interpreted as argument prefix\", \"nth_ref_alias\": \"cannot define an alias for a back-reference variable\", \"begin_in_method\": \"BEGIN in method\", \"backref_assignment\": \"cannot assign to a back-reference variable\", \"invalid_assignment\": \"cannot assign to a keyword\", \"module_name_const\": \"class or module name must be a constant literal\", \"unexpected_token\": \"unexpected token %{token}\", \"argument_const\": \"formal argument cannot be a constant\", \"argument_ivar\": \"formal argument cannot be an instance variable\", \"argument_gvar\": \"formal argument cannot be a global variable\", \"argument_cvar\": \"formal argument cannot be a class variable\", \"duplicate_argument\": \"duplicate argument name\", \"empty_symbol\": \"empty symbol literal\", \"odd_hash\": \"odd number of entries for a hash\", \"singleton_literal\": \"cannot define a singleton method for a literal\", \"dynamic_const\": \"dynamic constant assignment\", \"const_reassignment\": \"constant re-assignment\", \"module_in_def\": \"module definition in method body\", \"class_in_def\": \"class definition in method body\", \"unexpected_percent_str\": \"%{type}: unknown type of percent-literal\", \"block_and_blockarg\": \"both block argument and literal block are passed\", \"masgn_as_condition\": \"multiple assignment in conditional context\", \"block_given_to_yield\": \"block given to yield\", \"invalid_regexp\": \"%{message}\", \"useless_else\": \"else without rescue is useless\", \"invalid_encoding\": \"literal contains escape sequences incompatible with UTF-8\", \"invalid_action\": \"cannot %{action}\", \"clobbered\": \"clobbered by: %{action}\"}).$freeze())\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/ast/processor\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$updated', '$process_all', '$on_var', '$!', '$nil?', '$process', '$on_vasgn', '$on_argument', '$warn']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $AST, self = $AST = $module($base, 'AST');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Processor(){};\n        var self = $Processor = $klass($base, $super, 'Processor', $Processor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Processor_process_regular_node_1, TMP_Processor_on_var_2, TMP_Processor_process_variable_node_3, TMP_Processor_on_vasgn_4, TMP_Processor_process_var_asgn_node_5, TMP_Processor_on_op_asgn_6, TMP_Processor_on_const_7, TMP_Processor_on_casgn_8, TMP_Processor_on_argument_9, TMP_Processor_process_argument_node_10, TMP_Processor_on_def_11, TMP_Processor_on_defs_12, TMP_Processor_on_send_13, TMP_Processor_process_variable_node_14, TMP_Processor_process_var_asgn_node_15, TMP_Processor_process_argument_node_16;\n\n        \n        \n        Opal.defn(self, '$process_regular_node', TMP_Processor_process_regular_node_1 = function $$process_regular_node(node) {\n          var self = this;\n\n          return node.$updated(nil, self.$process_all(node))\n        }, TMP_Processor_process_regular_node_1.$$arity = 1);\n        Opal.alias(self, \"on_dstr\", \"process_regular_node\");\n        Opal.alias(self, \"on_dsym\", \"process_regular_node\");\n        Opal.alias(self, \"on_regexp\", \"process_regular_node\");\n        Opal.alias(self, \"on_xstr\", \"process_regular_node\");\n        Opal.alias(self, \"on_splat\", \"process_regular_node\");\n        Opal.alias(self, \"on_array\", \"process_regular_node\");\n        Opal.alias(self, \"on_pair\", \"process_regular_node\");\n        Opal.alias(self, \"on_hash\", \"process_regular_node\");\n        Opal.alias(self, \"on_irange\", \"process_regular_node\");\n        Opal.alias(self, \"on_erange\", \"process_regular_node\");\n        \n        Opal.defn(self, '$on_var', TMP_Processor_on_var_2 = function $$on_var(node) {\n          var self = this;\n\n          return node\n        }, TMP_Processor_on_var_2.$$arity = 1);\n        \n        Opal.defn(self, '$process_variable_node', TMP_Processor_process_variable_node_3 = function $$process_variable_node(node) {\n          var self = this;\n\n          return self.$on_var(node)\n        }, TMP_Processor_process_variable_node_3.$$arity = 1);\n        Opal.alias(self, \"on_lvar\", \"process_variable_node\");\n        Opal.alias(self, \"on_ivar\", \"process_variable_node\");\n        Opal.alias(self, \"on_gvar\", \"process_variable_node\");\n        Opal.alias(self, \"on_cvar\", \"process_variable_node\");\n        Opal.alias(self, \"on_back_ref\", \"process_variable_node\");\n        Opal.alias(self, \"on_nth_ref\", \"process_variable_node\");\n        \n        Opal.defn(self, '$on_vasgn', TMP_Processor_on_vasgn_4 = function $$on_vasgn(node) {\n          var $a, self = this, name = nil, value_node = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value_node = ($a[1] == null ? nil : $a[1])), $a;\n          if ($truthy(value_node['$nil?']()['$!']())) {\n            return node.$updated(nil, [name, self.$process(value_node)])\n            } else {\n            return node\n          };\n        }, TMP_Processor_on_vasgn_4.$$arity = 1);\n        \n        Opal.defn(self, '$process_var_asgn_node', TMP_Processor_process_var_asgn_node_5 = function $$process_var_asgn_node(node) {\n          var self = this;\n\n          return self.$on_vasgn(node)\n        }, TMP_Processor_process_var_asgn_node_5.$$arity = 1);\n        Opal.alias(self, \"on_lvasgn\", \"process_var_asgn_node\");\n        Opal.alias(self, \"on_ivasgn\", \"process_var_asgn_node\");\n        Opal.alias(self, \"on_gvasgn\", \"process_var_asgn_node\");\n        Opal.alias(self, \"on_cvasgn\", \"process_var_asgn_node\");\n        Opal.alias(self, \"on_and_asgn\", \"process_regular_node\");\n        Opal.alias(self, \"on_or_asgn\", \"process_regular_node\");\n        \n        Opal.defn(self, '$on_op_asgn', TMP_Processor_on_op_asgn_6 = function $$on_op_asgn(node) {\n          var $a, self = this, var_node = nil, method_name = nil, value_node = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (var_node = ($a[0] == null ? nil : $a[0])), (method_name = ($a[1] == null ? nil : $a[1])), (value_node = ($a[2] == null ? nil : $a[2])), $a;\n          return node.$updated(nil, [self.$process(var_node), method_name, self.$process(value_node)]);\n        }, TMP_Processor_on_op_asgn_6.$$arity = 1);\n        Opal.alias(self, \"on_mlhs\", \"process_regular_node\");\n        Opal.alias(self, \"on_masgn\", \"process_regular_node\");\n        \n        Opal.defn(self, '$on_const', TMP_Processor_on_const_7 = function $$on_const(node) {\n          var $a, self = this, scope_node = nil, name = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (scope_node = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), $a;\n          return node.$updated(nil, [self.$process(scope_node), name]);\n        }, TMP_Processor_on_const_7.$$arity = 1);\n        \n        Opal.defn(self, '$on_casgn', TMP_Processor_on_casgn_8 = function $$on_casgn(node) {\n          var $a, self = this, scope_node = nil, name = nil, value_node = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (scope_node = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), (value_node = ($a[2] == null ? nil : $a[2])), $a;\n          if ($truthy(value_node['$nil?']()['$!']())) {\n            return node.$updated(nil, [self.$process(scope_node), name, self.$process(value_node)])\n            } else {\n            return node.$updated(nil, [self.$process(scope_node), name])\n          };\n        }, TMP_Processor_on_casgn_8.$$arity = 1);\n        Opal.alias(self, \"on_args\", \"process_regular_node\");\n        \n        Opal.defn(self, '$on_argument', TMP_Processor_on_argument_9 = function $$on_argument(node) {\n          var $a, self = this, arg_name = nil, value_node = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (arg_name = ($a[0] == null ? nil : $a[0])), (value_node = ($a[1] == null ? nil : $a[1])), $a;\n          if ($truthy(value_node['$nil?']()['$!']())) {\n            return node.$updated(nil, [arg_name, self.$process(value_node)])\n            } else {\n            return node\n          };\n        }, TMP_Processor_on_argument_9.$$arity = 1);\n        \n        Opal.defn(self, '$process_argument_node', TMP_Processor_process_argument_node_10 = function $$process_argument_node(node) {\n          var self = this;\n\n          return self.$on_argument(node)\n        }, TMP_Processor_process_argument_node_10.$$arity = 1);\n        Opal.alias(self, \"on_arg\", \"process_argument_node\");\n        Opal.alias(self, \"on_optarg\", \"process_argument_node\");\n        Opal.alias(self, \"on_restarg\", \"process_argument_node\");\n        Opal.alias(self, \"on_blockarg\", \"process_argument_node\");\n        Opal.alias(self, \"on_shadowarg\", \"process_argument_node\");\n        Opal.alias(self, \"on_kwarg\", \"process_argument_node\");\n        Opal.alias(self, \"on_kwoptarg\", \"process_argument_node\");\n        Opal.alias(self, \"on_kwrestarg\", \"process_argument_node\");\n        Opal.alias(self, \"on_procarg0\", \"process_argument_node\");\n        Opal.alias(self, \"on_arg_expr\", \"process_regular_node\");\n        Opal.alias(self, \"on_restarg_expr\", \"process_regular_node\");\n        Opal.alias(self, \"on_blockarg_expr\", \"process_regular_node\");\n        Opal.alias(self, \"on_block_pass\", \"process_regular_node\");\n        Opal.alias(self, \"on_module\", \"process_regular_node\");\n        Opal.alias(self, \"on_class\", \"process_regular_node\");\n        Opal.alias(self, \"on_sclass\", \"process_regular_node\");\n        \n        Opal.defn(self, '$on_def', TMP_Processor_on_def_11 = function $$on_def(node) {\n          var $a, self = this, name = nil, args_node = nil, body_node = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (args_node = ($a[1] == null ? nil : $a[1])), (body_node = ($a[2] == null ? nil : $a[2])), $a;\n          return node.$updated(nil, [name, self.$process(args_node), self.$process(body_node)]);\n        }, TMP_Processor_on_def_11.$$arity = 1);\n        \n        Opal.defn(self, '$on_defs', TMP_Processor_on_defs_12 = function $$on_defs(node) {\n          var $a, self = this, definee_node = nil, name = nil, args_node = nil, body_node = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (definee_node = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), (args_node = ($a[2] == null ? nil : $a[2])), (body_node = ($a[3] == null ? nil : $a[3])), $a;\n          return node.$updated(nil, [self.$process(definee_node), name, self.$process(args_node), self.$process(body_node)]);\n        }, TMP_Processor_on_defs_12.$$arity = 1);\n        Opal.alias(self, \"on_undef\", \"process_regular_node\");\n        Opal.alias(self, \"on_alias\", \"process_regular_node\");\n        \n        Opal.defn(self, '$on_send', TMP_Processor_on_send_13 = function $$on_send(node) {\n          var $a, self = this, receiver_node = nil, method_name = nil, arg_nodes = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (receiver_node = ($a[0] == null ? nil : $a[0])), (method_name = ($a[1] == null ? nil : $a[1])), (arg_nodes = $slice.call($a, 2)), $a;\n          if ($truthy(receiver_node)) {\n            receiver_node = self.$process(receiver_node)};\n          return node.$updated(nil, [receiver_node, method_name].concat(Opal.to_a(self.$process_all(arg_nodes))));\n        }, TMP_Processor_on_send_13.$$arity = 1);\n        Opal.alias(self, \"on_csend\", \"on_send\");\n        Opal.alias(self, \"on_block\", \"process_regular_node\");\n        Opal.alias(self, \"on_while\", \"process_regular_node\");\n        Opal.alias(self, \"on_while_post\", \"process_regular_node\");\n        Opal.alias(self, \"on_until\", \"process_regular_node\");\n        Opal.alias(self, \"on_until_post\", \"process_regular_node\");\n        Opal.alias(self, \"on_for\", \"process_regular_node\");\n        Opal.alias(self, \"on_return\", \"process_regular_node\");\n        Opal.alias(self, \"on_break\", \"process_regular_node\");\n        Opal.alias(self, \"on_next\", \"process_regular_node\");\n        Opal.alias(self, \"on_redo\", \"process_regular_node\");\n        Opal.alias(self, \"on_retry\", \"process_regular_node\");\n        Opal.alias(self, \"on_super\", \"process_regular_node\");\n        Opal.alias(self, \"on_yield\", \"process_regular_node\");\n        Opal.alias(self, \"on_defined?\", \"process_regular_node\");\n        Opal.alias(self, \"on_not\", \"process_regular_node\");\n        Opal.alias(self, \"on_and\", \"process_regular_node\");\n        Opal.alias(self, \"on_or\", \"process_regular_node\");\n        Opal.alias(self, \"on_if\", \"process_regular_node\");\n        Opal.alias(self, \"on_when\", \"process_regular_node\");\n        Opal.alias(self, \"on_case\", \"process_regular_node\");\n        Opal.alias(self, \"on_iflipflop\", \"process_regular_node\");\n        Opal.alias(self, \"on_eflipflop\", \"process_regular_node\");\n        Opal.alias(self, \"on_match_current_line\", \"process_regular_node\");\n        Opal.alias(self, \"on_match_with_lvasgn\", \"process_regular_node\");\n        Opal.alias(self, \"on_resbody\", \"process_regular_node\");\n        Opal.alias(self, \"on_rescue\", \"process_regular_node\");\n        Opal.alias(self, \"on_ensure\", \"process_regular_node\");\n        Opal.alias(self, \"on_begin\", \"process_regular_node\");\n        Opal.alias(self, \"on_kwbegin\", \"process_regular_node\");\n        Opal.alias(self, \"on_preexe\", \"process_regular_node\");\n        Opal.alias(self, \"on_postexe\", \"process_regular_node\");\n        \n        Opal.defn(self, '$process_variable_node', TMP_Processor_process_variable_node_14 = function $$process_variable_node(node) {\n          var self = this;\n\n          \n          self.$warn(\"\" + \"Parser::AST::Processor#process_variable_node is deprecated as a\" + \" public API and will be removed. Please use \" + \"Parser::AST::Processor#on_var instead.\");\n          return self.$on_var(node);\n        }, TMP_Processor_process_variable_node_14.$$arity = 1);\n        \n        Opal.defn(self, '$process_var_asgn_node', TMP_Processor_process_var_asgn_node_15 = function $$process_var_asgn_node(node) {\n          var self = this;\n\n          \n          self.$warn(\"\" + \"Parser::AST::Processor#process_var_asgn_node is deprecated as a\" + \" public API and will be removed. Please use \" + \"Parser::AST::Processor#on_vasgn instead.\");\n          return self.$on_vasgn(node);\n        }, TMP_Processor_process_var_asgn_node_15.$$arity = 1);\n        return (Opal.defn(self, '$process_argument_node', TMP_Processor_process_argument_node_16 = function $$process_argument_node(node) {\n          var self = this;\n\n          \n          self.$warn(\"\" + \"Parser::AST::Processor#process_argument_node is deprecated as a\" + \" public API and will be removed. Please use \" + \"Parser::AST::Processor#on_argument instead.\");\n          return self.$on_argument(node);\n        }, TMP_Processor_process_argument_node_16.$$arity = 1), nil) && 'process_argument_node';\n      })($nesting[0], Opal.const_get_qualified(Opal.const_get_qualified('::', 'AST'), 'Processor'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/meta\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send;\n\n  Opal.add_stubs(['$freeze', '$to_set', '$map', '$to_proc']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Meta, self = $Meta = $module($base, 'Meta');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      Opal.const_set($nesting[0], 'NODE_TYPES', $send([\"true\", \"false\", \"nil\", \"int\", \"float\", \"str\", \"dstr\", \"sym\", \"dsym\", \"xstr\", \"regopt\", \"regexp\", \"array\", \"splat\", \"array\", \"pair\", \"kwsplat\", \"hash\", \"irange\", \"erange\", \"self\", \"lvar\", \"ivar\", \"cvar\", \"gvar\", \"const\", \"defined?\", \"lvasgn\", \"ivasgn\", \"cvasgn\", \"gvasgn\", \"casgn\", \"mlhs\", \"masgn\", \"op_asgn\", \"op_asgn\", \"and_asgn\", \"ensure\", \"rescue\", \"arg_expr\", \"or_asgn\", \"and_asgn\", \"or_asgn\", \"back_ref\", \"nth_ref\", \"match_with_lvasgn\", \"match_current_line\", \"module\", \"class\", \"sclass\", \"def\", \"defs\", \"undef\", \"alias\", \"args\", \"cbase\", \"arg\", \"optarg\", \"restarg\", \"blockarg\", \"block_pass\", \"args\", \"def\", \"kwarg\", \"kwoptarg\", \"kwrestarg\", \"send\", \"csend\", \"super\", \"zsuper\", \"yield\", \"block\", \"and\", \"not\", \"or\", \"if\", \"when\", \"case\", \"while\", \"until\", \"while_post\", \"until_post\", \"for\", \"break\", \"next\", \"redo\", \"return\", \"resbody\", \"kwbegin\", \"begin\", \"retry\", \"preexe\", \"postexe\", \"iflipflop\", \"eflipflop\", \"shadowarg\", \"complex\", \"rational\", \"__FILE__\", \"__LINE__\"], 'map', [], \"to_sym\".$to_proc()).$to_set().$freeze())\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/buffer\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$empty?', '$=~', '$==', '$[]', '$freeze', '$match', '$find', '$encoding', '$recognize_encoding', '$force_encoding', '$nil?', '$encode', '$open', '$read', '$source=', '$-', '$raise', '$frozen?', '$dup', '$reencode_string', '$class', '$valid_encoding?', '$name', '$raw_source=', '$gsub', '$!', '$ascii_only?', '$!=', '$line_for', '$+', '$[]=', '$to_a', '$lines', '$end_with?', '$<<', '$each', '$chomp!', '$fetch', '$source_lines', '$<=', '$>', '$size', '$line_begins', '$new', '$-@', '$private', '$index', '$unshift', '$length', '$respond_to?', '$bsearch']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Buffer(){};\n        var self = $Buffer = $klass($base, $super, 'Buffer', $Buffer);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Buffer_recognize_encoding_1, TMP_Buffer_reencode_string_2, TMP_Buffer_initialize_3, TMP_Buffer_read_5, TMP_Buffer_source_6, TMP_Buffer_source$eq_7, TMP_Buffer_raw_source$eq_8, TMP_Buffer_slice_9, TMP_Buffer_decompose_position_10, TMP_Buffer_line_for_position_11, TMP_Buffer_column_for_position_12, TMP_Buffer_source_lines_14, TMP_Buffer_source_line_15, TMP_Buffer_line_range_16, TMP_Buffer_last_line_17, TMP_Buffer_line_begins_18, TMP_Buffer_line_for_20, TMP_Buffer_line_for_22;\n\n        def.name = def.source = def.slice_source = def.first_line = def.line_for_position = def.column_for_position = def.lines = def.line_begins = nil;\n        \n        self.$attr_reader(\"name\", \"first_line\");\n        Opal.const_set($nesting[0], 'ENCODING_RE', new RegExp(\"\" + \"\\\\#.*coding\\\\s*[:=]\\\\s*\" + \"(\" + \"\" + \"(utf8-mac)\" + \"|\" + \"\" + \"([A-Za-z0-9_-]+?)(-unix|-dos|-mac)\" + \"|\" + \"([A-Za-z0-9_-]+)\" + \")\" + \"\"));\n        Opal.defs(self, '$recognize_encoding', TMP_Buffer_recognize_encoding_1 = function $$recognize_encoding(string) {\n          var $a, $b, self = this, first_line = nil, second_line = nil, encoding_line = nil, result = nil;\n\n          \n          if ($truthy(string['$empty?']())) {\n            return nil};\n          string['$=~'](/^(.*)\\n?(.*\\n)?/);\n          $a = [(($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))], (first_line = $a[0]), (second_line = $a[1]), $a;\n          if ($truthy(first_line['$=~'](/^\\xef\\xbb\\xbf/))) {\n            return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8')\n          } else if (first_line['$[]'](0, 2)['$=='](\"#!\".$force_encoding(\"ASCII-8BIT\").$freeze())) {\n            encoding_line = second_line\n            } else {\n            encoding_line = first_line\n          };\n          if ($truthy((result = Opal.const_get_relative($nesting, 'ENCODING_RE').$match(encoding_line)))) {\n            return Opal.const_get_relative($nesting, 'Encoding').$find(($truthy($a = ($truthy($b = result['$[]'](2)) ? $b : result['$[]'](3))) ? $a : result['$[]'](5)))\n            } else {\n            return nil\n          };\n        }, TMP_Buffer_recognize_encoding_1.$$arity = 1);\n        Opal.defs(self, '$reencode_string', TMP_Buffer_reencode_string_2 = function $$reencode_string(input) {\n          var self = this, original_encoding = nil, detected_encoding = nil;\n\n          \n          original_encoding = input.$encoding();\n          detected_encoding = self.$recognize_encoding(input.$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY')));\n          if ($truthy(detected_encoding['$nil?']())) {\n            return input.$force_encoding(original_encoding)\n          } else if (detected_encoding['$=='](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))) {\n            return input\n            } else {\n            return input.$force_encoding(detected_encoding).$encode(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8'))\n          };\n        }, TMP_Buffer_reencode_string_2.$$arity = 1);\n        \n        Opal.defn(self, '$initialize', TMP_Buffer_initialize_3 = function $$initialize(name, first_line) {\n          var self = this;\n\n          if (first_line == null) {\n            first_line = 1;\n          }\n          \n          self.name = name;\n          self.source = nil;\n          self.first_line = first_line;\n          self.lines = nil;\n          self.line_begins = nil;\n          self.slice_source = nil;\n          self.line_for_position = $hash2([], {});\n          return (self.column_for_position = $hash2([], {}));\n        }, TMP_Buffer_initialize_3.$$arity = -2);\n        \n        Opal.defn(self, '$read', TMP_Buffer_read_5 = function $$read() {\n          var TMP_4, self = this;\n\n          \n          $send(Opal.const_get_relative($nesting, 'File'), 'open', [self.name, \"rb\".$force_encoding(\"ASCII-8BIT\")], (TMP_4 = function(io){var self = TMP_4.$$s || this, $writer = nil;\nif (io == null) io = nil;\n          \n            $writer = [io.$read()];\n            $send(self, 'source=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));\n          return self;\n        }, TMP_Buffer_read_5.$$arity = 0);\n        \n        Opal.defn(self, '$source', TMP_Buffer_source_6 = function $$source() {\n          var self = this;\n\n          \n          if ($truthy(self.source['$nil?']())) {\n            self.$raise(Opal.const_get_relative($nesting, 'RuntimeError'), \"Cannot extract source from uninitialized Source::Buffer\".$force_encoding(\"ASCII-8BIT\"))};\n          return self.source;\n        }, TMP_Buffer_source_6.$$arity = 0);\n        \n        Opal.defn(self, '$source=', TMP_Buffer_source$eq_7 = function(input) {\n          var $a, self = this, $writer = nil;\n\n          \n          if ($truthy((($a = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n            \n            if ($truthy(input['$frozen?']())) {\n              input = input.$dup()};\n            input = self.$class().$reencode_string(input);\n            if ($truthy(input['$valid_encoding?']())) {\n              } else {\n              self.$raise(Opal.const_get_relative($nesting, 'EncodingError'), \"\" + \"invalid byte sequence in \" + (input.$encoding().$name()))\n            };};\n          \n          $writer = [input];\n          $send(self, 'raw_source=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];;\n        }, TMP_Buffer_source$eq_7.$$arity = 1);\n        \n        Opal.defn(self, '$raw_source=', TMP_Buffer_raw_source$eq_8 = function(input) {\n          var $a, $b, $c, $d, self = this;\n\n          \n          if ($truthy(self.source)) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"Source::Buffer is immutable\".$force_encoding(\"ASCII-8BIT\"))};\n          self.source = input.$gsub(\"\\r\\n\".$force_encoding(\"ASCII-8BIT\").$freeze(), \"\\n\".$force_encoding(\"ASCII-8BIT\").$freeze()).$freeze();\n          if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = (($d = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil)) ? self.source['$ascii_only?']()['$!']() : $c)) ? self.source.$encoding()['$!='](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_32LE')) : $b)) ? self.source.$encoding()['$!='](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY')) : $a))) {\n            return (self.slice_source = self.source.$encode(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_32LE')))\n            } else {\n            return nil\n          };\n        }, TMP_Buffer_raw_source$eq_8.$$arity = 1);\n        \n        Opal.defn(self, '$slice', TMP_Buffer_slice_9 = function $$slice(range) {\n          var self = this;\n\n          if ($truthy(self.slice_source['$nil?']())) {\n            return self.source['$[]'](range)\n            } else {\n            return self.slice_source['$[]'](range).$encode(self.source.$encoding())\n          }\n        }, TMP_Buffer_slice_9.$$arity = 1);\n        \n        Opal.defn(self, '$decompose_position', TMP_Buffer_decompose_position_10 = function $$decompose_position(position) {\n          var $a, $b, self = this, line_no = nil, line_begin = nil;\n\n          \n          $b = self.$line_for(position), $a = Opal.to_ary($b), (line_no = ($a[0] == null ? nil : $a[0])), (line_begin = ($a[1] == null ? nil : $a[1])), $b;\n          return [$rb_plus(self.first_line, line_no), $rb_minus(position, line_begin)];\n        }, TMP_Buffer_decompose_position_10.$$arity = 1);\n        \n        Opal.defn(self, '$line_for_position', TMP_Buffer_line_for_position_11 = function $$line_for_position(position) {\n          var $a, $b, $c, self = this, $writer = nil, line_no = nil, _ = nil;\n\n          return ($truthy($a = self.line_for_position['$[]'](position)) ? $a : (($writer = [position, ($c = self.$line_for(position), $b = Opal.to_ary($c), (line_no = ($b[0] == null ? nil : $b[0])), (_ = ($b[1] == null ? nil : $b[1])), $c, $rb_plus(self.first_line, line_no))]), $send(self.line_for_position, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n        }, TMP_Buffer_line_for_position_11.$$arity = 1);\n        \n        Opal.defn(self, '$column_for_position', TMP_Buffer_column_for_position_12 = function $$column_for_position(position) {\n          var $a, $b, $c, self = this, $writer = nil, _ = nil, line_begin = nil;\n\n          return ($truthy($a = self.column_for_position['$[]'](position)) ? $a : (($writer = [position, ($c = self.$line_for(position), $b = Opal.to_ary($c), (_ = ($b[0] == null ? nil : $b[0])), (line_begin = ($b[1] == null ? nil : $b[1])), $c, $rb_minus(position, line_begin))]), $send(self.column_for_position, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n        }, TMP_Buffer_column_for_position_12.$$arity = 1);\n        \n        Opal.defn(self, '$source_lines', TMP_Buffer_source_lines_14 = function $$source_lines() {\n          var $a, TMP_13, self = this, lines = nil;\n\n          return (self.lines = ($truthy($a = self.lines) ? $a : ((lines = self.source.$lines().$to_a()), (function() {if ($truthy(self.source['$end_with?'](\"\\n\".$force_encoding(\"ASCII-8BIT\").$freeze()))) {\n            return lines['$<<'](\"\".$force_encoding(\"ASCII-8BIT\"))\n            } else {\n            return nil\n          }; return nil; })(), $send(lines, 'each', [], (TMP_13 = function(line){var self = TMP_13.$$s || this;\nif (line == null) line = nil;\n          \n            line['$chomp!'](\"\\n\".$force_encoding(\"ASCII-8BIT\").$freeze());\n            return line.$freeze();}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13)), lines.$freeze())))\n        }, TMP_Buffer_source_lines_14.$$arity = 0);\n        \n        Opal.defn(self, '$source_line', TMP_Buffer_source_line_15 = function $$source_line(lineno) {\n          var self = this;\n\n          return self.$source_lines().$fetch($rb_minus(lineno, self.first_line)).$dup()\n        }, TMP_Buffer_source_line_15.$$arity = 1);\n        \n        Opal.defn(self, '$line_range', TMP_Buffer_line_range_16 = function $$line_range(lineno) {\n          var $a, self = this, index = nil;\n\n          \n          index = $rb_plus($rb_minus(lineno, self.first_line), 1);\n          if ($truthy(($truthy($a = $rb_le(index, 0)) ? $a : $rb_gt(index, self.$line_begins().$size())))) {\n            return self.$raise(Opal.const_get_relative($nesting, 'IndexError'), \"\" + \"Parser::Source::Buffer: range for line \" + (\"\" + (lineno) + \" requested, valid line numbers are \" + (self.first_line) + \"..\") + (\"\" + ($rb_minus($rb_plus(self.first_line, self.$line_begins().$size()), 1))))\n          } else if (index['$=='](self.$line_begins().$size())) {\n            return Opal.const_get_relative($nesting, 'Range').$new(self, self.$line_begins()['$[]'](index['$-@']())['$[]'](1), self.source.$size())\n            } else {\n            return Opal.const_get_relative($nesting, 'Range').$new(self, self.$line_begins()['$[]'](index['$-@']())['$[]'](1), $rb_minus(self.$line_begins()['$[]']($rb_minus(index['$-@'](), 1))['$[]'](1), 1))\n          };\n        }, TMP_Buffer_line_range_16.$$arity = 1);\n        \n        Opal.defn(self, '$last_line', TMP_Buffer_last_line_17 = function $$last_line() {\n          var self = this;\n\n          return $rb_minus($rb_plus(self.$line_begins().$size(), self.first_line), 1)\n        }, TMP_Buffer_last_line_17.$$arity = 0);\n        self.$private();\n        \n        Opal.defn(self, '$line_begins', TMP_Buffer_line_begins_18 = function $$line_begins() {\n          var $a, self = this, index = nil;\n\n          \n          if ($truthy(self.line_begins)) {\n            } else {\n            \n            $a = [[[0, 0]], 0], (self.line_begins = $a[0]), (index = $a[1]), $a;\n            while ($truthy((index = self.source.$index(\"\\n\".$force_encoding(\"ASCII-8BIT\").$freeze(), index)))) {\n              \n              index = $rb_plus(index, 1);\n              self.line_begins.$unshift([self.line_begins.$length(), index]);\n            };\n          };\n          return self.line_begins;\n        }, TMP_Buffer_line_begins_18.$$arity = 0);\n        if ($truthy([]['$respond_to?'](\"bsearch\"))) {\n          return (Opal.defn(self, '$line_for', TMP_Buffer_line_for_20 = function $$line_for(position) {\n            var TMP_19, self = this;\n\n            return $send(self.$line_begins(), 'bsearch', [], (TMP_19 = function(line, line_begin){var self = TMP_19.$$s || this;\nif (line == null) line = nil;if (line_begin == null) line_begin = nil;\n            return $rb_le(line_begin, position)}, TMP_19.$$s = self, TMP_19.$$arity = 2, TMP_19))\n          }, TMP_Buffer_line_for_20.$$arity = 1), nil) && 'line_for'\n          } else {\n          return (Opal.defn(self, '$line_for', TMP_Buffer_line_for_22 = function $$line_for(position) {\n            var TMP_21, self = this;\n\n            return $send(self.$line_begins(), 'find', [], (TMP_21 = function(line, line_begin){var self = TMP_21.$$s || this;\nif (line == null) line = nil;if (line_begin == null) line_begin = nil;\n            return $rb_le(line_begin, position)}, TMP_21.$$s = self, TMP_21.$$arity = 2, TMP_21))\n          }, TMP_Buffer_line_for_22.$$arity = 1), nil) && 'line_for'\n        };\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/range\"] = function(Opal) {\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$attr_reader', '$<', '$raise', '$nil?', '$freeze', '$new', '$-', '$line_for_position', '$alias_method', '$column_for_position', '$!=', '$line', '$begin', '$end', '$inspect', '$column', '$source_line', '$slice', '$begin_pos', '$end_pos', '$include?', '$source', '$to_a', '$decompose_position', '$join', '$name', '$+', '$min', '$max', '$disjoint?', '$>=', '$==', '$is_a?', '$source_buffer']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Range(){};\n        var self = $Range = $klass($base, $super, 'Range', $Range);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Range_initialize_1, TMP_Range_begin_2, TMP_Range_end_3, TMP_Range_size_4, TMP_Range_line_5, TMP_Range_column_6, TMP_Range_last_line_7, TMP_Range_last_column_8, TMP_Range_column_range_9, TMP_Range_source_line_10, TMP_Range_source_11, TMP_Range_is$q_12, TMP_Range_to_a_13, TMP_Range_to_s_14, TMP_Range_resize_15, TMP_Range_join_16, TMP_Range_intersect_17, TMP_Range_disjoint$q_18, TMP_Range_overlaps$q_19, TMP_Range_empty$q_20, TMP_Range_$eq$eq_21, TMP_Range_inspect_22;\n\n        def.source_buffer = def.begin_pos = def.end_pos = nil;\n        \n        self.$attr_reader(\"source_buffer\");\n        self.$attr_reader(\"begin_pos\", \"end_pos\");\n        \n        Opal.defn(self, '$initialize', TMP_Range_initialize_1 = function $$initialize(source_buffer, begin_pos, end_pos) {\n          var $a, self = this;\n\n          \n          if ($truthy($rb_lt(end_pos, begin_pos))) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"Parser::Source::Range: end_pos must not be less than begin_pos\")};\n          if ($truthy(source_buffer['$nil?']())) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"Parser::Source::Range: source_buffer must not be nil\")};\n          self.source_buffer = source_buffer;\n          $a = [begin_pos, end_pos], (self.begin_pos = $a[0]), (self.end_pos = $a[1]), $a;\n          return self.$freeze();\n        }, TMP_Range_initialize_1.$$arity = 3);\n        \n        Opal.defn(self, '$begin', TMP_Range_begin_2 = function $$begin() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Range').$new(self.source_buffer, self.begin_pos, self.begin_pos)\n        }, TMP_Range_begin_2.$$arity = 0);\n        \n        Opal.defn(self, '$end', TMP_Range_end_3 = function $$end() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Range').$new(self.source_buffer, self.end_pos, self.end_pos)\n        }, TMP_Range_end_3.$$arity = 0);\n        \n        Opal.defn(self, '$size', TMP_Range_size_4 = function $$size() {\n          var self = this;\n\n          return $rb_minus(self.end_pos, self.begin_pos)\n        }, TMP_Range_size_4.$$arity = 0);\n        Opal.alias(self, \"length\", \"size\");\n        \n        Opal.defn(self, '$line', TMP_Range_line_5 = function $$line() {\n          var self = this;\n\n          return self.source_buffer.$line_for_position(self.begin_pos)\n        }, TMP_Range_line_5.$$arity = 0);\n        self.$alias_method(\"first_line\", \"line\");\n        \n        Opal.defn(self, '$column', TMP_Range_column_6 = function $$column() {\n          var self = this;\n\n          return self.source_buffer.$column_for_position(self.begin_pos)\n        }, TMP_Range_column_6.$$arity = 0);\n        \n        Opal.defn(self, '$last_line', TMP_Range_last_line_7 = function $$last_line() {\n          var self = this;\n\n          return self.source_buffer.$line_for_position(self.end_pos)\n        }, TMP_Range_last_line_7.$$arity = 0);\n        \n        Opal.defn(self, '$last_column', TMP_Range_last_column_8 = function $$last_column() {\n          var self = this;\n\n          return self.source_buffer.$column_for_position(self.end_pos)\n        }, TMP_Range_last_column_8.$$arity = 0);\n        \n        Opal.defn(self, '$column_range', TMP_Range_column_range_9 = function $$column_range() {\n          var self = this;\n\n          \n          if ($truthy(self.$begin().$line()['$!='](self.$end().$line()))) {\n            self.$raise(Opal.const_get_relative($nesting, 'RangeError'), \"\" + (self.$inspect()) + \" spans more than one line\")};\n          return Opal.Range.$new(self.$begin().$column(),self.$end().$column(), true);\n        }, TMP_Range_column_range_9.$$arity = 0);\n        \n        Opal.defn(self, '$source_line', TMP_Range_source_line_10 = function $$source_line() {\n          var self = this;\n\n          return self.source_buffer.$source_line(self.$line())\n        }, TMP_Range_source_line_10.$$arity = 0);\n        \n        Opal.defn(self, '$source', TMP_Range_source_11 = function $$source() {\n          var self = this;\n\n          return self.source_buffer.$slice(Opal.Range.$new(self.$begin_pos(),self.$end_pos(), true))\n        }, TMP_Range_source_11.$$arity = 0);\n        \n        Opal.defn(self, '$is?', TMP_Range_is$q_12 = function($a_rest) {\n          var self = this, what;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          what = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            what[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return what['$include?'](self.$source())\n        }, TMP_Range_is$q_12.$$arity = -1);\n        \n        Opal.defn(self, '$to_a', TMP_Range_to_a_13 = function $$to_a() {\n          var self = this;\n\n          return Opal.Range.$new(self.begin_pos,self.end_pos, true).$to_a()\n        }, TMP_Range_to_a_13.$$arity = 0);\n        \n        Opal.defn(self, '$to_s', TMP_Range_to_s_14 = function $$to_s() {\n          var $a, $b, self = this, line = nil, column = nil;\n\n          \n          $b = self.source_buffer.$decompose_position(self.begin_pos), $a = Opal.to_ary($b), (line = ($a[0] == null ? nil : $a[0])), (column = ($a[1] == null ? nil : $a[1])), $b;\n          return [self.source_buffer.$name(), line, $rb_plus(column, 1)].$join(\":\");\n        }, TMP_Range_to_s_14.$$arity = 0);\n        \n        Opal.defn(self, '$resize', TMP_Range_resize_15 = function $$resize(new_size) {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Range').$new(self.source_buffer, self.begin_pos, $rb_plus(self.begin_pos, new_size))\n        }, TMP_Range_resize_15.$$arity = 1);\n        \n        Opal.defn(self, '$join', TMP_Range_join_16 = function $$join(other) {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Range').$new(self.source_buffer, [self.begin_pos, other.$begin_pos()].$min(), [self.end_pos, other.$end_pos()].$max())\n        }, TMP_Range_join_16.$$arity = 1);\n        \n        Opal.defn(self, '$intersect', TMP_Range_intersect_17 = function $$intersect(other) {\n          var self = this;\n\n          if ($truthy(self['$disjoint?'](other))) {\n            return nil\n            } else {\n            return Opal.const_get_relative($nesting, 'Range').$new(self.source_buffer, [self.begin_pos, other.$begin_pos()].$max(), [self.end_pos, other.$end_pos()].$min())\n          }\n        }, TMP_Range_intersect_17.$$arity = 1);\n        \n        Opal.defn(self, '$disjoint?', TMP_Range_disjoint$q_18 = function(other) {\n          var $a, self = this;\n\n          return ($truthy($a = $rb_ge(self.begin_pos, other.$end_pos())) ? $a : $rb_ge(other.$begin_pos(), self.end_pos))\n        }, TMP_Range_disjoint$q_18.$$arity = 1);\n        \n        Opal.defn(self, '$overlaps?', TMP_Range_overlaps$q_19 = function(other) {\n          var $a, self = this;\n\n          return ($truthy($a = $rb_lt(self.begin_pos, other.$end_pos())) ? $rb_lt(other.$begin_pos(), self.end_pos) : $a)\n        }, TMP_Range_overlaps$q_19.$$arity = 1);\n        \n        Opal.defn(self, '$empty?', TMP_Range_empty$q_20 = function() {\n          var self = this;\n\n          return self.begin_pos['$=='](self.end_pos)\n        }, TMP_Range_empty$q_20.$$arity = 0);\n        \n        Opal.defn(self, '$==', TMP_Range_$eq$eq_21 = function(other) {\n          var $a, $b, $c, self = this;\n\n          return ($truthy($a = ($truthy($b = ($truthy($c = other['$is_a?'](Opal.const_get_relative($nesting, 'Range'))) ? self.source_buffer['$=='](other.$source_buffer()) : $c)) ? self.begin_pos['$=='](other.$begin_pos()) : $b)) ? self.end_pos['$=='](other.$end_pos()) : $a)\n        }, TMP_Range_$eq$eq_21.$$arity = 1);\n        return (Opal.defn(self, '$inspect', TMP_Range_inspect_22 = function $$inspect() {\n          var self = this;\n\n          return \"\" + \"#<Parser::Source::Range \" + (self.source_buffer.$name()) + \" \" + (self.begin_pos) + \"...\" + (self.end_pos) + \">\"\n        }, TMP_Range_inspect_22.$$arity = 0), nil) && 'inspect';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/comment\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$attr_reader', '$alias_method', '$new', '$associate', '$associate_locations', '$freeze', '$source', '$text', '$===', '$==', '$type', '$is_a?', '$location', '$to_s', '$expression', '$inspect']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Comment(){};\n        var self = $Comment = $klass($base, $super, 'Comment', $Comment);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Comment_associate_1, TMP_Comment_associate_locations_2, TMP_Comment_initialize_3, TMP_Comment_type_4, TMP_Comment_inline$q_5, TMP_Comment_document$q_6, TMP_Comment_$eq$eq_7, TMP_Comment_inspect_8;\n\n        def.location = nil;\n        \n        self.$attr_reader(\"text\");\n        self.$attr_reader(\"location\");\n        self.$alias_method(\"loc\", \"location\");\n        Opal.defs(self, '$associate', TMP_Comment_associate_1 = function $$associate(ast, comments) {\n          var self = this, associator = nil;\n\n          \n          associator = Opal.const_get_relative($nesting, 'Associator').$new(ast, comments);\n          return associator.$associate();\n        }, TMP_Comment_associate_1.$$arity = 2);\n        Opal.defs(self, '$associate_locations', TMP_Comment_associate_locations_2 = function $$associate_locations(ast, comments) {\n          var self = this, associator = nil;\n\n          \n          associator = Opal.const_get_relative($nesting, 'Associator').$new(ast, comments);\n          return associator.$associate_locations();\n        }, TMP_Comment_associate_locations_2.$$arity = 2);\n        \n        Opal.defn(self, '$initialize', TMP_Comment_initialize_3 = function $$initialize(range) {\n          var self = this;\n\n          \n          self.location = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Parser'), 'Source'), 'Map').$new(range);\n          self.text = range.$source().$freeze();\n          return self.$freeze();\n        }, TMP_Comment_initialize_3.$$arity = 1);\n        \n        Opal.defn(self, '$type', TMP_Comment_type_4 = function $$type() {\n          var self = this, $case = nil;\n\n          return (function() {$case = self.$text();\n          if (/^#/['$===']($case)) {return \"inline\"}\n          else if (/^=begin/['$===']($case)) {return \"document\"}\n          else { return nil }})()\n        }, TMP_Comment_type_4.$$arity = 0);\n        \n        Opal.defn(self, '$inline?', TMP_Comment_inline$q_5 = function() {\n          var self = this;\n\n          return self.$type()['$=='](\"inline\")\n        }, TMP_Comment_inline$q_5.$$arity = 0);\n        \n        Opal.defn(self, '$document?', TMP_Comment_document$q_6 = function() {\n          var self = this;\n\n          return self.$type()['$=='](\"document\")\n        }, TMP_Comment_document$q_6.$$arity = 0);\n        \n        Opal.defn(self, '$==', TMP_Comment_$eq$eq_7 = function(other) {\n          var $a, self = this;\n\n          return ($truthy($a = other['$is_a?'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Comment'))) ? self.location['$=='](other.$location()) : $a)\n        }, TMP_Comment_$eq$eq_7.$$arity = 1);\n        return (Opal.defn(self, '$inspect', TMP_Comment_inspect_8 = function $$inspect() {\n          var self = this;\n\n          return \"\" + \"#<Parser::Source::Comment \" + (self.location.$expression().$to_s()) + \" \" + (self.$text().$inspect()) + \">\"\n        }, TMP_Comment_inspect_8.$$arity = 0), nil) && 'inspect';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/comment/associator\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$attr_accessor', '$do_associate', '$private', '$new', '$[]=', '$-', '$advance_comment', '$advance_through_directives', '$visit', '$process_leading_comments', '$location', '$<=', '$line', '$last_line', '$is_a?', '$each', '$children', '$loc', '$expression', '$process_trailing_comments', '$==', '$type', '$current_comment_before?', '$associate_and_advance_comment', '$current_comment_before_end?', '$current_comment_decorates?', '$+', '$[]', '$!', '$end_pos', '$begin_pos', '$<<', '$=~', '$text']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Associator(){};\n        var self = $Associator = $klass($base, $super, 'Associator', $Associator);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Associator_initialize_1, TMP_Associator_associate_2, TMP_Associator_associate_locations_3, TMP_Associator_do_associate_5, TMP_Associator_visit_7, TMP_Associator_process_leading_comments_8, TMP_Associator_process_trailing_comments_9, TMP_Associator_advance_comment_10, TMP_Associator_current_comment_before$q_11, TMP_Associator_current_comment_before_end$q_12, TMP_Associator_current_comment_decorates$q_13, TMP_Associator_associate_and_advance_comment_14, TMP_Associator_advance_through_directives_15;\n\n        def.skip_directives = def.ast = def.mapping = def.current_comment = def.comment_num = def.comments = def.map_using_locations = nil;\n        \n        self.$attr_accessor(\"skip_directives\");\n        \n        Opal.defn(self, '$initialize', TMP_Associator_initialize_1 = function $$initialize(ast, comments) {\n          var self = this;\n\n          \n          self.ast = ast;\n          self.comments = comments;\n          return (self.skip_directives = true);\n        }, TMP_Associator_initialize_1.$$arity = 2);\n        \n        Opal.defn(self, '$associate', TMP_Associator_associate_2 = function $$associate() {\n          var self = this;\n\n          \n          self.map_using_locations = false;\n          return self.$do_associate();\n        }, TMP_Associator_associate_2.$$arity = 0);\n        \n        Opal.defn(self, '$associate_locations', TMP_Associator_associate_locations_3 = function $$associate_locations() {\n          var self = this;\n\n          \n          self.map_using_locations = true;\n          return self.$do_associate();\n        }, TMP_Associator_associate_locations_3.$$arity = 0);\n        self.$private();\n        \n        Opal.defn(self, '$do_associate', TMP_Associator_do_associate_5 = function $$do_associate() {\n          var TMP_4, self = this;\n\n          \n          self.mapping = $send(Opal.const_get_relative($nesting, 'Hash'), 'new', [], (TMP_4 = function(h, k){var self = TMP_4.$$s || this, $writer = nil;\nif (h == null) h = nil;if (k == null) k = nil;\n          \n            $writer = [k, []];\n            $send(h, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_4.$$s = self, TMP_4.$$arity = 2, TMP_4));\n          self.comment_num = -1;\n          self.$advance_comment();\n          if ($truthy(self.skip_directives)) {\n            self.$advance_through_directives()};\n          if ($truthy(self.ast)) {\n            self.$visit(self.ast)};\n          return self.mapping;\n        }, TMP_Associator_do_associate_5.$$arity = 0);\n        \n        Opal.defn(self, '$visit', TMP_Associator_visit_7 = function $$visit(node) {\n          var $a, TMP_6, self = this, node_loc = nil;\n\n          \n          self.$process_leading_comments(node);\n          if ($truthy(self.current_comment)) {\n            } else {\n            return nil\n          };\n          node_loc = node.$location();\n          if ($truthy(($truthy($a = $rb_le(self.current_comment.$location().$line(), node_loc.$last_line())) ? $a : node_loc['$is_a?'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Map'), 'Heredoc'))))) {\n            \n            $send(node.$children(), 'each', [], (TMP_6 = function(child){var self = TMP_6.$$s || this, $b, $c;\nif (child == null) child = nil;\n            \n              if ($truthy(($truthy($b = ($truthy($c = child['$is_a?'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'AST'), 'Node'))) ? child.$loc() : $c)) ? child.$loc().$expression() : $b))) {\n                } else {\n                return nil;\n              };\n              return self.$visit(child);}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));\n            return self.$process_trailing_comments(node);\n            } else {\n            return nil\n          };\n        }, TMP_Associator_visit_7.$$arity = 1);\n        \n        Opal.defn(self, '$process_leading_comments', TMP_Associator_process_leading_comments_8 = function $$process_leading_comments(node) {\n          var $a, self = this;\n\n          \n          if (node.$type()['$=='](\"begin\")) {\n            return nil};\n          while ($truthy(self['$current_comment_before?'](node))) {\n            self.$associate_and_advance_comment(node)\n          };\n        }, TMP_Associator_process_leading_comments_8.$$arity = 1);\n        \n        Opal.defn(self, '$process_trailing_comments', TMP_Associator_process_trailing_comments_9 = function $$process_trailing_comments(node) {\n          var $a, self = this;\n\n          \n          while ($truthy(self['$current_comment_before_end?'](node))) {\n            self.$associate_and_advance_comment(node)\n          };\n          while ($truthy(self['$current_comment_decorates?'](node))) {\n            self.$associate_and_advance_comment(node)\n          };\n        }, TMP_Associator_process_trailing_comments_9.$$arity = 1);\n        \n        Opal.defn(self, '$advance_comment', TMP_Associator_advance_comment_10 = function $$advance_comment() {\n          var self = this;\n\n          \n          self.comment_num = $rb_plus(self.comment_num, 1);\n          return (self.current_comment = self.comments['$[]'](self.comment_num));\n        }, TMP_Associator_advance_comment_10.$$arity = 0);\n        \n        Opal.defn(self, '$current_comment_before?', TMP_Associator_current_comment_before$q_11 = function(node) {\n          var self = this, comment_loc = nil, node_loc = nil;\n\n          \n          if ($truthy(self.current_comment['$!']())) {\n            return false};\n          comment_loc = self.current_comment.$location().$expression();\n          node_loc = node.$location().$expression();\n          return $rb_le(comment_loc.$end_pos(), node_loc.$begin_pos());\n        }, TMP_Associator_current_comment_before$q_11.$$arity = 1);\n        \n        Opal.defn(self, '$current_comment_before_end?', TMP_Associator_current_comment_before_end$q_12 = function(node) {\n          var self = this, comment_loc = nil, node_loc = nil;\n\n          \n          if ($truthy(self.current_comment['$!']())) {\n            return false};\n          comment_loc = self.current_comment.$location().$expression();\n          node_loc = node.$location().$expression();\n          return $rb_le(comment_loc.$end_pos(), node_loc.$end_pos());\n        }, TMP_Associator_current_comment_before_end$q_12.$$arity = 1);\n        \n        Opal.defn(self, '$current_comment_decorates?', TMP_Associator_current_comment_decorates$q_13 = function(node) {\n          var self = this;\n\n          \n          if ($truthy(self.current_comment['$!']())) {\n            return false};\n          return self.current_comment.$location().$line()['$=='](node.$location().$last_line());\n        }, TMP_Associator_current_comment_decorates$q_13.$$arity = 1);\n        \n        Opal.defn(self, '$associate_and_advance_comment', TMP_Associator_associate_and_advance_comment_14 = function $$associate_and_advance_comment(node) {\n          var self = this, key = nil;\n\n          \n          key = (function() {if ($truthy(self.map_using_locations)) {\n            return node.$location()\n            } else {\n            return node\n          }; return nil; })();\n          self.mapping['$[]'](key)['$<<'](self.current_comment);\n          return self.$advance_comment();\n        }, TMP_Associator_associate_and_advance_comment_14.$$arity = 1);\n        return (Opal.defn(self, '$advance_through_directives', TMP_Associator_advance_through_directives_15 = function $$advance_through_directives() {\n          var $a, self = this;\n\n          \n          if ($truthy(($truthy($a = self.current_comment) ? self.current_comment.$text()['$=~'](/^#!/) : $a))) {\n            self.$advance_comment()};\n          if ($truthy(($truthy($a = self.current_comment) ? self.current_comment.$text()['$=~'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Buffer'), 'ENCODING_RE')) : $a))) {\n            return self.$advance_comment()\n            } else {\n            return nil\n          };\n        }, TMP_Associator_advance_through_directives_15.$$arity = 0), nil) && 'advance_through_directives';\n      })(Opal.const_get_relative($nesting, 'Comment'), null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/rewriter\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$attr_reader', '$new', '$lambda', '$puts', '$render', '$consumer=', '$-', '$append', '$freeze', '$begin', '$end', '$+', '$in_transaction?', '$raise', '$class', '$dup', '$source', '$each', '$sort', '$begin_pos', '$range', '$length', '$replacement', '$[]=', '$private', '$empty?', '$!', '$allow_multiple_insertions?', '$clobbered_insertion?', '$raise_clobber_error', '$record_insertion', '$adjacent_updates?', '$find', '$overlaps?', '$replace_compatible_with_insertion?', '$merge_actions!', '$<<', '$active_queue', '$adjacent_insertions?', '$merge_actions', '$delete', '$can_merge?', '$record_replace', '$|', '$active_insertions', '$active_insertions=', '$active_clobber', '$clobbered_position_mask', '$active_clobber=', '$size', '$!=', '$&', '$<=', '$end_pos', '$adjacent_insertion_mask', '$select', '$adjacent?', '$adjacent_position_mask', '$>=', '$==', '$[]', '$all?', '$intersect', '$nil?', '$max', '$sort_by', '$push', '$join', '$first', '$max_by', '$merge_replacements', '$replace_actions', '$disjoint?', '$<', '$process']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Rewriter(){};\n        var self = $Rewriter = $klass($base, $super, 'Rewriter', $Rewriter);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Rewriter_initialize_2, TMP_Rewriter_remove_3, TMP_Rewriter_insert_before_4, TMP_Rewriter_insert_before_multi_5, TMP_Rewriter_insert_after_6, TMP_Rewriter_insert_after_multi_7, TMP_Rewriter_replace_8, TMP_Rewriter_process_10, TMP_Rewriter_transaction_11, TMP_Rewriter_append_14, TMP_Rewriter_record_insertion_15, TMP_Rewriter_record_replace_16, TMP_Rewriter_clobbered_position_mask_17, TMP_Rewriter_adjacent_position_mask_18, TMP_Rewriter_adjacent_insertion_mask_19, TMP_Rewriter_clobbered_insertion$q_21, TMP_Rewriter_adjacent_insertions$q_23, TMP_Rewriter_adjacent_updates$q_25, TMP_Rewriter_replace_compatible_with_insertion$q_26, TMP_Rewriter_can_merge$q_28, TMP_Rewriter_merge_actions_31, TMP_Rewriter_merge_actions$B_32, TMP_Rewriter_merge_replacements_34, TMP_Rewriter_replace_actions_36, TMP_Rewriter_raise_clobber_error_37, TMP_Rewriter_in_transaction$q_38, TMP_Rewriter_active_queue_39, TMP_Rewriter_active_clobber_40, TMP_Rewriter_active_insertions_41, TMP_Rewriter_active_clobber$eq_42, TMP_Rewriter_active_insertions$eq_43, TMP_Rewriter_adjacent$q_44;\n\n        def.diagnostics = def.insert_before_multi_order = def.insert_after_multi_order = def.source_buffer = def.queue = def.clobber = def.insertions = def.pending_queue = def.pending_clobber = def.pending_insertions = nil;\n        \n        self.$attr_reader(\"source_buffer\");\n        self.$attr_reader(\"diagnostics\");\n        \n        Opal.defn(self, '$initialize', TMP_Rewriter_initialize_2 = function $$initialize(source_buffer) {\n          var TMP_1, self = this, $writer = nil;\n\n          \n          self.diagnostics = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Diagnostic'), 'Engine').$new();\n          \n          $writer = [$send(self, 'lambda', [], (TMP_1 = function(diag){var self = TMP_1.$$s || this;\n            if ($gvars.stderr == null) $gvars.stderr = nil;\nif (diag == null) diag = nil;\n          return $gvars.stderr.$puts(diag.$render())}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1))];\n          $send(self.diagnostics, 'consumer=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          self.source_buffer = source_buffer;\n          self.queue = [];\n          self.clobber = 0;\n          self.insertions = 0;\n          self.insert_before_multi_order = 0;\n          return (self.insert_after_multi_order = 0);\n        }, TMP_Rewriter_initialize_2.$$arity = 1);\n        \n        Opal.defn(self, '$remove', TMP_Rewriter_remove_3 = function $$remove(range) {\n          var self = this;\n\n          return self.$append(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriter'), 'Action').$new(range, \"\".$freeze()))\n        }, TMP_Rewriter_remove_3.$$arity = 1);\n        \n        Opal.defn(self, '$insert_before', TMP_Rewriter_insert_before_4 = function $$insert_before(range, content) {\n          var self = this;\n\n          return self.$append(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriter'), 'Action').$new(range.$begin(), content))\n        }, TMP_Rewriter_insert_before_4.$$arity = 2);\n        \n        Opal.defn(self, '$insert_before_multi', TMP_Rewriter_insert_before_multi_5 = function $$insert_before_multi(range, content) {\n          var self = this;\n\n          \n          self.insert_before_multi_order = $rb_minus(self.insert_before_multi_order, 1);\n          return self.$append(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriter'), 'Action').$new(range.$begin(), content, true, self.insert_before_multi_order));\n        }, TMP_Rewriter_insert_before_multi_5.$$arity = 2);\n        \n        Opal.defn(self, '$insert_after', TMP_Rewriter_insert_after_6 = function $$insert_after(range, content) {\n          var self = this;\n\n          return self.$append(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriter'), 'Action').$new(range.$end(), content))\n        }, TMP_Rewriter_insert_after_6.$$arity = 2);\n        \n        Opal.defn(self, '$insert_after_multi', TMP_Rewriter_insert_after_multi_7 = function $$insert_after_multi(range, content) {\n          var self = this;\n\n          \n          self.insert_after_multi_order = $rb_plus(self.insert_after_multi_order, 1);\n          return self.$append(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriter'), 'Action').$new(range.$end(), content, true, self.insert_after_multi_order));\n        }, TMP_Rewriter_insert_after_multi_7.$$arity = 2);\n        \n        Opal.defn(self, '$replace', TMP_Rewriter_replace_8 = function $$replace(range, content) {\n          var self = this;\n\n          return self.$append(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriter'), 'Action').$new(range, content))\n        }, TMP_Rewriter_replace_8.$$arity = 2);\n        \n        Opal.defn(self, '$process', TMP_Rewriter_process_10 = function $$process() {\n          var TMP_9, self = this, adjustment = nil, source = nil;\n\n          \n          if ($truthy(self['$in_transaction?']())) {\n            self.$raise(\"\" + \"Do not call \" + (self.$class()) + \"#\" + (\"process\") + \" inside a transaction\")};\n          adjustment = 0;\n          source = self.source_buffer.$source().$dup();\n          $send(self.queue.$sort(), 'each', [], (TMP_9 = function(action){var self = TMP_9.$$s || this, begin_pos = nil, end_pos = nil, $writer = nil;\nif (action == null) action = nil;\n          \n            begin_pos = $rb_plus(action.$range().$begin_pos(), adjustment);\n            end_pos = $rb_plus(begin_pos, action.$range().$length());\n            \n            $writer = [Opal.Range.$new(begin_pos,end_pos, true), action.$replacement()];\n            $send(source, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            return (adjustment = $rb_plus(adjustment, $rb_minus(action.$replacement().$length(), action.$range().$length())));}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9));\n          return source;\n        }, TMP_Rewriter_process_10.$$arity = 0);\n        \n        Opal.defn(self, '$transaction', TMP_Rewriter_transaction_11 = function $$transaction() {\n          var self = this, $iter = TMP_Rewriter_transaction_11.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_Rewriter_transaction_11.$$p = null;\n          return (function() { try {\n          \n          if (($yield !== nil)) {\n            } else {\n            self.$raise(\"\" + (self.$class()) + \"#\" + (\"transaction\") + \" requires block\")\n          };\n          if ($truthy(self['$in_transaction?']())) {\n            self.$raise(\"Nested transaction is not supported\")};\n          self.pending_queue = self.queue.$dup();\n          self.pending_clobber = self.clobber;\n          self.pending_insertions = self.insertions;\n          Opal.yieldX($yield, []);\n          self.queue = self.pending_queue;\n          self.clobber = self.pending_clobber;\n          self.insertions = self.pending_insertions;\n          return self;\n          } finally {\n            ((self.pending_queue = nil), (self.pending_clobber = nil), (self.pending_insertions = nil))\n          }; })()\n        }, TMP_Rewriter_transaction_11.$$arity = 0);\n        self.$private();\n        \n        Opal.defn(self, '$append', TMP_Rewriter_append_14 = function $$append(action) {\n          var $a, TMP_12, TMP_13, self = this, range = nil, conflicting = nil, adjacent = nil, insertions = nil;\n\n          \n          range = action.$range();\n          if ($truthy(range['$empty?']())) {\n            \n            if ($truthy(action.$replacement()['$empty?']())) {\n              return self};\n            if ($truthy(($truthy($a = action['$allow_multiple_insertions?']()['$!']()) ? (conflicting = self['$clobbered_insertion?'](range)) : $a))) {\n              self.$raise_clobber_error(action, [conflicting])};\n            self.$record_insertion(range);\n            if ($truthy((adjacent = self['$adjacent_updates?'](range)))) {\n              \n              conflicting = $send(adjacent, 'find', [], (TMP_12 = function(a){var self = TMP_12.$$s || this, $b;\nif (a == null) a = nil;\n              return ($truthy($b = a.$range()['$overlaps?'](range)) ? self['$replace_compatible_with_insertion?'](a, action)['$!']() : $b)}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));\n              if ($truthy(conflicting)) {\n                self.$raise_clobber_error(action, [conflicting])};\n              self['$merge_actions!'](action, adjacent);\n              } else {\n              self.$active_queue()['$<<'](action)\n            };\n            } else {\n            \n            if ($truthy((insertions = self['$adjacent_insertions?'](range)))) {\n              $send(insertions, 'each', [], (TMP_13 = function(insertion){var self = TMP_13.$$s || this, $b;\nif (insertion == null) insertion = nil;\n              if ($truthy(($truthy($b = range['$overlaps?'](insertion.$range())) ? self['$replace_compatible_with_insertion?'](action, insertion)['$!']() : $b))) {\n                  return self.$raise_clobber_error(action, [insertion])\n                  } else {\n                  \n                  action = self.$merge_actions(action, [insertion]);\n                  return self.$active_queue().$delete(insertion);\n                }}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13))};\n            if ($truthy((adjacent = self['$adjacent_updates?'](range)))) {\n              if ($truthy(self['$can_merge?'](action, adjacent))) {\n                \n                self.$record_replace(range);\n                self['$merge_actions!'](action, adjacent);\n                } else {\n                self.$raise_clobber_error(action, adjacent)\n              }\n              } else {\n              \n              self.$record_replace(range);\n              self.$active_queue()['$<<'](action);\n            };\n          };\n          return self;\n        }, TMP_Rewriter_append_14.$$arity = 1);\n        \n        Opal.defn(self, '$record_insertion', TMP_Rewriter_record_insertion_15 = function $$record_insertion(range) {\n          var self = this, $writer = nil;\n\n          \n          $writer = [self.$active_insertions()['$|']((1)['$<<'](range.$begin_pos()))];\n          $send(self, 'active_insertions=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        }, TMP_Rewriter_record_insertion_15.$$arity = 1);\n        \n        Opal.defn(self, '$record_replace', TMP_Rewriter_record_replace_16 = function $$record_replace(range) {\n          var self = this, $writer = nil;\n\n          \n          $writer = [self.$active_clobber()['$|'](self.$clobbered_position_mask(range))];\n          $send(self, 'active_clobber=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        }, TMP_Rewriter_record_replace_16.$$arity = 1);\n        \n        Opal.defn(self, '$clobbered_position_mask', TMP_Rewriter_clobbered_position_mask_17 = function $$clobbered_position_mask(range) {\n          var self = this;\n\n          return $rb_minus((1)['$<<'](range.$size()), 1)['$<<'](range.$begin_pos())\n        }, TMP_Rewriter_clobbered_position_mask_17.$$arity = 1);\n        \n        Opal.defn(self, '$adjacent_position_mask', TMP_Rewriter_adjacent_position_mask_18 = function $$adjacent_position_mask(range) {\n          var self = this;\n\n          return $rb_minus((1)['$<<']($rb_plus(range.$size(), 2)), 1)['$<<']($rb_minus(range.$begin_pos(), 1))\n        }, TMP_Rewriter_adjacent_position_mask_18.$$arity = 1);\n        \n        Opal.defn(self, '$adjacent_insertion_mask', TMP_Rewriter_adjacent_insertion_mask_19 = function $$adjacent_insertion_mask(range) {\n          var self = this;\n\n          return $rb_minus((1)['$<<']($rb_plus(range.$size(), 1)), 1)['$<<'](range.$begin_pos())\n        }, TMP_Rewriter_adjacent_insertion_mask_19.$$arity = 1);\n        \n        Opal.defn(self, '$clobbered_insertion?', TMP_Rewriter_clobbered_insertion$q_21 = function(insertion) {\n          var TMP_20, self = this, insertion_pos = nil;\n\n          \n          insertion_pos = insertion.$begin_pos();\n          if ($truthy(self.$active_insertions()['$&']((1)['$<<'](insertion_pos))['$!='](0))) {\n            return $send(self.$active_queue(), 'find', [], (TMP_20 = function(a){var self = TMP_20.$$s || this, $a;\nif (a == null) a = nil;\n            return ($truthy($a = $rb_le(a.$range().$begin_pos(), insertion_pos)) ? $rb_le(insertion_pos, a.$range().$end_pos()) : $a)}, TMP_20.$$s = self, TMP_20.$$arity = 1, TMP_20))\n            } else {\n            return nil\n          };\n        }, TMP_Rewriter_clobbered_insertion$q_21.$$arity = 1);\n        \n        Opal.defn(self, '$adjacent_insertions?', TMP_Rewriter_adjacent_insertions$q_23 = function(range) {\n          var TMP_22, self = this, result = nil;\n\n          if ($truthy(self.$active_insertions()['$&'](self.$adjacent_insertion_mask(range))['$!='](0))) {\n            \n            result = $send(self.$active_queue(), 'select', [], (TMP_22 = function(a){var self = TMP_22.$$s || this, $a;\nif (a == null) a = nil;\n            return ($truthy($a = a.$range()['$empty?']()) ? self['$adjacent?'](range, a.$range()) : $a)}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22));\n            if ($truthy(result['$empty?']())) {\n              return nil\n              } else {\n              return result\n            };\n            } else {\n            return nil\n          }\n        }, TMP_Rewriter_adjacent_insertions$q_23.$$arity = 1);\n        \n        Opal.defn(self, '$adjacent_updates?', TMP_Rewriter_adjacent_updates$q_25 = function(range) {\n          var TMP_24, self = this;\n\n          if ($truthy(self.$active_clobber()['$&'](self.$adjacent_position_mask(range))['$!='](0))) {\n            return $send(self.$active_queue(), 'select', [], (TMP_24 = function(a){var self = TMP_24.$$s || this;\nif (a == null) a = nil;\n            return self['$adjacent?'](range, a.$range())}, TMP_24.$$s = self, TMP_24.$$arity = 1, TMP_24))\n            } else {\n            return nil\n          }\n        }, TMP_Rewriter_adjacent_updates$q_25.$$arity = 1);\n        \n        Opal.defn(self, '$replace_compatible_with_insertion?', TMP_Rewriter_replace_compatible_with_insertion$q_26 = function(replace, insertion) {\n          var $a, $b, self = this, offset = nil;\n\n          return ($truthy($a = ($truthy($b = $rb_ge($rb_minus(replace.$replacement().$length(), replace.$range().$size()), insertion.$range().$size())) ? (offset = $rb_minus(insertion.$range().$begin_pos(), replace.$range().$begin_pos())) : $b)) ? replace.$replacement()['$[]'](offset, insertion.$replacement().$length())['$=='](insertion.$replacement()) : $a)\n        }, TMP_Rewriter_replace_compatible_with_insertion$q_26.$$arity = 2);\n        \n        Opal.defn(self, '$can_merge?', TMP_Rewriter_can_merge$q_28 = function(action, existing) {\n          var TMP_27, self = this, range = nil;\n\n          \n          range = action.$range();\n          return $send(existing, 'all?', [], (TMP_27 = function(other){var self = TMP_27.$$s || this, $a, overlap = nil, repl1_offset = nil, repl2_offset = nil, repl1_length = nil, repl2_length = nil, replacement1 = nil, replacement2 = nil;\nif (other == null) other = nil;\n          \n            overlap = range.$intersect(other.$range());\n            if ($truthy(overlap['$nil?']())) {\n              return true;};\n            repl1_offset = $rb_minus(overlap.$begin_pos(), range.$begin_pos());\n            repl2_offset = $rb_minus(overlap.$begin_pos(), other.$range().$begin_pos());\n            repl1_length = [$rb_minus(other.$range().$length(), repl2_offset), $rb_minus(other.$replacement().$length(), repl2_offset)].$max();\n            repl2_length = [$rb_minus(range.$length(), repl1_offset), $rb_minus(action.$replacement().$length(), repl1_offset)].$max();\n            replacement1 = ($truthy($a = action.$replacement()['$[]'](repl1_offset, repl1_length)) ? $a : \"\".$freeze());\n            replacement2 = ($truthy($a = other.$replacement()['$[]'](repl2_offset, repl2_length)) ? $a : \"\".$freeze());\n            return replacement1['$=='](replacement2);}, TMP_27.$$s = self, TMP_27.$$arity = 1, TMP_27));\n        }, TMP_Rewriter_can_merge$q_28.$$arity = 2);\n        \n        Opal.defn(self, '$merge_actions', TMP_Rewriter_merge_actions_31 = function $$merge_actions(action, existing) {\n          var TMP_29, TMP_30, self = this, actions = nil, range = nil;\n\n          \n          actions = $send(existing.$push(action), 'sort_by', [], (TMP_29 = function(a){var self = TMP_29.$$s || this;\nif (a == null) a = nil;\n          return [a.$range().$begin_pos(), a.$range().$end_pos()]}, TMP_29.$$s = self, TMP_29.$$arity = 1, TMP_29));\n          range = actions.$first().$range().$join($send(actions, 'max_by', [], (TMP_30 = function(a){var self = TMP_30.$$s || this;\nif (a == null) a = nil;\n          return a.$range().$end_pos()}, TMP_30.$$s = self, TMP_30.$$arity = 1, TMP_30)).$range());\n          return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriter'), 'Action').$new(range, self.$merge_replacements(actions));\n        }, TMP_Rewriter_merge_actions_31.$$arity = 2);\n        \n        Opal.defn(self, '$merge_actions!', TMP_Rewriter_merge_actions$B_32 = function(action, existing) {\n          var self = this, new_action = nil;\n\n          \n          new_action = self.$merge_actions(action, existing);\n          self.$active_queue().$delete(action);\n          return self.$replace_actions(existing, new_action);\n        }, TMP_Rewriter_merge_actions$B_32.$$arity = 2);\n        \n        Opal.defn(self, '$merge_replacements', TMP_Rewriter_merge_replacements_34 = function $$merge_replacements(actions) {\n          var TMP_33, self = this, result = nil, prev_act = nil;\n\n          \n          result = \"\";\n          prev_act = nil;\n          $send(actions, 'each', [], (TMP_33 = function(act){var self = TMP_33.$$s || this, $a, prev_end = nil, offset = nil;\nif (act == null) act = nil;\n          \n            if ($truthy(($truthy($a = prev_act['$!']()) ? $a : act.$range()['$disjoint?'](prev_act.$range())))) {\n              result['$<<'](act.$replacement())\n              } else {\n              \n              prev_end = [$rb_plus(prev_act.$range().$begin_pos(), prev_act.$replacement().$length()), prev_act.$range().$end_pos()].$max();\n              offset = $rb_minus(prev_end, act.$range().$begin_pos());\n              if ($truthy($rb_lt(offset, act.$replacement().$size()))) {\n                result['$<<'](act.$replacement()['$[]'](Opal.Range.$new(offset, -1, false)))};\n            };\n            return (prev_act = act);}, TMP_33.$$s = self, TMP_33.$$arity = 1, TMP_33));\n          return result;\n        }, TMP_Rewriter_merge_replacements_34.$$arity = 1);\n        \n        Opal.defn(self, '$replace_actions', TMP_Rewriter_replace_actions_36 = function $$replace_actions(old, updated) {\n          var TMP_35, self = this;\n\n          \n          $send(old, 'each', [], (TMP_35 = function(act){var self = TMP_35.$$s || this;\nif (act == null) act = nil;\n          return self.$active_queue().$delete(act)}, TMP_35.$$s = self, TMP_35.$$arity = 1, TMP_35));\n          return self.$active_queue()['$<<'](updated);\n        }, TMP_Rewriter_replace_actions_36.$$arity = 2);\n        \n        Opal.defn(self, '$raise_clobber_error', TMP_Rewriter_raise_clobber_error_37 = function $$raise_clobber_error(action, existing) {\n          var self = this, diagnostic = nil;\n\n          \n          diagnostic = Opal.const_get_relative($nesting, 'Diagnostic').$new(\"error\", \"invalid_action\", $hash2([\"action\"], {\"action\": action}), action.$range());\n          self.diagnostics.$process(diagnostic);\n          diagnostic = Opal.const_get_relative($nesting, 'Diagnostic').$new(\"note\", \"clobbered\", $hash2([\"action\"], {\"action\": existing['$[]'](0)}), existing['$[]'](0).$range());\n          self.diagnostics.$process(diagnostic);\n          return self.$raise(Opal.const_get_relative($nesting, 'ClobberingError'), \"Parser::Source::Rewriter detected clobbering\");\n        }, TMP_Rewriter_raise_clobber_error_37.$$arity = 2);\n        \n        Opal.defn(self, '$in_transaction?', TMP_Rewriter_in_transaction$q_38 = function() {\n          var self = this;\n\n          return self.pending_queue['$nil?']()['$!']()\n        }, TMP_Rewriter_in_transaction$q_38.$$arity = 0);\n        \n        Opal.defn(self, '$active_queue', TMP_Rewriter_active_queue_39 = function $$active_queue() {\n          var $a, self = this;\n\n          return ($truthy($a = self.pending_queue) ? $a : self.queue)\n        }, TMP_Rewriter_active_queue_39.$$arity = 0);\n        \n        Opal.defn(self, '$active_clobber', TMP_Rewriter_active_clobber_40 = function $$active_clobber() {\n          var $a, self = this;\n\n          return ($truthy($a = self.pending_clobber) ? $a : self.clobber)\n        }, TMP_Rewriter_active_clobber_40.$$arity = 0);\n        \n        Opal.defn(self, '$active_insertions', TMP_Rewriter_active_insertions_41 = function $$active_insertions() {\n          var $a, self = this;\n\n          return ($truthy($a = self.pending_insertions) ? $a : self.insertions)\n        }, TMP_Rewriter_active_insertions_41.$$arity = 0);\n        \n        Opal.defn(self, '$active_clobber=', TMP_Rewriter_active_clobber$eq_42 = function(value) {\n          var self = this;\n\n          if ($truthy(self.pending_clobber)) {\n            return (self.pending_clobber = value)\n            } else {\n            return (self.clobber = value)\n          }\n        }, TMP_Rewriter_active_clobber$eq_42.$$arity = 1);\n        \n        Opal.defn(self, '$active_insertions=', TMP_Rewriter_active_insertions$eq_43 = function(value) {\n          var self = this;\n\n          if ($truthy(self.pending_insertions)) {\n            return (self.pending_insertions = value)\n            } else {\n            return (self.insertions = value)\n          }\n        }, TMP_Rewriter_active_insertions$eq_43.$$arity = 1);\n        return (Opal.defn(self, '$adjacent?', TMP_Rewriter_adjacent$q_44 = function(range1, range2) {\n          var $a, self = this;\n\n          return ($truthy($a = $rb_le(range1.$begin_pos(), range2.$end_pos())) ? $rb_le(range2.$begin_pos(), range1.$end_pos()) : $a)\n        }, TMP_Rewriter_adjacent$q_44.$$arity = 2), nil) && 'adjacent?';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/rewriter/action\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$include', '$attr_reader', '$alias_method', '$freeze', '$<=>', '$begin_pos', '$range', '$zero?', '$order', '$==', '$length', '$empty?', '$inspect']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Action(){};\n        var self = $Action = $klass($base, $super, 'Action', $Action);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Action_initialize_1, TMP_Action_$lt$eq$gt_2, TMP_Action_to_s_3;\n\n        def.range = def.replacement = nil;\n        \n        self.$include(Opal.const_get_relative($nesting, 'Comparable'));\n        self.$attr_reader(\"range\", \"replacement\", \"allow_multiple_insertions\", \"order\");\n        self.$alias_method(\"allow_multiple_insertions?\", \"allow_multiple_insertions\");\n        \n        Opal.defn(self, '$initialize', TMP_Action_initialize_1 = function $$initialize(range, replacement, allow_multiple_insertions, order) {\n          var self = this;\n\n          if (replacement == null) {\n            replacement = \"\";\n          }\n          if (allow_multiple_insertions == null) {\n            allow_multiple_insertions = false;\n          }\n          if (order == null) {\n            order = 0;\n          }\n          \n          self.range = range;\n          self.replacement = replacement;\n          self.allow_multiple_insertions = allow_multiple_insertions;\n          self.order = order;\n          return self.$freeze();\n        }, TMP_Action_initialize_1.$$arity = -2);\n        \n        Opal.defn(self, '$<=>', TMP_Action_$lt$eq$gt_2 = function(other) {\n          var self = this, result = nil;\n\n          \n          result = self.$range().$begin_pos()['$<=>'](other.$range().$begin_pos());\n          if ($truthy(result['$zero?']())) {\n            } else {\n            return result\n          };\n          return self.$order()['$<=>'](other.$order());\n        }, TMP_Action_$lt$eq$gt_2.$$arity = 1);\n        return (Opal.defn(self, '$to_s', TMP_Action_to_s_3 = function $$to_s() {\n          var $a, self = this;\n\n          if ($truthy((($a = self.range.$length()['$=='](0)) ? self.replacement['$empty?']() : self.range.$length()['$=='](0)))) {\n            return \"do nothing\"\n          } else if (self.range.$length()['$=='](0)) {\n            return \"\" + \"insert \" + (self.replacement.$inspect())\n          } else if ($truthy(self.replacement['$empty?']())) {\n            return \"\" + \"remove \" + (self.range.$length()) + \" character(s)\"\n            } else {\n            return \"\" + \"replace \" + (self.range.$length()) + \" character(s) with \" + (self.replacement.$inspect())\n          }\n        }, TMP_Action_to_s_3.$$arity = 0), nil) && 'to_s';\n      })(Opal.const_get_relative($nesting, 'Rewriter'), null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $range = Opal.range;\n\n  Opal.add_stubs(['$attr_reader', '$freeze', '$line', '$alias_method', '$column', '$last_line', '$last_column', '$with', '$update_expression', '$==', '$class', '$reduce', '$map', '$instance_variables', '$instance_variable_get', '$send', '$inject', '$to_sym', '$[]', '$[]=', '$-', '$protected', '$tap', '$dup', '$to_proc']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Map(){};\n        var self = $Map = $klass($base, $super, 'Map', $Map);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Map_initialize_1, TMP_Map_initialize_copy_2, TMP_Map_node$eq_3, TMP_Map_line_4, TMP_Map_column_5, TMP_Map_last_line_6, TMP_Map_last_column_7, TMP_Map_with_expression_9, TMP_Map_$eq$eq_11, TMP_Map_to_hash_13, TMP_Map_with_14, TMP_Map_update_expression_15;\n\n        def.node = def.expression = nil;\n        \n        self.$attr_reader(\"node\");\n        self.$attr_reader(\"expression\");\n        \n        Opal.defn(self, '$initialize', TMP_Map_initialize_1 = function $$initialize(expression) {\n          var self = this;\n\n          return (self.expression = expression)\n        }, TMP_Map_initialize_1.$$arity = 1);\n        \n        Opal.defn(self, '$initialize_copy', TMP_Map_initialize_copy_2 = function $$initialize_copy(other) {\n          var self = this, $iter = TMP_Map_initialize_copy_2.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_Map_initialize_copy_2.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize_copy', TMP_Map_initialize_copy_2, false), $zuper, $iter);\n          return (self.node = nil);\n        }, TMP_Map_initialize_copy_2.$$arity = 1);\n        \n        Opal.defn(self, '$node=', TMP_Map_node$eq_3 = function(node) {\n          var self = this;\n\n          \n          self.node = node;\n          self.$freeze();\n          return self.node;\n        }, TMP_Map_node$eq_3.$$arity = 1);\n        \n        Opal.defn(self, '$line', TMP_Map_line_4 = function $$line() {\n          var self = this;\n\n          return self.expression.$line()\n        }, TMP_Map_line_4.$$arity = 0);\n        self.$alias_method(\"first_line\", \"line\");\n        \n        Opal.defn(self, '$column', TMP_Map_column_5 = function $$column() {\n          var self = this;\n\n          return self.expression.$column()\n        }, TMP_Map_column_5.$$arity = 0);\n        \n        Opal.defn(self, '$last_line', TMP_Map_last_line_6 = function $$last_line() {\n          var self = this;\n\n          return self.expression.$last_line()\n        }, TMP_Map_last_line_6.$$arity = 0);\n        \n        Opal.defn(self, '$last_column', TMP_Map_last_column_7 = function $$last_column() {\n          var self = this;\n\n          return self.expression.$last_column()\n        }, TMP_Map_last_column_7.$$arity = 0);\n        \n        Opal.defn(self, '$with_expression', TMP_Map_with_expression_9 = function $$with_expression(expression_l) {\n          var TMP_8, self = this;\n\n          return $send(self, 'with', [], (TMP_8 = function(map){var self = TMP_8.$$s || this;\nif (map == null) map = nil;\n          return map.$update_expression(expression_l)}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8))\n        }, TMP_Map_with_expression_9.$$arity = 1);\n        \n        Opal.defn(self, '$==', TMP_Map_$eq$eq_11 = function(other) {\n          var $a, TMP_10, self = this;\n\n          return (($a = other.$class()['$=='](self.$class())) ? $send(self.$instance_variables(), 'map', [], (TMP_10 = function(ivar){var self = TMP_10.$$s || this;\nif (ivar == null) ivar = nil;\n          return self.$instance_variable_get(ivar)['$=='](other.$send(\"instance_variable_get\", ivar))}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10)).$reduce(\"&\") : other.$class()['$=='](self.$class()))\n        }, TMP_Map_$eq$eq_11.$$arity = 1);\n        \n        Opal.defn(self, '$to_hash', TMP_Map_to_hash_13 = function $$to_hash() {\n          var TMP_12, self = this;\n\n          return $send(self.$instance_variables(), 'inject', [$hash2([], {})], (TMP_12 = function(hash, ivar){var self = TMP_12.$$s || this, $writer = nil;\nif (hash == null) hash = nil;if (ivar == null) ivar = nil;\n          \n            if (ivar.$to_sym()['$=='](\"@node\")) {\n              return hash;};\n            \n            $writer = [ivar['$[]']($range(1, -1, false)).$to_sym(), self.$instance_variable_get(ivar)];\n            $send(hash, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            return hash;}, TMP_12.$$s = self, TMP_12.$$arity = 2, TMP_12))\n        }, TMP_Map_to_hash_13.$$arity = 0);\n        self.$protected();\n        \n        Opal.defn(self, '$with', TMP_Map_with_14 = function() {\n          var self = this, $iter = TMP_Map_with_14.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Map_with_14.$$p = null;\n          return $send(self.$dup(), 'tap', [], block.$to_proc())\n        }, TMP_Map_with_14.$$arity = 0);\n        return (Opal.defn(self, '$update_expression', TMP_Map_update_expression_15 = function $$update_expression(expression_l) {\n          var self = this;\n\n          return (self.expression = expression_l)\n        }, TMP_Map_update_expression_15.$$arity = 1), nil) && 'update_expression';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/operator\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Operator(){};\n        var self = $Operator = $klass($base, $super, 'Operator', $Operator);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Operator_initialize_1;\n\n        \n        self.$attr_reader(\"operator\");\n        return (Opal.defn(self, '$initialize', TMP_Operator_initialize_1 = function $$initialize(operator, expression) {\n          var self = this, $iter = TMP_Operator_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_Operator_initialize_1.$$p = null;\n          \n          self.operator = operator;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Operator_initialize_1, false), [expression], null);\n        }, TMP_Operator_initialize_1.$$arity = 2), nil) && 'initialize';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/collection\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Collection(){};\n        var self = $Collection = $klass($base, $super, 'Collection', $Collection);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Collection_initialize_1;\n\n        \n        self.$attr_reader(\"begin\");\n        self.$attr_reader(\"end\");\n        return (Opal.defn(self, '$initialize', TMP_Collection_initialize_1 = function $$initialize(begin_l, end_l, expression_l) {\n          var $a, self = this, $iter = TMP_Collection_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_Collection_initialize_1.$$p = null;\n          \n          $a = [begin_l, end_l], (self.begin = $a[0]), (self.end = $a[1]), $a;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Collection_initialize_1, false), [expression_l], null);\n        }, TMP_Collection_initialize_1.$$arity = 3), nil) && 'initialize';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/constant\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$with', '$update_operator', '$protected']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Constant(){};\n        var self = $Constant = $klass($base, $super, 'Constant', $Constant);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Constant_initialize_1, TMP_Constant_with_operator_3, TMP_Constant_update_operator_4;\n\n        \n        self.$attr_reader(\"double_colon\");\n        self.$attr_reader(\"name\");\n        self.$attr_reader(\"operator\");\n        \n        Opal.defn(self, '$initialize', TMP_Constant_initialize_1 = function $$initialize(double_colon, name, expression) {\n          var $a, self = this, $iter = TMP_Constant_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_Constant_initialize_1.$$p = null;\n          \n          $a = [double_colon, name], (self.double_colon = $a[0]), (self.name = $a[1]), $a;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Constant_initialize_1, false), [expression], null);\n        }, TMP_Constant_initialize_1.$$arity = 3);\n        \n        Opal.defn(self, '$with_operator', TMP_Constant_with_operator_3 = function $$with_operator(operator_l) {\n          var TMP_2, self = this;\n\n          return $send(self, 'with', [], (TMP_2 = function(map){var self = TMP_2.$$s || this;\nif (map == null) map = nil;\n          return map.$update_operator(operator_l)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))\n        }, TMP_Constant_with_operator_3.$$arity = 1);\n        self.$protected();\n        return (Opal.defn(self, '$update_operator', TMP_Constant_update_operator_4 = function $$update_operator(operator_l) {\n          var self = this;\n\n          return (self.operator = operator_l)\n        }, TMP_Constant_update_operator_4.$$arity = 1), nil) && 'update_operator';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/variable\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$with', '$update_operator', '$protected']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Variable(){};\n        var self = $Variable = $klass($base, $super, 'Variable', $Variable);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Variable_initialize_1, TMP_Variable_with_operator_3, TMP_Variable_update_operator_4;\n\n        \n        self.$attr_reader(\"name\");\n        self.$attr_reader(\"operator\");\n        \n        Opal.defn(self, '$initialize', TMP_Variable_initialize_1 = function $$initialize(name_l, expression_l) {\n          var self = this, $iter = TMP_Variable_initialize_1.$$p, $yield = $iter || nil;\n\n          if (expression_l == null) {\n            expression_l = name_l;\n          }\n          if ($iter) TMP_Variable_initialize_1.$$p = null;\n          \n          self.name = name_l;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Variable_initialize_1, false), [expression_l], null);\n        }, TMP_Variable_initialize_1.$$arity = -2);\n        \n        Opal.defn(self, '$with_operator', TMP_Variable_with_operator_3 = function $$with_operator(operator_l) {\n          var TMP_2, self = this;\n\n          return $send(self, 'with', [], (TMP_2 = function(map){var self = TMP_2.$$s || this;\nif (map == null) map = nil;\n          return map.$update_operator(operator_l)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))\n        }, TMP_Variable_with_operator_3.$$arity = 1);\n        self.$protected();\n        return (Opal.defn(self, '$update_operator', TMP_Variable_update_operator_4 = function $$update_operator(operator_l) {\n          var self = this;\n\n          return (self.operator = operator_l)\n        }, TMP_Variable_update_operator_4.$$arity = 1), nil) && 'update_operator';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/keyword\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Keyword(){};\n        var self = $Keyword = $klass($base, $super, 'Keyword', $Keyword);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Keyword_initialize_1;\n\n        \n        self.$attr_reader(\"keyword\");\n        self.$attr_reader(\"begin\");\n        self.$attr_reader(\"end\");\n        return (Opal.defn(self, '$initialize', TMP_Keyword_initialize_1 = function $$initialize(keyword_l, begin_l, end_l, expression_l) {\n          var $a, self = this, $iter = TMP_Keyword_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_Keyword_initialize_1.$$p = null;\n          \n          self.keyword = keyword_l;\n          $a = [begin_l, end_l], (self.begin = $a[0]), (self.end = $a[1]), $a;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Keyword_initialize_1, false), [expression_l], null);\n        }, TMP_Keyword_initialize_1.$$arity = 4), nil) && 'initialize';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/definition\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$join']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Definition(){};\n        var self = $Definition = $klass($base, $super, 'Definition', $Definition);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Definition_initialize_1;\n\n        def.keyword = def.end = nil;\n        \n        self.$attr_reader(\"keyword\");\n        self.$attr_reader(\"operator\");\n        self.$attr_reader(\"name\");\n        self.$attr_reader(\"end\");\n        return (Opal.defn(self, '$initialize', TMP_Definition_initialize_1 = function $$initialize(keyword_l, operator_l, name_l, end_l) {\n          var self = this, $iter = TMP_Definition_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_Definition_initialize_1.$$p = null;\n          \n          self.keyword = keyword_l;\n          self.operator = operator_l;\n          self.name = name_l;\n          self.end = end_l;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Definition_initialize_1, false), [self.keyword.$join(self.end)], null);\n        }, TMP_Definition_initialize_1.$$arity = 4), nil) && 'initialize';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/send\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$with', '$update_operator', '$protected']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Send(){};\n        var self = $Send = $klass($base, $super, 'Send', $Send);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Send_initialize_1, TMP_Send_with_operator_3, TMP_Send_update_operator_4;\n\n        \n        self.$attr_reader(\"dot\");\n        self.$attr_reader(\"selector\");\n        self.$attr_reader(\"operator\");\n        self.$attr_reader(\"begin\");\n        self.$attr_reader(\"end\");\n        \n        Opal.defn(self, '$initialize', TMP_Send_initialize_1 = function $$initialize(dot_l, selector_l, begin_l, end_l, expression_l) {\n          var $a, self = this, $iter = TMP_Send_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_Send_initialize_1.$$p = null;\n          \n          self.dot = dot_l;\n          self.selector = selector_l;\n          $a = [begin_l, end_l], (self.begin = $a[0]), (self.end = $a[1]), $a;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Send_initialize_1, false), [expression_l], null);\n        }, TMP_Send_initialize_1.$$arity = 5);\n        \n        Opal.defn(self, '$with_operator', TMP_Send_with_operator_3 = function $$with_operator(operator_l) {\n          var TMP_2, self = this;\n\n          return $send(self, 'with', [], (TMP_2 = function(map){var self = TMP_2.$$s || this;\nif (map == null) map = nil;\n          return map.$update_operator(operator_l)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))\n        }, TMP_Send_with_operator_3.$$arity = 1);\n        self.$protected();\n        return (Opal.defn(self, '$update_operator', TMP_Send_update_operator_4 = function $$update_operator(operator_l) {\n          var self = this;\n\n          return (self.operator = operator_l)\n        }, TMP_Send_update_operator_4.$$arity = 1), nil) && 'update_operator';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/condition\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Condition(){};\n        var self = $Condition = $klass($base, $super, 'Condition', $Condition);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Condition_initialize_1;\n\n        \n        self.$attr_reader(\"keyword\");\n        self.$attr_reader(\"begin\");\n        self.$attr_reader(\"else\");\n        self.$attr_reader(\"end\");\n        return (Opal.defn(self, '$initialize', TMP_Condition_initialize_1 = function $$initialize(keyword_l, begin_l, else_l, end_l, expression_l) {\n          var $a, self = this, $iter = TMP_Condition_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_Condition_initialize_1.$$p = null;\n          \n          self.keyword = keyword_l;\n          $a = [begin_l, else_l, end_l], (self.begin = $a[0]), (self[\"else\"] = $a[1]), (self.end = $a[2]), $a;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Condition_initialize_1, false), [expression_l], null);\n        }, TMP_Condition_initialize_1.$$arity = 5), nil) && 'initialize';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/ternary\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Ternary(){};\n        var self = $Ternary = $klass($base, $super, 'Ternary', $Ternary);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Ternary_initialize_1;\n\n        \n        self.$attr_reader(\"question\");\n        self.$attr_reader(\"colon\");\n        return (Opal.defn(self, '$initialize', TMP_Ternary_initialize_1 = function $$initialize(question_l, colon_l, expression_l) {\n          var $a, self = this, $iter = TMP_Ternary_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_Ternary_initialize_1.$$p = null;\n          \n          $a = [question_l, colon_l], (self.question = $a[0]), (self.colon = $a[1]), $a;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Ternary_initialize_1, false), [expression_l], null);\n        }, TMP_Ternary_initialize_1.$$arity = 3), nil) && 'initialize';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/for\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $For(){};\n        var self = $For = $klass($base, $super, 'For', $For);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_For_initialize_1;\n\n        \n        self.$attr_reader(\"keyword\", \"in\");\n        self.$attr_reader(\"begin\", \"end\");\n        return (Opal.defn(self, '$initialize', TMP_For_initialize_1 = function $$initialize(keyword_l, in_l, begin_l, end_l, expression_l) {\n          var $a, self = this, $iter = TMP_For_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_For_initialize_1.$$p = null;\n          \n          $a = [keyword_l, in_l], (self.keyword = $a[0]), (self[\"in\"] = $a[1]), $a;\n          $a = [begin_l, end_l], (self.begin = $a[0]), (self.end = $a[1]), $a;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_For_initialize_1, false), [expression_l], null);\n        }, TMP_For_initialize_1.$$arity = 5), nil) && 'initialize';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/rescue_body\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $RescueBody(){};\n        var self = $RescueBody = $klass($base, $super, 'RescueBody', $RescueBody);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_RescueBody_initialize_1;\n\n        \n        self.$attr_reader(\"keyword\");\n        self.$attr_reader(\"assoc\");\n        self.$attr_reader(\"begin\");\n        return (Opal.defn(self, '$initialize', TMP_RescueBody_initialize_1 = function $$initialize(keyword_l, assoc_l, begin_l, expression_l) {\n          var self = this, $iter = TMP_RescueBody_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_RescueBody_initialize_1.$$p = null;\n          \n          self.keyword = keyword_l;\n          self.assoc = assoc_l;\n          self.begin = begin_l;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_RescueBody_initialize_1, false), [expression_l], null);\n        }, TMP_RescueBody_initialize_1.$$arity = 4), nil) && 'initialize';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/heredoc\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Heredoc(){};\n        var self = $Heredoc = $klass($base, $super, 'Heredoc', $Heredoc);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Heredoc_initialize_1;\n\n        \n        self.$attr_reader(\"heredoc_body\");\n        self.$attr_reader(\"heredoc_end\");\n        return (Opal.defn(self, '$initialize', TMP_Heredoc_initialize_1 = function $$initialize(begin_l, body_l, end_l) {\n          var self = this, $iter = TMP_Heredoc_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_Heredoc_initialize_1.$$p = null;\n          \n          self.heredoc_body = body_l;\n          self.heredoc_end = end_l;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Heredoc_initialize_1, false), [begin_l], null);\n        }, TMP_Heredoc_initialize_1.$$arity = 3), nil) && 'initialize';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/source/map/objc_kwarg\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $ObjcKwarg(){};\n        var self = $ObjcKwarg = $klass($base, $super, 'ObjcKwarg', $ObjcKwarg);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ObjcKwarg_initialize_1;\n\n        \n        self.$attr_reader(\"keyword\");\n        self.$attr_reader(\"operator\");\n        self.$attr_reader(\"argument\");\n        return (Opal.defn(self, '$initialize', TMP_ObjcKwarg_initialize_1 = function $$initialize(keyword_l, operator_l, argument_l, expression_l) {\n          var $a, self = this, $iter = TMP_ObjcKwarg_initialize_1.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_ObjcKwarg_initialize_1.$$p = null;\n          \n          $a = [keyword_l, operator_l, argument_l], (self.keyword = $a[0]), (self.operator = $a[1]), (self.argument = $a[2]), $a;\n          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_ObjcKwarg_initialize_1, false), [expression_l], null);\n        }, TMP_ObjcKwarg_initialize_1.$$arity = 4), nil) && 'initialize';\n      })(Opal.const_get_relative($nesting, 'Map'), Opal.const_get_relative($nesting, 'Map'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/syntax_error\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$message']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $SyntaxError(){};\n      var self = $SyntaxError = $klass($base, $super, 'SyntaxError', $SyntaxError);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SyntaxError_initialize_1;\n\n      \n      self.$attr_reader(\"diagnostic\");\n      return (Opal.defn(self, '$initialize', TMP_SyntaxError_initialize_1 = function $$initialize(diagnostic) {\n        var self = this, $iter = TMP_SyntaxError_initialize_1.$$p, $yield = $iter || nil;\n\n        if ($iter) TMP_SyntaxError_initialize_1.$$p = null;\n        \n        self.diagnostic = diagnostic;\n        return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_SyntaxError_initialize_1, false), [diagnostic.$message()], null);\n      }, TMP_SyntaxError_initialize_1.$$arity = 1), nil) && 'initialize';\n    })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/clobbering_error\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $ClobberingError(){};\n      var self = $ClobberingError = $klass($base, $super, 'ClobberingError', $ClobberingError);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return nil\n    })($nesting[0], Opal.const_get_relative($nesting, 'RuntimeError'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/diagnostic\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$freeze', '$attr_reader', '$include?', '$raise', '$join', '$inspect', '$dup', '$%', '$[]', '$==', '$line', '$last_line', '$is?', '$+', '$message', '$render_line', '$first_line_only', '$last_line_only', '$-', '$source_buffer', '$decompose_position', '$end_pos', '$>', '$private', '$source_line', '$*', '$length', '$each', '$line_range', '$intersect', '$column_range', '$size', '$[]=', '$!', '$>=', '$map', '$name', '$!=', '$resize', '$=~', '$source', '$new', '$begin_pos']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Diagnostic(){};\n      var self = $Diagnostic = $klass($base, $super, 'Diagnostic', $Diagnostic);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Diagnostic_initialize_1, TMP_Diagnostic_message_2, TMP_Diagnostic_render_3, TMP_Diagnostic_render_line_6, TMP_Diagnostic_first_line_only_7, TMP_Diagnostic_last_line_only_8;\n\n      def.reason = def[\"arguments\"] = def.location = def.level = def.highlights = nil;\n      \n      Opal.const_set($nesting[0], 'LEVELS', [\"note\", \"warning\", \"error\", \"fatal\"].$freeze());\n      self.$attr_reader(\"level\", \"reason\", \"arguments\");\n      self.$attr_reader(\"location\", \"highlights\");\n      \n      Opal.defn(self, '$initialize', TMP_Diagnostic_initialize_1 = function $$initialize(level, reason, arguments$, location, highlights) {\n        var $a, self = this;\n\n        if (highlights == null) {\n          highlights = [];\n        }\n        \n        if ($truthy(Opal.const_get_relative($nesting, 'LEVELS')['$include?'](level))) {\n          } else {\n          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + (\"\" + \"Diagnostic#level must be one of \" + (Opal.const_get_relative($nesting, 'LEVELS').$join(\", \")) + \"; \") + (\"\" + (level.$inspect()) + \" provided.\"))\n        };\n        if ($truthy(location)) {\n          } else {\n          self.$raise(\"Expected a location\")\n        };\n        self.level = level;\n        self.reason = reason;\n        self[\"arguments\"] = ($truthy($a = arguments$) ? $a : $hash2([], {})).$dup().$freeze();\n        self.location = location;\n        self.highlights = highlights.$dup().$freeze();\n        return self.$freeze();\n      }, TMP_Diagnostic_initialize_1.$$arity = -5);\n      \n      Opal.defn(self, '$message', TMP_Diagnostic_message_2 = function $$message() {\n        var self = this;\n\n        return Opal.const_get_relative($nesting, 'MESSAGES')['$[]'](self.reason)['$%'](self[\"arguments\"])\n      }, TMP_Diagnostic_message_2.$$arity = 0);\n      \n      Opal.defn(self, '$render', TMP_Diagnostic_render_3 = function $$render() {\n        var $a, $b, self = this, first_line = nil, last_line = nil, num_lines = nil, buffer = nil, last_lineno = nil, last_column = nil;\n\n        if ($truthy(($truthy($a = self.location.$line()['$=='](self.location.$last_line())) ? $a : self.location['$is?'](\"\\n\")))) {\n          return $rb_plus([\"\" + (self.location) + \": \" + (self.level) + \": \" + (self.$message())], self.$render_line(self.location))\n          } else {\n          \n          first_line = self.$first_line_only(self.location);\n          last_line = self.$last_line_only(self.location);\n          num_lines = $rb_plus($rb_minus(self.location.$last_line(), self.location.$line()), 1);\n          buffer = self.location.$source_buffer();\n          $b = buffer.$decompose_position(self.location.$end_pos()), $a = Opal.to_ary($b), (last_lineno = ($a[0] == null ? nil : $a[0])), (last_column = ($a[1] == null ? nil : $a[1])), $b;\n          return $rb_plus($rb_plus([\"\" + (self.location) + \"-\" + (last_lineno) + \":\" + (last_column) + \": \" + (self.level) + \": \" + (self.$message())], self.$render_line(first_line, $rb_gt(num_lines, 2), false)), self.$render_line(last_line, false, true));\n        }\n      }, TMP_Diagnostic_render_3.$$arity = 0);\n      self.$private();\n      \n      Opal.defn(self, '$render_line', TMP_Diagnostic_render_line_6 = function $$render_line(range, ellipsis, range_end) {\n        var TMP_4, $a, TMP_5, self = this, source_line = nil, highlight_line = nil, $writer = nil;\n\n        if (ellipsis == null) {\n          ellipsis = false;\n        }\n        if (range_end == null) {\n          range_end = false;\n        }\n        \n        source_line = range.$source_line();\n        highlight_line = $rb_times(\" \", source_line.$length());\n        $send(self.highlights, 'each', [], (TMP_4 = function(highlight){var self = TMP_4.$$s || this, line_range = nil, $writer = nil;\nif (highlight == null) highlight = nil;\n        \n          line_range = range.$source_buffer().$line_range(range.$line());\n          if ($truthy((highlight = highlight.$intersect(line_range)))) {\n            \n            $writer = [highlight.$column_range(), $rb_times(\"~\", highlight.$size())];\n            $send(highlight_line, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n            } else {\n            return nil\n          };}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));\n        if ($truthy(range['$is?'](\"\\n\"))) {\n          highlight_line = $rb_plus(highlight_line, \"^\")\n        } else if ($truthy(($truthy($a = range_end['$!']()) ? $rb_ge(range.$size(), 1) : $a))) {\n          \n          $writer = [range.$column_range(), $rb_plus(\"^\", $rb_times(\"~\", $rb_minus(range.$size(), 1)))];\n          $send(highlight_line, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n          \n          $writer = [range.$column_range(), $rb_times(\"~\", range.$size())];\n          $send(highlight_line, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        };\n        if ($truthy(ellipsis)) {\n          highlight_line = $rb_plus(highlight_line, \"...\")};\n        return $send([source_line, highlight_line], 'map', [], (TMP_5 = function(line){var self = TMP_5.$$s || this;\nif (line == null) line = nil;\n        return \"\" + (range.$source_buffer().$name()) + \":\" + (range.$line()) + \": \" + (line)}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));\n      }, TMP_Diagnostic_render_line_6.$$arity = -2);\n      \n      Opal.defn(self, '$first_line_only', TMP_Diagnostic_first_line_only_7 = function $$first_line_only(range) {\n        var self = this;\n\n        if ($truthy(range.$line()['$!='](range.$last_line()))) {\n          return range.$resize(range.$source()['$=~'](/\\n/))\n          } else {\n          return range\n        }\n      }, TMP_Diagnostic_first_line_only_7.$$arity = 1);\n      return (Opal.defn(self, '$last_line_only', TMP_Diagnostic_last_line_only_8 = function $$last_line_only(range) {\n        var self = this;\n\n        if ($truthy(range.$line()['$!='](range.$last_line()))) {\n          return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Range').$new(range.$source_buffer(), $rb_plus(range.$begin_pos(), range.$source()['$=~'](/[^\\n]*$/)), range.$end_pos())\n          } else {\n          return range\n        }\n      }, TMP_Diagnostic_last_line_only_8.$$arity = 1), nil) && 'last_line_only';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/diagnostic/engine\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$attr_accessor', '$ignore?', '$call', '$raise?', '$raise', '$protected', '$==', '$level']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Engine(){};\n      var self = $Engine = $klass($base, $super, 'Engine', $Engine);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Engine_initialize_1, TMP_Engine_process_2, TMP_Engine_ignore$q_3, TMP_Engine_raise$q_4;\n\n      def.consumer = def.ignore_warnings = def.all_errors_are_fatal = nil;\n      \n      self.$attr_accessor(\"consumer\");\n      self.$attr_accessor(\"all_errors_are_fatal\");\n      self.$attr_accessor(\"ignore_warnings\");\n      \n      Opal.defn(self, '$initialize', TMP_Engine_initialize_1 = function $$initialize(consumer) {\n        var self = this;\n\n        if (consumer == null) {\n          consumer = nil;\n        }\n        \n        self.consumer = consumer;\n        self.all_errors_are_fatal = false;\n        return (self.ignore_warnings = false);\n      }, TMP_Engine_initialize_1.$$arity = -1);\n      \n      Opal.defn(self, '$process', TMP_Engine_process_2 = function $$process(diagnostic) {\n        var self = this;\n\n        \n        if ($truthy(self['$ignore?'](diagnostic))) {\n        } else if ($truthy(self.consumer)) {\n          self.consumer.$call(diagnostic)};\n        if ($truthy(self['$raise?'](diagnostic))) {\n          self.$raise(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Parser'), 'SyntaxError'), diagnostic)};\n        return self;\n      }, TMP_Engine_process_2.$$arity = 1);\n      self.$protected();\n      \n      Opal.defn(self, '$ignore?', TMP_Engine_ignore$q_3 = function(diagnostic) {\n        var $a, self = this;\n\n        return ($truthy($a = self.ignore_warnings) ? diagnostic.$level()['$=='](\"warning\") : $a)\n      }, TMP_Engine_ignore$q_3.$$arity = 1);\n      return (Opal.defn(self, '$raise?', TMP_Engine_raise$q_4 = function(diagnostic) {\n        var $a, $b, self = this;\n\n        return ($truthy($a = ($truthy($b = self.all_errors_are_fatal) ? diagnostic.$level()['$=='](\"error\") : $b)) ? $a : diagnostic.$level()['$=='](\"fatal\"))\n      }, TMP_Engine_raise$q_4.$$arity = 1), nil) && 'raise?';\n    })(Opal.const_get_relative($nesting, 'Diagnostic'), null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/static_environment\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$reset', '$[]', '$push', '$dup', '$pop', '$add', '$to_sym', '$include?']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $StaticEnvironment(){};\n      var self = $StaticEnvironment = $klass($base, $super, 'StaticEnvironment', $StaticEnvironment);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_StaticEnvironment_initialize_1, TMP_StaticEnvironment_reset_2, TMP_StaticEnvironment_extend_static_3, TMP_StaticEnvironment_extend_dynamic_4, TMP_StaticEnvironment_unextend_5, TMP_StaticEnvironment_declare_6, TMP_StaticEnvironment_declared$q_7;\n\n      def.stack = def.variables = nil;\n      \n      \n      Opal.defn(self, '$initialize', TMP_StaticEnvironment_initialize_1 = function $$initialize() {\n        var self = this;\n\n        return self.$reset()\n      }, TMP_StaticEnvironment_initialize_1.$$arity = 0);\n      \n      Opal.defn(self, '$reset', TMP_StaticEnvironment_reset_2 = function $$reset() {\n        var self = this;\n\n        \n        self.variables = Opal.const_get_relative($nesting, 'Set')['$[]']();\n        return (self.stack = []);\n      }, TMP_StaticEnvironment_reset_2.$$arity = 0);\n      \n      Opal.defn(self, '$extend_static', TMP_StaticEnvironment_extend_static_3 = function $$extend_static() {\n        var self = this;\n\n        \n        self.stack.$push(self.variables);\n        self.variables = Opal.const_get_relative($nesting, 'Set')['$[]']();\n        return self;\n      }, TMP_StaticEnvironment_extend_static_3.$$arity = 0);\n      \n      Opal.defn(self, '$extend_dynamic', TMP_StaticEnvironment_extend_dynamic_4 = function $$extend_dynamic() {\n        var self = this;\n\n        \n        self.stack.$push(self.variables);\n        self.variables = self.variables.$dup();\n        return self;\n      }, TMP_StaticEnvironment_extend_dynamic_4.$$arity = 0);\n      \n      Opal.defn(self, '$unextend', TMP_StaticEnvironment_unextend_5 = function $$unextend() {\n        var self = this;\n\n        \n        self.variables = self.stack.$pop();\n        return self;\n      }, TMP_StaticEnvironment_unextend_5.$$arity = 0);\n      \n      Opal.defn(self, '$declare', TMP_StaticEnvironment_declare_6 = function $$declare(name) {\n        var self = this;\n\n        \n        self.variables.$add(name.$to_sym());\n        return self;\n      }, TMP_StaticEnvironment_declare_6.$$arity = 1);\n      return (Opal.defn(self, '$declared?', TMP_StaticEnvironment_declared$q_7 = function(name) {\n        var self = this;\n\n        return self.variables['$include?'](name.$to_sym())\n      }, TMP_StaticEnvironment_declared$q_7.$$arity = 1), nil) && 'declared?';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/lexer\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash = Opal.hash, $truthy = Opal.truthy, $hash2 = Opal.hash2, $range = Opal.range, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$attr_accessor', '$private', '$_lex_trans_keys=', '$-', '$_lex_key_spans=', '$_lex_index_offsets=', '$_lex_indicies=', '$_lex_trans_targs=', '$_lex_trans_actions=', '$_lex_to_state_actions=', '$_lex_from_state_actions=', '$_lex_eof_trans=', '$lex_start=', '$lex_error=', '$lex_en_interp_words=', '$lex_en_interp_string=', '$lex_en_plain_words=', '$lex_en_plain_string=', '$lex_en_interp_backslash_delimited=', '$lex_en_plain_backslash_delimited=', '$lex_en_interp_backslash_delimited_words=', '$lex_en_plain_backslash_delimited_words=', '$lex_en_regexp_modifiers=', '$lex_en_expr_variable=', '$lex_en_expr_fname=', '$lex_en_expr_endfn=', '$lex_en_expr_dot=', '$lex_en_expr_arg=', '$lex_en_expr_cmdarg=', '$lex_en_expr_endarg=', '$lex_en_expr_mid=', '$lex_en_expr_beg=', '$lex_en_expr_labelarg=', '$lex_en_expr_value=', '$lex_en_expr_end=', '$lex_en_leading_dot=', '$lex_en_line_comment=', '$lex_en_line_begin=', '$freeze', '$ord', '$union', '$chars', '$attr_reader', '$reset', '$lex_en_line_begin', '$class', '$new', '$source', '$==', '$encoding', '$unpack', '$[]', '$lex_en_expr_dot', '$lex_en_expr_fname', '$lex_en_expr_value', '$lex_en_expr_beg', '$lex_en_expr_mid', '$lex_en_expr_arg', '$lex_en_expr_cmdarg', '$lex_en_expr_end', '$lex_en_expr_endarg', '$lex_en_expr_endfn', '$lex_en_expr_labelarg', '$lex_en_interp_string', '$lex_en_interp_words', '$lex_en_plain_string', '$fetch', '$invert', '$push', '$count', '$pop', '$any?', '$shift', '$send', '$+', '$size', '$<=', '$===', '$<<', '$>', '$!=', '$emit_comment', '$literal', '$flush_string', '$extend_content', '$emit', '$heredoc?', '$saved_herebody_s=', '$start_interp_brace', '$[]=', '$diagnostic', '$range', '$str_s', '$gsub', '$tok', '$version?', '$nest_and_try_closing', '$heredoc_e', '$pop_literal', '$infer_indent_level', '$words?', '$!', '$eof_codepoint?', '$extend_space', '$extend_string', '$>=', '$active?', '$slice', '$chr', '$munge_escape?', '$regexp?', '$match', '$scan', '$join', '$=~', '$to_i', '$stack_pop', '$emit_table', '$push_literal', '$arg_or_cmdarg', '$emit_do', '$start_with?', '$nil?', '$declared?', '$force_encoding', '$dup', '$lexpop', '$include?', '$inspect', '$last', '$end_with?', '$empty?', '$index', '$call', '$to_f', '$Float', '$length', '$lambda', '$Rational', '$Complex', '$each', '$split', '$encode_escape', '$%', '$end_interp_brace_and_try_closing', '$saved_herebody_s', '$&', '$|', '$lex_error', '$protected', '$process', '$backslash_delimited?', '$interpolate?', '$lex_en_interp_backslash_delimited_words', '$lex_en_plain_backslash_delimited_words', '$lex_en_plain_words', '$lex_en_interp_backslash_delimited', '$lex_en_plain_backslash_delimited', '$dedent_level', '$type', '$lex_en_regexp_modifiers', '$upcase']);\n  return (function($base, $super, $parent_nesting) {\n    function $Lexer(){};\n    var self = $Lexer = $klass($base, $super, 'Lexer', $Lexer);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Lexer_initialize_1, TMP_Lexer_reset_2, TMP_Lexer_source_buffer$eq_3, TMP_Lexer_encoding_4, TMP_Lexer_state_5, TMP_Lexer_state$eq_6, TMP_Lexer_push_cmdarg_7, TMP_Lexer_pop_cmdarg_8, TMP_Lexer_push_cond_9, TMP_Lexer_pop_cond_10, TMP_Lexer_dedent_level_11, TMP_Lexer_advance_36, TMP_Lexer_eof_codepoint$q_37, TMP_Lexer_version$q_38, TMP_Lexer_stack_pop_39, $a, TMP_Lexer_encode_escape_40, TMP_Lexer_encode_escape_41, TMP_Lexer_tok_42, TMP_Lexer_range_43, TMP_Lexer_emit_44, TMP_Lexer_emit_table_45, TMP_Lexer_emit_do_46, TMP_Lexer_arg_or_cmdarg_47, TMP_Lexer_emit_comment_48, TMP_Lexer_diagnostic_49, TMP_Lexer_push_literal_50, TMP_Lexer_literal_51, TMP_Lexer_pop_literal_52, TMP_Lexer_53, $writer = nil;\n\n    def.source_buffer = def.source_pts = def.cs = def.cmdarg_stack = def.cmdarg = def.cond_stack = def.cond = def.dedent_level = def.token_queue = def.p = def.herebody_s = def.sharp_s = def.ts = def.top = def.stack = def.te = def.version = def.escape_s = def.escape = def.act = def.static_env = def.lambda_stack = def.paren_nest = def.num_digits_s = def.num_suffix_s = def.num_base = def.num_xfrm = def.newline_s = def.eq_begin_s = def.in_kwarg = def.tokens = def.command_state = def.comments = def.diagnostics = def.literal_stack = nil;\n    \n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$attr_accessor(\"_lex_trans_keys\");\n      return self.$private(\"_lex_trans_keys\", \"_lex_trans_keys=\");\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [[0, 0, 101, 101, 103, 103, 105, 105, 110, 110, 69, 69, 78, 78, 68, 68, 95, 95, 95, 95, 0, 26, 0, 127, 0, 127, 0, 127, 0, 127, 0, 45, 0, 77, 0, 77, 0, 92, 0, 26, 0, 26, 0, 45, 0, 99, 0, 26, 67, 99, 45, 45, 0, 92, 0, 77, 0, 102, 0, 127, 0, 127, 0, 127, 0, 127, 0, 45, 0, 77, 0, 77, 0, 92, 0, 26, 0, 26, 0, 45, 0, 99, 0, 26, 67, 99, 45, 45, 0, 92, 0, 77, 0, 102, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 26, 0, 127, 58, 58, 58, 58, 0, 127, 58, 58, 60, 60, 62, 62, 10, 10, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 115, 115, 99, 99, 117, 117, 101, 101, 108, 116, 101, 101, 115, 115, 115, 115, 105, 105, 108, 108, 105, 105, 108, 108, 58, 58, 0, 127, 10, 10, 0, 127, 58, 58, 98, 98, 101, 101, 103, 103, 105, 105, 110, 110, 0, 122, 61, 61, 0, 127, 0, 127, 61, 126, 0, 127, 0, 127, 93, 93, 0, 127, 0, 127, 10, 10, 10, 34, 10, 10, 10, 39, 0, 127, 10, 96, 0, 45, 0, 77, 0, 77, 0, 92, 0, 26, 0, 26, 0, 45, 0, 99, 0, 26, 67, 99, 45, 45, 0, 92, 0, 77, 0, 102, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 58, 58, 58, 58, 0, 127, 43, 57, 48, 57, 48, 57, 48, 57, 48, 57, 0, 127, 58, 58, 9, 92, 9, 92, 9, 92, 9, 92, 9, 92, 9, 92, 60, 60, 10, 10, 9, 46, 46, 46, 0, 95, 9, 32, 0, 0, 10, 10, 10, 10, 98, 98, 9, 32, 10, 10, 95, 95, 0, 92, 9, 32, 36, 123, 0, 127, 48, 57, 0, 120, 0, 0, 0, 0, 48, 55, 48, 55, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 92, 45, 45, 0, 0, 0, 0, 0, 0, 0, 92, 0, 45, 0, 92, 0, 92, 0, 0, 0, 0, 0, 92, 0, 45, 10, 10, 0, 92, 0, 123, 0, 26, 0, 26, 0, 26, 0, 0, 0, 102, 0, 102, 0, 102, 0, 0, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 125, 0, 125, 0, 0, 0, 125, 0, 26, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 125, 0, 0, 48, 102, 0, 0, 0, 92, 36, 123, 0, 127, 48, 57, 0, 120, 0, 0, 0, 0, 48, 55, 48, 55, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 92, 45, 45, 0, 0, 0, 0, 0, 0, 0, 92, 0, 45, 0, 92, 0, 92, 0, 0, 0, 0, 0, 92, 0, 45, 10, 10, 0, 92, 0, 123, 0, 26, 0, 26, 0, 26, 0, 0, 0, 102, 0, 102, 0, 102, 0, 0, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 125, 0, 125, 0, 0, 0, 125, 0, 26, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 125, 0, 0, 48, 102, 0, 0, 0, 92, 9, 32, 0, 26, 0, 92, 0, 26, 0, 35, 36, 123, 0, 127, 48, 57, 0, 26, 0, 35, 9, 32, 36, 123, 0, 127, 48, 57, 0, 32, 9, 32, 65, 122, 65, 122, 36, 64, 0, 127, 48, 57, 0, 127, 0, 127, 0, 127, 0, 127, 9, 32, 0, 0, 61, 126, 10, 10, 10, 10, 0, 127, 0, 127, 48, 57, 115, 115, 38, 38, 42, 42, 64, 64, 58, 58, 60, 61, 62, 62, 61, 126, 61, 61, 61, 62, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 93, 93, 10, 10, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 124, 124, 0, 127, 0, 127, 9, 32, 10, 10, 10, 10, 10, 10, 0, 0, 0, 127, 0, 127, 61, 61, 0, 0, 9, 32, 0, 0, 61, 126, 10, 10, 10, 10, 38, 38, 42, 42, 64, 64, 60, 61, 62, 62, 61, 126, 61, 61, 61, 62, 0, 127, 93, 93, 10, 10, 124, 124, 0, 126, 0, 127, 0, 61, 9, 61, 9, 61, 0, 0, 9, 61, 9, 62, 46, 46, 46, 46, 58, 58, 9, 32, 0, 0, 0, 127, 0, 0, 9, 124, 0, 0, 10, 10, 10, 10, 0, 0, 9, 61, 58, 58, 60, 60, 62, 62, 9, 32, 10, 10, 0, 127, 102, 102, 101, 101, 110, 110, 104, 104, 0, 127, 0, 127, 0, 127, 0, 0, 0, 127, 10, 10, 0, 123, 9, 32, 10, 10, 10, 10, 10, 10, 0, 0, 111, 111, 0, 0, 0, 127, 0, 127, 9, 32, 0, 0, 10, 10, 10, 10, 10, 10, 0, 0, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 58, 61, 0, 0, 61, 126, 61, 61, 0, 0, 0, 0, 0, 0, 9, 32, 61, 61, 9, 32, 61, 126, 10, 10, 10, 10, 65, 122, 0, 122, 38, 61, 0, 0, 42, 61, 61, 61, 48, 61, 48, 62, 46, 46, 46, 46, 0, 26, 0, 127, 0, 127, 61, 61, 0, 0, 61, 126, 61, 62, 0, 0, 0, 0, 0, 0, 0, 0, 61, 126, 0, 127, 48, 57, 38, 38, 42, 42, 64, 64, 60, 61, 62, 62, 61, 61, 61, 62, 124, 124, 60, 61, 0, 0, 62, 62, 61, 126, 61, 62, 0, 122, 0, 0, 0, 127, 0, 127, 0, 120, 0, 0, 0, 0, 48, 55, 48, 55, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 92, 45, 45, 0, 0, 0, 0, 0, 0, 0, 92, 0, 45, 0, 92, 0, 92, 0, 0, 0, 0, 0, 92, 0, 45, 10, 10, 0, 92, 0, 123, 0, 26, 0, 26, 0, 26, 0, 0, 0, 102, 0, 102, 0, 102, 0, 0, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 125, 0, 125, 0, 0, 0, 125, 0, 26, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 125, 0, 0, 0, 0, 48, 102, 0, 0, 0, 127, 0, 127, 0, 127, 0, 0, 10, 10, 0, 0, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 61, 126, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 0, 61, 124, 0, 92, 9, 32, 0, 0, 10, 10, 10, 10, 10, 10, 0, 0, 0, 127, 0, 127, 9, 32, 0, 0, 10, 10, 10, 10, 10, 10, 0, 0, 0, 127, 0, 127, 61, 61, 0, 0, 9, 32, 0, 0, 61, 126, 10, 10, 10, 10, 0, 127, 0, 127, 48, 57, 61, 61, 38, 61, 0, 0, 0, 0, 42, 61, 61, 62, 46, 57, 46, 46, 48, 101, 48, 95, 46, 120, 48, 114, 43, 57, 48, 105, 0, 0, 105, 105, 0, 0, 48, 114, 48, 114, 48, 114, 48, 114, 105, 114, 0, 0, 105, 105, 0, 0, 48, 114, 48, 114, 48, 114, 48, 114, 48, 114, 48, 114, 48, 114, 48, 114, 46, 114, 48, 114, 46, 114, 48, 114, 58, 58, 60, 61, 62, 62, 61, 126, 61, 61, 61, 62, 0, 127, 0, 127, 0, 0, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 0, 10, 10, 0, 0, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 9, 92, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 127, 0, 0, 61, 124, 0, 0, 9, 46, 9, 46, 46, 46, 10, 61, 10, 10, 10, 101, 10, 110, 10, 100, 10, 10, 0]];\n    $send(self, '_lex_trans_keys=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$attr_accessor(\"_lex_key_spans\");\n      return self.$private(\"_lex_key_spans\", \"_lex_key_spans=\");\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 27, 128, 128, 128, 128, 46, 78, 78, 93, 27, 27, 46, 100, 27, 33, 1, 93, 78, 103, 128, 128, 128, 128, 46, 78, 78, 93, 27, 27, 46, 100, 27, 33, 1, 93, 78, 103, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 27, 128, 1, 1, 128, 1, 1, 1, 1, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 1, 1, 128, 1, 128, 1, 1, 1, 1, 1, 1, 123, 1, 128, 128, 66, 128, 128, 1, 128, 128, 1, 25, 1, 30, 128, 87, 46, 78, 78, 93, 27, 27, 46, 100, 27, 33, 1, 93, 78, 103, 128, 128, 128, 128, 128, 128, 1, 1, 128, 15, 10, 10, 10, 10, 128, 1, 84, 84, 84, 84, 84, 84, 1, 1, 38, 1, 96, 24, 0, 1, 1, 1, 24, 1, 1, 93, 24, 88, 128, 10, 121, 0, 0, 8, 8, 0, 0, 93, 0, 0, 0, 93, 1, 0, 0, 0, 93, 46, 93, 93, 0, 0, 93, 46, 1, 93, 124, 27, 27, 27, 0, 103, 103, 103, 0, 126, 126, 126, 126, 126, 0, 126, 126, 0, 126, 27, 126, 126, 126, 126, 126, 126, 126, 126, 126, 0, 126, 0, 55, 0, 93, 88, 128, 10, 121, 0, 0, 8, 8, 0, 0, 93, 0, 0, 0, 93, 1, 0, 0, 0, 93, 46, 93, 93, 0, 0, 93, 46, 1, 93, 124, 27, 27, 27, 0, 103, 103, 103, 0, 126, 126, 126, 126, 126, 0, 126, 126, 0, 126, 27, 126, 126, 126, 126, 126, 126, 126, 126, 126, 0, 126, 0, 55, 0, 93, 24, 27, 93, 27, 36, 88, 128, 10, 27, 36, 24, 88, 128, 10, 33, 24, 58, 58, 29, 128, 10, 128, 128, 128, 128, 24, 0, 66, 1, 1, 128, 128, 10, 1, 1, 1, 1, 1, 2, 1, 66, 1, 2, 128, 128, 128, 128, 128, 128, 128, 1, 1, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 1, 128, 128, 24, 1, 1, 1, 0, 128, 128, 1, 0, 24, 0, 66, 1, 1, 1, 1, 1, 2, 1, 66, 1, 2, 128, 1, 1, 1, 127, 128, 62, 53, 53, 0, 53, 54, 1, 1, 1, 24, 0, 128, 0, 116, 0, 1, 1, 0, 53, 1, 1, 1, 24, 1, 128, 1, 1, 1, 1, 128, 128, 128, 0, 128, 1, 124, 24, 1, 1, 1, 0, 1, 0, 128, 128, 24, 0, 1, 1, 1, 0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 4, 0, 66, 1, 0, 0, 0, 24, 1, 24, 66, 1, 1, 58, 123, 24, 0, 20, 1, 14, 15, 1, 1, 27, 128, 128, 1, 0, 66, 2, 0, 0, 0, 0, 66, 128, 10, 1, 1, 1, 2, 1, 1, 2, 1, 2, 0, 1, 66, 2, 123, 0, 128, 128, 121, 0, 0, 8, 8, 0, 0, 93, 0, 0, 0, 93, 1, 0, 0, 0, 93, 46, 93, 93, 0, 0, 93, 46, 1, 93, 124, 27, 27, 27, 0, 103, 103, 103, 0, 126, 126, 126, 126, 126, 0, 126, 126, 0, 126, 27, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 0, 0, 55, 0, 128, 128, 128, 0, 1, 0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 64, 93, 24, 0, 1, 1, 1, 0, 128, 128, 24, 0, 1, 1, 1, 0, 128, 128, 1, 0, 24, 0, 66, 1, 1, 128, 128, 10, 1, 24, 0, 0, 20, 2, 12, 1, 54, 48, 75, 67, 15, 58, 0, 1, 0, 67, 67, 67, 67, 10, 0, 1, 0, 67, 67, 67, 67, 67, 67, 67, 67, 69, 67, 69, 67, 1, 2, 1, 66, 1, 2, 128, 128, 0, 128, 128, 128, 128, 128, 128, 0, 1, 0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 84, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 64, 0, 38, 38, 1, 52, 1, 92, 101, 91, 1]];\n    $send(self, '_lex_key_spans=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$attr_accessor(\"_lex_index_offsets\");\n      return self.$private(\"_lex_index_offsets\", \"_lex_index_offsets=\");\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [[0, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 46, 175, 304, 433, 562, 609, 688, 767, 861, 889, 917, 964, 1065, 1093, 1127, 1129, 1223, 1302, 1406, 1535, 1664, 1793, 1922, 1969, 2048, 2127, 2221, 2249, 2277, 2324, 2425, 2453, 2487, 2489, 2583, 2662, 2766, 2895, 3024, 3153, 3282, 3411, 3540, 3669, 3798, 3927, 4056, 4185, 4314, 4443, 4471, 4600, 4602, 4604, 4733, 4735, 4737, 4739, 4741, 4870, 4999, 5128, 5257, 5386, 5515, 5644, 5773, 5902, 6031, 6160, 6289, 6418, 6547, 6676, 6805, 6934, 7063, 7065, 7067, 7069, 7071, 7081, 7083, 7085, 7087, 7089, 7091, 7093, 7095, 7097, 7226, 7228, 7357, 7359, 7361, 7363, 7365, 7367, 7369, 7493, 7495, 7624, 7753, 7820, 7949, 8078, 8080, 8209, 8338, 8340, 8366, 8368, 8399, 8528, 8616, 8663, 8742, 8821, 8915, 8943, 8971, 9018, 9119, 9147, 9181, 9183, 9277, 9356, 9460, 9589, 9718, 9847, 9976, 10105, 10234, 10236, 10238, 10367, 10383, 10394, 10405, 10416, 10427, 10556, 10558, 10643, 10728, 10813, 10898, 10983, 11068, 11070, 11072, 11111, 11113, 11210, 11235, 11236, 11238, 11240, 11242, 11267, 11269, 11271, 11365, 11390, 11479, 11608, 11619, 11741, 11742, 11743, 11752, 11761, 11762, 11763, 11857, 11858, 11859, 11860, 11954, 11956, 11957, 11958, 11959, 12053, 12100, 12194, 12288, 12289, 12290, 12384, 12431, 12433, 12527, 12652, 12680, 12708, 12736, 12737, 12841, 12945, 13049, 13050, 13177, 13304, 13431, 13558, 13685, 13686, 13813, 13940, 13941, 14068, 14096, 14223, 14350, 14477, 14604, 14731, 14858, 14985, 15112, 15239, 15240, 15367, 15368, 15424, 15425, 15519, 15608, 15737, 15748, 15870, 15871, 15872, 15881, 15890, 15891, 15892, 15986, 15987, 15988, 15989, 16083, 16085, 16086, 16087, 16088, 16182, 16229, 16323, 16417, 16418, 16419, 16513, 16560, 16562, 16656, 16781, 16809, 16837, 16865, 16866, 16970, 17074, 17178, 17179, 17306, 17433, 17560, 17687, 17814, 17815, 17942, 18069, 18070, 18197, 18225, 18352, 18479, 18606, 18733, 18860, 18987, 19114, 19241, 19368, 19369, 19496, 19497, 19553, 19554, 19648, 19673, 19701, 19795, 19823, 19860, 19949, 20078, 20089, 20117, 20154, 20179, 20268, 20397, 20408, 20442, 20467, 20526, 20585, 20615, 20744, 20755, 20884, 21013, 21142, 21271, 21296, 21297, 21364, 21366, 21368, 21497, 21626, 21637, 21639, 21641, 21643, 21645, 21647, 21650, 21652, 21719, 21721, 21724, 21853, 21982, 22111, 22240, 22369, 22498, 22627, 22629, 22631, 22760, 22889, 23018, 23147, 23276, 23405, 23534, 23663, 23792, 23921, 24050, 24179, 24308, 24437, 24566, 24695, 24824, 24953, 25082, 25211, 25340, 25469, 25598, 25727, 25856, 25985, 26114, 26243, 26372, 26501, 26630, 26759, 26888, 27017, 27146, 27275, 27404, 27533, 27662, 27791, 27920, 28049, 28178, 28307, 28436, 28565, 28694, 28823, 28952, 29081, 29210, 29339, 29468, 29597, 29726, 29855, 29984, 30113, 30242, 30371, 30500, 30629, 30758, 30887, 31016, 31145, 31274, 31403, 31532, 31661, 31790, 31919, 32048, 32177, 32306, 32435, 32564, 32693, 32822, 32951, 33080, 33209, 33338, 33340, 33469, 33598, 33623, 33625, 33627, 33629, 33630, 33759, 33888, 33890, 33891, 33916, 33917, 33984, 33986, 33988, 33990, 33992, 33994, 33997, 33999, 34066, 34068, 34071, 34200, 34202, 34204, 34206, 34334, 34463, 34526, 34580, 34634, 34635, 34689, 34744, 34746, 34748, 34750, 34775, 34776, 34905, 34906, 35023, 35024, 35026, 35028, 35029, 35083, 35085, 35087, 35089, 35114, 35116, 35245, 35247, 35249, 35251, 35253, 35382, 35511, 35640, 35641, 35770, 35772, 35897, 35922, 35924, 35926, 35928, 35929, 35931, 35932, 36061, 36190, 36215, 36216, 36218, 36220, 36222, 36223, 36352, 36481, 36610, 36739, 36868, 36997, 37126, 37255, 37384, 37513, 37642, 37771, 37900, 38029, 38158, 38287, 38416, 38545, 38550, 38551, 38618, 38620, 38621, 38622, 38623, 38648, 38650, 38675, 38742, 38744, 38746, 38805, 38929, 38954, 38955, 38976, 38978, 38993, 39009, 39011, 39013, 39041, 39170, 39299, 39301, 39302, 39369, 39372, 39373, 39374, 39375, 39376, 39443, 39572, 39583, 39585, 39587, 39589, 39592, 39594, 39596, 39599, 39601, 39604, 39605, 39607, 39674, 39677, 39801, 39802, 39931, 40060, 40182, 40183, 40184, 40193, 40202, 40203, 40204, 40298, 40299, 40300, 40301, 40395, 40397, 40398, 40399, 40400, 40494, 40541, 40635, 40729, 40730, 40731, 40825, 40872, 40874, 40968, 41093, 41121, 41149, 41177, 41178, 41282, 41386, 41490, 41491, 41618, 41745, 41872, 41999, 42126, 42127, 42254, 42381, 42382, 42509, 42537, 42664, 42791, 42918, 43045, 43172, 43299, 43426, 43553, 43680, 43807, 43934, 44061, 44188, 44315, 44316, 44317, 44373, 44374, 44503, 44632, 44761, 44762, 44764, 44765, 44894, 45023, 45152, 45281, 45410, 45539, 45668, 45797, 45926, 46055, 46184, 46313, 46442, 46571, 46700, 46829, 46958, 47087, 47216, 47345, 47474, 47603, 47732, 47861, 47990, 48119, 48248, 48377, 48506, 48635, 48764, 48893, 49022, 49151, 49280, 49409, 49538, 49667, 49796, 49925, 50054, 50183, 50312, 50441, 50570, 50699, 50828, 50957, 51086, 51215, 51344, 51473, 51602, 51731, 51860, 51989, 52118, 52247, 52376, 52505, 52572, 52701, 52830, 52959, 53088, 53217, 53346, 53475, 53604, 53733, 53862, 53991, 54120, 54249, 54378, 54507, 54636, 54765, 54894, 55023, 55152, 55281, 55410, 55539, 55668, 55797, 55798, 55863, 55957, 55982, 55983, 55985, 55987, 55989, 55990, 56119, 56248, 56273, 56274, 56276, 56278, 56280, 56281, 56410, 56539, 56541, 56542, 56567, 56568, 56635, 56637, 56639, 56768, 56897, 56908, 56910, 56935, 56936, 56937, 56958, 56961, 56974, 56976, 57031, 57080, 57156, 57224, 57240, 57299, 57300, 57302, 57303, 57371, 57439, 57507, 57575, 57586, 57587, 57589, 57590, 57658, 57726, 57794, 57862, 57930, 57998, 58066, 58134, 58204, 58272, 58342, 58410, 58412, 58415, 58417, 58484, 58486, 58489, 58618, 58747, 58748, 58877, 59006, 59135, 59264, 59393, 59522, 59523, 59525, 59526, 59655, 59784, 59913, 60042, 60171, 60300, 60429, 60558, 60687, 60816, 60945, 61074, 61203, 61332, 61461, 61590, 61719, 61848, 61977, 62106, 62235, 62364, 62493, 62622, 62751, 62880, 63009, 63138, 63267, 63396, 63525, 63654, 63783, 63912, 64041, 64170, 64299, 64384, 64513, 64642, 64771, 64900, 65029, 65158, 65287, 65416, 65545, 65674, 65803, 65932, 66061, 66190, 66319, 66448, 66577, 66706, 66835, 66964, 67093, 67222, 67351, 67480, 67609, 67738, 67867, 67996, 68125, 68254, 68383, 68512, 68641, 68770, 68899, 69028, 69157, 69286, 69415, 69544, 69673, 69802, 69931, 70060, 70189, 70318, 70447, 70576, 70705, 70834, 70963, 71092, 71221, 71350, 71479, 71608, 71737, 71866, 71995, 72124, 72253, 72382, 72511, 72640, 72769, 72770, 72835, 72836, 72875, 72914, 72916, 72969, 72971, 73064, 73166, 73258]];\n    $send(self, '_lex_index_offsets=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$attr_accessor(\"_lex_indicies\");\n      return self.$private(\"_lex_indicies\", \"_lex_indicies=\");\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [[1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8, 0, 9, 0, 10, 0, 0, 0, 10, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 14, 14, 12, 14, 12, 14, 14, 12, 12, 14, 14, 14, 15, 14, 14, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 14, 12, 12, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 14, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 12, 12, 12, 12, 12, 12, 12, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 12, 12, 12, 12, 14, 12, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 12, 12, 12, 12, 12, 14, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 17, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 13, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 13, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 13, 18, 19, 19, 19, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 19, 18, 21, 21, 21, 18, 21, 21, 21, 21, 21, 22, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 18, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 23, 21, 18, 21, 21, 21, 18, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 18, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 24, 21, 18, 25, 25, 25, 18, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 18, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 27, 25, 18, 28, 28, 28, 18, 28, 28, 28, 28, 28, 29, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 18, 28, 18, 28, 28, 28, 18, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 18, 28, 18, 19, 19, 19, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 30, 19, 18, 31, 31, 31, 18, 31, 31, 31, 31, 31, 32, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 18, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 33, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 34, 31, 31, 31, 31, 31, 31, 35, 31, 18, 31, 31, 31, 18, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 18, 31, 36, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 37, 18, 37, 18, 18, 38, 38, 38, 18, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 18, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 39, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 40, 38, 18, 21, 21, 21, 18, 21, 21, 21, 21, 21, 22, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 18, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 24, 21, 18, 41, 41, 41, 18, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 18, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 41, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 41, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 45, 45, 43, 45, 43, 45, 45, 43, 43, 45, 45, 45, 46, 45, 45, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 45, 45, 45, 45, 45, 45, 45, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 43, 45, 43, 43, 44, 45, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 43, 43, 43, 45, 43, 44, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 43, 43, 43, 43, 43, 43, 43, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 43, 43, 43, 43, 45, 43, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 43, 43, 43, 43, 43, 45, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 43, 43, 43, 43, 43, 43, 48, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 43, 43, 43, 43, 44, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 43, 43, 43, 43, 43, 44, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 43, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 43, 43, 43, 43, 44, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 43, 43, 43, 43, 43, 44, 49, 50, 50, 50, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 50, 49, 52, 52, 52, 49, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 49, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 54, 52, 49, 52, 52, 52, 49, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 49, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 55, 52, 49, 56, 56, 56, 49, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 49, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 58, 56, 49, 59, 59, 59, 49, 59, 59, 59, 59, 59, 60, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 49, 59, 49, 59, 59, 59, 49, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 49, 59, 49, 50, 50, 50, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 61, 50, 49, 62, 62, 62, 49, 62, 62, 62, 62, 62, 63, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 64, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 65, 62, 62, 62, 62, 62, 62, 66, 62, 49, 62, 62, 62, 49, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 62, 67, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 68, 49, 68, 49, 49, 69, 69, 69, 49, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 49, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 70, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 71, 69, 49, 52, 52, 52, 49, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 49, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 55, 52, 49, 72, 72, 72, 49, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 49, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 72, 72, 72, 72, 72, 72, 72, 73, 73, 73, 73, 73, 73, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 73, 73, 73, 73, 73, 73, 72, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 76, 76, 74, 76, 74, 76, 76, 74, 74, 76, 76, 76, 77, 76, 76, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 76, 76, 76, 76, 76, 76, 76, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 74, 76, 74, 74, 75, 76, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 74, 74, 74, 76, 74, 75, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 74, 74, 74, 74, 74, 74, 74, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 74, 74, 74, 74, 76, 74, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 74, 74, 74, 74, 74, 76, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 74, 74, 74, 74, 74, 74, 79, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 74, 74, 74, 74, 75, 74, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 74, 74, 74, 74, 74, 75, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 74, 74, 74, 74, 74, 74, 74, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 74, 74, 74, 74, 75, 74, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 74, 74, 74, 74, 74, 75, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 82, 82, 80, 82, 80, 82, 82, 80, 80, 82, 82, 82, 83, 82, 82, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 82, 82, 82, 82, 82, 82, 82, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 80, 82, 80, 80, 81, 82, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 80, 80, 80, 82, 80, 81, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 80, 80, 80, 80, 80, 80, 80, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 80, 80, 80, 80, 82, 80, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 80, 80, 80, 80, 80, 82, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 80, 80, 80, 80, 80, 80, 85, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 80, 80, 80, 80, 81, 80, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 80, 80, 80, 80, 80, 81, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 80, 80, 80, 80, 80, 80, 80, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 80, 80, 80, 80, 81, 80, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 80, 80, 80, 80, 80, 81, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 87, 87, 88, 87, 88, 87, 87, 88, 88, 87, 87, 87, 89, 87, 87, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 87, 87, 87, 87, 87, 87, 87, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 88, 87, 88, 88, 86, 87, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 88, 88, 88, 87, 88, 86, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 88, 88, 88, 88, 88, 88, 88, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 88, 88, 88, 88, 87, 88, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 88, 88, 88, 88, 88, 87, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 88, 88, 88, 88, 88, 88, 92, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 88, 88, 88, 88, 91, 88, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 88, 88, 88, 88, 88, 91, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 88, 88, 88, 88, 88, 88, 88, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 88, 88, 88, 88, 93, 88, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 88, 88, 88, 88, 88, 93, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 94, 94, 94, 94, 94, 94, 94, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 94, 94, 94, 94, 95, 94, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 94, 94, 94, 94, 94, 95, 96, 97, 97, 97, 96, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 96, 97, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 100, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 101, 98, 98, 98, 98, 100, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 98, 98, 98, 98, 99, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 98, 98, 98, 98, 98, 99, 101, 98, 98, 102, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 105, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 103, 103, 103, 103, 105, 103, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 103, 103, 103, 103, 104, 103, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 103, 103, 103, 103, 103, 104, 106, 103, 108, 107, 109, 107, 110, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 112, 107, 112, 112, 112, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 112, 107, 107, 107, 107, 113, 114, 107, 115, 107, 116, 117, 118, 119, 120, 113, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 121, 107, 122, 118, 123, 124, 107, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 125, 126, 118, 127, 111, 107, 111, 111, 111, 111, 111, 111, 111, 111, 128, 111, 111, 111, 111, 111, 111, 111, 111, 129, 111, 111, 130, 111, 131, 111, 111, 111, 132, 133, 107, 127, 107, 111, 107, 107, 107, 107, 107, 107, 107, 107, 107, 134, 107, 134, 134, 134, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 134, 107, 107, 107, 107, 135, 136, 107, 137, 107, 138, 139, 140, 141, 142, 135, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 143, 107, 144, 140, 145, 146, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 147, 148, 140, 109, 104, 107, 104, 104, 104, 104, 104, 104, 104, 104, 149, 104, 104, 104, 104, 104, 104, 104, 104, 150, 104, 104, 151, 104, 152, 104, 104, 104, 153, 154, 107, 109, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 155, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 156, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 157, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 158, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 159, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 155, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 160, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 161, 104, 104, 104, 104, 104, 104, 104, 162, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 163, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 164, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 155, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 104, 104, 104, 165, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 155, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 104, 104, 166, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 104, 104, 104, 167, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 107, 107, 107, 107, 105, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 104, 107, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 159, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 107, 107, 107, 107, 107, 104, 169, 168, 170, 168, 171, 168, 140, 168, 172, 168, 168, 168, 168, 168, 168, 168, 173, 168, 174, 168, 175, 168, 140, 168, 176, 168, 140, 168, 177, 168, 171, 168, 179, 178, 180, 180, 180, 180, 180, 180, 180, 180, 180, 182, 180, 182, 182, 182, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 182, 180, 180, 180, 180, 180, 180, 180, 183, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 180, 184, 180, 180, 181, 180, 181, 181, 181, 185, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 180, 180, 180, 180, 180, 181, 186, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 188, 180, 188, 188, 188, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 188, 180, 180, 180, 180, 180, 180, 180, 189, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 180, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 180, 190, 180, 180, 187, 180, 187, 187, 187, 191, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 180, 180, 180, 180, 180, 187, 192, 193, 195, 194, 196, 194, 197, 194, 198, 194, 199, 194, 200, 201, 201, 201, 200, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 200, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 201, 201, 201, 201, 201, 201, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 201, 203, 192, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 206, 206, 204, 206, 204, 206, 206, 204, 204, 206, 206, 206, 207, 206, 206, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 206, 206, 206, 206, 206, 206, 206, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 204, 206, 204, 204, 205, 206, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 204, 204, 204, 206, 204, 205, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 204, 204, 204, 204, 204, 204, 204, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 204, 204, 204, 204, 206, 204, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 206, 204, 204, 204, 204, 204, 206, 209, 206, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 206, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 210, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 204, 204, 204, 204, 205, 204, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 204, 204, 204, 204, 204, 205, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 204, 204, 204, 204, 205, 204, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 204, 204, 204, 204, 204, 205, 209, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 212, 204, 204, 204, 204, 213, 204, 204, 204, 204, 204, 214, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 203, 204, 204, 204, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 204, 204, 204, 204, 211, 215, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 204, 204, 204, 214, 204, 211, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 218, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 217, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 217, 217, 217, 217, 217, 217, 217, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 217, 217, 217, 217, 216, 217, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 216, 217, 217, 217, 217, 217, 216, 220, 219, 204, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 221, 212, 218, 217, 204, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, 221, 213, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 212, 204, 204, 204, 204, 213, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 204, 204, 204, 204, 211, 215, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 211, 204, 204, 204, 204, 204, 211, 204, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, 221, 215, 222, 223, 223, 223, 222, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 222, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 224, 223, 222, 225, 225, 225, 222, 225, 225, 225, 225, 225, 226, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 222, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 227, 225, 222, 225, 225, 225, 222, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 222, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 228, 225, 222, 229, 229, 229, 222, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 222, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 230, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 231, 229, 222, 232, 232, 232, 222, 232, 232, 232, 232, 232, 233, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 222, 232, 222, 232, 232, 232, 222, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 222, 232, 222, 223, 223, 223, 222, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 222, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 234, 223, 222, 235, 235, 235, 222, 235, 235, 235, 235, 235, 236, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 222, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 237, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 238, 235, 235, 235, 235, 235, 235, 239, 235, 222, 235, 235, 235, 222, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 235, 222, 235, 240, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 241, 222, 241, 222, 222, 242, 242, 242, 222, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 222, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 243, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 244, 242, 222, 225, 225, 225, 222, 225, 225, 225, 225, 225, 226, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 222, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 228, 225, 222, 245, 245, 245, 222, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 222, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 246, 246, 246, 246, 246, 246, 246, 246, 246, 246, 245, 245, 245, 245, 245, 245, 245, 246, 246, 246, 246, 246, 246, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 246, 246, 246, 246, 246, 246, 245, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 248, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 249, 192, 192, 250, 192, 248, 192, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 192, 192, 192, 192, 247, 192, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 192, 192, 192, 192, 192, 247, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 248, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 249, 204, 204, 250, 204, 248, 204, 247, 247, 247, 247, 247, 247, 251, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 204, 204, 204, 204, 247, 204, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 204, 204, 204, 204, 204, 247, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 248, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 249, 204, 204, 250, 204, 248, 204, 247, 247, 247, 247, 247, 247, 247, 247, 252, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 204, 204, 204, 204, 247, 204, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 204, 204, 204, 204, 204, 247, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 248, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 249, 204, 204, 250, 204, 248, 204, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 253, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 204, 204, 204, 204, 247, 204, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 204, 204, 204, 204, 204, 247, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 248, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 249, 204, 204, 250, 204, 248, 204, 247, 247, 247, 253, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 204, 204, 204, 204, 247, 204, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 204, 204, 204, 204, 204, 247, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 256, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 257, 254, 254, 254, 254, 256, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 254, 254, 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 254, 254, 254, 254, 255, 257, 254, 254, 258, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 259, 259, 259, 259, 259, 259, 259, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 259, 259, 259, 259, 260, 259, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 259, 259, 259, 259, 259, 260, 262, 261, 262, 261, 261, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 261, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 261, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 261, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 265, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 265, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 259, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 259, 259, 259, 259, 259, 259, 259, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 259, 259, 259, 259, 268, 259, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 259, 259, 259, 259, 259, 268, 269, 265, 270, 271, 270, 270, 270, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 270, 265, 265, 272, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 273, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 274, 265, 275, 276, 275, 275, 275, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 275, 265, 265, 277, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 278, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 279, 265, 281, 282, 281, 281, 281, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 281, 280, 280, 283, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 284, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 285, 280, 287, 288, 287, 287, 287, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 287, 286, 286, 289, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 290, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 291, 286, 287, 288, 287, 287, 287, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 287, 286, 286, 289, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 292, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 291, 286, 287, 293, 287, 287, 287, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 287, 286, 286, 289, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 290, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 291, 286, 294, 265, 271, 265, 296, 295, 296, 296, 296, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 296, 295, 295, 295, 295, 295, 297, 295, 295, 295, 295, 295, 295, 295, 298, 295, 299, 295, 301, 300, 300, 300, 301, 300, 300, 300, 300, 302, 303, 302, 302, 302, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 301, 300, 300, 300, 300, 300, 302, 300, 300, 304, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 305, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 306, 300, 300, 307, 300, 302, 308, 302, 302, 302, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 308, 302, 308, 309, 310, 311, 312, 313, 315, 314, 317, 318, 317, 317, 317, 316, 316, 316, 316, 316, 316, 316, 316, 316, 316, 316, 316, 316, 316, 316, 316, 316, 316, 317, 316, 303, 314, 319, 314, 321, 320, 320, 320, 321, 320, 320, 320, 320, 322, 323, 322, 322, 322, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 321, 320, 320, 320, 320, 320, 322, 320, 320, 324, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 325, 320, 322, 326, 322, 322, 322, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 322, 326, 328, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 329, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 330, 327, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 331, 331, 331, 331, 331, 331, 331, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 331, 331, 331, 331, 13, 331, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 331, 331, 331, 331, 331, 13, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 331, 334, 333, 333, 333, 334, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 334, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 335, 335, 335, 335, 335, 335, 335, 335, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 336, 333, 333, 333, 333, 333, 333, 333, 333, 333, 337, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 338, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 339, 333, 333, 340, 333, 341, 342, 344, 344, 344, 344, 344, 344, 344, 344, 343, 345, 345, 345, 345, 345, 345, 345, 345, 343, 343, 346, 346, 38, 38, 38, 346, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 346, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 39, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 347, 38, 348, 349, 350, 350, 38, 38, 38, 350, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 350, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 39, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 351, 38, 37, 350, 352, 353, 354, 354, 25, 25, 25, 354, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 354, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 355, 25, 350, 19, 19, 19, 350, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 350, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 356, 19, 346, 25, 25, 25, 346, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 346, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 27, 25, 346, 357, 357, 357, 346, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 346, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 358, 357, 359, 360, 360, 357, 357, 357, 360, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 360, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 357, 361, 357, 360, 19, 19, 19, 360, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 360, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 356, 19, 362, 360, 360, 25, 25, 25, 360, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 360, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 27, 25, 363, 364, 364, 364, 363, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 363, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 365, 365, 365, 365, 365, 365, 365, 365, 365, 365, 364, 364, 364, 364, 364, 364, 364, 365, 365, 365, 365, 365, 365, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 365, 365, 365, 365, 365, 365, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 366, 364, 363, 367, 367, 367, 363, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 363, 367, 363, 368, 368, 368, 363, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 363, 368, 363, 369, 369, 369, 363, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 363, 369, 363, 363, 367, 367, 367, 363, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 363, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 367, 367, 367, 367, 367, 367, 367, 370, 370, 370, 370, 370, 370, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 370, 370, 370, 370, 370, 370, 367, 363, 368, 368, 368, 363, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 363, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 371, 371, 371, 371, 371, 371, 371, 371, 371, 371, 368, 368, 368, 368, 368, 368, 368, 371, 371, 371, 371, 371, 371, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 371, 371, 371, 371, 371, 371, 368, 363, 369, 369, 369, 363, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 363, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 372, 372, 372, 372, 372, 372, 372, 372, 372, 372, 369, 369, 369, 369, 369, 369, 369, 372, 372, 372, 372, 372, 372, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 372, 372, 372, 372, 372, 372, 369, 373, 376, 375, 375, 375, 376, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 376, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 377, 377, 377, 377, 377, 377, 377, 377, 377, 377, 375, 375, 375, 375, 375, 375, 375, 377, 377, 377, 377, 377, 377, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 377, 377, 377, 377, 377, 377, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 367, 375, 376, 378, 378, 378, 376, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 376, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 379, 379, 379, 379, 379, 379, 379, 379, 379, 379, 378, 378, 378, 378, 378, 378, 378, 379, 379, 379, 379, 379, 379, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 379, 379, 379, 379, 379, 379, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 380, 378, 376, 381, 381, 381, 376, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 376, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 381, 381, 381, 381, 381, 381, 381, 382, 382, 382, 382, 382, 382, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 382, 382, 382, 382, 382, 382, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 383, 381, 376, 384, 384, 384, 376, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 384, 384, 384, 384, 384, 384, 384, 385, 385, 385, 385, 385, 385, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 385, 385, 385, 385, 385, 385, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 376, 384, 384, 384, 376, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 384, 384, 384, 384, 384, 384, 384, 385, 385, 385, 385, 385, 385, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 385, 385, 385, 385, 385, 385, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 386, 376, 385, 385, 385, 376, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 376, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 386, 385, 376, 385, 385, 385, 376, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 376, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 374, 385, 374, 376, 382, 382, 382, 376, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 376, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 369, 382, 374, 369, 369, 369, 374, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 374, 369, 376, 378, 378, 378, 376, 378, 378, 378, 378, 387, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 376, 378, 378, 378, 378, 378, 387, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 388, 388, 388, 388, 388, 388, 388, 388, 388, 388, 378, 378, 378, 378, 378, 378, 378, 388, 388, 388, 388, 388, 388, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 388, 388, 388, 388, 388, 388, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 378, 389, 378, 376, 384, 384, 384, 376, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 384, 384, 384, 384, 384, 384, 384, 390, 390, 390, 390, 390, 390, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 390, 390, 390, 390, 390, 390, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 376, 384, 384, 384, 376, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 384, 384, 384, 384, 384, 384, 384, 391, 391, 391, 391, 391, 391, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 391, 391, 391, 391, 391, 391, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 389, 384, 376, 384, 384, 384, 376, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 392, 392, 392, 392, 392, 392, 392, 392, 392, 392, 384, 384, 384, 384, 384, 384, 384, 392, 392, 392, 392, 392, 392, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 392, 392, 392, 392, 392, 392, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 389, 384, 376, 384, 384, 384, 376, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 393, 393, 393, 393, 393, 393, 393, 393, 393, 393, 384, 384, 384, 384, 384, 384, 384, 393, 393, 393, 393, 393, 393, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 393, 393, 393, 393, 393, 393, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 389, 384, 376, 384, 384, 384, 376, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 394, 394, 394, 394, 394, 394, 394, 394, 394, 394, 384, 384, 384, 384, 384, 384, 384, 394, 394, 394, 394, 394, 394, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 394, 394, 394, 394, 394, 394, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 389, 384, 376, 384, 384, 384, 376, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 395, 395, 395, 395, 395, 395, 395, 395, 395, 395, 384, 384, 384, 384, 384, 384, 384, 395, 395, 395, 395, 395, 395, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 395, 395, 395, 395, 395, 395, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 389, 384, 376, 384, 384, 384, 376, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 384, 384, 384, 384, 387, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 384, 384, 384, 384, 384, 384, 384, 396, 396, 396, 396, 396, 396, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 396, 396, 396, 396, 396, 396, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 389, 384, 376, 384, 384, 384, 376, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 376, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 384, 384, 384, 384, 384, 384, 384, 396, 396, 396, 396, 396, 396, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 396, 396, 396, 396, 396, 396, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 386, 384, 397, 376, 381, 381, 381, 376, 381, 381, 381, 381, 387, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 376, 381, 381, 381, 381, 381, 387, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 392, 392, 392, 392, 392, 392, 392, 392, 392, 392, 381, 381, 381, 381, 381, 381, 381, 392, 392, 392, 392, 392, 392, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 392, 392, 392, 392, 392, 392, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 381, 389, 381, 398, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 399, 399, 399, 399, 399, 399, 399, 400, 400, 400, 400, 400, 400, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 399, 400, 400, 400, 400, 400, 400, 399, 399, 402, 401, 401, 401, 402, 401, 401, 401, 401, 401, 403, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 402, 401, 401, 401, 401, 401, 401, 401, 401, 404, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 405, 401, 407, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 408, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 409, 406, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 410, 410, 410, 410, 410, 410, 410, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 410, 410, 410, 410, 44, 410, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 410, 410, 410, 410, 410, 44, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 410, 413, 412, 412, 412, 413, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 413, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 414, 414, 414, 414, 414, 414, 414, 414, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 415, 412, 412, 412, 412, 412, 412, 412, 412, 412, 416, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 417, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 418, 412, 412, 419, 412, 420, 421, 423, 423, 423, 423, 423, 423, 423, 423, 422, 424, 424, 424, 424, 424, 424, 424, 424, 422, 422, 425, 425, 69, 69, 69, 425, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 425, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 70, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 426, 69, 427, 428, 429, 429, 69, 69, 69, 429, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 429, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 70, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 430, 69, 68, 429, 431, 432, 433, 433, 56, 56, 56, 433, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 433, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 434, 56, 429, 50, 50, 50, 429, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 429, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 435, 50, 425, 56, 56, 56, 425, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 425, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 58, 56, 425, 436, 436, 436, 425, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 425, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 437, 436, 438, 439, 439, 436, 436, 436, 439, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 439, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 440, 436, 439, 50, 50, 50, 439, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 439, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 435, 50, 441, 439, 439, 56, 56, 56, 439, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 439, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 58, 56, 442, 443, 443, 443, 442, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 442, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 444, 444, 444, 444, 444, 444, 444, 444, 444, 444, 443, 443, 443, 443, 443, 443, 443, 444, 444, 444, 444, 444, 444, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 444, 444, 444, 444, 444, 444, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 443, 445, 443, 442, 446, 446, 446, 442, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 442, 446, 442, 447, 447, 447, 442, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 442, 447, 442, 448, 448, 448, 442, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 442, 448, 442, 442, 446, 446, 446, 442, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 442, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 449, 449, 449, 449, 449, 449, 449, 449, 449, 449, 446, 446, 446, 446, 446, 446, 446, 449, 449, 449, 449, 449, 449, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 446, 449, 449, 449, 449, 449, 449, 446, 442, 447, 447, 447, 442, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 442, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 447, 447, 447, 447, 447, 447, 447, 450, 450, 450, 450, 450, 450, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 450, 450, 450, 450, 450, 450, 447, 442, 448, 448, 448, 442, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 442, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 451, 451, 451, 451, 451, 451, 451, 451, 451, 451, 448, 448, 448, 448, 448, 448, 448, 451, 451, 451, 451, 451, 451, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 451, 451, 451, 451, 451, 451, 448, 452, 455, 454, 454, 454, 455, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 455, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 454, 454, 454, 454, 454, 454, 454, 456, 456, 456, 456, 456, 456, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 456, 456, 456, 456, 456, 456, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 454, 446, 454, 455, 457, 457, 457, 455, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 455, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 457, 457, 457, 457, 457, 457, 457, 458, 458, 458, 458, 458, 458, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 458, 458, 458, 458, 458, 458, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 459, 457, 455, 460, 460, 460, 455, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 455, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 460, 460, 460, 460, 460, 460, 460, 461, 461, 461, 461, 461, 461, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 461, 461, 461, 461, 461, 461, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 462, 460, 455, 463, 463, 463, 455, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 463, 463, 463, 463, 463, 463, 463, 464, 464, 464, 464, 464, 464, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 464, 464, 464, 464, 464, 464, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 455, 463, 463, 463, 455, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 463, 463, 463, 463, 463, 463, 463, 464, 464, 464, 464, 464, 464, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 464, 464, 464, 464, 464, 464, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 465, 455, 464, 464, 464, 455, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 455, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 465, 464, 455, 464, 464, 464, 455, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 455, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 464, 453, 464, 453, 455, 461, 461, 461, 455, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 455, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 448, 461, 453, 448, 448, 448, 453, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, 453, 448, 455, 457, 457, 457, 455, 457, 457, 457, 457, 466, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 455, 457, 457, 457, 457, 457, 466, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 467, 467, 467, 467, 467, 467, 467, 467, 467, 467, 457, 457, 457, 457, 457, 457, 457, 467, 467, 467, 467, 467, 467, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 467, 467, 467, 467, 467, 467, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 457, 468, 457, 455, 463, 463, 463, 455, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 469, 469, 469, 469, 469, 469, 469, 469, 469, 469, 463, 463, 463, 463, 463, 463, 463, 469, 469, 469, 469, 469, 469, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 469, 469, 469, 469, 469, 469, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 455, 463, 463, 463, 455, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 463, 463, 463, 463, 463, 463, 463, 470, 470, 470, 470, 470, 470, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 470, 470, 470, 470, 470, 470, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 468, 463, 455, 463, 463, 463, 455, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 471, 471, 471, 471, 471, 471, 471, 471, 471, 471, 463, 463, 463, 463, 463, 463, 463, 471, 471, 471, 471, 471, 471, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 471, 471, 471, 471, 471, 471, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 468, 463, 455, 463, 463, 463, 455, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 472, 472, 472, 472, 472, 472, 472, 472, 472, 472, 463, 463, 463, 463, 463, 463, 463, 472, 472, 472, 472, 472, 472, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 472, 472, 472, 472, 472, 472, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 468, 463, 455, 463, 463, 463, 455, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 473, 473, 473, 473, 473, 473, 473, 473, 473, 473, 463, 463, 463, 463, 463, 463, 463, 473, 473, 473, 473, 473, 473, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 473, 473, 473, 473, 473, 473, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 468, 463, 455, 463, 463, 463, 455, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 474, 474, 474, 474, 474, 474, 474, 474, 474, 474, 463, 463, 463, 463, 463, 463, 463, 474, 474, 474, 474, 474, 474, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 474, 474, 474, 474, 474, 474, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 468, 463, 455, 463, 463, 463, 455, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 463, 463, 463, 463, 466, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 475, 475, 475, 475, 475, 475, 475, 475, 475, 475, 463, 463, 463, 463, 463, 463, 463, 475, 475, 475, 475, 475, 475, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 475, 475, 475, 475, 475, 475, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 468, 463, 455, 463, 463, 463, 455, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 455, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 475, 475, 475, 475, 475, 475, 475, 475, 475, 475, 463, 463, 463, 463, 463, 463, 463, 475, 475, 475, 475, 475, 475, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 475, 475, 475, 475, 475, 475, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 463, 465, 463, 476, 455, 460, 460, 460, 455, 460, 460, 460, 460, 466, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 455, 460, 460, 460, 460, 460, 466, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 471, 471, 471, 471, 471, 471, 471, 471, 471, 471, 460, 460, 460, 460, 460, 460, 460, 471, 471, 471, 471, 471, 471, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 471, 471, 471, 471, 471, 471, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 468, 460, 477, 479, 479, 479, 479, 479, 479, 479, 479, 479, 479, 478, 478, 478, 478, 478, 478, 478, 479, 479, 479, 479, 479, 479, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 478, 479, 479, 479, 479, 479, 479, 478, 478, 481, 480, 480, 480, 481, 480, 480, 480, 480, 482, 483, 482, 482, 482, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 481, 480, 480, 480, 480, 480, 482, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 480, 484, 480, 482, 485, 482, 482, 482, 485, 485, 485, 485, 485, 485, 485, 485, 485, 485, 485, 485, 485, 485, 485, 485, 485, 485, 482, 485, 486, 487, 487, 487, 486, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 487, 486, 487, 489, 488, 488, 488, 489, 488, 488, 488, 488, 488, 490, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 489, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 488, 491, 488, 492, 493, 493, 493, 492, 493, 493, 493, 493, 493, 494, 493, 493, 493, 493, 493, 493, 493, 493, 493, 493, 493, 493, 493, 493, 493, 492, 493, 496, 495, 495, 495, 496, 495, 495, 495, 495, 495, 497, 495, 495, 495, 495, 495, 495, 495, 495, 495, 495, 495, 495, 495, 495, 495, 496, 495, 495, 495, 495, 495, 495, 495, 495, 498, 495, 500, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 501, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 499, 502, 499, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 503, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 503, 503, 503, 503, 503, 503, 503, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 503, 503, 503, 503, 75, 503, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 503, 503, 503, 503, 503, 75, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 503, 505, 504, 504, 504, 505, 504, 504, 504, 504, 504, 506, 504, 504, 504, 504, 504, 504, 504, 504, 504, 504, 504, 504, 504, 504, 504, 505, 504, 508, 507, 507, 507, 508, 507, 507, 507, 507, 509, 510, 509, 509, 509, 507, 507, 507, 507, 507, 507, 507, 507, 507, 507, 507, 507, 508, 507, 507, 507, 507, 507, 509, 507, 507, 511, 507, 509, 512, 509, 509, 509, 512, 512, 512, 512, 512, 512, 512, 512, 512, 512, 512, 512, 512, 512, 512, 512, 512, 512, 509, 512, 514, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 515, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 513, 516, 513, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 517, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 517, 517, 517, 517, 517, 517, 517, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 517, 517, 517, 517, 81, 517, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 517, 517, 517, 517, 517, 81, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 517, 519, 518, 518, 518, 519, 518, 518, 518, 518, 520, 521, 520, 520, 520, 518, 518, 518, 518, 518, 518, 518, 518, 518, 518, 518, 518, 519, 518, 518, 518, 518, 518, 520, 518, 520, 522, 520, 520, 520, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 520, 522, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 523, 523, 523, 523, 523, 523, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 523, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 525, 525, 525, 525, 525, 525, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 525, 526, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 527, 88, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 528, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 528, 528, 528, 528, 528, 528, 528, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 528, 528, 528, 528, 86, 528, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 528, 528, 528, 528, 528, 86, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 528, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 529, 529, 529, 529, 529, 529, 529, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 529, 529, 529, 529, 91, 529, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 529, 529, 529, 529, 529, 91, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 530, 530, 530, 530, 530, 530, 530, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 530, 530, 530, 530, 93, 530, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 530, 530, 530, 530, 530, 93, 532, 533, 533, 533, 532, 533, 533, 533, 533, 534, 535, 534, 534, 534, 533, 533, 533, 533, 533, 533, 533, 533, 533, 533, 533, 533, 532, 533, 533, 533, 533, 533, 534, 536, 533, 537, 538, 539, 540, 533, 533, 533, 541, 542, 533, 542, 533, 543, 533, 533, 533, 533, 533, 533, 533, 533, 533, 533, 544, 533, 545, 546, 547, 533, 533, 548, 549, 548, 548, 550, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 551, 552, 533, 543, 553, 543, 554, 555, 556, 557, 558, 559, 531, 531, 560, 531, 531, 531, 561, 562, 563, 531, 531, 564, 565, 566, 567, 531, 568, 531, 569, 531, 533, 570, 533, 542, 533, 531, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 572, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 571, 571, 571, 572, 571, 572, 571, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 571, 571, 571, 571, 531, 571, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 571, 571, 571, 571, 571, 531, 534, 573, 534, 534, 534, 573, 573, 573, 573, 573, 573, 573, 573, 573, 573, 573, 573, 573, 573, 573, 573, 573, 573, 534, 573, 574, 543, 575, 575, 543, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 575, 543, 575, 576, 577, 578, 579, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 95, 95, 580, 95, 580, 95, 95, 580, 580, 95, 95, 95, 582, 95, 95, 583, 583, 583, 583, 583, 583, 583, 583, 583, 583, 95, 95, 95, 95, 95, 95, 95, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 580, 95, 580, 580, 581, 95, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 580, 580, 580, 95, 580, 581, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 584, 584, 584, 584, 584, 584, 584, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 584, 584, 584, 584, 581, 584, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 584, 584, 584, 584, 584, 581, 583, 583, 583, 583, 583, 583, 583, 583, 583, 583, 584, 585, 575, 543, 575, 543, 575, 543, 575, 587, 586, 543, 588, 575, 543, 575, 589, 543, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 543, 580, 543, 575, 543, 543, 575, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 572, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 571, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 571, 571, 571, 572, 571, 572, 571, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 571, 571, 571, 571, 548, 571, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 571, 571, 571, 571, 571, 548, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 572, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 572, 590, 572, 590, 548, 548, 548, 548, 591, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 548, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 590, 548, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 572, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 572, 590, 572, 590, 548, 548, 548, 548, 548, 548, 592, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 548, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 590, 548, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 572, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 572, 590, 572, 590, 548, 548, 548, 548, 548, 548, 548, 548, 593, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 548, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 590, 548, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 572, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 572, 590, 572, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 594, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 548, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 590, 548, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 572, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 572, 590, 572, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 595, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 548, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 590, 548, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 572, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 572, 590, 572, 590, 548, 548, 548, 594, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 548, 590, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 548, 590, 590, 590, 590, 590, 548, 589, 580, 535, 580, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 597, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 598, 599, 531, 531, 531, 531, 531, 600, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 601, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 602, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 603, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 604, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 605, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 606, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 607, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 608, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 609, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 610, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 611, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 607, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 612, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 611, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 613, 531, 614, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 615, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 616, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 617, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 618, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 619, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 620, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 621, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 622, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 623, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 624, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 625, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 626, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 616, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 627, 531, 531, 531, 531, 531, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 628, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 572, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 629, 629, 629, 572, 629, 572, 629, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 629, 629, 629, 629, 531, 629, 531, 531, 531, 531, 531, 531, 531, 531, 630, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 629, 629, 629, 629, 629, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 631, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 632, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 633, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 634, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 635, 531, 636, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 637, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 609, 531, 531, 531, 638, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 639, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 640, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 625, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 641, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 563, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 623, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 642, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 643, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 644, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 625, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 645, 531, 531, 531, 646, 531, 531, 531, 531, 531, 647, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 647, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 648, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 649, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 650, 651, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 609, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 652, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 625, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 653, 531, 531, 654, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 609, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 620, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 655, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 656, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 638, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 657, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 563, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 658, 531, 531, 531, 531, 531, 531, 531, 531, 531, 652, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 620, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 659, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 660, 531, 531, 531, 531, 531, 531, 531, 661, 531, 531, 531, 531, 531, 531, 531, 662, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 638, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 626, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 646, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 663, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 620, 531, 531, 531, 644, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 664, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 665, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 572, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 572, 596, 572, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 531, 596, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 614, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 531, 596, 596, 596, 596, 596, 531, 543, 575, 667, 668, 668, 668, 667, 668, 668, 668, 668, 669, 668, 669, 669, 669, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 667, 668, 668, 668, 668, 668, 669, 668, 668, 670, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 668, 671, 668, 668, 666, 668, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 668, 668, 668, 668, 668, 666, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 100, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 672, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 101, 672, 672, 672, 672, 100, 672, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 672, 672, 672, 672, 99, 672, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 672, 672, 672, 672, 672, 99, 669, 673, 669, 669, 669, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 669, 673, 674, 675, 676, 677, 678, 672, 679, 681, 682, 682, 682, 681, 682, 682, 682, 682, 683, 684, 683, 683, 683, 682, 682, 682, 682, 682, 682, 682, 682, 682, 682, 682, 682, 681, 682, 682, 682, 682, 682, 683, 685, 682, 686, 682, 687, 688, 682, 682, 682, 689, 690, 682, 690, 682, 687, 682, 682, 682, 682, 682, 682, 682, 682, 682, 682, 682, 682, 691, 692, 693, 682, 682, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 695, 696, 682, 687, 680, 687, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 682, 697, 682, 690, 682, 680, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 699, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 698, 698, 698, 698, 698, 699, 698, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 698, 698, 698, 698, 680, 698, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 680, 698, 698, 698, 698, 698, 680, 701, 700, 702, 683, 703, 683, 683, 683, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 683, 703, 704, 687, 705, 705, 687, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 687, 705, 706, 707, 708, 709, 687, 705, 687, 705, 687, 705, 687, 710, 705, 687, 705, 712, 687, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 687, 711, 687, 705, 687, 687, 705, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 699, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 713, 713, 713, 713, 713, 699, 713, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 713, 713, 713, 713, 694, 713, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 694, 713, 713, 713, 713, 713, 694, 712, 711, 684, 711, 687, 705, 715, 714, 714, 714, 715, 714, 714, 714, 714, 716, 717, 716, 716, 716, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 715, 714, 714, 714, 714, 714, 716, 714, 714, 718, 714, 109, 719, 714, 720, 714, 721, 109, 140, 722, 142, 109, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 723, 714, 724, 140, 725, 726, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 140, 727, 140, 109, 714, 714, 714, 714, 714, 714, 714, 714, 714, 714, 728, 714, 714, 714, 714, 714, 714, 714, 714, 729, 714, 714, 730, 714, 731, 714, 714, 714, 153, 154, 714, 109, 714, 732, 732, 732, 732, 732, 732, 732, 732, 732, 716, 732, 716, 716, 716, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 716, 732, 732, 732, 732, 135, 136, 732, 137, 732, 138, 139, 140, 141, 142, 135, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 143, 732, 144, 140, 145, 146, 732, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 147, 148, 140, 109, 104, 732, 104, 104, 104, 104, 104, 104, 104, 104, 149, 104, 104, 104, 104, 104, 104, 104, 104, 150, 104, 104, 151, 104, 152, 104, 104, 104, 153, 154, 732, 109, 732, 104, 733, 734, 734, 734, 733, 734, 734, 734, 734, 140, 735, 140, 140, 140, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 733, 734, 734, 734, 734, 734, 140, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 140, 734, 140, 735, 140, 140, 140, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 140, 103, 103, 103, 103, 103, 109, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 140, 103, 140, 735, 140, 140, 140, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 140, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 140, 103, 736, 140, 735, 140, 140, 140, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 140, 737, 737, 737, 737, 737, 737, 737, 737, 737, 738, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 737, 140, 737, 140, 735, 140, 140, 140, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 140, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 140, 140, 103, 739, 733, 140, 733, 741, 740, 743, 744, 743, 743, 743, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 743, 742, 745, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 105, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 106, 733, 733, 733, 733, 105, 733, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 733, 733, 733, 733, 104, 733, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 733, 733, 733, 733, 733, 104, 746, 140, 735, 140, 140, 140, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 140, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 140, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 109, 733, 747, 748, 749, 750, 751, 752, 140, 735, 140, 140, 140, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 140, 733, 733, 733, 733, 733, 733, 733, 733, 733, 109, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 733, 140, 733, 140, 740, 109, 753, 109, 753, 754, 755, 754, 754, 754, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 754, 742, 756, 753, 757, 757, 757, 757, 757, 757, 757, 757, 757, 112, 757, 112, 112, 112, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 112, 757, 757, 757, 757, 113, 114, 757, 115, 757, 116, 117, 118, 119, 120, 113, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 121, 757, 122, 118, 123, 124, 757, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 125, 126, 118, 127, 111, 757, 111, 111, 111, 111, 111, 111, 111, 111, 128, 111, 111, 111, 111, 111, 111, 111, 111, 129, 111, 111, 130, 111, 131, 111, 111, 111, 132, 133, 757, 127, 757, 111, 140, 753, 758, 753, 759, 753, 760, 753, 761, 179, 179, 179, 761, 179, 179, 179, 179, 762, 179, 762, 762, 762, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 761, 179, 179, 179, 179, 179, 762, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 179, 763, 179, 179, 181, 179, 181, 181, 181, 185, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 179, 179, 179, 179, 179, 181, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 764, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 179, 178, 178, 178, 178, 764, 178, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 178, 178, 178, 178, 181, 178, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 178, 178, 178, 178, 178, 181, 765, 765, 765, 765, 765, 765, 765, 765, 765, 182, 765, 182, 182, 182, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 182, 765, 765, 765, 765, 765, 765, 765, 183, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 765, 184, 765, 765, 181, 765, 181, 181, 181, 185, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 765, 765, 765, 765, 765, 181, 766, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 764, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 765, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 179, 765, 765, 765, 765, 764, 765, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 765, 765, 765, 765, 181, 765, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 767, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 765, 765, 765, 765, 765, 181, 186, 765, 769, 768, 768, 768, 769, 768, 768, 768, 768, 770, 768, 770, 770, 770, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 769, 768, 768, 768, 768, 768, 770, 768, 768, 771, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 772, 768, 768, 768, 768, 768, 768, 768, 773, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 774, 768, 770, 775, 770, 770, 770, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 770, 775, 776, 777, 778, 779, 781, 780, 782, 783, 780, 784, 786, 787, 787, 787, 786, 787, 787, 787, 787, 788, 789, 788, 788, 788, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 786, 787, 787, 787, 787, 787, 788, 787, 787, 790, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 787, 791, 787, 787, 785, 787, 785, 785, 785, 785, 785, 785, 785, 785, 792, 785, 785, 785, 785, 785, 785, 785, 785, 793, 785, 785, 794, 785, 795, 785, 785, 785, 787, 787, 787, 787, 787, 785, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 796, 796, 796, 796, 796, 796, 796, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 796, 796, 796, 796, 785, 796, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 796, 796, 796, 796, 796, 785, 788, 797, 788, 788, 788, 797, 797, 797, 797, 797, 797, 797, 797, 797, 797, 797, 797, 797, 797, 797, 797, 797, 797, 788, 797, 798, 799, 800, 801, 802, 804, 803, 805, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 807, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 808, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 809, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 810, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 811, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 807, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 812, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 813, 785, 785, 785, 785, 785, 785, 785, 814, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 815, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 816, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 807, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 785, 785, 785, 817, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 807, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 785, 785, 818, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 785, 785, 785, 819, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 806, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 785, 806, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 811, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 806, 806, 806, 806, 806, 785, 821, 203, 203, 203, 821, 203, 203, 203, 203, 822, 823, 822, 822, 822, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 821, 203, 203, 203, 203, 203, 822, 824, 203, 825, 203, 826, 827, 203, 828, 203, 829, 830, 203, 831, 832, 833, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 834, 203, 835, 836, 837, 838, 203, 839, 840, 839, 839, 841, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 839, 842, 843, 203, 844, 845, 203, 846, 847, 848, 849, 850, 851, 820, 820, 852, 820, 820, 820, 853, 854, 855, 820, 820, 856, 857, 858, 859, 820, 860, 820, 861, 820, 862, 863, 203, 844, 203, 820, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 248, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 192, 192, 250, 192, 248, 192, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 192, 192, 192, 192, 820, 192, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 192, 192, 192, 192, 192, 820, 865, 864, 864, 866, 864, 867, 869, 870, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 871, 868, 873, 872, 874, 875, 876, 822, 877, 822, 822, 822, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 877, 822, 877, 879, 878, 881, 882, 881, 881, 881, 880, 880, 880, 880, 880, 880, 880, 880, 880, 880, 880, 880, 880, 880, 880, 880, 880, 880, 881, 880, 203, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 203, 883, 884, 885, 886, 887, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 889, 889, 889, 889, 889, 889, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 889, 891, 201, 201, 201, 891, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 891, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 201, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 201, 201, 201, 201, 201, 201, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 202, 201, 893, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 892, 203, 892, 894, 896, 895, 895, 895, 895, 895, 895, 895, 895, 895, 895, 895, 895, 895, 895, 895, 895, 895, 895, 203, 895, 203, 192, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 892, 892, 892, 203, 892, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 892, 892, 892, 203, 203, 892, 898, 883, 203, 883, 883, 899, 899, 899, 883, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 899, 883, 899, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 901, 902, 883, 903, 206, 904, 902, 883, 883, 905, 906, 883, 906, 883, 206, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 907, 883, 908, 909, 910, 883, 911, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 912, 883, 883, 206, 900, 206, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 883, 913, 883, 906, 883, 900, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 915, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 914, 914, 914, 916, 914, 915, 914, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 914, 914, 914, 914, 900, 914, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 914, 914, 914, 914, 914, 900, 918, 917, 919, 921, 922, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 920, 923, 920, 925, 926, 924, 927, 928, 929, 930, 206, 914, 914, 206, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 206, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 914, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 914, 914, 914, 914, 914, 914, 914, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 914, 914, 914, 914, 205, 914, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 914, 914, 914, 914, 914, 205, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 914, 206, 914, 206, 914, 206, 914, 206, 931, 914, 206, 914, 206, 914, 206, 206, 914, 206, 914, 932, 933, 883, 934, 203, 883, 844, 203, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 203, 883, 203, 893, 883, 937, 936, 936, 936, 937, 936, 936, 936, 936, 938, 939, 938, 938, 938, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 937, 936, 936, 936, 936, 936, 938, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 936, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 936, 941, 936, 936, 940, 936, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 936, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 942, 942, 942, 942, 943, 942, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 943, 942, 942, 942, 942, 942, 943, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 944, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 944, 944, 944, 944, 944, 944, 944, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 944, 944, 944, 944, 945, 944, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 945, 944, 944, 944, 944, 944, 945, 948, 947, 947, 947, 948, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 948, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 949, 949, 949, 949, 949, 949, 949, 949, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 950, 947, 947, 947, 947, 947, 947, 947, 947, 947, 951, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 952, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 947, 953, 947, 947, 954, 947, 955, 956, 958, 958, 958, 958, 958, 958, 958, 958, 957, 959, 959, 959, 959, 959, 959, 959, 959, 957, 957, 960, 960, 242, 242, 242, 960, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 960, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 243, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 961, 242, 962, 963, 964, 964, 242, 242, 242, 964, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 964, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 243, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 242, 965, 242, 241, 964, 966, 967, 968, 968, 229, 229, 229, 968, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 968, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 230, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 969, 229, 964, 223, 223, 223, 964, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 964, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 970, 223, 960, 229, 229, 229, 960, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 960, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 230, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 231, 229, 960, 971, 971, 971, 960, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 960, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 972, 971, 973, 974, 974, 971, 971, 971, 974, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 974, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 971, 975, 971, 974, 223, 223, 223, 974, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 974, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 970, 223, 976, 974, 974, 229, 229, 229, 974, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 974, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 230, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 231, 229, 977, 978, 978, 978, 977, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 977, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 979, 979, 979, 979, 979, 979, 979, 979, 979, 979, 978, 978, 978, 978, 978, 978, 978, 979, 979, 979, 979, 979, 979, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 979, 979, 979, 979, 979, 979, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 978, 980, 978, 977, 981, 981, 981, 977, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 977, 981, 977, 982, 982, 982, 977, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 977, 982, 977, 983, 983, 983, 977, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 977, 983, 977, 977, 981, 981, 981, 977, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 977, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 984, 984, 984, 984, 984, 984, 984, 984, 984, 984, 981, 981, 981, 981, 981, 981, 981, 984, 984, 984, 984, 984, 984, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 981, 984, 984, 984, 984, 984, 984, 981, 977, 982, 982, 982, 977, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 977, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 982, 982, 982, 982, 982, 982, 982, 985, 985, 985, 985, 985, 985, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 982, 985, 985, 985, 985, 985, 985, 982, 977, 983, 983, 983, 977, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 977, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 986, 986, 986, 986, 986, 986, 986, 986, 986, 986, 983, 983, 983, 983, 983, 983, 983, 986, 986, 986, 986, 986, 986, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 986, 986, 986, 986, 986, 986, 983, 987, 990, 989, 989, 989, 990, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 990, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 991, 991, 991, 991, 991, 991, 991, 991, 991, 991, 989, 989, 989, 989, 989, 989, 989, 991, 991, 991, 991, 991, 991, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 991, 991, 991, 991, 991, 991, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 989, 981, 989, 990, 992, 992, 992, 990, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 990, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 993, 993, 993, 993, 993, 993, 993, 993, 993, 993, 992, 992, 992, 992, 992, 992, 992, 993, 993, 993, 993, 993, 993, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 993, 993, 993, 993, 993, 993, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 994, 992, 990, 995, 995, 995, 990, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 990, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 995, 995, 995, 995, 995, 995, 995, 996, 996, 996, 996, 996, 996, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 996, 996, 996, 996, 996, 996, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 997, 995, 990, 998, 998, 998, 990, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 998, 998, 998, 998, 998, 998, 998, 999, 999, 999, 999, 999, 999, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 999, 999, 999, 999, 999, 999, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 990, 998, 998, 998, 990, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 998, 998, 998, 998, 998, 998, 998, 999, 999, 999, 999, 999, 999, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 999, 999, 999, 999, 999, 999, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 1000, 990, 999, 999, 999, 990, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 990, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 1000, 999, 990, 999, 999, 999, 990, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 990, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 988, 999, 988, 990, 996, 996, 996, 990, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 990, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 996, 983, 996, 988, 983, 983, 983, 988, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 988, 983, 990, 992, 992, 992, 990, 992, 992, 992, 992, 1001, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 990, 992, 992, 992, 992, 992, 1001, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 1002, 1002, 1002, 1002, 1002, 1002, 1002, 1002, 1002, 1002, 992, 992, 992, 992, 992, 992, 992, 1002, 1002, 1002, 1002, 1002, 1002, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 1002, 1002, 1002, 1002, 1002, 1002, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 1003, 992, 990, 998, 998, 998, 990, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 998, 998, 998, 998, 998, 998, 998, 1004, 1004, 1004, 1004, 1004, 1004, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1004, 1004, 1004, 1004, 1004, 1004, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 990, 998, 998, 998, 990, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1005, 1005, 1005, 1005, 1005, 1005, 1005, 1005, 1005, 1005, 998, 998, 998, 998, 998, 998, 998, 1005, 1005, 1005, 1005, 1005, 1005, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1005, 1005, 1005, 1005, 1005, 1005, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1000, 998, 990, 998, 998, 998, 990, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1006, 1006, 1006, 1006, 1006, 1006, 1006, 1006, 1006, 1006, 998, 998, 998, 998, 998, 998, 998, 1006, 1006, 1006, 1006, 1006, 1006, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1006, 1006, 1006, 1006, 1006, 1006, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1000, 998, 990, 998, 998, 998, 990, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 998, 998, 998, 998, 998, 998, 998, 1007, 1007, 1007, 1007, 1007, 1007, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1007, 1007, 1007, 1007, 1007, 1007, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1000, 998, 990, 998, 998, 998, 990, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1008, 1008, 1008, 1008, 1008, 1008, 1008, 1008, 1008, 1008, 998, 998, 998, 998, 998, 998, 998, 1008, 1008, 1008, 1008, 1008, 1008, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1008, 1008, 1008, 1008, 1008, 1008, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1000, 998, 990, 998, 998, 998, 990, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1009, 1009, 1009, 1009, 1009, 1009, 1009, 1009, 1009, 1009, 998, 998, 998, 998, 998, 998, 998, 1009, 1009, 1009, 1009, 1009, 1009, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1009, 1009, 1009, 1009, 1009, 1009, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1000, 998, 990, 998, 998, 998, 990, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 998, 998, 998, 998, 998, 998, 998, 1010, 1010, 1010, 1010, 1010, 1010, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1010, 1010, 1010, 1010, 1010, 1010, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1000, 998, 990, 998, 998, 998, 990, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 998, 998, 998, 998, 998, 998, 998, 1010, 1010, 1010, 1010, 1010, 1010, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1010, 1010, 1010, 1010, 1010, 1010, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1000, 998, 990, 995, 995, 995, 990, 995, 995, 995, 995, 1001, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 990, 995, 995, 995, 995, 995, 1001, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 995, 995, 995, 995, 995, 995, 995, 1011, 1011, 1011, 1011, 1011, 1011, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 1011, 1011, 1011, 1011, 1011, 1011, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 1003, 995, 990, 998, 998, 998, 990, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 998, 998, 998, 998, 998, 998, 998, 1012, 1012, 1012, 1012, 1012, 1012, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1012, 1012, 1012, 1012, 1012, 1012, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1003, 998, 990, 998, 998, 998, 990, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 998, 998, 998, 998, 998, 998, 998, 1013, 1013, 1013, 1013, 1013, 1013, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1013, 1013, 1013, 1013, 1013, 1013, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1003, 998, 990, 998, 998, 998, 990, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1014, 1014, 1014, 1014, 1014, 1014, 1014, 1014, 1014, 1014, 998, 998, 998, 998, 998, 998, 998, 1014, 1014, 1014, 1014, 1014, 1014, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1014, 1014, 1014, 1014, 1014, 1014, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1003, 998, 990, 998, 998, 998, 990, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 990, 998, 998, 998, 998, 998, 1001, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 998, 998, 998, 998, 998, 998, 998, 1010, 1010, 1010, 1010, 1010, 1010, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1010, 1010, 1010, 1010, 1010, 1010, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 998, 1003, 998, 1015, 1016, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1018, 1018, 1018, 1018, 1018, 1018, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1018, 1018, 1018, 1018, 1018, 1018, 1017, 1017, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 248, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 249, 192, 192, 250, 192, 248, 192, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 192, 192, 192, 192, 247, 192, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 192, 192, 192, 192, 192, 247, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 248, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 249, 883, 883, 250, 883, 248, 883, 247, 247, 247, 247, 1019, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 883, 883, 883, 883, 247, 883, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 883, 883, 883, 883, 883, 247, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 248, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 249, 883, 883, 250, 883, 248, 883, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 1020, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 883, 883, 883, 883, 247, 883, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 883, 883, 883, 883, 883, 247, 1021, 1022, 883, 878, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1024, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 1025, 1026, 820, 820, 820, 820, 820, 1027, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1028, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 1029, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1030, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 1031, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 1032, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1033, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 1034, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1035, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1036, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 1037, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1038, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 1034, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 1039, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1038, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1040, 820, 1041, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 1042, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 1043, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1044, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1045, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 1046, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 1047, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1048, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 1049, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 1050, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1051, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1052, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 1053, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1043, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1054, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1055, 820, 1056, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1057, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1036, 820, 820, 820, 1054, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1058, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1059, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1052, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 1060, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 855, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1050, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 1061, 820, 820, 820, 820, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1062, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 1063, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1064, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1052, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1065, 820, 820, 820, 1066, 820, 820, 820, 820, 820, 1067, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1067, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1068, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 1069, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1070, 1071, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1036, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 1072, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1073, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1074, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1077, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1078, 1075, 1075, 1079, 1075, 1077, 1075, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1075, 1075, 1075, 1075, 1076, 1075, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1075, 1075, 1075, 1075, 1075, 1076, 869, 1080, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 868, 871, 868, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1081, 820, 820, 1082, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1036, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1047, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1083, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1084, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1054, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1085, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 855, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 1086, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1087, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1047, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1052, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1088, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 1089, 820, 820, 820, 820, 820, 820, 820, 1090, 820, 820, 820, 820, 820, 820, 820, 1091, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1054, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1092, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1093, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1061, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 1094, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1061, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 1095, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1047, 820, 820, 820, 1096, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1097, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1061, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 1098, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 1099, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 248, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 249, 1023, 1023, 250, 1023, 248, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 820, 1023, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1041, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 1023, 1023, 1023, 1023, 1023, 820, 1100, 203, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 883, 893, 883, 1102, 1101, 1101, 1101, 1102, 1101, 1101, 1101, 1101, 1103, 1104, 1103, 1103, 1103, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1102, 1101, 1101, 1101, 1101, 1101, 1103, 1101, 1101, 1105, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1106, 1101, 1103, 1107, 1103, 1103, 1103, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1107, 1103, 1107, 1108, 1109, 1110, 1111, 1112, 1114, 1113, 1115, 1117, 1118, 1118, 1118, 1117, 1118, 1118, 1118, 1118, 1119, 1120, 1119, 1119, 1119, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1117, 1118, 1118, 1118, 1118, 1118, 1119, 1118, 1121, 1122, 1118, 1118, 1118, 1121, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1118, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1118, 1123, 1118, 1118, 1116, 1118, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1116, 1118, 1118, 1118, 1118, 1118, 1116, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 256, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 1124, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 257, 1124, 1124, 1124, 1124, 256, 1124, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 1124, 1124, 1124, 1124, 255, 1124, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 1124, 1124, 1124, 1124, 1124, 255, 1119, 1125, 1119, 1119, 1119, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1119, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1124, 1132, 1134, 1135, 1135, 1135, 1134, 1135, 1135, 1135, 1135, 1136, 1137, 1136, 1136, 1136, 1135, 1135, 1135, 1135, 1135, 1135, 1135, 1135, 1135, 1135, 1135, 1135, 1134, 1135, 1135, 1135, 1135, 1135, 1136, 1138, 1139, 1140, 1141, 1142, 1143, 1139, 1144, 1145, 1146, 1142, 1147, 1148, 1149, 1142, 1150, 1151, 1151, 1151, 1151, 1151, 1151, 1151, 1151, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1159, 1159, 1161, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1162, 1163, 1164, 1142, 1165, 1139, 1166, 1167, 1168, 1169, 1170, 1171, 1133, 1133, 1172, 1133, 1133, 1133, 1173, 1174, 1175, 1133, 1133, 1176, 1177, 1178, 1179, 1133, 1180, 1133, 1181, 1133, 1182, 1183, 1184, 1142, 1135, 1133, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 1185, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 265, 265, 265, 265, 265, 1185, 265, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 265, 265, 265, 265, 1133, 265, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 265, 265, 265, 265, 265, 1133, 1187, 1186, 1188, 1136, 1189, 1136, 1136, 1136, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1189, 1136, 1189, 1190, 1192, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1192, 1191, 1193, 1194, 1195, 1196, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 260, 260, 1197, 260, 1197, 260, 260, 1197, 1197, 260, 260, 260, 1198, 260, 260, 1199, 1199, 1199, 1199, 1199, 1199, 1199, 1199, 1199, 1199, 260, 260, 260, 260, 260, 260, 260, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1197, 260, 1197, 1197, 268, 260, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1197, 1197, 1197, 260, 1197, 268, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1200, 1200, 1200, 1200, 268, 1200, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1200, 1200, 1200, 1200, 1200, 268, 1199, 1199, 1199, 1199, 1199, 1199, 1199, 1199, 1199, 1199, 1200, 1201, 1191, 1142, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1202, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1201, 1191, 1203, 1204, 1142, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1201, 1191, 1201, 1205, 1191, 1207, 1206, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 1206, 1147, 1208, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1210, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1211, 1209, 1209, 1209, 1209, 1209, 1210, 1209, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 1209, 262, 1209, 1213, 1212, 1214, 1214, 1214, 1214, 1214, 1214, 1214, 1214, 1214, 1214, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1215, 1212, 1216, 1217, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1218, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1219, 1212, 1212, 1212, 1212, 1212, 1212, 1220, 1212, 1212, 1215, 1212, 1216, 1217, 1212, 1212, 1212, 1221, 1212, 1212, 1212, 1212, 1212, 1218, 1212, 1212, 1222, 1212, 1212, 1212, 1212, 1212, 1219, 1212, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1224, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1225, 1223, 1223, 1223, 1223, 1223, 1224, 1223, 1223, 1223, 1226, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1223, 1227, 1223, 1228, 265, 1228, 265, 265, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 265, 267, 267, 267, 267, 267, 267, 267, 267, 267, 267, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1228, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1229, 1230, 1229, 1231, 1233, 1232, 1234, 1214, 1214, 1214, 1214, 1214, 1214, 1214, 1214, 1214, 1214, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1220, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1221, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1222, 1212, 1235, 1235, 1235, 1235, 1235, 1235, 1235, 1235, 1235, 1235, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1236, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1221, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1222, 1212, 1238, 1238, 1238, 1238, 1238, 1238, 1238, 1238, 1238, 1238, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1239, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1240, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1241, 1237, 1238, 1238, 1238, 1238, 1238, 1238, 1238, 1238, 1238, 1238, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1242, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1240, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1241, 1237, 1240, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1241, 1237, 1243, 1245, 1244, 1246, 1248, 1248, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1249, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1250, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1247, 1251, 1247, 1252, 1252, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1253, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1240, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1241, 1237, 1252, 1252, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1242, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1240, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1241, 1237, 1255, 1255, 1255, 1255, 1255, 1255, 1255, 1255, 1255, 1255, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1256, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1257, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1258, 1254, 1260, 1260, 1260, 1260, 1260, 1260, 1260, 1260, 1260, 1260, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1261, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1262, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1259, 1263, 1259, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1265, 1265, 1265, 1265, 1265, 1265, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1266, 1264, 1265, 1265, 1265, 1265, 1265, 1265, 1264, 1264, 1267, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1264, 1268, 1264, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1269, 1269, 1269, 1269, 1269, 1269, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1270, 1237, 1269, 1269, 1269, 1269, 1269, 1269, 1237, 1237, 1240, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1241, 1237, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1269, 1269, 1269, 1269, 1269, 1269, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1242, 1237, 1269, 1269, 1269, 1269, 1269, 1269, 1237, 1237, 1240, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1241, 1237, 1272, 1271, 1273, 1273, 1273, 1273, 1273, 1273, 1273, 1273, 1273, 1273, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1274, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1275, 1271, 1271, 1271, 1271, 1271, 1274, 1271, 1271, 1271, 1276, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1277, 1271, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1279, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1276, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1271, 1277, 1271, 1280, 1237, 1281, 1281, 1281, 1281, 1281, 1281, 1281, 1281, 1281, 1281, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1282, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1283, 1237, 1237, 1237, 1237, 1237, 1282, 1237, 1237, 1237, 1240, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1241, 1237, 1281, 1281, 1281, 1281, 1281, 1281, 1281, 1281, 1281, 1281, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1242, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1240, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1237, 1241, 1237, 1202, 1208, 1142, 1284, 1191, 1192, 1191, 1285, 1192, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1208, 1192, 1208, 1192, 1191, 1192, 1142, 1191, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 1197, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1197, 1197, 1197, 1197, 1197, 1197, 1286, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1197, 1197, 1197, 1197, 268, 1197, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 1197, 1197, 1197, 1197, 1197, 268, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 1185, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1287, 265, 265, 265, 265, 1185, 265, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 265, 265, 265, 265, 1159, 265, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 265, 265, 265, 265, 265, 1159, 1288, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1185, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1287, 1289, 1289, 1289, 1289, 1185, 1289, 1159, 1159, 1159, 1159, 1290, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1159, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1289, 1159, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1185, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1287, 1289, 1289, 1289, 1289, 1185, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1291, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1159, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1289, 1159, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1185, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1287, 1289, 1289, 1289, 1289, 1185, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1292, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1159, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1289, 1159, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1185, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1287, 1289, 1289, 1289, 1289, 1185, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1293, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1159, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1289, 1159, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1185, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1287, 1289, 1289, 1289, 1289, 1185, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1294, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1159, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1289, 1159, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1185, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1287, 1289, 1289, 1289, 1289, 1185, 1289, 1159, 1159, 1159, 1293, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1159, 1289, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1289, 1289, 1289, 1289, 1289, 1159, 1295, 1297, 1296, 1298, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1300, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1301, 1302, 1133, 1133, 1133, 1133, 1133, 1303, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1304, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1305, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1306, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1307, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1308, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1309, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1310, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1311, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1312, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1313, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1314, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1315, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1316, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1317, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1318, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1314, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1319, 1133, 1320, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1321, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1322, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1323, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1324, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1325, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1326, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1327, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1328, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1324, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1329, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1330, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1331, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1332, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1333, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1334, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1324, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1335, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1336, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1337, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 270, 271, 270, 270, 270, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 270, 1185, 1338, 272, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1338, 1338, 273, 1338, 1338, 1185, 1338, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1338, 274, 1338, 1338, 1133, 1338, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1338, 1338, 1338, 1338, 1338, 1133, 287, 288, 287, 287, 287, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 287, 286, 286, 289, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 292, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 291, 286, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1340, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1341, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1342, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1185, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1343, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1343, 1343, 1343, 1343, 1343, 1185, 1343, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1343, 1343, 1343, 1343, 1133, 1343, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1344, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1343, 1343, 1343, 1343, 1343, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1345, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1346, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1347, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1348, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1349, 1133, 1350, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1351, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1324, 1133, 1133, 1133, 1352, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1324, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1317, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1353, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1354, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1334, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1355, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1175, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1356, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1357, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1317, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1324, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1358, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1324, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1359, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1360, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1361, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1334, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1362, 1133, 1133, 1133, 1363, 1133, 1133, 1133, 1133, 1133, 1364, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1365, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1331, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1317, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1366, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1367, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1368, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1369, 1370, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1317, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1371, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1372, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1358, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1373, 1133, 1133, 1374, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1317, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1375, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1331, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1376, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1377, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1378, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1317, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1379, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1380, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1366, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1381, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1382, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1328, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1357, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1383, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1384, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1385, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1386, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1387, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1323, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1388, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1389, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1358, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1390, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1358, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1391, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1328, 1133, 1133, 1133, 1392, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1393, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1358, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1394, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1395, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1396, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1185, 1299, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1133, 1299, 1133, 1133, 1133, 1366, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1133, 1299, 1299, 1299, 1299, 1299, 1133, 1397, 1201, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1191, 1142, 1191, 1398, 1400, 1399, 1400, 1400, 1400, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 1400, 1399, 1399, 1399, 1399, 1399, 1401, 1399, 1399, 1399, 1399, 1399, 1399, 1399, 298, 1399, 296, 1402, 296, 296, 296, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 296, 1402, 1402, 1402, 1402, 1402, 297, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 298, 1402, 299, 1402, 1404, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1405, 1403, 1404, 1403, 1404, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1407, 1403, 1404, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1408, 1403, 1404, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1403, 1409, 1403, 1411, 1409, 0]];\n    $send(self, '_lex_indicies=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$attr_accessor(\"_lex_trans_targs\");\n      return self.$private(\"_lex_trans_targs\", \"_lex_trans_targs=\");\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [[165, 2, 3, 4, 171, 6, 7, 8, 9, 10, 165, 165, 174, 177, 174, 12, 178, 14, 174, 185, 186, 189, 190, 196, 191, 192, 193, 19, 194, 195, 198, 200, 201, 202, 203, 204, 25, 18, 187, 188, 27, 236, 237, 239, 241, 239, 30, 242, 32, 239, 249, 250, 253, 254, 260, 255, 256, 257, 37, 258, 259, 262, 264, 265, 266, 267, 268, 43, 36, 251, 252, 45, 300, 301, 308, 310, 308, 48, 311, 50, 313, 316, 313, 52, 317, 54, 323, 322, 0, 56, 324, 325, 58, 326, 327, 327, 327, 327, 440, 61, 62, 63, 440, 468, 64, 65, 468, 468, 472, 472, 69, 64, 70, 470, 471, 473, 474, 472, 468, 475, 476, 478, 66, 67, 479, 480, 68, 472, 71, 72, 77, 84, 482, 483, 70, 470, 471, 473, 474, 472, 468, 475, 476, 478, 66, 67, 479, 480, 68, 71, 72, 77, 84, 482, 483, 481, 73, 74, 75, 76, 78, 79, 82, 80, 81, 83, 85, 86, 468, 88, 89, 90, 92, 95, 93, 94, 96, 98, 499, 499, 499, 500, 100, 502, 101, 503, 102, 500, 100, 502, 101, 503, 537, 537, 537, 105, 106, 107, 108, 548, 537, 537, 553, 537, 537, 574, 537, 112, 575, 581, 115, 118, 120, 122, 123, 124, 118, 119, 585, 119, 585, 121, 537, 599, 600, 603, 604, 610, 605, 606, 607, 129, 608, 609, 612, 614, 615, 616, 617, 618, 135, 128, 601, 602, 137, 654, 655, 139, 539, 103, 541, 141, 142, 657, 758, 144, 145, 146, 758, 766, 766, 766, 149, 787, 786, 766, 789, 791, 776, 823, 155, 156, 157, 161, 162, 155, 156, 157, 161, 162, 158, 158, 156, 157, 159, 160, 158, 158, 156, 157, 159, 160, 870, 156, 766, 939, 163, 164, 939, 939, 165, 165, 166, 167, 168, 170, 172, 173, 165, 165, 165, 169, 165, 169, 165, 1, 165, 165, 165, 5, 174, 174, 175, 174, 176, 179, 174, 174, 11, 13, 174, 174, 174, 180, 181, 182, 15, 21, 26, 205, 28, 174, 174, 174, 183, 184, 174, 16, 174, 174, 174, 17, 174, 174, 174, 20, 197, 199, 22, 174, 174, 23, 24, 174, 206, 210, 214, 207, 208, 209, 211, 212, 213, 174, 174, 215, 219, 225, 216, 223, 224, 217, 221, 222, 218, 220, 174, 226, 235, 234, 227, 228, 229, 230, 231, 232, 233, 174, 174, 174, 238, 239, 239, 239, 240, 243, 239, 29, 31, 239, 239, 239, 244, 245, 246, 33, 39, 44, 269, 46, 239, 239, 239, 247, 248, 239, 34, 239, 239, 239, 35, 239, 239, 239, 38, 261, 263, 40, 239, 239, 41, 42, 239, 270, 274, 278, 271, 272, 273, 275, 276, 277, 239, 239, 279, 283, 289, 280, 287, 288, 281, 285, 286, 282, 284, 239, 290, 299, 298, 291, 292, 293, 294, 295, 296, 297, 239, 239, 239, 302, 303, 303, 304, 303, 305, 303, 303, 303, 306, 306, 306, 307, 306, 306, 306, 308, 308, 308, 309, 308, 47, 49, 308, 308, 312, 312, 312, 313, 313, 314, 313, 315, 313, 313, 51, 53, 313, 313, 318, 318, 319, 318, 318, 320, 321, 320, 55, 57, 322, 322, 322, 328, 327, 327, 329, 330, 331, 332, 334, 337, 338, 339, 340, 327, 341, 342, 344, 346, 347, 348, 352, 354, 355, 356, 372, 377, 384, 389, 396, 403, 406, 407, 411, 405, 415, 423, 427, 429, 434, 436, 439, 327, 327, 327, 327, 327, 327, 333, 327, 333, 327, 335, 59, 336, 327, 60, 327, 327, 343, 345, 327, 349, 350, 351, 347, 353, 327, 357, 358, 367, 370, 359, 360, 361, 362, 363, 364, 365, 366, 328, 368, 369, 371, 373, 376, 374, 375, 378, 381, 379, 380, 382, 383, 385, 387, 386, 388, 390, 391, 327, 392, 393, 394, 395, 327, 397, 400, 398, 399, 401, 402, 404, 408, 409, 410, 412, 414, 413, 416, 417, 418, 420, 419, 421, 422, 424, 425, 426, 428, 430, 431, 432, 433, 435, 437, 438, 441, 440, 440, 442, 443, 445, 440, 440, 440, 444, 440, 444, 446, 440, 448, 447, 447, 451, 452, 453, 454, 447, 456, 457, 458, 459, 461, 463, 464, 465, 466, 467, 447, 449, 447, 450, 447, 447, 447, 447, 447, 455, 447, 455, 460, 447, 462, 447, 468, 468, 469, 484, 485, 471, 487, 488, 475, 489, 490, 491, 492, 493, 495, 496, 497, 498, 468, 468, 468, 468, 468, 468, 472, 477, 468, 468, 468, 468, 468, 468, 468, 468, 468, 486, 468, 486, 468, 468, 468, 468, 494, 468, 87, 91, 97, 499, 501, 504, 99, 499, 499, 500, 505, 505, 506, 507, 509, 511, 512, 505, 505, 508, 505, 508, 505, 510, 505, 505, 505, 514, 513, 513, 515, 516, 517, 519, 521, 522, 527, 534, 513, 513, 513, 513, 518, 513, 518, 513, 520, 513, 513, 514, 523, 524, 525, 526, 528, 529, 532, 530, 531, 533, 535, 536, 538, 537, 546, 547, 549, 550, 552, 554, 555, 556, 558, 559, 560, 562, 563, 584, 587, 588, 589, 657, 658, 659, 660, 661, 557, 663, 679, 684, 691, 696, 698, 704, 707, 708, 712, 706, 716, 727, 731, 734, 742, 746, 749, 750, 537, 103, 540, 537, 537, 542, 544, 545, 537, 543, 537, 537, 537, 537, 537, 104, 537, 537, 537, 537, 537, 551, 537, 551, 537, 537, 109, 537, 537, 110, 537, 537, 557, 537, 561, 537, 564, 573, 537, 111, 576, 577, 578, 537, 579, 113, 582, 114, 116, 583, 537, 565, 567, 537, 566, 537, 537, 568, 571, 572, 537, 569, 570, 537, 537, 537, 537, 580, 117, 586, 537, 537, 590, 537, 537, 537, 591, 593, 537, 592, 537, 592, 537, 594, 595, 596, 125, 131, 136, 619, 138, 537, 537, 537, 597, 598, 537, 126, 537, 537, 537, 127, 537, 537, 537, 130, 611, 613, 132, 537, 537, 133, 134, 537, 620, 624, 628, 621, 622, 623, 625, 626, 627, 537, 537, 629, 633, 639, 630, 637, 638, 631, 635, 636, 632, 634, 537, 640, 648, 653, 641, 642, 643, 644, 645, 646, 647, 649, 650, 651, 652, 537, 537, 537, 656, 140, 143, 537, 662, 537, 664, 665, 674, 677, 666, 667, 668, 669, 670, 671, 672, 673, 538, 675, 676, 678, 680, 683, 681, 682, 685, 688, 686, 687, 689, 690, 692, 694, 693, 695, 697, 699, 701, 700, 702, 703, 705, 538, 709, 710, 711, 713, 715, 714, 717, 718, 719, 724, 720, 721, 722, 537, 538, 539, 103, 723, 544, 725, 726, 728, 729, 730, 732, 733, 735, 736, 737, 740, 738, 739, 741, 743, 744, 745, 747, 748, 537, 751, 751, 752, 753, 754, 756, 751, 751, 751, 755, 751, 755, 751, 757, 751, 759, 758, 758, 760, 761, 758, 762, 764, 758, 758, 758, 758, 763, 758, 763, 765, 758, 767, 766, 766, 770, 771, 772, 766, 773, 775, 778, 779, 780, 781, 782, 766, 783, 784, 788, 811, 815, 766, 816, 818, 820, 766, 821, 822, 824, 828, 830, 831, 766, 833, 851, 856, 863, 871, 878, 885, 890, 891, 895, 889, 900, 910, 916, 919, 928, 932, 936, 937, 938, 768, 766, 769, 766, 766, 766, 766, 766, 766, 774, 766, 774, 766, 147, 777, 766, 766, 766, 766, 766, 766, 766, 785, 766, 766, 148, 150, 766, 151, 795, 803, 806, 790, 807, 808, 796, 800, 801, 766, 790, 151, 792, 793, 152, 766, 792, 766, 766, 794, 766, 797, 799, 766, 797, 798, 800, 801, 799, 766, 766, 802, 766, 766, 804, 799, 800, 801, 804, 805, 766, 797, 799, 800, 801, 766, 797, 799, 800, 801, 766, 809, 799, 800, 801, 809, 810, 766, 151, 811, 790, 812, 800, 801, 813, 799, 151, 813, 790, 814, 817, 819, 153, 154, 766, 766, 825, 826, 827, 822, 829, 766, 766, 832, 766, 766, 834, 835, 844, 849, 836, 837, 838, 839, 840, 841, 842, 843, 767, 845, 846, 847, 848, 767, 850, 852, 855, 853, 854, 767, 767, 857, 860, 858, 859, 861, 862, 767, 864, 866, 865, 867, 868, 869, 766, 766, 872, 767, 873, 766, 874, 875, 876, 877, 768, 879, 882, 880, 881, 883, 884, 886, 887, 888, 767, 892, 893, 894, 896, 898, 899, 897, 767, 901, 902, 903, 906, 904, 905, 907, 908, 909, 911, 913, 912, 914, 915, 917, 918, 920, 921, 923, 926, 922, 924, 925, 927, 929, 930, 931, 933, 934, 935, 766, 766, 939, 940, 941, 939, 943, 942, 944, 942, 945, 946, 947, 942, 942]];\n    $send(self, '_lex_trans_targs=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$attr_accessor(\"_lex_trans_actions\");\n      return self.$private(\"_lex_trans_actions\", \"_lex_trans_actions=\");\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 0, 5, 0, 0, 0, 6, 0, 7, 0, 8, 0, 7, 0, 0, 0, 0, 8, 7, 0, 8, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 9, 0, 10, 0, 0, 0, 11, 0, 7, 0, 8, 0, 7, 0, 0, 0, 0, 8, 7, 0, 8, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 12, 0, 13, 0, 0, 0, 14, 0, 15, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 17, 18, 19, 20, 21, 0, 0, 0, 22, 23, 0, 0, 24, 25, 26, 27, 28, 29, 29, 30, 31, 29, 32, 31, 33, 31, 29, 29, 30, 29, 34, 29, 29, 35, 29, 29, 29, 29, 29, 29, 0, 36, 37, 0, 38, 37, 39, 37, 0, 0, 36, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 44, 45, 0, 0, 0, 45, 28, 46, 29, 29, 29, 46, 47, 48, 49, 0, 0, 0, 0, 0, 50, 51, 0, 52, 53, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 55, 56, 0, 28, 0, 57, 0, 7, 0, 8, 0, 7, 0, 0, 0, 0, 8, 7, 0, 8, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 58, 59, 0, 0, 0, 60, 61, 62, 63, 0, 7, 7, 64, 65, 65, 0, 0, 0, 28, 0, 0, 0, 29, 66, 29, 29, 29, 67, 68, 69, 68, 68, 68, 0, 70, 71, 70, 70, 70, 72, 73, 74, 75, 0, 76, 77, 78, 81, 82, 0, 28, 0, 7, 0, 7, 83, 84, 85, 67, 86, 0, 87, 0, 88, 89, 90, 0, 91, 92, 0, 93, 7, 7, 94, 95, 0, 0, 96, 97, 98, 99, 99, 99, 99, 99, 99, 99, 99, 100, 101, 102, 0, 0, 103, 0, 104, 105, 106, 0, 107, 108, 109, 0, 7, 0, 0, 110, 111, 0, 28, 112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 113, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 117, 118, 0, 119, 120, 121, 7, 7, 122, 0, 0, 123, 124, 125, 99, 99, 99, 99, 99, 99, 99, 99, 126, 127, 128, 0, 0, 129, 0, 130, 131, 132, 0, 133, 134, 135, 0, 7, 0, 0, 136, 137, 0, 28, 138, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 140, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 143, 144, 0, 145, 146, 0, 147, 0, 148, 149, 150, 151, 152, 153, 0, 154, 155, 156, 157, 158, 159, 7, 160, 0, 0, 161, 162, 163, 164, 165, 166, 167, 0, 168, 7, 169, 170, 0, 0, 171, 172, 173, 174, 0, 175, 176, 177, 0, 178, 0, 0, 179, 180, 181, 182, 183, 184, 0, 28, 0, 0, 7, 7, 0, 0, 0, 185, 0, 0, 0, 0, 186, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 187, 188, 189, 190, 191, 192, 67, 193, 0, 194, 0, 0, 0, 195, 0, 196, 197, 0, 0, 198, 0, 0, 0, 199, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 201, 0, 0, 0, 0, 202, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 203, 204, 0, 0, 0, 205, 206, 207, 67, 208, 0, 28, 209, 0, 210, 211, 0, 28, 0, 0, 212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 213, 0, 214, 0, 215, 216, 217, 218, 219, 67, 220, 0, 0, 221, 0, 222, 223, 224, 225, 28, 0, 27, 0, 0, 27, 0, 0, 0, 0, 0, 0, 7, 7, 7, 226, 227, 228, 229, 230, 231, 232, 0, 233, 234, 235, 236, 237, 238, 239, 240, 241, 67, 242, 0, 243, 244, 245, 246, 247, 248, 0, 0, 0, 249, 7, 7, 0, 250, 251, 252, 253, 254, 0, 0, 0, 0, 0, 255, 256, 67, 257, 0, 258, 28, 259, 260, 261, 262, 263, 264, 0, 28, 0, 0, 0, 0, 0, 0, 265, 266, 267, 268, 67, 269, 0, 270, 28, 271, 272, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 274, 275, 0, 8, 0, 0, 7, 276, 0, 0, 0, 0, 0, 0, 7, 7, 0, 277, 0, 277, 277, 277, 0, 0, 277, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 0, 277, 278, 279, 0, 280, 281, 0, 58, 0, 282, 0, 283, 284, 285, 286, 287, 29, 288, 289, 290, 291, 292, 67, 293, 0, 294, 295, 0, 296, 297, 0, 298, 299, 276, 300, 0, 301, 0, 0, 302, 0, 0, 0, 0, 303, 0, 0, 0, 0, 0, 0, 304, 0, 0, 305, 0, 306, 307, 0, 0, 0, 308, 0, 0, 309, 310, 311, 312, 0, 0, 0, 313, 314, 0, 315, 316, 317, 0, 7, 318, 319, 320, 0, 321, 99, 99, 99, 99, 99, 99, 99, 99, 322, 323, 324, 0, 0, 325, 0, 326, 327, 328, 0, 329, 330, 331, 0, 7, 0, 0, 332, 333, 0, 28, 334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 335, 336, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 337, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 338, 339, 340, 0, 0, 0, 341, 28, 342, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 58, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 343, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 344, 345, 346, 347, 348, 348, 344, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 349, 350, 351, 0, 28, 0, 0, 352, 353, 354, 67, 355, 0, 356, 28, 357, 7, 358, 359, 0, 28, 360, 0, 0, 361, 362, 363, 364, 67, 365, 0, 28, 366, 367, 368, 369, 0, 28, 0, 370, 0, 7, 0, 0, 0, 0, 0, 371, 0, 0, 372, 372, 0, 373, 0, 0, 0, 374, 7, 375, 375, 375, 0, 0, 376, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 377, 378, 0, 379, 380, 381, 382, 383, 384, 67, 385, 0, 386, 0, 0, 387, 388, 389, 390, 391, 392, 393, 0, 394, 395, 0, 0, 396, 397, 398, 0, 0, 399, 0, 0, 398, 400, 400, 401, 402, 0, 403, 403, 0, 404, 405, 406, 407, 0, 408, 398, 398, 409, 0, 0, 410, 410, 0, 411, 412, 0, 413, 414, 415, 415, 416, 416, 0, 0, 417, 418, 418, 419, 419, 420, 421, 421, 422, 422, 423, 424, 424, 425, 425, 0, 0, 426, 427, 428, 429, 430, 431, 431, 428, 430, 432, 372, 433, 0, 0, 0, 0, 0, 434, 435, 375, 375, 375, 436, 375, 437, 438, 28, 439, 440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 441, 0, 0, 0, 0, 436, 0, 0, 0, 0, 0, 442, 443, 0, 0, 0, 0, 0, 0, 444, 0, 0, 0, 0, 0, 443, 445, 446, 0, 447, 0, 448, 0, 0, 0, 0, 449, 0, 0, 0, 0, 0, 0, 0, 0, 0, 450, 0, 0, 0, 0, 0, 0, 0, 449, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 451, 452, 453, 7, 76, 454, 0, 455, 0, 456, 0, 0, 0, 457, 458]];\n    $send(self, '_lex_trans_actions=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$attr_accessor(\"_lex_to_state_actions\");\n      return self.$private(\"_lex_to_state_actions\", \"_lex_to_state_actions=\");\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 79, 0, 79, 0, 0, 0, 79, 79, 0, 0, 0, 0, 79, 0, 79, 0, 79, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 79, 0, 0, 0, 0, 0]];\n    $send(self, '_lex_to_state_actions=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$attr_accessor(\"_lex_from_state_actions\");\n      return self.$private(\"_lex_from_state_actions\", \"_lex_from_state_actions=\");\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 80, 0, 80, 0, 0, 0, 80, 80, 0, 0, 0, 0, 80, 0, 80, 0, 80, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 0, 0, 80, 0, 0, 0, 0, 0]];\n    $send(self, '_lex_from_state_actions=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$attr_accessor(\"_lex_eof_trans\");\n      return self.$private(\"_lex_eof_trans\", \"_lex_eof_trans=\");\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 13, 13, 13, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 44, 44, 44, 44, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 75, 75, 75, 75, 81, 81, 81, 81, 0, 0, 0, 0, 95, 97, 99, 99, 99, 104, 104, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 169, 169, 169, 169, 169, 169, 169, 169, 169, 169, 169, 169, 179, 181, 181, 181, 193, 195, 195, 195, 195, 195, 201, 193, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 205, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 223, 193, 205, 205, 205, 205, 255, 255, 255, 260, 262, 262, 262, 266, 266, 260, 266, 266, 266, 266, 266, 266, 266, 266, 266, 296, 296, 0, 309, 310, 311, 313, 315, 317, 315, 315, 0, 327, 328, 332, 332, 333, 342, 343, 344, 344, 344, 347, 347, 349, 350, 351, 351, 351, 353, 354, 355, 355, 351, 347, 347, 360, 361, 361, 361, 361, 361, 364, 364, 364, 364, 364, 364, 364, 364, 374, 375, 375, 375, 375, 387, 387, 387, 375, 375, 375, 375, 387, 387, 387, 387, 387, 387, 387, 387, 387, 398, 387, 399, 400, 400, 0, 407, 411, 411, 412, 421, 422, 423, 423, 423, 426, 426, 428, 429, 430, 430, 430, 432, 433, 434, 434, 430, 426, 426, 439, 440, 440, 440, 440, 440, 443, 443, 443, 443, 443, 443, 443, 443, 453, 454, 454, 454, 454, 466, 466, 466, 454, 454, 454, 454, 466, 466, 466, 466, 466, 466, 466, 466, 466, 477, 466, 478, 479, 479, 0, 486, 487, 0, 493, 0, 500, 504, 504, 0, 0, 513, 514, 518, 518, 0, 523, 0, 526, 0, 529, 529, 530, 531, 0, 572, 574, 575, 576, 577, 579, 581, 585, 585, 576, 576, 576, 576, 587, 576, 576, 581, 576, 576, 572, 591, 591, 591, 591, 591, 591, 581, 581, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 630, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 597, 576, 0, 673, 674, 675, 677, 673, 680, 0, 699, 701, 703, 704, 705, 706, 707, 709, 706, 706, 706, 706, 706, 712, 706, 706, 714, 712, 712, 706, 0, 733, 734, 104, 104, 737, 738, 104, 734, 734, 741, 743, 746, 734, 747, 734, 748, 749, 751, 753, 734, 741, 754, 754, 743, 754, 758, 754, 754, 754, 754, 0, 179, 766, 767, 766, 766, 0, 776, 777, 779, 781, 783, 781, 785, 0, 797, 798, 799, 800, 802, 804, 806, 807, 807, 807, 807, 807, 807, 807, 807, 807, 807, 807, 807, 807, 807, 807, 807, 0, 193, 865, 868, 869, 873, 875, 876, 877, 878, 879, 881, 884, 885, 887, 889, 892, 893, 895, 896, 193, 893, 893, 884, 884, 884, 884, 915, 918, 920, 921, 925, 928, 929, 930, 931, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 884, 935, 884, 884, 884, 936, 943, 943, 945, 947, 956, 957, 958, 958, 958, 961, 961, 963, 964, 965, 965, 965, 967, 968, 969, 969, 965, 961, 961, 974, 975, 975, 975, 975, 975, 978, 978, 978, 978, 978, 978, 978, 978, 988, 989, 989, 989, 989, 1001, 1001, 1001, 989, 989, 989, 989, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1016, 1017, 1018, 1018, 193, 884, 884, 1022, 884, 879, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1076, 869, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1101, 884, 0, 1108, 1109, 1110, 1112, 1114, 1116, 0, 1125, 1126, 1127, 1128, 1130, 1125, 1133, 0, 266, 1187, 1189, 1190, 1191, 1192, 1194, 1196, 1198, 1201, 1201, 1192, 1192, 1204, 1205, 1192, 1192, 1207, 1209, 1210, 1210, 1213, 1224, 266, 1230, 1232, 1233, 1235, 1213, 1213, 1238, 1238, 1238, 1244, 1245, 1247, 1248, 1238, 1238, 1255, 1260, 1265, 1238, 1238, 1272, 1272, 1238, 1238, 1209, 1192, 1192, 1209, 1192, 1192, 1198, 266, 1289, 1290, 1290, 1290, 1290, 1290, 1290, 1296, 1198, 1299, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1339, 1340, 1300, 1300, 1344, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1398, 1192, 1399, 0, 1403, 1403, 0, 1407, 1407, 1407, 1407, 1411]];\n    $send(self, '_lex_eof_trans=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_start\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [165];\n    $send(self, 'lex_start=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_error\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [0];\n    $send(self, 'lex_error=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_interp_words\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [174];\n    $send(self, 'lex_en_interp_words=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_interp_string\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [239];\n    $send(self, 'lex_en_interp_string=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_plain_words\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [303];\n    $send(self, 'lex_en_plain_words=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_plain_string\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [306];\n    $send(self, 'lex_en_plain_string=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_interp_backslash_delimited\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [308];\n    $send(self, 'lex_en_interp_backslash_delimited=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_plain_backslash_delimited\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [312];\n    $send(self, 'lex_en_plain_backslash_delimited=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_interp_backslash_delimited_words\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [313];\n    $send(self, 'lex_en_interp_backslash_delimited_words=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_plain_backslash_delimited_words\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [318];\n    $send(self, 'lex_en_plain_backslash_delimited_words=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_regexp_modifiers\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [320];\n    $send(self, 'lex_en_regexp_modifiers=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_variable\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [322];\n    $send(self, 'lex_en_expr_variable=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_fname\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [327];\n    $send(self, 'lex_en_expr_fname=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_endfn\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [440];\n    $send(self, 'lex_en_expr_endfn=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_dot\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [447];\n    $send(self, 'lex_en_expr_dot=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_arg\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [468];\n    $send(self, 'lex_en_expr_arg=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_cmdarg\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [499];\n    $send(self, 'lex_en_expr_cmdarg=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_endarg\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [505];\n    $send(self, 'lex_en_expr_endarg=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_mid\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [513];\n    $send(self, 'lex_en_expr_mid=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_beg\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [537];\n    $send(self, 'lex_en_expr_beg=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_labelarg\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [751];\n    $send(self, 'lex_en_expr_labelarg=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_value\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [758];\n    $send(self, 'lex_en_expr_value=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_expr_end\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [766];\n    $send(self, 'lex_en_expr_end=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_leading_dot\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [939];\n    $send(self, 'lex_en_leading_dot=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_line_comment\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [942];\n    $send(self, 'lex_en_line_comment=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"lex_en_line_begin\")\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    $writer = [165];\n    $send(self, 'lex_en_line_begin=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    Opal.const_set($nesting[0], 'ESCAPES', $hash(\"a\".$ord(), \"\\u0007\", \"b\".$ord(), \"\\b\", \"e\".$ord(), \"\\u001b\", \"f\".$ord(), \"\\f\", \"n\".$ord(), \"\\n\", \"r\".$ord(), \"\\r\", \"s\".$ord(), \" \", \"t\".$ord(), \"\\t\", \"v\".$ord(), \"\\v\", \"\\\\\".$ord(), \"\\\\\").$freeze());\n    Opal.const_set($nesting[0], 'REGEXP_META_CHARACTERS', $send(Opal.const_get_relative($nesting, 'Regexp'), 'union', Opal.to_a(\"\\\\$()*+.<>?[]^{|}\".$chars())).$freeze());\n    Opal.const_set($nesting[0], 'RBRACE_OR_RBRACK', [\"}\", \"]\"].$freeze());\n    self.$attr_reader(\"source_buffer\");\n    self.$attr_accessor(\"diagnostics\");\n    self.$attr_accessor(\"static_env\");\n    self.$attr_accessor(\"force_utf32\");\n    self.$attr_accessor(\"cond\", \"cmdarg\", \"in_kwarg\");\n    self.$attr_accessor(\"tokens\", \"comments\");\n    \n    Opal.defn(self, '$initialize', TMP_Lexer_initialize_1 = function $$initialize(version) {\n      var self = this;\n\n      \n      self.version = version;\n      self.static_env = nil;\n      self.tokens = nil;\n      self.comments = nil;\n      return self.$reset();\n    }, TMP_Lexer_initialize_1.$$arity = 1);\n    \n    Opal.defn(self, '$reset', TMP_Lexer_reset_2 = function $$reset(reset_state) {\n      var self = this;\n\n      if (reset_state == null) {\n        reset_state = true;\n      }\n      \n      if ($truthy(reset_state)) {\n        \n        self.cs = self.$class().$lex_en_line_begin();\n        self.cond = Opal.const_get_relative($nesting, 'StackState').$new(\"cond\");\n        self.cmdarg = Opal.const_get_relative($nesting, 'StackState').$new(\"cmdarg\");\n        self.cond_stack = [];\n        self.cmdarg_stack = [];};\n      self.force_utf32 = false;\n      self.source_pts = nil;\n      self.p = 0;\n      self.ts = nil;\n      self.te = nil;\n      self.act = 0;\n      self.stack = [];\n      self.top = 0;\n      self.token_queue = [];\n      self.literal_stack = [];\n      self.eq_begin_s = nil;\n      self.sharp_s = nil;\n      self.newline_s = nil;\n      self.num_base = nil;\n      self.num_digits_s = nil;\n      self.num_suffix_s = nil;\n      self.num_xfrm = nil;\n      self.escape_s = nil;\n      self.escape = nil;\n      self.herebody_s = nil;\n      self.paren_nest = 0;\n      self.lambda_stack = [];\n      self.dedent_level = nil;\n      self.command_state = false;\n      return (self.in_kwarg = false);\n    }, TMP_Lexer_reset_2.$$arity = -1);\n    \n    Opal.defn(self, '$source_buffer=', TMP_Lexer_source_buffer$eq_3 = function(source_buffer) {\n      var $a, $b, self = this, source = nil;\n\n      \n      self.source_buffer = source_buffer;\n      if ($truthy(self.source_buffer)) {\n        \n        source = self.source_buffer.$source();\n        if ($truthy(($truthy($a = (($b = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil)) ? source.$encoding()['$=='](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8')) : $a))) {\n          self.source_pts = source.$unpack(\"U*\")\n          } else {\n          self.source_pts = source.$unpack(\"C*\")\n        };\n        if (self.source_pts['$[]'](0)['$=='](65279)) {\n          return (self.p = 1)\n          } else {\n          return nil\n        };\n        } else {\n        return (self.source_pts = nil)\n      };\n    }, TMP_Lexer_source_buffer$eq_3.$$arity = 1);\n    \n    Opal.defn(self, '$encoding', TMP_Lexer_encoding_4 = function $$encoding() {\n      var self = this;\n\n      return self.source_buffer.$source().$encoding()\n    }, TMP_Lexer_encoding_4.$$arity = 0);\n    Opal.const_set($nesting[0], 'LEX_STATES', $hash2([\"line_begin\", \"expr_dot\", \"expr_fname\", \"expr_value\", \"expr_beg\", \"expr_mid\", \"expr_arg\", \"expr_cmdarg\", \"expr_end\", \"expr_endarg\", \"expr_endfn\", \"expr_labelarg\", \"interp_string\", \"interp_words\", \"plain_string\", \"plain_words\"], {\"line_begin\": self.$lex_en_line_begin(), \"expr_dot\": self.$lex_en_expr_dot(), \"expr_fname\": self.$lex_en_expr_fname(), \"expr_value\": self.$lex_en_expr_value(), \"expr_beg\": self.$lex_en_expr_beg(), \"expr_mid\": self.$lex_en_expr_mid(), \"expr_arg\": self.$lex_en_expr_arg(), \"expr_cmdarg\": self.$lex_en_expr_cmdarg(), \"expr_end\": self.$lex_en_expr_end(), \"expr_endarg\": self.$lex_en_expr_endarg(), \"expr_endfn\": self.$lex_en_expr_endfn(), \"expr_labelarg\": self.$lex_en_expr_labelarg(), \"interp_string\": self.$lex_en_interp_string(), \"interp_words\": self.$lex_en_interp_words(), \"plain_string\": self.$lex_en_plain_string(), \"plain_words\": self.$lex_en_plain_string()}));\n    \n    Opal.defn(self, '$state', TMP_Lexer_state_5 = function $$state() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'LEX_STATES').$invert().$fetch(self.cs, self.cs)\n    }, TMP_Lexer_state_5.$$arity = 0);\n    \n    Opal.defn(self, '$state=', TMP_Lexer_state$eq_6 = function(state) {\n      var self = this;\n\n      return (self.cs = Opal.const_get_relative($nesting, 'LEX_STATES').$fetch(state))\n    }, TMP_Lexer_state$eq_6.$$arity = 1);\n    \n    Opal.defn(self, '$push_cmdarg', TMP_Lexer_push_cmdarg_7 = function $$push_cmdarg() {\n      var self = this;\n\n      \n      self.cmdarg_stack.$push(self.cmdarg);\n      return (self.cmdarg = Opal.const_get_relative($nesting, 'StackState').$new(\"\" + \"cmdarg.\" + (self.cmdarg_stack.$count())));\n    }, TMP_Lexer_push_cmdarg_7.$$arity = 0);\n    \n    Opal.defn(self, '$pop_cmdarg', TMP_Lexer_pop_cmdarg_8 = function $$pop_cmdarg() {\n      var self = this;\n\n      return (self.cmdarg = self.cmdarg_stack.$pop())\n    }, TMP_Lexer_pop_cmdarg_8.$$arity = 0);\n    \n    Opal.defn(self, '$push_cond', TMP_Lexer_push_cond_9 = function $$push_cond() {\n      var self = this;\n\n      \n      self.cond_stack.$push(self.cond);\n      return (self.cond = Opal.const_get_relative($nesting, 'StackState').$new(\"\" + \"cond.\" + (self.cond_stack.$count())));\n    }, TMP_Lexer_push_cond_9.$$arity = 0);\n    \n    Opal.defn(self, '$pop_cond', TMP_Lexer_pop_cond_10 = function $$pop_cond() {\n      var self = this;\n\n      return (self.cond = self.cond_stack.$pop())\n    }, TMP_Lexer_pop_cond_10.$$arity = 0);\n    \n    Opal.defn(self, '$dedent_level', TMP_Lexer_dedent_level_11 = function $$dedent_level() {\n      var $a, self = this, dedent_level = nil;\n\n      \n      $a = [self.dedent_level, nil], (dedent_level = $a[0]), (self.dedent_level = $a[1]), $a;\n      return dedent_level;\n    }, TMP_Lexer_dedent_level_11.$$arity = 0);\n    \n    Opal.defn(self, '$advance', TMP_Lexer_advance_36 = function $$advance() {\n      var $a, $b, $c, $d, TMP_12, TMP_13, TMP_14, TMP_15, TMP_16, TMP_17, TMP_18, TMP_19, TMP_20, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, TMP_21, $p, $q, $r, $s, $t, $u, TMP_22, TMP_23, TMP_24, $v, $w, TMP_25, TMP_26, TMP_27, $x, $y, TMP_28, TMP_29, TMP_30, TMP_31, TMP_32, TMP_33, TMP_34, TMP_35, self = this, klass = nil, _lex_trans_keys = nil, _lex_key_spans = nil, _lex_index_offsets = nil, _lex_indicies = nil, _lex_trans_targs = nil, _lex_trans_actions = nil, _lex_to_state_actions = nil, _lex_from_state_actions = nil, _lex_eof_trans = nil, pe = nil, p = nil, eof = nil, testEof = nil, _slen = nil, _trans = nil, _keys = nil, _inds = nil, _acts = nil, _nacts = nil, _goto_level = nil, _resume = nil, _eof_trans = nil, _again = nil, _test_eof = nil, _out = nil, $case = nil, _wide = nil, tm = nil, heredoc_e = nil, current_literal = nil, $writer = nil, line = nil, string = nil, lookahead = nil, token = nil, escaped_char = nil, unknown_options = nil, type = nil, delimiter = nil, escape = nil, ident = nil, value = nil, digits = nil, invalid_idx = nil, invalid_s = nil, codepoints = nil, codepoint_s = nil, codepoint = nil, new_herebody_s = nil, indent = nil, dedent_body = nil;\n\n      \n      if ($truthy(self.token_queue['$any?']())) {\n        return self.token_queue.$shift()};\n      klass = self.$class();\n      _lex_trans_keys = klass.$send(\"_lex_trans_keys\");\n      _lex_key_spans = klass.$send(\"_lex_key_spans\");\n      _lex_index_offsets = klass.$send(\"_lex_index_offsets\");\n      _lex_indicies = klass.$send(\"_lex_indicies\");\n      _lex_trans_targs = klass.$send(\"_lex_trans_targs\");\n      _lex_trans_actions = klass.$send(\"_lex_trans_actions\");\n      _lex_to_state_actions = klass.$send(\"_lex_to_state_actions\");\n      _lex_from_state_actions = klass.$send(\"_lex_from_state_actions\");\n      _lex_eof_trans = klass.$send(\"_lex_eof_trans\");\n      pe = $rb_plus(self.source_pts.$size(), 2);\n      $a = [self.p, pe], (p = $a[0]), (eof = $a[1]), $a;\n      self.command_state = ($truthy($a = self.cs['$=='](klass.$lex_en_expr_value())) ? $a : self.cs['$=='](klass.$lex_en_line_begin()));\n      \n      testEof = false;\n      $b = nil, $a = Opal.to_ary($b), (_slen = ($a[0] == null ? nil : $a[0])), (_trans = ($a[1] == null ? nil : $a[1])), (_keys = ($a[2] == null ? nil : $a[2])), (_inds = ($a[3] == null ? nil : $a[3])), (_acts = ($a[4] == null ? nil : $a[4])), (_nacts = ($a[5] == null ? nil : $a[5])), $b;\n      _goto_level = 0;\n      _resume = 10;\n      _eof_trans = 15;\n      _again = 20;\n      _test_eof = 30;\n      _out = 40;\n      while ($truthy(true)) {\n        \n        if ($truthy($rb_le(_goto_level, 0))) {\n          \n          if (p['$=='](pe)) {\n            \n            _goto_level = _test_eof;\n            continue;;};\n          if (self.cs['$=='](0)) {\n            \n            _goto_level = _out;\n            continue;;};};\n        if ($truthy($rb_le(_goto_level, _resume))) {\n          \n          $case = _lex_from_state_actions['$[]'](self.cs);\n          if ((80)['$===']($case)) {\n          self.ts = p;};\n          _keys = self.cs['$<<'](1);\n          _inds = _lex_index_offsets['$[]'](self.cs);\n          _slen = _lex_key_spans['$[]'](self.cs);\n          _wide = ($truthy($b = self.source_pts['$[]'](p)) ? $b : 0);\n          _trans = (function() {if ($truthy(($truthy($b = ($truthy($c = $rb_gt(_slen, 0)) ? $rb_le(_lex_trans_keys['$[]'](_keys), _wide) : $c)) ? $rb_le(_wide, _lex_trans_keys['$[]']($rb_plus(_keys, 1))) : $b))) {\n            return _lex_indicies['$[]']($rb_minus($rb_plus(_inds, _wide), _lex_trans_keys['$[]'](_keys)))\n            } else {\n            return _lex_indicies['$[]']($rb_plus(_inds, _slen))\n          }; return nil; })();};\n        if ($truthy($rb_le(_goto_level, _eof_trans))) {\n          \n          self.cs = _lex_trans_targs['$[]'](_trans);\n          if ($truthy(_lex_trans_actions['$[]'](_trans)['$!='](0))) {\n            $case = _lex_trans_actions['$[]'](_trans);\n            if ((28)['$===']($case)) {\n            self.newline_s = p;}\n            else if ((99)['$===']($case)) {\n            self.escape_s = p;\n            self.escape = nil;}\n            else if ((29)['$===']($case)) {\n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};}\n            else if ((67)['$===']($case)) {\n            self.sharp_s = $rb_minus(p, 1);}\n            else if ((70)['$===']($case)) {\n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());}\n            else if ((279)['$===']($case)) {\n            tm = p;}\n            else if ((36)['$===']($case)) {\n            tm = p;}\n            else if ((38)['$===']($case)) {\n            tm = p;}\n            else if ((40)['$===']($case)) {\n            tm = p;}\n            else if ((55)['$===']($case)) {\n            heredoc_e = p;}\n            else if ((319)['$===']($case)) {\n            self.escape = nil;}\n            else if ((348)['$===']($case)) {\n            tm = p;}\n            else if ((424)['$===']($case)) {\n            self.num_base = 16;\n            self.num_digits_s = p;}\n            else if ((418)['$===']($case)) {\n            self.num_base = 10;\n            self.num_digits_s = p;}\n            else if ((421)['$===']($case)) {\n            self.num_base = 8;\n            self.num_digits_s = p;}\n            else if ((415)['$===']($case)) {\n            self.num_base = 2;\n            self.num_digits_s = p;}\n            else if ((430)['$===']($case)) {\n            self.num_base = 10;\n            self.num_digits_s = self.ts;}\n            else if ((398)['$===']($case)) {\n            self.num_base = 8;\n            self.num_digits_s = self.ts;}\n            else if ((410)['$===']($case)) {\n            self.num_suffix_s = p;}\n            else if ((405)['$===']($case)) {\n            self.num_suffix_s = p;}\n            else if ((403)['$===']($case)) {\n            self.num_suffix_s = p;}\n            else if ((76)['$===']($case)) {\n            tm = p;}\n            else if ((7)['$===']($case)) {\n            self.te = $rb_plus(p, 1);}\n            else if ((96)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DBEG\", \"\\#{\".$freeze());\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              \n              $writer = [self.herebody_s];\n              $send(current_literal, 'saved_herebody_s=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              self.herebody_s = nil;};\n            current_literal.$start_interp_brace();\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 758;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((5)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DVAR\", nil, self.ts, $rb_plus(self.ts, 1));\n            p = self.ts;\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((92)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($b = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $b))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;}\n            else if ((91)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((97)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DVAR\", nil, self.ts, $rb_plus(self.ts, 1));\n            p = self.ts;\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((94)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$literal().$extend_space(self.ts, self.te);;}\n            else if ((95)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((6)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($b = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $b))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($b = self.escape) ? $b : self.$tok()), self.ts, self.te)\n            };;}\n            else if ((4)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((123)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DBEG\", \"\\#{\".$freeze());\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              \n              $writer = [self.herebody_s];\n              $send(current_literal, 'saved_herebody_s=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              self.herebody_s = nil;};\n            current_literal.$start_interp_brace();\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 758;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((10)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DVAR\", nil, self.ts, $rb_plus(self.ts, 1));\n            p = self.ts;\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((120)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($b = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $b))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;}\n            else if ((119)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((124)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DVAR\", nil, self.ts, $rb_plus(self.ts, 1));\n            p = self.ts;\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((122)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((11)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($b = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $b))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($b = self.escape) ? $b : self.$tok()), self.ts, self.te)\n            };;}\n            else if ((9)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((146)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($b = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $b))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;}\n            else if ((145)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((148)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$literal().$extend_space(self.ts, self.te);;}\n            else if ((149)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((152)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($b = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $b))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;}\n            else if ((151)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((154)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((161)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DBEG\", \"\\#{\".$freeze());\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              \n              $writer = [self.herebody_s];\n              $send(current_literal, 'saved_herebody_s=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              self.herebody_s = nil;};\n            current_literal.$start_interp_brace();\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 758;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((13)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DVAR\", nil, self.ts, $rb_plus(self.ts, 1));\n            p = self.ts;\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((158)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($b = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $b))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;}\n            else if ((157)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((162)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DVAR\", nil, self.ts, $rb_plus(self.ts, 1));\n            p = self.ts;\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((160)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((12)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((164)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($b = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $b))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;}\n            else if ((163)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((171)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DBEG\", \"\\#{\".$freeze());\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              \n              $writer = [self.herebody_s];\n              $send(current_literal, 'saved_herebody_s=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              self.herebody_s = nil;};\n            current_literal.$start_interp_brace();\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 758;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((15)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DVAR\", nil, self.ts, $rb_plus(self.ts, 1));\n            p = self.ts;\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((167)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($b = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $b))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;}\n            else if ((166)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((172)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            current_literal.$flush_string();\n            current_literal.$extend_content();\n            self.$emit(\"tSTRING_DVAR\", nil, self.ts, $rb_plus(self.ts, 1));\n            p = self.ts;\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((169)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$literal().$extend_space(self.ts, self.te);;}\n            else if ((170)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((14)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((174)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($b = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $b))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;}\n            else if ((173)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            string = self.$tok();\n            if ($truthy(($truthy($b = $rb_ge(self.version, 22)) ? self.cond['$active?']()['$!']() : $b))) {\n              lookahead = self.source_buffer.$slice(Opal.Range.$new(self.te,$rb_plus(self.te, 2), true))};\n            current_literal = self.$literal();\n            if ($truthy(($truthy($b = current_literal['$heredoc?']()['$!']()) ? (token = current_literal.$nest_and_try_closing(string, self.ts, self.te, lookahead)) : $b))) {\n              \n              if (token['$[]'](0)['$=='](\"tLABEL_END\")) {\n                \n                p = $rb_plus(p, 1);\n                self.$pop_literal();\n                self.cs = 751;\n                } else {\n                self.cs = self.$pop_literal()\n              };\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              current_literal.$extend_string(string, self.ts, self.te)\n            };;}\n            else if ((176)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$literal().$extend_space(self.ts, self.te);;}\n            else if ((177)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit(\"tREGEXP_OPT\", self.$tok(self.ts, $rb_minus(self.te, 1)), self.ts, $rb_minus(self.te, 1));\n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((178)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            unknown_options = self.$tok().$scan(/[^imxouesn]/);\n            if ($truthy(unknown_options['$any?']())) {\n              self.$diagnostic(\"error\", \"regexp_options\", $hash2([\"options\"], {\"options\": unknown_options.$join()}))};\n            self.$emit(\"tREGEXP_OPT\");\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((16)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            if ($truthy(self.$tok()['$=~'](/^\\$([1-9][0-9]*)$/))) {\n              self.$emit(\"tNTH_REF\", self.$tok($rb_plus(self.ts, 1)).$to_i())\n            } else if ($truthy(self.$tok()['$=~'](/^\\$([&`'+])$/))) {\n              self.$emit(\"tBACK_REF\")\n              } else {\n              self.$emit(\"tGVAR\")\n            };\n            self.cs = self.$stack_pop();\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((179)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            if ($truthy(self.$tok()['$=~'](/^\\$([1-9][0-9]*)$/))) {\n              self.$emit(\"tNTH_REF\", self.$tok($rb_plus(self.ts, 1)).$to_i())\n            } else if ($truthy(self.$tok()['$=~'](/^\\$([&`'+])$/))) {\n              self.$emit(\"tBACK_REF\")\n              } else {\n              self.$emit(\"tGVAR\")\n            };\n            self.cs = self.$stack_pop();\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((181)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            if ($truthy(self.$tok()['$=~'](/^@@[0-9]/))) {\n              self.$diagnostic(\"error\", \"cvar_name\", $hash2([\"name\"], {\"name\": self.$tok()}))};\n            self.$emit(\"tCVAR\");\n            self.cs = self.$stack_pop();\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((180)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            if ($truthy(self.$tok()['$=~'](/^@[0-9]/))) {\n              self.$diagnostic(\"error\", \"ivar_name\", $hash2([\"name\"], {\"name\": self.$tok()}))};\n            self.$emit(\"tIVAR\");\n            self.cs = self.$stack_pop();\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((202)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS_BEGIN'));\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((188)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit(\"tIDENTIFIER\");\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((18)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            self.cs = 766;\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((185)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((197)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((20)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            if ($truthy(self['$version?'](23))) {\n              \n              $b = [self.$tok()['$[]']($range(0, -2, false)), self.$tok()['$[]'](-1).$chr()], (type = $b[0]), (delimiter = $b[1]), $b;\n              \n              self.cs = self.$push_literal(type, delimiter, self.ts);\n              _goto_level = _again;\n              continue;;;\n              } else {\n              \n              p = $rb_minus(self.ts, 1);\n              \n              self.cs = 766;\n              _goto_level = _again;\n              continue;;;\n            };;}\n            else if ((184)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((183)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((201)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS_BEGIN'));\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((198)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tCONSTANT\");\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((200)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tIDENTIFIER\");\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((195)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            self.cs = 766;\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((191)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((196)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((189)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);}\n            else if ((194)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((19)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((17)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((187)['$===']($case)) {\n            $case = self.act;\n            if ((39)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS_BEGIN'));\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((40)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"tCONSTANT\");\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((41)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"tIDENTIFIER\");\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;};}\n            else if ((22)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit(\"tLABEL\", self.$tok(self.ts, $rb_minus(self.te, 2)), self.ts, $rb_minus(self.te, 1));\n            p = $rb_minus(p, 1);\n            self.cs = 751;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((204)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((203)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((206)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);}\n            else if ((205)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((21)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((212)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 468;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((211)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((210)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((222)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tCONSTANT\");\n            self.cs = self.$arg_or_cmdarg();\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((213)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tIDENTIFIER\");\n            self.cs = self.$arg_or_cmdarg();\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((218)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 468;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((216)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);}\n            else if ((221)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((245)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((228)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            if (self.$tok(tm, $rb_plus(tm, 1))['$=='](\"/\".$freeze())) {\n              self.$diagnostic(\"warning\", \"ambiguous_literal\", nil, self.$range(tm, $rb_plus(tm, 1)))};\n            p = $rb_minus(tm, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((234)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((24)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((236)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(tm, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((39)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((223)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((224)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((235)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((231)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$diagnostic(\"warning\", \"ambiguous_prefix\", $hash2([\"prefix\"], {\"prefix\": self.$tok(tm, self.te)}), self.$range(tm, self.te));\n            p = $rb_minus(tm, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((233)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((227)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((226)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);}\n            else if ((244)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((25)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;}\n            else if ((41)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((23)['$===']($case)) {\n            $case = self.act;\n            if ((67)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if (self.$tok(tm, $rb_plus(tm, 1))['$=='](\"/\".$freeze())) {\n              self.$diagnostic(\"warning\", \"ambiguous_literal\", nil, self.$range(tm, $rb_plus(tm, 1)))};\n            p = $rb_minus(tm, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;}\n            else if ((68)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$diagnostic(\"warning\", \"ambiguous_prefix\", $hash2([\"prefix\"], {\"prefix\": self.$tok(tm, self.te)}), self.$range(tm, self.te));\n            p = $rb_minus(tm, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;}\n            else if ((73)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;}\n            else {\n            \n            p = $rb_minus(self.te, 1);;};}\n            else if ((43)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 468;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((249)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((250)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 468;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((44)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 468;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((42)['$===']($case)) {\n            $case = self.act;\n            if ((80)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if ($truthy(self.cond['$active?']())) {\n              self.$emit(\"kDO_COND\", \"do\".$freeze(), $rb_minus(self.te, 2), self.te)\n              } else {\n              self.$emit(\"kDO\", \"do\".$freeze(), $rb_minus(self.te, 2), self.te)\n            };\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((81)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 468;\n            _goto_level = _again;\n            continue;;;};}\n            else if ((260)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit_do(true);\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((253)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((254)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((255)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);}\n            else if ((258)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((264)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((263)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((272)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((266)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);}\n            else if ((270)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((265)['$===']($case)) {\n            $case = self.act;\n            if ((88)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((89)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;};}\n            else if ((300)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            if ($truthy(self.$tok()['$start_with?'](\"-\".$freeze()))) {\n              \n              self.$emit(\"tUMINUS_NUM\", \"-\".$freeze(), self.ts, $rb_plus(self.ts, 1));\n              self.cs = 766;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;};;}\n            else if ((301)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            type = (delimiter = self.$tok()['$[]'](0).$chr());\n            p = $rb_minus(p, 1);\n            \n            self.cs = self.$push_literal(type, delimiter, self.ts);\n            _goto_level = _again;\n            continue;;;;}\n            else if ((295)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            $b = [self.source_buffer.$slice(self.ts).$chr(), self.$tok()['$[]'](-1).$chr()], (type = $b[0]), (delimiter = $b[1]), $b;\n            \n            self.cs = self.$push_literal(type, delimiter, self.ts);\n            _goto_level = _again;\n            continue;;;;}\n            else if ((51)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            $b = [self.$tok()['$[]']($range(0, -2, false)), self.$tok()['$[]'](-1).$chr()], (type = $b[0]), (delimiter = $b[1]), $b;\n            \n            self.cs = self.$push_literal(type, delimiter, self.ts);\n            _goto_level = _again;\n            continue;;;;}\n            else if ((302)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            $b = [self.$tok(), self.$tok()['$[]'](-1).$chr()], (type = $b[0]), (delimiter = $b[1]), $b;\n            \n            self.cs = self.$push_literal(type, delimiter, self.ts);\n            _goto_level = _again;\n            continue;;;;}\n            else if ((54)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit(\"tSYMBOL\", self.$tok($rb_plus(self.ts, 1)), self.ts);\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((316)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            escape = $hash2([\" \", \"\\r\", \"\\n\", \"\\t\", \"\\v\", \"\\f\"], {\" \": \"\\\\s\", \"\\r\": \"\\\\r\", \"\\n\": \"\\\\n\", \"\\t\": \"\\\\t\", \"\\v\": \"\\\\v\", \"\\f\": \"\\\\f\"})['$[]'](self.source_buffer.$slice($rb_plus(self.ts, 1)));\n            self.$diagnostic(\"warning\", \"invalid_escape_use\", $hash2([\"escape\"], {\"escape\": escape}), self.$range());\n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((315)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$diagnostic(\"fatal\", \"incomplete_escape\", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));;}\n            else if ((303)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION_BEGIN'));\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((48)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            if ($truthy(self['$version?'](18))) {\n              \n              ident = self.$tok(self.ts, $rb_minus(self.te, 2));\n              self.$emit((function() {if ($truthy(self.source_buffer.$slice(self.ts)['$=~'](/[A-Z]/))) {\n                return \"tCONSTANT\"\n                } else {\n                return \"tIDENTIFIER\"\n              }; return nil; })(), ident, self.ts, $rb_minus(self.te, 2));\n              p = $rb_minus(p, 1);\n              if ($truthy(($truthy($b = self.static_env['$nil?']()['$!']()) ? self.static_env['$declared?'](ident) : $b))) {\n                self.cs = 766\n                } else {\n                self.cs = self.$arg_or_cmdarg()\n              };\n              } else {\n              \n              self.$emit(\"tLABEL\", self.$tok(self.ts, $rb_minus(self.te, 2)), self.ts, $rb_minus(self.te, 1));\n              self.cs = 751;\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((289)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 165;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((52)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((275)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((299)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tSTAR\", \"*\".$freeze());\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((296)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            $b = [self.$tok()['$[]']($range(0, -2, false)), self.$tok()['$[]'](-1).$chr()], (type = $b[0]), (delimiter = $b[1]), $b;\n            \n            self.cs = self.$push_literal(type, delimiter, self.ts);\n            _goto_level = _again;\n            continue;;;;}\n            else if ((294)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));;}\n            else if ((304)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tSYMBOL\", self.$tok($rb_plus(self.ts, 1)), self.ts);\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((314)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$diagnostic(\"fatal\", \"incomplete_escape\", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));;}\n            else if ((320)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((297)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION_BEGIN'));\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((342)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tIDENTIFIER\");\n            if ($truthy(($truthy($b = self.static_env['$nil?']()['$!']()) ? self.static_env['$declared?'](self.$tok()) : $b))) {\n              \n              self.cs = 440;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              \n              self.cs = self.$arg_or_cmdarg();\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };;}\n            else if ((286)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);}\n            else if ((288)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 165;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((291)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((50)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));;}\n            else if ((57)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            value = ($truthy($b = self.escape) ? $b : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($b = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((49)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;}\n            else if ((53)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((47)['$===']($case)) {\n            $case = self.act;\n            if ((111)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION_BEGIN'));\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((112)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"kRESCUE\", \"rescue\".$freeze(), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            self.cs = 513;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((113)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS_BEGIN'));\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((115)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;}\n            else if ((116)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"tIDENTIFIER\");\n            if ($truthy(($truthy($c = self.static_env['$nil?']()['$!']()) ? self.static_env['$declared?'](self.$tok()) : $c))) {\n              \n              self.cs = 440;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              \n              self.cs = self.$arg_or_cmdarg();\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };}\n            else if ((119)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;};}\n            else if ((350)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((351)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((352)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);}\n            else if ((356)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((60)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((360)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            \n            self.cs = self.$push_literal(self.$tok(), self.$tok(), self.ts);\n            _goto_level = _again;\n            continue;;;;}\n            else if ((359)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((358)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((362)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);}\n            else if ((361)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((59)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 537;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((392)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit(\"tLAMBDA\", \"->\".$freeze(), self.ts, $rb_plus(self.ts, 2));\n            self.lambda_stack.$push(self.paren_nest);\n            self.cs = 440;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((74)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit(\"kCLASS\", \"class\".$freeze(), self.ts, $rb_plus(self.ts, 5));\n            self.$emit(\"tLSHFT\", \"<<\".$freeze(), $rb_minus(self.te, 2), self.te);\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((370)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            $c = [self.$tok(), self.$tok()['$[]'](-1).$chr()], (type = $c[0]), (delimiter = $c[1]), $c;\n            \n            self.cs = self.$push_literal(type, delimiter, self.ts, nil, false, false, true);\n            _goto_level = _again;\n            continue;;;;}\n            else if ((62)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((389)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 447;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((383)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((376)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cond.$lexpop();\n            self.cmdarg.$lexpop();\n            if ($truthy(Opal.const_get_relative($nesting, 'RBRACE_OR_RBRACK')['$include?'](self.$tok()))) {\n              self.cs = 505};\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((388)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit(\"tOP_ASGN\", self.$tok(self.ts, $rb_minus(self.te, 1)));\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((374)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit(\"tEH\", \"?\".$freeze());\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((371)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((373)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit(\"tSEMI\", \";\".$freeze());\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((438)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$diagnostic(\"error\", \"bare_backslash\", nil, self.$range(self.ts, $rb_plus(self.ts, 1)));\n            p = $rb_minus(p, 1);;}\n            else if ((369)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$diagnostic(\"fatal\", \"unexpected\", $hash2([\"character\"], {\"character\": self.$tok().$inspect()['$[]']($range(1, -2, false))}));;}\n            else if ((368)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((448)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            self.cs = 327;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((446)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"kCLASS\", \"class\".$freeze(), self.ts, $rb_plus(self.ts, 5));\n            self.$emit(\"tLSHFT\", \"<<\".$freeze(), $rb_minus(self.te, 2), self.te);\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((445)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((395)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$diagnostic(\"error\", \"no_dot_digit_literal\");;}\n            else if ((435)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tCONSTANT\");\n            self.cs = self.$arg_or_cmdarg();\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((387)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            \n            $writer = [self.top, self.cs];\n            $send(self.stack, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.top = $rb_plus(self.top, 1);\n            self.cs = 322;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((393)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 447;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((440)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tIDENTIFIER\");\n            if ($truthy(($truthy($c = self.static_env['$nil?']()['$!']()) ? self.static_env['$declared?'](self.$tok()) : $c))) {\n              \n              self.cs = 440;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              \n              self.cs = self.$arg_or_cmdarg();\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };;}\n            else if ((382)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((394)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((380)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);}\n            else if ((386)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$diagnostic(\"fatal\", \"unexpected\", $hash2([\"character\"], {\"character\": self.$tok().$inspect()['$[]']($range(1, -2, false))}));;}\n            else if ((63)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            self.$diagnostic(\"error\", \"no_dot_digit_literal\");;}\n            else if ((61)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            self.$diagnostic(\"fatal\", \"unexpected\", $hash2([\"character\"], {\"character\": self.$tok().$inspect()['$[]']($range(1, -2, false))}));;}\n            else if ((64)['$===']($case)) {\n            $case = self.act;\n            if ((132)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if (self.lambda_stack.$last()['$=='](self.paren_nest)) {\n              \n              self.lambda_stack.$pop();\n              if (self.$tok()['$=='](\"{\".$freeze())) {\n                self.$emit(\"tLAMBEG\", \"{\".$freeze())\n                } else {\n                self.$emit(\"kDO_LAMBDA\", \"do\".$freeze())\n              };\n            } else if (self.$tok()['$=='](\"{\".$freeze())) {\n              self.$emit(\"tLCURLY\", \"{\".$freeze())\n              } else {\n              self.$emit_do()\n            };\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((133)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            self.cs = 327;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((134)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"kCLASS\", \"class\".$freeze(), self.ts, $rb_plus(self.ts, 5));\n            self.$emit(\"tLSHFT\", \"<<\".$freeze(), $rb_minus(self.te, 2), self.te);\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((135)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((136)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((137)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            self.cs = 513;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((138)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            if ($truthy(($truthy($c = self['$version?'](18)) ? self.$tok()['$=='](\"not\".$freeze()) : $c))) {\n              \n              self.cs = 537;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              \n              self.cs = 468;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };}\n            else if ((139)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if ($truthy(self['$version?'](18))) {\n              \n              self.$emit(\"tIDENTIFIER\");\n              if ($truthy(($truthy($c = self.static_env['$nil?']()['$!']()) ? self.static_env['$declared?'](self.$tok()) : $c))) {\n                } else {\n                self.cs = self.$arg_or_cmdarg()\n              };\n              } else {\n              self.$emit(\"k__ENCODING__\", \"__ENCODING__\".$freeze())\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((140)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((141)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($c = ($truthy($d = digits['$empty?']()) ? self.num_base['$=='](8) : $d)) ? self['$version?'](18) : $c))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($c = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((143)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": self.$tok($rb_minus(self.te, 1), self.te)}), self.$range($rb_minus(self.te, 1), self.te))\n              } else {\n              \n              self.$emit(\"tINTEGER\", self.$tok(self.ts, $rb_minus(self.te, 1)).$to_i(), self.ts, $rb_minus(self.te, 1));\n              p = $rb_minus(p, 1);\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };}\n            else if ((144)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": self.$tok($rb_minus(self.te, 1), self.te)}), self.$range($rb_minus(self.te, 1), self.te))\n              } else {\n              \n              self.$emit(\"tFLOAT\", self.$tok(self.ts, $rb_minus(self.te, 1)).$to_f(), self.ts, $rb_minus(self.te, 1));\n              p = $rb_minus(p, 1);\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };}\n            else if ((145)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            digits = self.$tok(self.ts, self.num_suffix_s);\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tFLOAT\", self.$Float(digits), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits)\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((147)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"tCONSTANT\");\n            self.cs = self.$arg_or_cmdarg();\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((151)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"tIDENTIFIER\");\n            if ($truthy(($truthy($c = self.static_env['$nil?']()['$!']()) ? self.static_env['$declared?'](self.$tok()) : $c))) {\n              \n              self.cs = 440;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              \n              self.cs = self.$arg_or_cmdarg();\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };}\n            else if ((152)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if (tm['$=='](self.te)) {\n              self.$emit(\"tFID\")\n              } else {\n              \n              self.$emit(\"tIDENTIFIER\", self.$tok(self.ts, tm), self.ts, tm);\n              p = $rb_minus(tm, 1);\n            };\n            self.cs = 468;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;};}\n            else if ((78)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(tm, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((453)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.$emit(\"tNL\", nil, self.newline_s, $rb_plus(self.newline_s, 1));\n            p = $rb_minus(p, 1);\n            self.cs = 165;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((454)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tNL\", nil, self.newline_s, $rb_plus(self.newline_s, 1));\n            p = $rb_minus(p, 1);\n            self.cs = 165;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((75)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            self.$emit(\"tNL\", nil, self.newline_s, $rb_plus(self.newline_s, 1));\n            p = $rb_minus(p, 1);\n            self.cs = 165;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((457)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_comment(self.eq_begin_s, self.te);\n            \n            self.cs = 165;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((456)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$diagnostic(\"fatal\", \"embedded_document\", nil, self.$range(self.eq_begin_s, $rb_plus(self.eq_begin_s, \"=begin\".$length())));;}\n            else if ((89)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            self.eq_begin_s = self.ts;\n            \n            self.cs = 942;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((2)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(pe, 3);;}\n            else if ((81)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 758;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((82)['$===']($case)) {\n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;}\n            else if ((83)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);}\n            else if ((88)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.eq_begin_s = self.ts;\n            \n            self.cs = 942;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((87)['$===']($case)) {\n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 758;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((1)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 758;\n            _goto_level = _again;\n            continue;;;;}\n            else if ((73)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;}\n            else if ((93)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($c = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $c))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;;}\n            else if ((121)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($c = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $c))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;;}\n            else if ((147)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($c = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $c))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;;}\n            else if ((153)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($c = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $c))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;;}\n            else if ((159)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($c = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $c))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;;}\n            else if ((165)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($c = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $c))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;;}\n            else if ((168)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($c = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $c))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;;}\n            else if ((175)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($c = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $c))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;;}\n            else if ((246)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((237)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(tm, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((229)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((317)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            escape = $hash2([\" \", \"\\r\", \"\\n\", \"\\t\", \"\\v\", \"\\f\"], {\" \": \"\\\\s\", \"\\r\": \"\\\\r\", \"\\n\": \"\\\\n\", \"\\t\": \"\\\\t\", \"\\v\": \"\\\\v\", \"\\f\": \"\\\\f\"})['$[]'](self.source_buffer.$slice($rb_plus(self.ts, 1)));\n            self.$diagnostic(\"warning\", \"invalid_escape_use\", $hash2([\"escape\"], {\"escape\": escape}), self.$range());\n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((290)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 165;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((458)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            self.$emit_comment(self.eq_begin_s, self.te);\n            \n            self.cs = 165;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((455)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);;}\n            else if ((90)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            self.eq_begin_s = self.ts;\n            \n            self.cs = 942;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((3)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(pe, 3);;;}\n            else if ((412)['$===']($case)) {\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_12 = function(chars){var self = TMP_12.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tRATIONAL\", self.$Rational(chars))}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($c = ($truthy($d = digits['$empty?']()) ? self.num_base['$=='](8) : $d)) ? self['$version?'](18) : $c))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($c = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((411)['$===']($case)) {\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_13 = function(chars){var self = TMP_13.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tIMAGINARY\", self.$Complex(0, chars))}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($c = ($truthy($d = digits['$empty?']()) ? self.num_base['$=='](8) : $d)) ? self['$version?'](18) : $c))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($c = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((413)['$===']($case)) {\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_14 = function(chars){var self = TMP_14.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tIMAGINARY\", self.$Complex(0, self.$Rational(chars)))}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($c = ($truthy($d = digits['$empty?']()) ? self.num_base['$=='](8) : $d)) ? self['$version?'](18) : $c))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($c = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((406)['$===']($case)) {\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_15 = function(chars){var self = TMP_15.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tIMAGINARY\", self.$Complex(0, self.$Float(chars)))}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.ts, self.num_suffix_s);\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tFLOAT\", self.$Float(digits), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits)\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((407)['$===']($case)) {\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_16 = function(chars){var self = TMP_16.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tRATIONAL\", self.$Rational(chars))}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.ts, self.num_suffix_s);\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tFLOAT\", self.$Float(digits), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits)\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((408)['$===']($case)) {\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_17 = function(chars){var self = TMP_17.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tIMAGINARY\", self.$Complex(0, self.$Rational(chars)))}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.ts, self.num_suffix_s);\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tFLOAT\", self.$Float(digits), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits)\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((116)['$===']($case)) {\n            \n            self.escape = \"\";\n            codepoints = self.$tok($rb_plus(self.escape_s, 2), $rb_minus(p, 1));\n            codepoint_s = $rb_plus(self.escape_s, 2);\n            (function(){var $brk = Opal.new_brk(); try {return $send(codepoints.$split(/[ \\t]/), 'each', [], (TMP_18 = function(codepoint_str){var self = TMP_18.$$s || this, codepoint = nil;\n              if (self.escape == null) self.escape = nil;\nif (codepoint_str == null) codepoint_str = nil;\n            \n              codepoint = codepoint_str.$to_i(16);\n              if ($truthy($rb_ge(codepoint, 1114112))) {\n                \n                self.$diagnostic(\"error\", \"unicode_point_too_large\", nil, self.$range(codepoint_s, $rb_plus(codepoint_s, codepoint_str.$length())));\n                \n                Opal.brk(nil, $brk);};\n              self.escape = $rb_plus(self.escape, codepoint.$chr(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8')));\n              return (codepoint_s = $rb_plus(codepoint_s, $rb_plus(codepoint_str.$length(), 1)));}, TMP_18.$$s = self, TMP_18.$$brk = $brk, TMP_18.$$arity = 1, TMP_18))\n            } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($c = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $c))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($c = self.escape) ? $c : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((142)['$===']($case)) {\n            \n            self.escape = \"\";\n            codepoints = self.$tok($rb_plus(self.escape_s, 2), $rb_minus(p, 1));\n            codepoint_s = $rb_plus(self.escape_s, 2);\n            (function(){var $brk = Opal.new_brk(); try {return $send(codepoints.$split(/[ \\t]/), 'each', [], (TMP_19 = function(codepoint_str){var self = TMP_19.$$s || this, codepoint = nil;\n              if (self.escape == null) self.escape = nil;\nif (codepoint_str == null) codepoint_str = nil;\n            \n              codepoint = codepoint_str.$to_i(16);\n              if ($truthy($rb_ge(codepoint, 1114112))) {\n                \n                self.$diagnostic(\"error\", \"unicode_point_too_large\", nil, self.$range(codepoint_s, $rb_plus(codepoint_s, codepoint_str.$length())));\n                \n                Opal.brk(nil, $brk);};\n              self.escape = $rb_plus(self.escape, codepoint.$chr(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8')));\n              return (codepoint_s = $rb_plus(codepoint_s, $rb_plus(codepoint_str.$length(), 1)));}, TMP_19.$$s = self, TMP_19.$$brk = $brk, TMP_19.$$arity = 1, TMP_19))\n            } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($c = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $c))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($c = self.escape) ? $c : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((338)['$===']($case)) {\n            \n            self.escape = \"\";\n            codepoints = self.$tok($rb_plus(self.escape_s, 2), $rb_minus(p, 1));\n            codepoint_s = $rb_plus(self.escape_s, 2);\n            (function(){var $brk = Opal.new_brk(); try {return $send(codepoints.$split(/[ \\t]/), 'each', [], (TMP_20 = function(codepoint_str){var self = TMP_20.$$s || this, codepoint = nil;\n              if (self.escape == null) self.escape = nil;\nif (codepoint_str == null) codepoint_str = nil;\n            \n              codepoint = codepoint_str.$to_i(16);\n              if ($truthy($rb_ge(codepoint, 1114112))) {\n                \n                self.$diagnostic(\"error\", \"unicode_point_too_large\", nil, self.$range(codepoint_s, $rb_plus(codepoint_s, codepoint_str.$length())));\n                \n                Opal.brk(nil, $brk);};\n              self.escape = $rb_plus(self.escape, codepoint.$chr(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8')));\n              return (codepoint_s = $rb_plus(codepoint_s, $rb_plus(codepoint_str.$length(), 1)));}, TMP_20.$$s = self, TMP_20.$$brk = $brk, TMP_20.$$arity = 1, TMP_20))\n            } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($c = self.escape) ? $c : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($c = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((100)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($d = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $d))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($d = self.escape) ? $d : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((126)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($d = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $d))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($d = self.escape) ? $d : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((322)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($d = self.escape) ? $d : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($d = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((103)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_escape\");;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($e = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $e))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($e = self.escape) ? $e : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((129)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_escape\");;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($e = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $e))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($e = self.escape) ? $e : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((325)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_escape\");;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($e = self.escape) ? $e : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($e = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((105)['$===']($case)) {\n            \n            self.escape = \"\\u007F\";;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($f = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $f))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($f = self.escape) ? $f : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((131)['$===']($case)) {\n            \n            self.escape = \"\\u007F\";;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($f = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $f))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($f = self.escape) ? $f : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((327)['$===']($case)) {\n            \n            self.escape = \"\\u007F\";;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($f = self.escape) ? $f : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($f = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((102)['$===']($case)) {\n            \n            self.escape = self.$encode_escape(self.$tok(self.escape_s, p).$to_i(8)['$%'](256));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($g = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $g))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($g = self.escape) ? $g : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((128)['$===']($case)) {\n            \n            self.escape = self.$encode_escape(self.$tok(self.escape_s, p).$to_i(8)['$%'](256));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($g = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $g))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($g = self.escape) ? $g : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((324)['$===']($case)) {\n            \n            self.escape = self.$encode_escape(self.$tok(self.escape_s, p).$to_i(8)['$%'](256));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($g = self.escape) ? $g : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($g = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((118)['$===']($case)) {\n            \n            self.escape = self.$encode_escape(self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($h = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $h))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($h = self.escape) ? $h : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((144)['$===']($case)) {\n            \n            self.escape = self.$encode_escape(self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($h = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $h))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($h = self.escape) ? $h : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((340)['$===']($case)) {\n            \n            self.escape = self.$encode_escape(self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($h = self.escape) ? $h : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($h = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((113)['$===']($case)) {\n            \n            self.escape = self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16).$chr(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8'));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($i = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $i))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($i = self.escape) ? $i : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((139)['$===']($case)) {\n            \n            self.escape = self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16).$chr(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8'));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($i = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $i))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($i = self.escape) ? $i : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((335)['$===']($case)) {\n            \n            self.escape = self.$tok($rb_plus(self.escape_s, 1), p).$to_i(16).$chr(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8'));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($i = self.escape) ? $i : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($i = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((117)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_hex_escape\", nil, self.$range($rb_minus(self.escape_s, 1), $rb_plus(p, 2)));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($j = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $j))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($j = self.escape) ? $j : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((143)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_hex_escape\", nil, self.$range($rb_minus(self.escape_s, 1), $rb_plus(p, 2)));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($j = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $j))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($j = self.escape) ? $j : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((339)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_hex_escape\", nil, self.$range($rb_minus(self.escape_s, 1), $rb_plus(p, 2)));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($j = self.escape) ? $j : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($j = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((112)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_unicode_escape\", nil, self.$range($rb_minus(self.escape_s, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($k = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $k))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($k = self.escape) ? $k : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((138)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_unicode_escape\", nil, self.$range($rb_minus(self.escape_s, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($k = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $k))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($k = self.escape) ? $k : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((334)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_unicode_escape\", nil, self.$range($rb_minus(self.escape_s, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($k = self.escape) ? $k : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($k = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((115)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"unterminated_unicode\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($l = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $l))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($l = self.escape) ? $l : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((141)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"unterminated_unicode\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($l = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $l))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($l = self.escape) ? $l : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((337)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"unterminated_unicode\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($l = self.escape) ? $l : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($l = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((101)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"escape_eof\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($m = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $m))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($m = self.escape) ? $m : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((127)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"escape_eof\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($m = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $m))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($m = self.escape) ? $m : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((323)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"escape_eof\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($m = self.escape) ? $m : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($m = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((150)['$===']($case)) {\n            \n            self.escape_s = p;\n            self.escape = nil;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($n = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $n))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($n = self.escape) ? $n : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((155)['$===']($case)) {\n            \n            self.escape_s = p;\n            self.escape = nil;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($n = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $n))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($n = self.escape) ? $n : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((66)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.newline_s = p;;}\n            else if ((30)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            tm = p;;}\n            else if ((32)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            tm = p;;}\n            else if ((34)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            tm = p;;}\n            else if ((190)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((209)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((217)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((33)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((248)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((240)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((259)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((271)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((267)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(p, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((287)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((357)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((353)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            if ($truthy(self.in_kwarg)) {\n              \n              p = $rb_minus(p, 1);\n              \n              self.cs = 766;\n              _goto_level = _again;\n              continue;;;\n              } else {\n              \n              self.cs = 165;\n              _goto_level = _again;\n              continue;;\n            };;;}\n            else if ((366)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((363)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            \n            self.cs = 165;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((439)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((381)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            \n            self.cs = 939;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((84)['$===']($case)) {\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((239)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);\n            current_literal = self.$literal();\n            if ($truthy(current_literal)) {\n              current_literal.$start_interp_brace()};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            if (self.lambda_stack.$last()['$=='](self.paren_nest)) {\n              \n              p = $rb_minus(self.ts, 1);\n              \n              self.cs = 766;\n              _goto_level = _again;\n              continue;;;\n              } else {\n              \n              self.$emit(\"tLCURLY\", \"{\".$freeze(), $rb_minus(self.te, 1), self.te);\n              self.cs = 758;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };;;}\n            else if ((261)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);\n            current_literal = self.$literal();\n            if ($truthy(current_literal)) {\n              current_literal.$start_interp_brace()};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            if (self.lambda_stack.$last()['$=='](self.paren_nest)) {\n              \n              self.lambda_stack.$pop();\n              self.$emit(\"tLAMBEG\", \"{\".$freeze());\n              } else {\n              self.$emit(\"tLBRACE_ARG\", \"{\".$freeze())\n            };\n            self.cs = 758;;;}\n            else if ((349)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);\n            current_literal = self.$literal();\n            if ($truthy(current_literal)) {\n              current_literal.$start_interp_brace()};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            if (self.lambda_stack.$last()['$=='](self.paren_nest)) {\n              \n              self.lambda_stack.$pop();\n              self.$emit(\"tLAMBEG\", \"{\".$freeze());\n              } else {\n              self.$emit(\"tLBRACE\", \"{\".$freeze())\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((451)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);\n            current_literal = self.$literal();\n            if ($truthy(current_literal)) {\n              current_literal.$start_interp_brace()};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            if (self.lambda_stack.$last()['$=='](self.paren_nest)) {\n              \n              self.lambda_stack.$pop();\n              if (self.$tok()['$=='](\"{\".$freeze())) {\n                self.$emit(\"tLAMBEG\", \"{\".$freeze())\n                } else {\n                self.$emit(\"kDO_LAMBDA\", \"do\".$freeze())\n              };\n            } else if (self.$tok()['$=='](\"{\".$freeze())) {\n              self.$emit(\"tLCURLY\", \"{\".$freeze())\n              } else {\n              self.$emit_do()\n            };\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((452)['$===']($case)) {\n            \n            current_literal = self.$literal();\n            if ($truthy(current_literal)) {\n              if ($truthy(current_literal.$end_interp_brace_and_try_closing())) {\n                \n                if ($truthy(self['$version?'](18, 19))) {\n                  self.$emit(\"tRCURLY\", \"}\".$freeze(), $rb_minus(p, 1), p)\n                  } else {\n                  self.$emit(\"tSTRING_DEND\", \"}\".$freeze(), $rb_minus(p, 1), p)\n                };\n                if ($truthy(current_literal.$saved_herebody_s())) {\n                  self.herebody_s = current_literal.$saved_herebody_s()};\n                p = $rb_minus(p, 1);\n                self.cs = self.$stack_pop();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;}};;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cond.$lexpop();\n            self.cmdarg.$lexpop();\n            if ($truthy(Opal.const_get_relative($nesting, 'RBRACE_OR_RBRACK')['$include?'](self.$tok()))) {\n              self.cs = 505};\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((68)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;}\n            else if ((71)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.newline_s = p;;}\n            else if ((193)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((208)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((220)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((242)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((257)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((269)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((293)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((355)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((365)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((385)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((86)['$===']($case)) {\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((214)['$===']($case)) {\n            \n            tm = p;;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tFID\", self.$tok(self.ts, tm), self.ts, tm);\n            self.cs = self.$arg_or_cmdarg();\n            p = $rb_minus(tm, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((305)['$===']($case)) {\n            \n            tm = p;;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tSYMBOL\", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((278)['$===']($case)) {\n            \n            tm = p;;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((378)['$===']($case)) {\n            \n            tm = p;;\n            \n            $case = self.act;\n            if ((132)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if (self.lambda_stack.$last()['$=='](self.paren_nest)) {\n              \n              self.lambda_stack.$pop();\n              if (self.$tok()['$=='](\"{\".$freeze())) {\n                self.$emit(\"tLAMBEG\", \"{\".$freeze())\n                } else {\n                self.$emit(\"kDO_LAMBDA\", \"do\".$freeze())\n              };\n            } else if (self.$tok()['$=='](\"{\".$freeze())) {\n              self.$emit(\"tLCURLY\", \"{\".$freeze())\n              } else {\n              self.$emit_do()\n            };\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((133)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            self.cs = 327;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((134)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"kCLASS\", \"class\".$freeze(), self.ts, $rb_plus(self.ts, 5));\n            self.$emit(\"tLSHFT\", \"<<\".$freeze(), $rb_minus(self.te, 2), self.te);\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((135)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((136)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((137)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            self.cs = 513;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((138)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            if ($truthy(($truthy($n = self['$version?'](18)) ? self.$tok()['$=='](\"not\".$freeze()) : $n))) {\n              \n              self.cs = 537;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              \n              self.cs = 468;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };}\n            else if ((139)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if ($truthy(self['$version?'](18))) {\n              \n              self.$emit(\"tIDENTIFIER\");\n              if ($truthy(($truthy($n = self.static_env['$nil?']()['$!']()) ? self.static_env['$declared?'](self.$tok()) : $n))) {\n                } else {\n                self.cs = self.$arg_or_cmdarg()\n              };\n              } else {\n              self.$emit(\"k__ENCODING__\", \"__ENCODING__\".$freeze())\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((140)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS'));\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((141)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($n = ($truthy($o = digits['$empty?']()) ? self.num_base['$=='](8) : $o)) ? self['$version?'](18) : $n))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($n = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((143)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": self.$tok($rb_minus(self.te, 1), self.te)}), self.$range($rb_minus(self.te, 1), self.te))\n              } else {\n              \n              self.$emit(\"tINTEGER\", self.$tok(self.ts, $rb_minus(self.te, 1)).$to_i(), self.ts, $rb_minus(self.te, 1));\n              p = $rb_minus(p, 1);\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };}\n            else if ((144)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": self.$tok($rb_minus(self.te, 1), self.te)}), self.$range($rb_minus(self.te, 1), self.te))\n              } else {\n              \n              self.$emit(\"tFLOAT\", self.$tok(self.ts, $rb_minus(self.te, 1)).$to_f(), self.ts, $rb_minus(self.te, 1));\n              p = $rb_minus(p, 1);\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };}\n            else if ((145)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            digits = self.$tok(self.ts, self.num_suffix_s);\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tFLOAT\", self.$Float(digits), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits)\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((147)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"tCONSTANT\");\n            self.cs = self.$arg_or_cmdarg();\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((151)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"tIDENTIFIER\");\n            if ($truthy(($truthy($n = self.static_env['$nil?']()['$!']()) ? self.static_env['$declared?'](self.$tok()) : $n))) {\n              \n              self.cs = 440;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              \n              self.cs = self.$arg_or_cmdarg();\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };}\n            else if ((152)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            if (tm['$=='](self.te)) {\n              self.$emit(\"tFID\")\n              } else {\n              \n              self.$emit(\"tIDENTIFIER\", self.$tok(self.ts, tm), self.ts, tm);\n              p = $rb_minus(tm, 1);\n            };\n            self.cs = 468;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;};;}\n            else if ((215)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tFID\", self.$tok(self.ts, tm), self.ts, tm);\n            self.cs = self.$arg_or_cmdarg();\n            p = $rb_minus(tm, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((306)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tSYMBOL\", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((280)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((379)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            if (tm['$=='](self.te)) {\n              self.$emit(\"tFID\")\n              } else {\n              \n              self.$emit(\"tIDENTIFIER\", self.$tok(self.ts, tm), self.ts, tm);\n              p = $rb_minus(tm, 1);\n            };\n            self.cs = 468;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((307)['$===']($case)) {\n            \n            tm = p;;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tSYMBOL\", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((281)['$===']($case)) {\n            \n            tm = p;;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((308)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tSYMBOL\", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((282)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((312)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tSYMBOL\", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((285)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((311)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tSYMBOL\", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((284)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            $case = self.act;\n            if ((111)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION_BEGIN'));\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((112)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"kRESCUE\", \"rescue\".$freeze(), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            self.cs = 513;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((113)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit_table(Opal.const_get_relative($nesting, 'KEYWORDS_BEGIN'));\n            self.cs = 758;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;}\n            else if ((115)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;}\n            else if ((116)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            self.$emit(\"tIDENTIFIER\");\n            if ($truthy(($truthy($n = self.static_env['$nil?']()['$!']()) ? self.static_env['$declared?'](self.$tok()) : $n))) {\n              \n              self.cs = 440;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              \n              self.cs = self.$arg_or_cmdarg();\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };}\n            else if ((119)['$===']($case)) {\n            \n            p = $rb_minus(self.te, 1);;\n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;};;}\n            else if ((309)['$===']($case)) {\n            \n            tm = $rb_minus(p, 3);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tSYMBOL\", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((283)['$===']($case)) {\n            \n            tm = $rb_minus(p, 3);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            p = $rb_minus(self.ts, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((310)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tSYMBOL\", self.$tok($rb_plus(self.ts, 1), tm), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((434)['$===']($case)) {\n            \n            tm = $rb_minus(p, 2);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tCONSTANT\", self.$tok(self.ts, tm), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((238)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tLBRACK\", \"[\".$freeze(), $rb_minus(self.te, 1), self.te);\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((341)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tLBRACK\", \"[\".$freeze());\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((437)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tLBRACK2\", \"[\".$freeze());\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((230)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);\n            self.paren_nest = $rb_plus(self.paren_nest, 1);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            if ($truthy(self['$version?'](18))) {\n              \n              self.$emit(\"tLPAREN2\", \"(\".$freeze(), $rb_minus(self.te, 1), self.te);\n              self.cs = 758;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              \n              self.$emit(\"tLPAREN_ARG\", \"(\".$freeze(), $rb_minus(self.te, 1), self.te);\n              self.cs = 537;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };;;}\n            else if ((243)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);\n            self.paren_nest = $rb_plus(self.paren_nest, 1);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tLPAREN2\", \"(\".$freeze());\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((251)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);\n            self.paren_nest = $rb_plus(self.paren_nest, 1);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tLPAREN_ARG\", \"(\".$freeze(), $rb_minus(self.te, 1), self.te);\n            if ($truthy(self['$version?'](18))) {\n              \n              self.cs = 758;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              \n              self.cs = 537;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n            };;;}\n            else if ((298)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);\n            self.paren_nest = $rb_plus(self.paren_nest, 1);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"tLPAREN\", \"(\".$freeze());\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((390)['$===']($case)) {\n            \n            self.cond.$push(false);\n            self.cmdarg.$push(false);\n            self.paren_nest = $rb_plus(self.paren_nest, 1);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cs = 537;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((391)['$===']($case)) {\n            \n            self.paren_nest = $rb_minus(self.paren_nest, 1);;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit_table(Opal.const_get_relative($nesting, 'PUNCTUATION'));\n            self.cond.$lexpop();\n            self.cmdarg.$lexpop();\n            if ($truthy(Opal.const_get_relative($nesting, 'RBRACE_OR_RBRACK')['$include?'](self.$tok()))) {\n              self.cs = 505};\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((56)['$===']($case)) {\n            \n            heredoc_e = p;;\n            \n            self.newline_s = p;;}\n            else if ((313)['$===']($case)) {\n            \n            new_herebody_s = p;;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$tok(self.ts, heredoc_e)['$=~'](/^<<(-?)(~?)([\"'`]?)(.*)\\3$/);\n            indent = ($truthy($n = (($o = $gvars['~']) === nil ? nil : $o['$[]'](1))['$empty?']()['$!']()) ? $n : (($o = $gvars['~']) === nil ? nil : $o['$[]'](2))['$empty?']()['$!']());\n            dedent_body = (($n = $gvars['~']) === nil ? nil : $n['$[]'](2))['$empty?']()['$!']();\n            type = (function() {if ($truthy((($n = $gvars['~']) === nil ? nil : $n['$[]'](3))['$empty?']())) {\n              return \"<<\\\"\".$freeze()\n              } else {\n              \n              return $rb_plus(\"<<\".$freeze(), (($n = $gvars['~']) === nil ? nil : $n['$[]'](3)));\n            }; return nil; })();\n            delimiter = (($n = $gvars['~']) === nil ? nil : $n['$[]'](4));\n            if ($truthy(($truthy($n = dedent_body) ? self['$version?'](18, 19, 20, 21, 22) : $n))) {\n              \n              self.$emit(\"tLSHFT\", \"<<\".$freeze(), self.ts, $rb_plus(self.ts, 2));\n              p = $rb_plus(self.ts, 1);\n              self.cs = 537;\n              \n              p = $rb_plus(p, 1);\n              _goto_level = _out;\n              continue;;;\n              } else {\n              \n              self.cs = self.$push_literal(type, delimiter, self.ts, heredoc_e, indent, dedent_body);\n              self.herebody_s = ($truthy($n = self.herebody_s) ? $n : new_herebody_s);\n              p = $rb_minus(self.herebody_s, 1);\n            };;;}\n            else if ((318)['$===']($case)) {\n            \n            self.escape = nil;;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($n = self.escape) ? $n : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($n = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((345)['$===']($case)) {\n            \n            tm = p;;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            self.$emit(\"kRESCUE\", \"rescue\".$freeze(), self.ts, tm);\n            p = $rb_minus(tm, 1);\n            self.cs = 513;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((425)['$===']($case)) {\n            \n            self.num_base = 16;\n            self.num_digits_s = p;;\n            \n            self.num_suffix_s = p;;}\n            else if ((419)['$===']($case)) {\n            \n            self.num_base = 10;\n            self.num_digits_s = p;;\n            \n            self.num_suffix_s = p;;}\n            else if ((422)['$===']($case)) {\n            \n            self.num_base = 8;\n            self.num_digits_s = p;;\n            \n            self.num_suffix_s = p;;}\n            else if ((416)['$===']($case)) {\n            \n            self.num_base = 2;\n            self.num_digits_s = p;;\n            \n            self.num_suffix_s = p;;}\n            else if ((431)['$===']($case)) {\n            \n            self.num_base = 10;\n            self.num_digits_s = self.ts;;\n            \n            self.num_suffix_s = p;;}\n            else if ((400)['$===']($case)) {\n            \n            self.num_base = 8;\n            self.num_digits_s = self.ts;;\n            \n            self.num_suffix_s = p;;}\n            else if ((432)['$===']($case)) {\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_21 = function(chars){var self = TMP_21.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21));;}\n            else if ((77)['$===']($case)) {\n            \n            tm = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            p = $rb_minus(tm, 1);\n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((8)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.newline_s = p;;}\n            else if ((199)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 39;;}\n            else if ((186)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 40;;}\n            else if ((182)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 41;;}\n            else if ((26)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 67;;}\n            else if ((232)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 68;;}\n            else if ((27)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 73;;}\n            else if ((225)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 74;;}\n            else if ((252)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 80;;}\n            else if ((45)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 81;;}\n            else if ((273)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 88;;}\n            else if ((262)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 89;;}\n            else if ((276)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 111;;}\n            else if ((344)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 112;;}\n            else if ((343)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 113;;}\n            else if ((58)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 115;;}\n            else if ((274)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 116;;}\n            else if ((277)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 119;;}\n            else if ((447)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 132;;}\n            else if ((442)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 133;;}\n            else if ((450)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 135;;}\n            else if ((443)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 136;;}\n            else if ((444)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 137;;}\n            else if ((449)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 138;;}\n            else if ((441)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 139;;}\n            else if ((436)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 140;;}\n            else if ((372)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 141;;}\n            else if ((402)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 144;;}\n            else if ((65)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 145;;}\n            else if ((375)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 147;;}\n            else if ((367)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 151;;}\n            else if ((377)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.act = 152;;}\n            else if ((156)['$===']($case)) {\n            \n            self.newline_s = p;;\n            \n            self.te = $rb_plus(p, 1);\n            \n            current_literal = self.$literal();\n            if (self.te['$=='](pe)) {\n              self.$diagnostic(\"fatal\", \"string_eof\", nil, self.$range(current_literal.$str_s(), $rb_plus(current_literal.$str_s(), 1)))};\n            if ($truthy(current_literal['$heredoc?']())) {\n              \n              line = self.$tok(self.herebody_s, self.ts).$gsub(/\\r+$/, \"\".$freeze());\n              if ($truthy(self['$version?'](18, 19, 20))) {\n                line = line.$gsub(/\\r.*$/, \"\".$freeze())};\n              if ($truthy(current_literal.$nest_and_try_closing(line, self.herebody_s, self.ts))) {\n                \n                self.herebody_s = self.te;\n                p = $rb_minus(current_literal.$heredoc_e(), 1);\n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;\n                } else {\n                \n                current_literal.$infer_indent_level(line);\n                self.herebody_s = self.te;\n              };\n              } else {\n              \n              if ($truthy(current_literal.$nest_and_try_closing(self.$tok(), self.ts, self.te))) {\n                \n                self.cs = self.$pop_literal();\n                \n                p = $rb_plus(p, 1);\n                _goto_level = _out;\n                continue;;;};\n              if ($truthy(self.herebody_s)) {\n                \n                p = $rb_minus(self.herebody_s, 1);\n                self.herebody_s = nil;};\n            };\n            if ($truthy(($truthy($o = current_literal['$words?']()) ? self['$eof_codepoint?'](self.source_pts['$[]'](p))['$!']() : $o))) {\n              current_literal.$extend_space(self.ts, self.te)\n              } else {\n              \n              current_literal.$extend_string(self.$tok(), self.ts, self.te);\n              current_literal.$flush_string();\n            };;;\n            \n            self.escape_s = p;\n            self.escape = nil;;}\n            else if ((106)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($o = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $o))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($o = self.escape) ? $o : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((132)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($o = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $o))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($o = self.escape) ? $o : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((328)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($o = self.escape) ? $o : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($o = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((111)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($p = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $p))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($p = self.escape) ? $p : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((137)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($p = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $p))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($p = self.escape) ? $p : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((333)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($p = self.escape) ? $p : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($p = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((110)['$===']($case)) {\n            \n            self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($q = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $q))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($q = self.escape) ? $q : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((136)['$===']($case)) {\n            \n            self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($q = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $q))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($q = self.escape) ? $q : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((332)['$===']($case)) {\n            \n            self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($q = self.escape) ? $q : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($q = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((108)['$===']($case)) {\n            \n            self.escape = \"\\u007F\";;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($r = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $r))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($r = self.escape) ? $r : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((134)['$===']($case)) {\n            \n            self.escape = \"\\u007F\";;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($r = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $r))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($r = self.escape) ? $r : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((330)['$===']($case)) {\n            \n            self.escape = \"\\u007F\";;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($r = self.escape) ? $r : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($r = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((104)['$===']($case)) {\n            \n            self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($s = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $s))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($s = self.escape) ? $s : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((130)['$===']($case)) {\n            \n            self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($s = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $s))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($s = self.escape) ? $s : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((326)['$===']($case)) {\n            \n            self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($s = self.escape) ? $s : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($s = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((114)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_unicode_escape\", nil, self.$range($rb_minus(self.escape_s, 1), p));;\n            \n            self.$diagnostic(\"fatal\", \"unterminated_unicode\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($t = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $t))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($t = self.escape) ? $t : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((140)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_unicode_escape\", nil, self.$range($rb_minus(self.escape_s, 1), p));;\n            \n            self.$diagnostic(\"fatal\", \"unterminated_unicode\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($t = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $t))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($t = self.escape) ? $t : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((336)['$===']($case)) {\n            \n            self.$diagnostic(\"fatal\", \"invalid_unicode_escape\", nil, self.$range($rb_minus(self.escape_s, 1), p));;\n            \n            self.$diagnostic(\"fatal\", \"unterminated_unicode\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($t = self.escape) ? $t : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($t = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((98)['$===']($case)) {\n            \n            self.escape_s = p;\n            self.escape = nil;;\n            \n            self.$diagnostic(\"fatal\", \"escape_eof\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($u = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $u))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($u = self.escape) ? $u : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((125)['$===']($case)) {\n            \n            self.escape_s = p;\n            self.escape = nil;;\n            \n            self.$diagnostic(\"fatal\", \"escape_eof\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($u = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $u))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($u = self.escape) ? $u : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((321)['$===']($case)) {\n            \n            self.escape_s = p;\n            self.escape = nil;;\n            \n            self.$diagnostic(\"fatal\", \"escape_eof\", nil, self.$range($rb_minus(p, 1), p));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($u = self.escape) ? $u : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($u = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((69)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.newline_s = p;;}\n            else if ((192)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((207)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((219)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((241)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            \n            self.cs = 766;\n            _goto_level = _again;\n            continue;;;;;}\n            else if ((256)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((268)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((292)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((354)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((364)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((384)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((85)['$===']($case)) {\n            \n            self.sharp_s = $rb_minus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);;}\n            else if ((427)['$===']($case)) {\n            \n            self.num_base = 10;\n            self.num_digits_s = self.ts;;\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_22 = function(chars){var self = TMP_22.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22));;}\n            else if ((397)['$===']($case)) {\n            \n            self.num_base = 8;\n            self.num_digits_s = self.ts;;\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_23 = function(chars){var self = TMP_23.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_23.$$s = self, TMP_23.$$arity = 1, TMP_23));;}\n            else if ((409)['$===']($case)) {\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_24 = function(chars){var self = TMP_24.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_24.$$s = self, TMP_24.$$arity = 1, TMP_24));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($v = ($truthy($w = digits['$empty?']()) ? self.num_base['$=='](8) : $w)) ? self['$version?'](18) : $v))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($v = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((404)['$===']($case)) {\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_25 = function(chars){var self = TMP_25.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tFLOAT\", self.$Float(chars))}, TMP_25.$$s = self, TMP_25.$$arity = 1, TMP_25));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.ts, self.num_suffix_s);\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tFLOAT\", self.$Float(digits), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits)\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((401)['$===']($case)) {\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_26 = function(chars){var self = TMP_26.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tFLOAT\", self.$Float(chars))}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.ts, self.num_suffix_s);\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tFLOAT\", self.$Float(digits), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits)\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((247)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.newline_s = p;;\n            \n            self.act = 74;;}\n            else if ((35)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.act = 73;;}\n            else if ((46)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            self.act = 81;;}\n            else if ((72)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.$emit_comment(self.sharp_s, (function() {if (p['$=='](pe)) {\n              return $rb_minus(p, 2)\n              } else {\n              return p\n            }; return nil; })());;\n            \n            self.act = 134;;}\n            else if ((37)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            tm = p;;\n            \n            self.act = 68;;}\n            else if ((347)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            tm = p;;\n            \n            self.act = 115;;}\n            else if ((346)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            tm = p;;\n            \n            self.act = 116;;}\n            else if ((428)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.num_base = 10;\n            self.num_digits_s = self.ts;;\n            \n            self.act = 141;;}\n            else if ((109)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($v = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $v))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($v = self.escape) ? $v : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((135)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($v = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $v))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($v = self.escape) ? $v : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((331)['$===']($case)) {\n            \n            codepoint = self.source_pts['$[]']($rb_minus(p, 1));\n            if ($truthy((self.escape = Opal.const_get_relative($nesting, 'ESCAPES')['$[]'](codepoint))['$nil?']())) {\n              self.escape = self.$encode_escape(self.source_buffer.$slice($rb_minus(p, 1)))};;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($v = self.escape) ? $v : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($v = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((107)['$===']($case)) {\n            \n            self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($w = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $w))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($w = self.escape) ? $w : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((133)['$===']($case)) {\n            \n            self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            current_literal = self.$literal();\n            escaped_char = self.source_buffer.$slice(self.escape_s).$chr();\n            if ($truthy(current_literal['$munge_escape?'](escaped_char))) {\n              if ($truthy(($truthy($w = current_literal['$regexp?']()) ? Opal.const_get_relative($nesting, 'REGEXP_META_CHARACTERS').$match(escaped_char) : $w))) {\n                current_literal.$extend_string(self.$tok(), self.ts, self.te)\n                } else {\n                current_literal.$extend_string(escaped_char, self.ts, self.te)\n              }\n            } else if ($truthy(current_literal['$regexp?']())) {\n              current_literal.$extend_string(self.$tok().$gsub(\"\\\\\\n\".$freeze(), \"\".$freeze()), self.ts, self.te)\n              } else {\n              current_literal.$extend_string(($truthy($w = self.escape) ? $w : self.$tok()), self.ts, self.te)\n            };;;}\n            else if ((329)['$===']($case)) {\n            \n            self.escape = self.source_buffer.$slice($rb_minus(p, 1)).$chr();;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$&'](159));;\n            \n            self.escape = self.$encode_escape(self.escape['$[]'](0).$ord()['$|'](128));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            value = ($truthy($w = self.escape) ? $w : self.$tok($rb_plus(self.ts, 1)));\n            if ($truthy(self['$version?'](18))) {\n              if ($truthy((($w = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n                self.$emit(\"tINTEGER\", value.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))['$[]'](0).$ord())\n                } else {\n                self.$emit(\"tINTEGER\", value['$[]'](0).$ord())\n              }\n              } else {\n              self.$emit(\"tCHARACTER\", value)\n            };\n            self.cs = 766;\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((423)['$===']($case)) {\n            \n            self.num_base = 16;\n            self.num_digits_s = p;;\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_27 = function(chars){var self = TMP_27.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_27.$$s = self, TMP_27.$$arity = 1, TMP_27));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($x = ($truthy($y = digits['$empty?']()) ? self.num_base['$=='](8) : $y)) ? self['$version?'](18) : $x))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($x = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((417)['$===']($case)) {\n            \n            self.num_base = 10;\n            self.num_digits_s = p;;\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_28 = function(chars){var self = TMP_28.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_28.$$s = self, TMP_28.$$arity = 1, TMP_28));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($x = ($truthy($y = digits['$empty?']()) ? self.num_base['$=='](8) : $y)) ? self['$version?'](18) : $x))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($x = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((420)['$===']($case)) {\n            \n            self.num_base = 8;\n            self.num_digits_s = p;;\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_29 = function(chars){var self = TMP_29.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_29.$$s = self, TMP_29.$$arity = 1, TMP_29));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($x = ($truthy($y = digits['$empty?']()) ? self.num_base['$=='](8) : $y)) ? self['$version?'](18) : $x))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($x = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((414)['$===']($case)) {\n            \n            self.num_base = 2;\n            self.num_digits_s = p;;\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_30 = function(chars){var self = TMP_30.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_30.$$s = self, TMP_30.$$arity = 1, TMP_30));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($x = ($truthy($y = digits['$empty?']()) ? self.num_base['$=='](8) : $y)) ? self['$version?'](18) : $x))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($x = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((426)['$===']($case)) {\n            \n            self.num_base = 10;\n            self.num_digits_s = self.ts;;\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_31 = function(chars){var self = TMP_31.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($x = ($truthy($y = digits['$empty?']()) ? self.num_base['$=='](8) : $y)) ? self['$version?'](18) : $x))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($x = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((396)['$===']($case)) {\n            \n            self.num_base = 8;\n            self.num_digits_s = self.ts;;\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_32 = function(chars){var self = TMP_32.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_32.$$s = self, TMP_32.$$arity = 1, TMP_32));;\n            \n            self.te = p;\n            p = $rb_minus(p, 1);\n            \n            digits = self.$tok(self.num_digits_s, self.num_suffix_s);\n            if ($truthy(digits['$end_with?'](\"_\".$freeze()))) {\n              self.$diagnostic(\"error\", \"trailing_in_number\", $hash2([\"character\"], {\"character\": \"_\".$freeze()}), self.$range($rb_minus(self.te, 1), self.te))\n            } else if ($truthy(($truthy($x = ($truthy($y = digits['$empty?']()) ? self.num_base['$=='](8) : $y)) ? self['$version?'](18) : $x))) {\n              digits = \"0\".$freeze()\n            } else if ($truthy(digits['$empty?']())) {\n              self.$diagnostic(\"error\", \"empty_numeric\")\n            } else if ($truthy((($x = self.num_base['$=='](8)) ? (invalid_idx = digits.$index(/[89]/)) : self.num_base['$=='](8)))) {\n              \n              invalid_s = $rb_plus(self.num_digits_s, invalid_idx);\n              self.$diagnostic(\"error\", \"invalid_octal\", nil, self.$range(invalid_s, $rb_plus(invalid_s, 1)));};\n            if ($truthy(self['$version?'](18, 19, 20))) {\n              \n              self.$emit(\"tINTEGER\", digits.$to_i(self.num_base), self.ts, self.num_suffix_s);\n              p = $rb_minus(self.num_suffix_s, 1);\n              } else {\n              self.num_xfrm.$call(digits.$to_i(self.num_base))\n            };\n            \n            p = $rb_plus(p, 1);\n            _goto_level = _out;\n            continue;;;;;}\n            else if ((31)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            if ($truthy(self.herebody_s)) {\n              \n              p = self.herebody_s;\n              self.herebody_s = nil;};;\n            \n            tm = p;;\n            \n            self.act = 68;;}\n            else if ((433)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_33 = function(chars){var self = TMP_33.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_33.$$s = self, TMP_33.$$arity = 1, TMP_33));;\n            \n            self.act = 143;;}\n            else if ((429)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.num_base = 10;\n            self.num_digits_s = self.ts;;\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_34 = function(chars){var self = TMP_34.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34));;\n            \n            self.act = 143;;}\n            else if ((399)['$===']($case)) {\n            \n            self.te = $rb_plus(p, 1);;\n            \n            self.num_base = 8;\n            self.num_digits_s = self.ts;;\n            \n            self.num_suffix_s = p;;\n            \n            self.num_xfrm = $send(self, 'lambda', [], (TMP_35 = function(chars){var self = TMP_35.$$s || this;\nif (chars == null) chars = nil;\n            return self.$emit(\"tINTEGER\", chars)}, TMP_35.$$s = self, TMP_35.$$arity = 1, TMP_35));;\n            \n            self.act = 143;;}};};\n        if ($truthy($rb_le(_goto_level, _again))) {\n          \n          $case = _lex_to_state_actions['$[]'](self.cs);\n          if ((79)['$===']($case)) {\n          self.ts = nil;};\n          if (self.cs['$=='](0)) {\n            \n            _goto_level = _out;\n            continue;;};\n          p = $rb_plus(p, 1);\n          if ($truthy(p['$!='](pe))) {\n            \n            _goto_level = _resume;\n            continue;;};};\n        if ($truthy($rb_le(_goto_level, _test_eof))) {\n          if (p['$=='](eof)) {\n            if ($truthy($rb_gt(_lex_eof_trans['$[]'](self.cs), 0))) {\n              \n              _trans = $rb_minus(_lex_eof_trans['$[]'](self.cs), 1);\n              _goto_level = _eof_trans;\n              continue;;}}};\n        if ($truthy($rb_le(_goto_level, _out))) {\n          break;};\n      };;\n      self.p = p;\n      if ($truthy(self.token_queue['$any?']())) {\n        return self.token_queue.$shift()\n      } else if (self.cs['$=='](klass.$lex_error())) {\n        return [false, [\"$error\".$freeze(), self.$range($rb_minus(p, 1), p)]]\n        } else {\n        \n        eof = self.source_pts.$size();\n        return [false, [\"$eof\".$freeze(), self.$range(eof, eof)]];\n      };\n    }, TMP_Lexer_advance_36.$$arity = 0);\n    self.$protected();\n    \n    Opal.defn(self, '$eof_codepoint?', TMP_Lexer_eof_codepoint$q_37 = function(point) {\n      var self = this;\n\n      return [4, 26, 0]['$include?'](point)\n    }, TMP_Lexer_eof_codepoint$q_37.$$arity = 1);\n    \n    Opal.defn(self, '$version?', TMP_Lexer_version$q_38 = function($a_rest) {\n      var self = this, versions;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      versions = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        versions[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return versions['$include?'](self.version)\n    }, TMP_Lexer_version$q_38.$$arity = -1);\n    \n    Opal.defn(self, '$stack_pop', TMP_Lexer_stack_pop_39 = function $$stack_pop() {\n      var self = this;\n\n      \n      self.top = $rb_minus(self.top, 1);\n      return self.stack['$[]'](self.top);\n    }, TMP_Lexer_stack_pop_39.$$arity = 0);\n    if ($truthy((($a = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n      \n      Opal.defn(self, '$encode_escape', TMP_Lexer_encode_escape_40 = function $$encode_escape(ord) {\n        var self = this;\n\n        return ord.$chr().$force_encoding(self.source_buffer.$source().$encoding())\n      }, TMP_Lexer_encode_escape_40.$$arity = 1)\n      } else {\n      \n      Opal.defn(self, '$encode_escape', TMP_Lexer_encode_escape_41 = function $$encode_escape(ord) {\n        var self = this;\n\n        return ord.$chr()\n      }, TMP_Lexer_encode_escape_41.$$arity = 1)\n    };\n    \n    Opal.defn(self, '$tok', TMP_Lexer_tok_42 = function $$tok(s, e) {\n      var self = this;\n\n      if (s == null) {\n        s = self.ts;\n      }\n      if (e == null) {\n        e = self.te;\n      }\n      return self.source_buffer.$slice(Opal.Range.$new(s,e, true))\n    }, TMP_Lexer_tok_42.$$arity = -1);\n    \n    Opal.defn(self, '$range', TMP_Lexer_range_43 = function $$range(s, e) {\n      var self = this;\n\n      if (s == null) {\n        s = self.ts;\n      }\n      if (e == null) {\n        e = self.te;\n      }\n      return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Parser'), 'Source'), 'Range').$new(self.source_buffer, s, e)\n    }, TMP_Lexer_range_43.$$arity = -1);\n    \n    Opal.defn(self, '$emit', TMP_Lexer_emit_44 = function $$emit(type, value, s, e) {\n      var self = this, token = nil;\n\n      if (value == null) {\n        value = self.$tok();\n      }\n      if (s == null) {\n        s = self.ts;\n      }\n      if (e == null) {\n        e = self.te;\n      }\n      \n      token = [type, [value, self.$range(s, e)]];\n      self.token_queue.$push(token);\n      if ($truthy(self.tokens)) {\n        self.tokens.$push(token)};\n      return token;\n    }, TMP_Lexer_emit_44.$$arity = -2);\n    \n    Opal.defn(self, '$emit_table', TMP_Lexer_emit_table_45 = function $$emit_table(table, s, e) {\n      var self = this, value = nil;\n\n      if (s == null) {\n        s = self.ts;\n      }\n      if (e == null) {\n        e = self.te;\n      }\n      \n      value = self.$tok(s, e);\n      return self.$emit(table['$[]'](value), value, s, e);\n    }, TMP_Lexer_emit_table_45.$$arity = -2);\n    \n    Opal.defn(self, '$emit_do', TMP_Lexer_emit_do_46 = function $$emit_do(do_block) {\n      var $a, self = this;\n\n      if (do_block == null) {\n        do_block = false;\n      }\n      if ($truthy(self.cond['$active?']())) {\n        return self.$emit(\"kDO_COND\", \"do\".$freeze())\n      } else if ($truthy(($truthy($a = self.cmdarg['$active?']()) ? $a : do_block))) {\n        return self.$emit(\"kDO_BLOCK\", \"do\".$freeze())\n        } else {\n        return self.$emit(\"kDO\", \"do\".$freeze())\n      }\n    }, TMP_Lexer_emit_do_46.$$arity = -1);\n    \n    Opal.defn(self, '$arg_or_cmdarg', TMP_Lexer_arg_or_cmdarg_47 = function $$arg_or_cmdarg() {\n      var self = this;\n\n      if ($truthy(self.command_state)) {\n        return self.$class().$lex_en_expr_cmdarg()\n        } else {\n        return self.$class().$lex_en_expr_arg()\n      }\n    }, TMP_Lexer_arg_or_cmdarg_47.$$arity = 0);\n    \n    Opal.defn(self, '$emit_comment', TMP_Lexer_emit_comment_48 = function $$emit_comment(s, e) {\n      var self = this;\n\n      if (s == null) {\n        s = self.ts;\n      }\n      if (e == null) {\n        e = self.te;\n      }\n      \n      if ($truthy(self.comments)) {\n        self.comments.$push(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Parser'), 'Source'), 'Comment').$new(self.$range(s, e)))};\n      if ($truthy(self.tokens)) {\n        self.tokens.$push([\"tCOMMENT\", [self.$tok(s, e), self.$range(s, e)]])};\n      return nil;\n    }, TMP_Lexer_emit_comment_48.$$arity = -1);\n    \n    Opal.defn(self, '$diagnostic', TMP_Lexer_diagnostic_49 = function $$diagnostic(type, reason, arguments$, location, highlights) {\n      var self = this;\n\n      if (arguments$ == null) {\n        arguments$ = nil;\n      }\n      if (location == null) {\n        location = self.$range();\n      }\n      if (highlights == null) {\n        highlights = [];\n      }\n      return self.diagnostics.$process(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Parser'), 'Diagnostic').$new(type, reason, arguments$, location, highlights))\n    }, TMP_Lexer_diagnostic_49.$$arity = -3);\n    \n    Opal.defn(self, '$push_literal', TMP_Lexer_push_literal_50 = function $$push_literal($a_rest) {\n      var $b, self = this, args, new_literal = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      new_literal = $send(Opal.const_get_relative($nesting, 'Literal'), 'new', [self].concat(Opal.to_a(args)));\n      self.literal_stack.$push(new_literal);\n      if ($truthy(($truthy($b = new_literal['$words?']()) ? new_literal['$backslash_delimited?']() : $b))) {\n        if ($truthy(new_literal['$interpolate?']())) {\n          return self.$class().$lex_en_interp_backslash_delimited_words()\n          } else {\n          return self.$class().$lex_en_plain_backslash_delimited_words()\n        }\n      } else if ($truthy(($truthy($b = new_literal['$words?']()) ? new_literal['$backslash_delimited?']()['$!']() : $b))) {\n        if ($truthy(new_literal['$interpolate?']())) {\n          return self.$class().$lex_en_interp_words()\n          } else {\n          return self.$class().$lex_en_plain_words()\n        }\n      } else if ($truthy(($truthy($b = new_literal['$words?']()['$!']()) ? new_literal['$backslash_delimited?']() : $b))) {\n        if ($truthy(new_literal['$interpolate?']())) {\n          return self.$class().$lex_en_interp_backslash_delimited()\n          } else {\n          return self.$class().$lex_en_plain_backslash_delimited()\n        }\n      } else if ($truthy(new_literal['$interpolate?']())) {\n        return self.$class().$lex_en_interp_string()\n        } else {\n        return self.$class().$lex_en_plain_string()\n      };\n    }, TMP_Lexer_push_literal_50.$$arity = -1);\n    \n    Opal.defn(self, '$literal', TMP_Lexer_literal_51 = function $$literal() {\n      var self = this;\n\n      return self.literal_stack.$last()\n    }, TMP_Lexer_literal_51.$$arity = 0);\n    \n    Opal.defn(self, '$pop_literal', TMP_Lexer_pop_literal_52 = function $$pop_literal() {\n      var self = this, old_literal = nil;\n\n      \n      old_literal = self.literal_stack.$pop();\n      self.dedent_level = old_literal.$dedent_level();\n      if (old_literal.$type()['$=='](\"tREGEXP_BEG\")) {\n        return self.$class().$lex_en_regexp_modifiers()\n        } else {\n        return self.$class().$lex_en_expr_end()\n      };\n    }, TMP_Lexer_pop_literal_52.$$arity = 0);\n    Opal.const_set($nesting[0], 'PUNCTUATION', $hash2([\"=\", \"&\", \"|\", \"!\", \"^\", \"+\", \"-\", \"*\", \"/\", \"%\", \"~\", \",\", \";\", \".\", \"..\", \"...\", \"[\", \"]\", \"(\", \")\", \"?\", \":\", \"&&\", \"||\", \"-@\", \"+@\", \"~@\", \"**\", \"->\", \"=~\", \"!~\", \"==\", \"!=\", \">\", \">>\", \">=\", \"<\", \"<<\", \"<=\", \"=>\", \"::\", \"===\", \"<=>\", \"[]\", \"[]=\", \"{\", \"}\", \"`\", \"!@\", \"&.\"], {\"=\": \"tEQL\", \"&\": \"tAMPER2\", \"|\": \"tPIPE\", \"!\": \"tBANG\", \"^\": \"tCARET\", \"+\": \"tPLUS\", \"-\": \"tMINUS\", \"*\": \"tSTAR2\", \"/\": \"tDIVIDE\", \"%\": \"tPERCENT\", \"~\": \"tTILDE\", \",\": \"tCOMMA\", \";\": \"tSEMI\", \".\": \"tDOT\", \"..\": \"tDOT2\", \"...\": \"tDOT3\", \"[\": \"tLBRACK2\", \"]\": \"tRBRACK\", \"(\": \"tLPAREN2\", \")\": \"tRPAREN\", \"?\": \"tEH\", \":\": \"tCOLON\", \"&&\": \"tANDOP\", \"||\": \"tOROP\", \"-@\": \"tUMINUS\", \"+@\": \"tUPLUS\", \"~@\": \"tTILDE\", \"**\": \"tPOW\", \"->\": \"tLAMBDA\", \"=~\": \"tMATCH\", \"!~\": \"tNMATCH\", \"==\": \"tEQ\", \"!=\": \"tNEQ\", \">\": \"tGT\", \">>\": \"tRSHFT\", \">=\": \"tGEQ\", \"<\": \"tLT\", \"<<\": \"tLSHFT\", \"<=\": \"tLEQ\", \"=>\": \"tASSOC\", \"::\": \"tCOLON2\", \"===\": \"tEQQ\", \"<=>\": \"tCMP\", \"[]\": \"tAREF\", \"[]=\": \"tASET\", \"{\": \"tLCURLY\", \"}\": \"tRCURLY\", \"`\": \"tBACK_REF2\", \"!@\": \"tBANG\", \"&.\": \"tANDDOT\"}));\n    Opal.const_set($nesting[0], 'PUNCTUATION_BEGIN', $hash2([\"&\", \"*\", \"**\", \"+\", \"-\", \"::\", \"(\", \"{\", \"[\"], {\"&\": \"tAMPER\", \"*\": \"tSTAR\", \"**\": \"tDSTAR\", \"+\": \"tUPLUS\", \"-\": \"tUMINUS\", \"::\": \"tCOLON3\", \"(\": \"tLPAREN\", \"{\": \"tLBRACE\", \"[\": \"tLBRACK\"}));\n    Opal.const_set($nesting[0], 'KEYWORDS', $hash2([\"if\", \"unless\", \"while\", \"until\", \"rescue\", \"defined?\", \"BEGIN\", \"END\"], {\"if\": \"kIF_MOD\", \"unless\": \"kUNLESS_MOD\", \"while\": \"kWHILE_MOD\", \"until\": \"kUNTIL_MOD\", \"rescue\": \"kRESCUE_MOD\", \"defined?\": \"kDEFINED\", \"BEGIN\": \"klBEGIN\", \"END\": \"klEND\"}));\n    Opal.const_set($nesting[0], 'KEYWORDS_BEGIN', $hash2([\"if\", \"unless\", \"while\", \"until\", \"rescue\", \"defined?\"], {\"if\": \"kIF\", \"unless\": \"kUNLESS\", \"while\": \"kWHILE\", \"until\": \"kUNTIL\", \"rescue\": \"kRESCUE\", \"defined?\": \"kDEFINED\"}));\n    return $send([\"class\", \"module\", \"def\", \"undef\", \"begin\", \"end\", \"then\", \"elsif\", \"else\", \"ensure\", \"case\", \"when\", \"for\", \"break\", \"next\", \"redo\", \"retry\", \"in\", \"do\", \"return\", \"yield\", \"super\", \"self\", \"nil\", \"true\", \"false\", \"and\", \"or\", \"not\", \"alias\", \"__FILE__\", \"__LINE__\", \"__ENCODING__\"], 'each', [], (TMP_Lexer_53 = function(keyword){var self = TMP_Lexer_53.$$s || this;\nif (keyword == null) keyword = nil;\n    \n      $writer = [keyword, (($writer = [keyword, \"\" + \"k\" + (keyword.$upcase())]), $send(Opal.const_get_relative($nesting, 'KEYWORDS'), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])];\n      $send(Opal.const_get_relative($nesting, 'KEYWORDS_BEGIN'), '[]=', Opal.to_a($writer));\n      return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_Lexer_53.$$s = self, TMP_Lexer_53.$$arity = 1, TMP_Lexer_53));\n  })(Opal.const_get_relative($nesting, 'Parser'), null, $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/lexer/literal\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$attr_accessor', '$coerce_encoding', '$include?', '$send', '$+', '$[]', '$fetch', '$==', '$!', '$heredoc?', '$start_with?', '$freeze', '$clear_buffer', '$emit_start_tok', '$type', '$words?', '$=~', '$delimiter?', '$-', '$extend_space', '$!=', '$flush_string', '$emit', '$each_char', '$===', '$%', '$nil?', '$>', '$empty?', '$extend_content', '$protected', '$lstrip', '$force_encoding', '$dup', '$encoding', '$source', '$source_buffer', '$length']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Literal(){};\n      var self = $Literal = $klass($base, $super, 'Literal', $Literal);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Literal_initialize_1, TMP_Literal_interpolate$q_2, TMP_Literal_words$q_3, TMP_Literal_regexp$q_4, TMP_Literal_heredoc$q_5, TMP_Literal_backslash_delimited$q_6, TMP_Literal_type_7, TMP_Literal_munge_escape$q_8, TMP_Literal_nest_and_try_closing_9, TMP_Literal_infer_indent_level_11, TMP_Literal_start_interp_brace_12, TMP_Literal_end_interp_brace_and_try_closing_13, TMP_Literal_extend_string_14, TMP_Literal_flush_string_15, TMP_Literal_extend_content_16, TMP_Literal_extend_space_17, TMP_Literal_delimiter$q_18, TMP_Literal_coerce_encoding_19, TMP_Literal_clear_buffer_20, TMP_Literal_emit_start_tok_21, TMP_Literal_emit_22;\n\n      def.lexer = def.start_tok = def.str_type = def.monolithic = def.interpolate = def.heredoc_e = def.end_delim = def.start_delim = def.nesting = def.label_allowed = def.buffer = def.str_s = def.dedent_body = def.interp_braces = def.buffer_s = def.buffer_e = def.space_emitted = def.indent = nil;\n      \n      Opal.const_set($nesting[0], 'DELIMITERS', $hash2([\"(\", \"[\", \"{\", \"<\"], {\"(\": \")\".$force_encoding(\"ASCII-8BIT\"), \"[\": \"]\".$force_encoding(\"ASCII-8BIT\"), \"{\": \"}\".$force_encoding(\"ASCII-8BIT\"), \"<\": \">\".$force_encoding(\"ASCII-8BIT\")}));\n      Opal.const_set($nesting[0], 'TYPES', $hash2([\"'\", \"<<'\", \"%q\", \"\\\"\", \"<<\\\"\", \"%\", \"%Q\", \"%w\", \"%W\", \"%i\", \"%I\", \":'\", \"%s\", \":\\\"\", \"/\", \"%r\", \"%x\", \"`\", \"<<`\"], {\"'\": [\"tSTRING_BEG\", false], \"<<'\": [\"tSTRING_BEG\", false], \"%q\": [\"tSTRING_BEG\", false], \"\\\"\": [\"tSTRING_BEG\", true], \"<<\\\"\": [\"tSTRING_BEG\", true], \"%\": [\"tSTRING_BEG\", true], \"%Q\": [\"tSTRING_BEG\", true], \"%w\": [\"tQWORDS_BEG\", false], \"%W\": [\"tWORDS_BEG\", true], \"%i\": [\"tQSYMBOLS_BEG\", false], \"%I\": [\"tSYMBOLS_BEG\", true], \":'\": [\"tSYMBEG\", false], \"%s\": [\"tSYMBEG\", false], \":\\\"\": [\"tSYMBEG\", true], \"/\": [\"tREGEXP_BEG\", true], \"%r\": [\"tREGEXP_BEG\", true], \"%x\": [\"tXSTRING_BEG\", true], \"`\": [\"tXSTRING_BEG\", true], \"<<`\": [\"tXSTRING_BEG\", true]}));\n      self.$attr_reader(\"heredoc_e\", \"str_s\", \"dedent_level\");\n      self.$attr_accessor(\"saved_herebody_s\");\n      \n      Opal.defn(self, '$initialize', TMP_Literal_initialize_1 = function $$initialize(lexer, str_type, delimiter, str_s, heredoc_e, indent, dedent_body, label_allowed) {\n        var $a, $b, self = this;\n\n        if (heredoc_e == null) {\n          heredoc_e = nil;\n        }\n        if (indent == null) {\n          indent = false;\n        }\n        if (dedent_body == null) {\n          dedent_body = false;\n        }\n        if (label_allowed == null) {\n          label_allowed = false;\n        }\n        \n        self.lexer = lexer;\n        self.nesting = 1;\n        str_type = self.$coerce_encoding(str_type);\n        delimiter = self.$coerce_encoding(delimiter);\n        if ($truthy(Opal.const_get_relative($nesting, 'TYPES')['$include?'](str_type))) {\n          } else {\n          lexer.$send(\"diagnostic\", \"error\", \"unexpected_percent_str\", $hash2([\"type\"], {\"type\": str_type}), self.lexer.$send(\"range\", str_s, $rb_plus(str_s, 2)))\n        };\n        self.str_type = str_type;\n        self.str_s = str_s;\n        $b = Opal.const_get_relative($nesting, 'TYPES')['$[]'](str_type), $a = Opal.to_ary($b), (self.start_tok = ($a[0] == null ? nil : $a[0])), (self.interpolate = ($a[1] == null ? nil : $a[1])), $b;\n        self.start_delim = (function() {if ($truthy(Opal.const_get_relative($nesting, 'DELIMITERS')['$include?'](delimiter))) {\n          return delimiter\n          } else {\n          return nil\n        }; return nil; })();\n        self.end_delim = Opal.const_get_relative($nesting, 'DELIMITERS').$fetch(delimiter, delimiter);\n        self.heredoc_e = heredoc_e;\n        self.indent = indent;\n        self.label_allowed = label_allowed;\n        self.dedent_body = dedent_body;\n        self.dedent_level = nil;\n        self.interp_braces = 0;\n        self.space_emitted = true;\n        self.monolithic = ($truthy($a = (($b = self.start_tok['$=='](\"tSTRING_BEG\")) ? [\"'\".$force_encoding(\"ASCII-8BIT\"), \"\\\"\".$force_encoding(\"ASCII-8BIT\")]['$include?'](str_type) : self.start_tok['$=='](\"tSTRING_BEG\"))) ? self['$heredoc?']()['$!']() : $a);\n        if ($truthy(self.str_type['$start_with?'](\"%\".$force_encoding(\"ASCII-8BIT\").$freeze()))) {\n          self.str_type = $rb_plus(self.str_type, delimiter)};\n        self.$clear_buffer();\n        if ($truthy(self.monolithic)) {\n          return nil\n          } else {\n          return self.$emit_start_tok()\n        };\n      }, TMP_Literal_initialize_1.$$arity = -5);\n      \n      Opal.defn(self, '$interpolate?', TMP_Literal_interpolate$q_2 = function() {\n        var self = this;\n\n        return self.interpolate\n      }, TMP_Literal_interpolate$q_2.$$arity = 0);\n      \n      Opal.defn(self, '$words?', TMP_Literal_words$q_3 = function() {\n        var $a, $b, $c, self = this;\n\n        return ($truthy($a = ($truthy($b = ($truthy($c = self.$type()['$=='](\"tWORDS_BEG\")) ? $c : self.$type()['$=='](\"tQWORDS_BEG\"))) ? $b : self.$type()['$=='](\"tSYMBOLS_BEG\"))) ? $a : self.$type()['$=='](\"tQSYMBOLS_BEG\"))\n      }, TMP_Literal_words$q_3.$$arity = 0);\n      \n      Opal.defn(self, '$regexp?', TMP_Literal_regexp$q_4 = function() {\n        var self = this;\n\n        return self.$type()['$=='](\"tREGEXP_BEG\")\n      }, TMP_Literal_regexp$q_4.$$arity = 0);\n      \n      Opal.defn(self, '$heredoc?', TMP_Literal_heredoc$q_5 = function() {\n        var self = this;\n\n        return self.heredoc_e['$!']()['$!']()\n      }, TMP_Literal_heredoc$q_5.$$arity = 0);\n      \n      Opal.defn(self, '$backslash_delimited?', TMP_Literal_backslash_delimited$q_6 = function() {\n        var self = this;\n\n        return self.end_delim['$=='](\"\\\\\".$force_encoding(\"ASCII-8BIT\").$freeze())\n      }, TMP_Literal_backslash_delimited$q_6.$$arity = 0);\n      \n      Opal.defn(self, '$type', TMP_Literal_type_7 = function $$type() {\n        var self = this;\n\n        return self.start_tok\n      }, TMP_Literal_type_7.$$arity = 0);\n      \n      Opal.defn(self, '$munge_escape?', TMP_Literal_munge_escape$q_8 = function(character) {\n        var $a, self = this;\n\n        \n        character = self.$coerce_encoding(character);\n        if ($truthy(($truthy($a = self['$words?']()) ? character['$=~'](/[ \\t\\v\\r\\f\\n]/) : $a))) {\n          return true\n          } else {\n          return [\"\\\\\".$force_encoding(\"ASCII-8BIT\").$freeze(), self.start_delim, self.end_delim]['$include?'](character)\n        };\n      }, TMP_Literal_munge_escape$q_8.$$arity = 1);\n      \n      Opal.defn(self, '$nest_and_try_closing', TMP_Literal_nest_and_try_closing_9 = function $$nest_and_try_closing(delimiter, ts, te, lookahead) {\n        var $a, $b, $c, $d, self = this;\n\n        if (lookahead == null) {\n          lookahead = nil;\n        }\n        \n        delimiter = self.$coerce_encoding(delimiter);\n        if ($truthy(($truthy($a = self.start_delim) ? self.start_delim['$=='](delimiter) : $a))) {\n          self.nesting = $rb_plus(self.nesting, 1)\n        } else if ($truthy(self['$delimiter?'](delimiter))) {\n          self.nesting = $rb_minus(self.nesting, 1)};\n        if (self.nesting['$=='](0)) {\n          \n          if ($truthy(self['$words?']())) {\n            self.$extend_space(ts, ts)};\n          if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = lookahead) ? self.label_allowed : $d)) ? lookahead['$[]'](0)['$=='](\":\".$force_encoding(\"ASCII-8BIT\")) : $c)) ? lookahead['$[]'](1)['$!='](\":\".$force_encoding(\"ASCII-8BIT\")) : $b)) ? self.start_tok['$=='](\"tSTRING_BEG\") : $a))) {\n            \n            self.$flush_string();\n            return self.$emit(\"tLABEL_END\", self.end_delim, ts, $rb_plus(te, 1));\n          } else if ($truthy(self.monolithic)) {\n            return self.$emit(\"tSTRING\", self.buffer, self.str_s, te)\n            } else {\n            \n            if ($truthy(self['$heredoc?']())) {\n              } else {\n              self.$flush_string()\n            };\n            return self.$emit(\"tSTRING_END\", self.end_delim, ts, te);\n          };\n          } else {\n          return nil\n        };\n      }, TMP_Literal_nest_and_try_closing_9.$$arity = -4);\n      \n      Opal.defn(self, '$infer_indent_level', TMP_Literal_infer_indent_level_11 = function $$infer_indent_level(line) {\n        var TMP_10, self = this, indent_level = nil;\n\n        \n        if ($truthy(self.dedent_body['$!']())) {\n          return nil};\n        indent_level = 0;\n        return (function(){var $brk = Opal.new_brk(); try {return $send(line, 'each_char', [], (TMP_10 = function(char$){var self = TMP_10.$$s || this, $a, $case = nil;\n          if (self.dedent_level == null) self.dedent_level = nil;\nif (char$ == null) char$ = nil;\n        return (function() {$case = char$;\n          if (\" \"['$===']($case)) {return (indent_level = $rb_plus(indent_level, 1))}\n          else if (\"\\t\"['$===']($case)) {return (indent_level = $rb_plus(indent_level, $rb_minus(8, indent_level['$%'](8))))}\n          else {\n          if ($truthy(($truthy($a = self.dedent_level['$nil?']()) ? $a : $rb_gt(self.dedent_level, indent_level)))) {\n            self.dedent_level = indent_level};\n          \n          Opal.brk(nil, $brk);}})()}, TMP_10.$$s = self, TMP_10.$$brk = $brk, TMP_10.$$arity = 1, TMP_10))\n        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();\n      }, TMP_Literal_infer_indent_level_11.$$arity = 1);\n      \n      Opal.defn(self, '$start_interp_brace', TMP_Literal_start_interp_brace_12 = function $$start_interp_brace() {\n        var self = this;\n\n        return (self.interp_braces = $rb_plus(self.interp_braces, 1))\n      }, TMP_Literal_start_interp_brace_12.$$arity = 0);\n      \n      Opal.defn(self, '$end_interp_brace_and_try_closing', TMP_Literal_end_interp_brace_and_try_closing_13 = function $$end_interp_brace_and_try_closing() {\n        var self = this;\n\n        \n        self.interp_braces = $rb_minus(self.interp_braces, 1);\n        \n        return self.interp_braces['$=='](0);;\n      }, TMP_Literal_end_interp_brace_and_try_closing_13.$$arity = 0);\n      \n      Opal.defn(self, '$extend_string', TMP_Literal_extend_string_14 = function $$extend_string(string, ts, te) {\n        var $a, self = this;\n\n        \n        self.buffer_s = ($truthy($a = self.buffer_s) ? $a : ts);\n        self.buffer_e = te;\n        return (self.buffer = $rb_plus(self.buffer, string));\n      }, TMP_Literal_extend_string_14.$$arity = 3);\n      \n      Opal.defn(self, '$flush_string', TMP_Literal_flush_string_15 = function $$flush_string() {\n        var self = this;\n\n        \n        if ($truthy(self.monolithic)) {\n          \n          self.$emit_start_tok();\n          self.monolithic = false;};\n        if ($truthy(self.buffer['$empty?']())) {\n          return nil\n          } else {\n          \n          self.$emit(\"tSTRING_CONTENT\", self.buffer, self.buffer_s, self.buffer_e);\n          self.$clear_buffer();\n          return self.$extend_content();\n        };\n      }, TMP_Literal_flush_string_15.$$arity = 0);\n      \n      Opal.defn(self, '$extend_content', TMP_Literal_extend_content_16 = function $$extend_content() {\n        var self = this;\n\n        return (self.space_emitted = false)\n      }, TMP_Literal_extend_content_16.$$arity = 0);\n      \n      Opal.defn(self, '$extend_space', TMP_Literal_extend_space_17 = function $$extend_space(ts, te) {\n        var self = this;\n\n        \n        self.$flush_string();\n        if ($truthy(self.space_emitted)) {\n          return nil\n          } else {\n          \n          self.$emit(\"tSPACE\", nil, ts, te);\n          return (self.space_emitted = true);\n        };\n      }, TMP_Literal_extend_space_17.$$arity = 2);\n      self.$protected();\n      \n      Opal.defn(self, '$delimiter?', TMP_Literal_delimiter$q_18 = function(delimiter) {\n        var self = this;\n\n        if ($truthy(self.indent)) {\n          return self.end_delim['$=='](delimiter.$lstrip())\n          } else {\n          return self.end_delim['$=='](delimiter)\n        }\n      }, TMP_Literal_delimiter$q_18.$$arity = 1);\n      \n      Opal.defn(self, '$coerce_encoding', TMP_Literal_coerce_encoding_19 = function $$coerce_encoding(string) {\n        var $a, self = this;\n\n        if ($truthy((($a = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n          return string.$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))\n          } else {\n          return string\n        }\n      }, TMP_Literal_coerce_encoding_19.$$arity = 1);\n      \n      Opal.defn(self, '$clear_buffer', TMP_Literal_clear_buffer_20 = function $$clear_buffer() {\n        var $a, self = this;\n\n        \n        self.buffer = \"\".$force_encoding(\"ASCII-8BIT\");\n        if ($truthy((($a = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n          self.buffer.$force_encoding(self.lexer.$source_buffer().$source().$encoding())};\n        self.buffer_s = nil;\n        return (self.buffer_e = nil);\n      }, TMP_Literal_clear_buffer_20.$$arity = 0);\n      \n      Opal.defn(self, '$emit_start_tok', TMP_Literal_emit_start_tok_21 = function $$emit_start_tok() {\n        var $a, self = this, str_e = nil;\n\n        \n        str_e = ($truthy($a = self.heredoc_e) ? $a : $rb_plus(self.str_s, self.str_type.$length()));\n        return self.$emit(self.start_tok, self.str_type, self.str_s, str_e);\n      }, TMP_Literal_emit_start_tok_21.$$arity = 0);\n      return (Opal.defn(self, '$emit', TMP_Literal_emit_22 = function $$emit(token, type, s, e) {\n        var self = this;\n\n        return self.lexer.$send(\"emit\", token, type, s, e)\n      }, TMP_Literal_emit_22.$$arity = 4), nil) && 'emit';\n    })(Opal.const_get_relative($nesting, 'Lexer'), null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/lexer/stack_state\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$freeze', '$clear', '$|', '$<<', '$&', '$>>', '$==', '$push', '$pop', '$[]', '$to_s']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $StackState(){};\n      var self = $StackState = $klass($base, $super, 'StackState', $StackState);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_StackState_initialize_1, TMP_StackState_clear_2, TMP_StackState_push_3, TMP_StackState_pop_4, TMP_StackState_lexpop_5, TMP_StackState_active$q_6, TMP_StackState_to_s_7;\n\n      def.stack = def.name = nil;\n      \n      \n      Opal.defn(self, '$initialize', TMP_StackState_initialize_1 = function $$initialize(name) {\n        var self = this;\n\n        \n        self.name = name.$freeze();\n        return self.$clear();\n      }, TMP_StackState_initialize_1.$$arity = 1);\n      \n      Opal.defn(self, '$clear', TMP_StackState_clear_2 = function $$clear() {\n        var self = this;\n\n        return (self.stack = 0)\n      }, TMP_StackState_clear_2.$$arity = 0);\n      \n      Opal.defn(self, '$push', TMP_StackState_push_3 = function $$push(bit) {\n        var self = this, bit_value = nil;\n\n        \n        bit_value = (function() {if ($truthy(bit)) {\n          return 1\n          } else {\n          return 0\n        }; return nil; })();\n        self.stack = self.stack['$<<'](1)['$|'](bit_value);\n        return bit;\n      }, TMP_StackState_push_3.$$arity = 1);\n      \n      Opal.defn(self, '$pop', TMP_StackState_pop_4 = function $$pop() {\n        var self = this, bit_value = nil;\n\n        \n        bit_value = self.stack['$&'](1);\n        self.stack = self.stack['$>>'](1);\n        return bit_value['$=='](1);\n      }, TMP_StackState_pop_4.$$arity = 0);\n      \n      Opal.defn(self, '$lexpop', TMP_StackState_lexpop_5 = function $$lexpop() {\n        var $a, self = this;\n\n        return self.$push(($truthy($a = self.$pop()) ? $a : self.$pop()))\n      }, TMP_StackState_lexpop_5.$$arity = 0);\n      \n      Opal.defn(self, '$active?', TMP_StackState_active$q_6 = function() {\n        var self = this;\n\n        return self.stack['$[]'](0)['$=='](1)\n      }, TMP_StackState_active$q_6.$$arity = 0);\n      \n      Opal.defn(self, '$to_s', TMP_StackState_to_s_7 = function $$to_s() {\n        var self = this;\n\n        return \"\" + \"[\" + (self.stack.$to_s(2)) + \" <= \" + (self.name) + \"]\"\n      }, TMP_StackState_to_s_7.$$arity = 0);\n      return Opal.alias(self, \"inspect\", \"to_s\");\n    })(Opal.const_get_relative($nesting, 'Lexer'), null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/lexer/dedenter\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$-', '$length', '$each_with_index', '$chars', '$==', '$>=', '$slice!', '$+', '$===', '$%']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Dedenter(){};\n      var self = $Dedenter = $klass($base, $super, 'Dedenter', $Dedenter);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Dedenter_initialize_1, TMP_Dedenter_dedent_3, TMP_Dedenter_interrupt_4;\n\n      def.at_line_begin = nil;\n      \n      \n      Opal.defn(self, '$initialize', TMP_Dedenter_initialize_1 = function $$initialize(dedent_level) {\n        var self = this;\n\n        \n        self.dedent_level = dedent_level;\n        self.at_line_begin = true;\n        return (self.indent_level = 0);\n      }, TMP_Dedenter_initialize_1.$$arity = 1);\n      \n      Opal.defn(self, '$dedent', TMP_Dedenter_dedent_3 = function $$dedent(string) {\n        var TMP_2, self = this, space_begin = nil, space_end = nil, offset = nil, last_index = nil;\n\n        \n        space_begin = (space_end = (offset = 0));\n        last_index = $rb_minus(string.$length(), 1);\n        $send(string.$chars(), 'each_with_index', [], (TMP_2 = function(char$, index){var self = TMP_2.$$s || this, $a, $case = nil;\n          if (self.at_line_begin == null) self.at_line_begin = nil;\n          if (self.indent_level == null) self.indent_level = nil;\n          if (self.dedent_level == null) self.dedent_level = nil;\nif (char$ == null) char$ = nil;if (index == null) index = nil;\n        if ($truthy(self.at_line_begin)) {\n            \n            if ($truthy(($truthy($a = char$['$=='](\"\\n\")) ? $a : $rb_ge(self.indent_level, self.dedent_level)))) {\n              \n              string['$slice!'](Opal.Range.$new(space_begin,space_end, true));\n              offset = $rb_plus(offset, $rb_minus($rb_minus(space_end, space_begin), 1));\n              self.at_line_begin = false;\n              if (char$['$=='](\"\\n\")) {\n                return TMP_2.apply(null, $slice.call(arguments))};};\n            return (function() {$case = char$;\n            if (\" \"['$===']($case)) {\n            self.indent_level = $rb_plus(self.indent_level, 1);\n            return (space_end = $rb_plus(space_end, 1));}\n            else if (\"\\t\"['$===']($case)) {\n            self.indent_level = $rb_plus(self.indent_level, $rb_minus(8, self.indent_level['$%'](8)));\n            return (space_end = $rb_plus(space_end, 1));}\n            else { return nil }})();\n          } else if ($truthy((($a = char$['$=='](\"\\n\")) ? index['$=='](last_index) : char$['$=='](\"\\n\")))) {\n            \n            self.at_line_begin = true;\n            self.indent_level = 0;\n            return (space_begin = (space_end = $rb_plus($rb_minus(index, offset), 1)));\n            } else {\n            return nil\n          }}, TMP_2.$$s = self, TMP_2.$$arity = 2, TMP_2));\n        if ($truthy(self.at_line_begin)) {\n          string['$slice!'](Opal.Range.$new(space_begin, space_end, false))};\n        return nil;\n      }, TMP_Dedenter_dedent_3.$$arity = 1);\n      return (Opal.defn(self, '$interrupt', TMP_Dedenter_interrupt_4 = function $$interrupt() {\n        var self = this;\n\n        return (self.at_line_begin = false)\n      }, TMP_Dedenter_interrupt_4.$$arity = 0), nil) && 'interrupt';\n    })(Opal.const_get_relative($nesting, 'Lexer'), null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/builders/default\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;\n\n  Opal.add_stubs(['$attr_accessor', '$n0', '$token_map', '$numeric', '$n', '$value', '$new', '$loc', '$private', '$updated', '$-@', '$join', '$expression', '$string_value', '$delimited_string_map', '$unquoted_map', '$collapse_string_parts?', '$nil?', '$first', '$children', '$string_map', '$prefix_string_map', '$to_sym', '$collection_map', '$==', '$version', '$empty?', '$diagnostic', '$!', '$type', '$dedent', '$each', '$interrupt', '$map', '$uniq', '$sort', '$each_char', '$to_proc', '$static_regexp', '$message', '$<<', '$regexp_map', '$unary_op_map', '$===', '$binary_op_map', '$!=', '$%', '$size', '$last', '$each_slice', '$pair_keyword_map', '$pair_quoted_map', '$symbol_compose', '$variable_map', '$name', '$source_buffer', '$dup', '$line', '$declared?', '$static_env', '$var_send_map', '$constant_map', '$in_def?', '$declare', '$with_expression', '$with_operator', '$join_exprs', '$[]', '$module_definition_map', '$definition_map', '$keyword_map', '$check_duplicate_args', '$arg_prefix_map', '$kwarg_map', '$emit_procarg0', '$class', '$resize', '$-', '$end', '$call_type_for_dot', '$send_map', '$emit_lambda', '$expr_map', '$keyword', '$include?', '$block_map', '$array', '$+', '$send_index_map', '$send_binary_op_map', '$static_regexp_node', '$names', '$send_unary_op_map', '$check_condition', '$condition_map', '$keyword_mod_map', '$ternary_map', '$for_map', '$>', '$count', '$rescue_body_map', '$any?', '$eh_keyword_map', '$push', '$none?', '$one?', '$begin', '$<=', '$[]=', '$arg_name_collides?', '$begin_pos', '$end_pos', '$start_with?', '$static_string', '$encode', '$valid_encoding?', '$process', '$diagnostics', '$send']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Default(){};\n      var self = $Default = $klass($base, $super, 'Default', $Default);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Default_initialize_2, TMP_Default_nil_3, TMP_Default_true_4, TMP_Default_false_5, TMP_Default_integer_6, TMP_Default_float_7, TMP_Default_rational_8, TMP_Default_complex_9, TMP_Default_numeric_10, TMP_Default_negate_11, TMP_Default___LINE___12, TMP_Default_string_13, TMP_Default_string_internal_14, TMP_Default_string_compose_15, TMP_Default_character_16, TMP_Default___FILE___17, TMP_Default_symbol_18, TMP_Default_symbol_internal_19, TMP_Default_symbol_compose_20, TMP_Default_xstring_compose_21, TMP_Default_dedent_string_23, TMP_Default_regexp_options_24, TMP_Default_regexp_compose_25, TMP_Default_array_26, TMP_Default_splat_27, TMP_Default_word_28, TMP_Default_words_compose_29, TMP_Default_symbols_compose_31, TMP_Default_pair_32, TMP_Default_pair_list_18_34, TMP_Default_pair_keyword_35, TMP_Default_pair_quoted_36, TMP_Default_kwsplat_37, TMP_Default_associate_38, TMP_Default_range_inclusive_39, TMP_Default_range_exclusive_40, TMP_Default_self_41, TMP_Default_ident_42, TMP_Default_ivar_43, TMP_Default_gvar_44, TMP_Default_cvar_45, TMP_Default_back_ref_46, TMP_Default_nth_ref_47, TMP_Default_accessible_48, TMP_Default_const_49, TMP_Default_const_global_50, TMP_Default_const_fetch_51, TMP_Default___ENCODING___52, TMP_Default_assignable_53, TMP_Default_const_op_assignable_54, TMP_Default_assign_55, TMP_Default_op_assign_56, TMP_Default_multi_lhs_57, TMP_Default_multi_assign_58, TMP_Default_def_class_59, TMP_Default_def_sclass_60, TMP_Default_def_module_61, TMP_Default_def_method_62, TMP_Default_def_singleton_63, TMP_Default_undef_method_64, TMP_Default_alias_65, TMP_Default_args_66, TMP_Default_arg_67, TMP_Default_optarg_68, TMP_Default_restarg_69, TMP_Default_kwarg_70, TMP_Default_kwoptarg_71, TMP_Default_kwrestarg_72, TMP_Default_shadowarg_73, TMP_Default_blockarg_74, TMP_Default_procarg0_75, TMP_Default_arg_expr_76, TMP_Default_restarg_expr_77, TMP_Default_blockarg_expr_78, TMP_Default_objc_kwarg_79, TMP_Default_objc_restarg_80, TMP_Default_call_type_for_dot_81, TMP_Default_call_method_82, TMP_Default_call_lambda_83, TMP_Default_block_84, TMP_Default_block_pass_85, TMP_Default_objc_varargs_86, TMP_Default_attr_asgn_87, TMP_Default_index_88, TMP_Default_index_asgn_89, TMP_Default_binary_op_90, TMP_Default_match_op_92, TMP_Default_unary_op_93, TMP_Default_not_op_94, TMP_Default_logical_op_95, TMP_Default_condition_96, TMP_Default_condition_mod_97, TMP_Default_ternary_98, TMP_Default_when_99, TMP_Default_case_100, TMP_Default_loop_101, TMP_Default_loop_mod_102, TMP_Default_for_103, TMP_Default_keyword_cmd_104, TMP_Default_preexe_105, TMP_Default_postexe_106, TMP_Default_rescue_body_107, TMP_Default_begin_body_108, TMP_Default_compstmt_109, TMP_Default_begin_110, TMP_Default_begin_keyword_111, TMP_Default_check_condition_112, TMP_Default_check_duplicate_args_114, TMP_Default_arg_name_collides$q_115, TMP_Default_n_116, TMP_Default_n0_117, TMP_Default_join_exprs_118, TMP_Default_token_map_119, TMP_Default_delimited_string_map_120, TMP_Default_prefix_string_map_121, TMP_Default_unquoted_map_122, TMP_Default_pair_keyword_map_123, TMP_Default_pair_quoted_map_124, TMP_Default_expr_map_125, TMP_Default_collection_map_126, TMP_Default_string_map_127, TMP_Default_regexp_map_128, TMP_Default_constant_map_129, TMP_Default_variable_map_130, TMP_Default_binary_op_map_131, TMP_Default_unary_op_map_132, TMP_Default_arg_prefix_map_133, TMP_Default_kwarg_map_134, TMP_Default_module_definition_map_135, TMP_Default_definition_map_136, TMP_Default_send_map_137, TMP_Default_var_send_map_138, TMP_Default_send_binary_op_map_139, TMP_Default_send_unary_op_map_140, TMP_Default_send_index_map_141, TMP_Default_block_map_142, TMP_Default_keyword_map_143, TMP_Default_keyword_mod_map_144, TMP_Default_condition_map_145, TMP_Default_ternary_map_146, TMP_Default_for_map_147, TMP_Default_rescue_body_map_148, TMP_Default_eh_keyword_map_149, TMP_Default_static_string_151, TMP_Default_static_regexp_152, TMP_Default_static_regexp_node_153, TMP_Default_collapse_string_parts$q_154, TMP_Default_value_155, $a, TMP_Default_string_value_156, TMP_Default_loc_157, TMP_Default_diagnostic_158;\n\n      def.parser = def.emit_file_line_as_literals = nil;\n      \n      (function(self, $parent_nesting) {\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return self.$attr_accessor(\"emit_lambda\")\n      })(Opal.get_singleton_class(self), $nesting);\n      self.emit_lambda = false;\n      (function(self, $parent_nesting) {\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return self.$attr_accessor(\"emit_procarg0\")\n      })(Opal.get_singleton_class(self), $nesting);\n      self.emit_procarg0 = false;\n      (function(self, $parent_nesting) {\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_modernize_1;\n\n        return (Opal.defn(self, '$modernize', TMP_modernize_1 = function $$modernize() {\n          var self = this;\n\n          \n          self.emit_lambda = true;\n          return (self.emit_procarg0 = true);\n        }, TMP_modernize_1.$$arity = 0), nil) && 'modernize'\n      })(Opal.get_singleton_class(self), $nesting);\n      self.$attr_accessor(\"parser\");\n      self.$attr_accessor(\"emit_file_line_as_literals\");\n      \n      Opal.defn(self, '$initialize', TMP_Default_initialize_2 = function $$initialize() {\n        var self = this;\n\n        return (self.emit_file_line_as_literals = true)\n      }, TMP_Default_initialize_2.$$arity = 0);\n      \n      Opal.defn(self, '$nil', TMP_Default_nil_3 = function $$nil(nil_t) {\n        var self = this;\n\n        return self.$n0(\"nil\", self.$token_map(nil_t))\n      }, TMP_Default_nil_3.$$arity = 1);\n      \n      Opal.defn(self, '$true', TMP_Default_true_4 = function(true_t) {\n        var self = this;\n\n        return self.$n0(\"true\", self.$token_map(true_t))\n      }, TMP_Default_true_4.$$arity = 1);\n      \n      Opal.defn(self, '$false', TMP_Default_false_5 = function(false_t) {\n        var self = this;\n\n        return self.$n0(\"false\", self.$token_map(false_t))\n      }, TMP_Default_false_5.$$arity = 1);\n      \n      Opal.defn(self, '$integer', TMP_Default_integer_6 = function $$integer(integer_t) {\n        var self = this;\n\n        return self.$numeric(\"int\", integer_t)\n      }, TMP_Default_integer_6.$$arity = 1);\n      \n      Opal.defn(self, '$float', TMP_Default_float_7 = function(float_t) {\n        var self = this;\n\n        return self.$numeric(\"float\", float_t)\n      }, TMP_Default_float_7.$$arity = 1);\n      \n      Opal.defn(self, '$rational', TMP_Default_rational_8 = function $$rational(rational_t) {\n        var self = this;\n\n        return self.$numeric(\"rational\", rational_t)\n      }, TMP_Default_rational_8.$$arity = 1);\n      \n      Opal.defn(self, '$complex', TMP_Default_complex_9 = function $$complex(complex_t) {\n        var self = this;\n\n        return self.$numeric(\"complex\", complex_t)\n      }, TMP_Default_complex_9.$$arity = 1);\n      \n      Opal.defn(self, '$numeric', TMP_Default_numeric_10 = function $$numeric(kind, token) {\n        var self = this;\n\n        return self.$n(kind, [self.$value(token)], Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Operator').$new(nil, self.$loc(token)))\n      }, TMP_Default_numeric_10.$$arity = 2);\n      self.$private(\"numeric\");\n      \n      Opal.defn(self, '$negate', TMP_Default_negate_11 = function $$negate(uminus_t, numeric) {\n        var $a, self = this, value = nil, operator_loc = nil;\n\n        \n        $a = [].concat(Opal.to_a(numeric)), (value = ($a[0] == null ? nil : $a[0])), $a;\n        operator_loc = self.$loc(uminus_t);\n        return numeric.$updated(nil, [value['$-@']()], $hash2([\"location\"], {\"location\": Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Operator').$new(operator_loc, operator_loc.$join(numeric.$loc().$expression()))}));\n      }, TMP_Default_negate_11.$$arity = 2);\n      \n      Opal.defn(self, '$__LINE__', TMP_Default___LINE___12 = function $$__LINE__(__LINE__t) {\n        var self = this;\n\n        return self.$n0(\"__LINE__\", self.$token_map(__LINE__t))\n      }, TMP_Default___LINE___12.$$arity = 1);\n      \n      Opal.defn(self, '$string', TMP_Default_string_13 = function $$string(string_t) {\n        var self = this;\n\n        return self.$n(\"str\", [self.$string_value(string_t)], self.$delimited_string_map(string_t))\n      }, TMP_Default_string_13.$$arity = 1);\n      \n      Opal.defn(self, '$string_internal', TMP_Default_string_internal_14 = function $$string_internal(string_t) {\n        var self = this;\n\n        return self.$n(\"str\", [self.$string_value(string_t)], self.$unquoted_map(string_t))\n      }, TMP_Default_string_internal_14.$$arity = 1);\n      \n      Opal.defn(self, '$string_compose', TMP_Default_string_compose_15 = function $$string_compose(begin_t, parts, end_t) {\n        var $a, self = this;\n\n        if ($truthy(self['$collapse_string_parts?'](parts))) {\n          if ($truthy(($truthy($a = begin_t['$nil?']()) ? end_t['$nil?']() : $a))) {\n            return parts.$first()\n            } else {\n            return self.$n(\"str\", parts.$first().$children(), self.$string_map(begin_t, parts, end_t))\n          }\n          } else {\n          return self.$n(\"dstr\", [].concat(Opal.to_a(parts)), self.$string_map(begin_t, parts, end_t))\n        }\n      }, TMP_Default_string_compose_15.$$arity = 3);\n      \n      Opal.defn(self, '$character', TMP_Default_character_16 = function $$character(char_t) {\n        var self = this;\n\n        return self.$n(\"str\", [self.$string_value(char_t)], self.$prefix_string_map(char_t))\n      }, TMP_Default_character_16.$$arity = 1);\n      \n      Opal.defn(self, '$__FILE__', TMP_Default___FILE___17 = function $$__FILE__(__FILE__t) {\n        var self = this;\n\n        return self.$n0(\"__FILE__\", self.$token_map(__FILE__t))\n      }, TMP_Default___FILE___17.$$arity = 1);\n      \n      Opal.defn(self, '$symbol', TMP_Default_symbol_18 = function $$symbol(symbol_t) {\n        var self = this;\n\n        return self.$n(\"sym\", [self.$string_value(symbol_t).$to_sym()], self.$prefix_string_map(symbol_t))\n      }, TMP_Default_symbol_18.$$arity = 1);\n      \n      Opal.defn(self, '$symbol_internal', TMP_Default_symbol_internal_19 = function $$symbol_internal(symbol_t) {\n        var self = this;\n\n        return self.$n(\"sym\", [self.$string_value(symbol_t).$to_sym()], self.$unquoted_map(symbol_t))\n      }, TMP_Default_symbol_internal_19.$$arity = 1);\n      \n      Opal.defn(self, '$symbol_compose', TMP_Default_symbol_compose_20 = function $$symbol_compose(begin_t, parts, end_t) {\n        var $a, self = this, str = nil;\n\n        if ($truthy(self['$collapse_string_parts?'](parts))) {\n          \n          str = parts.$first();\n          return self.$n(\"sym\", [str.$children().$first().$to_sym()], self.$collection_map(begin_t, str.$loc().$expression(), end_t));\n        } else if ($truthy((($a = self.parser.$version()['$=='](18)) ? parts['$empty?']() : self.parser.$version()['$=='](18)))) {\n          return self.$diagnostic(\"error\", \"empty_symbol\", nil, self.$loc(begin_t).$join(self.$loc(end_t)))\n          } else {\n          return self.$n(\"dsym\", [].concat(Opal.to_a(parts)), self.$collection_map(begin_t, parts, end_t))\n        }\n      }, TMP_Default_symbol_compose_20.$$arity = 3);\n      \n      Opal.defn(self, '$xstring_compose', TMP_Default_xstring_compose_21 = function $$xstring_compose(begin_t, parts, end_t) {\n        var self = this;\n\n        return self.$n(\"xstr\", [].concat(Opal.to_a(parts)), self.$string_map(begin_t, parts, end_t))\n      }, TMP_Default_xstring_compose_21.$$arity = 3);\n      \n      Opal.defn(self, '$dedent_string', TMP_Default_dedent_string_23 = function $$dedent_string(node, dedent_level) {\n        var $a, TMP_22, self = this, dedenter = nil, str = nil;\n\n        \n        if ($truthy(dedent_level['$nil?']()['$!']())) {\n          \n          dedenter = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Lexer'), 'Dedenter').$new(dedent_level);\n          if (node.$type()['$=='](\"str\")) {\n            \n            str = node.$children().$first();\n            dedenter.$dedent(str);\n          } else if ($truthy(($truthy($a = node.$type()['$=='](\"dstr\")) ? $a : node.$type()['$=='](\"xstr\")))) {\n            $send(node.$children(), 'each', [], (TMP_22 = function(str_node){var self = TMP_22.$$s || this;\nif (str_node == null) str_node = nil;\n            if (str_node.$type()['$=='](\"str\")) {\n                \n                str = str_node.$children().$first();\n                return dedenter.$dedent(str);\n                } else {\n                return dedenter.$interrupt()\n              }}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22))};};\n        return node;\n      }, TMP_Default_dedent_string_23.$$arity = 2);\n      \n      Opal.defn(self, '$regexp_options', TMP_Default_regexp_options_24 = function $$regexp_options(regopt_t) {\n        var self = this, options = nil;\n\n        \n        options = $send(self.$value(regopt_t).$each_char().$sort().$uniq(), 'map', [], \"to_sym\".$to_proc());\n        return self.$n(\"regopt\", options, self.$token_map(regopt_t));\n      }, TMP_Default_regexp_options_24.$$arity = 1);\n      \n      Opal.defn(self, '$regexp_compose', TMP_Default_regexp_compose_25 = function $$regexp_compose(begin_t, parts, end_t, options) {\n        var self = this, e = nil;\n\n        \n        \n        try {\n          self.$static_regexp(parts, options)\n        } catch ($err) {\n          if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'RegexpError')])) {e = $err;\n            try {\n              self.$diagnostic(\"error\", \"invalid_regexp\", $hash2([\"message\"], {\"message\": e.$message()}), self.$loc(begin_t).$join(self.$loc(end_t)))\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        };;\n        return self.$n(\"regexp\", parts['$<<'](options), self.$regexp_map(begin_t, end_t, options));\n      }, TMP_Default_regexp_compose_25.$$arity = 4);\n      \n      Opal.defn(self, '$array', TMP_Default_array_26 = function $$array(begin_t, elements, end_t) {\n        var self = this;\n\n        return self.$n(\"array\", elements, self.$collection_map(begin_t, elements, end_t))\n      }, TMP_Default_array_26.$$arity = 3);\n      \n      Opal.defn(self, '$splat', TMP_Default_splat_27 = function $$splat(star_t, arg) {\n        var self = this;\n\n        if (arg == null) {\n          arg = nil;\n        }\n        if ($truthy(arg['$nil?']())) {\n          return self.$n0(\"splat\", self.$unary_op_map(star_t))\n          } else {\n          return self.$n(\"splat\", [arg], self.$unary_op_map(star_t, arg))\n        }\n      }, TMP_Default_splat_27.$$arity = -2);\n      \n      Opal.defn(self, '$word', TMP_Default_word_28 = function $$word(parts) {\n        var self = this;\n\n        if ($truthy(self['$collapse_string_parts?'](parts))) {\n          return parts.$first()\n          } else {\n          return self.$n(\"dstr\", [].concat(Opal.to_a(parts)), self.$collection_map(nil, parts, nil))\n        }\n      }, TMP_Default_word_28.$$arity = 1);\n      \n      Opal.defn(self, '$words_compose', TMP_Default_words_compose_29 = function $$words_compose(begin_t, parts, end_t) {\n        var self = this;\n\n        return self.$n(\"array\", [].concat(Opal.to_a(parts)), self.$collection_map(begin_t, parts, end_t))\n      }, TMP_Default_words_compose_29.$$arity = 3);\n      \n      Opal.defn(self, '$symbols_compose', TMP_Default_symbols_compose_31 = function $$symbols_compose(begin_t, parts, end_t) {\n        var TMP_30, self = this;\n\n        \n        parts = $send(parts, 'map', [], (TMP_30 = function(part){var self = TMP_30.$$s || this, $a, $case = nil, value = nil;\nif (part == null) part = nil;\n        return (function() {$case = part.$type();\n          if (\"str\"['$===']($case)) {\n          $a = [].concat(Opal.to_a(part)), (value = ($a[0] == null ? nil : $a[0])), $a;\n          return part.$updated(\"sym\", [value.$to_sym()]);}\n          else if (\"dstr\"['$===']($case)) {return part.$updated(\"dsym\")}\n          else {return part}})()}, TMP_30.$$s = self, TMP_30.$$arity = 1, TMP_30));\n        return self.$n(\"array\", [].concat(Opal.to_a(parts)), self.$collection_map(begin_t, parts, end_t));\n      }, TMP_Default_symbols_compose_31.$$arity = 3);\n      \n      Opal.defn(self, '$pair', TMP_Default_pair_32 = function $$pair(key, assoc_t, value) {\n        var self = this;\n\n        return self.$n(\"pair\", [key, value], self.$binary_op_map(key, assoc_t, value))\n      }, TMP_Default_pair_32.$$arity = 3);\n      \n      Opal.defn(self, '$pair_list_18', TMP_Default_pair_list_18_34 = function $$pair_list_18(list) {\n        var TMP_33, self = this;\n\n        if ($truthy(list.$size()['$%'](2)['$!='](0))) {\n          return self.$diagnostic(\"error\", \"odd_hash\", nil, list.$last().$loc().$expression())\n          } else {\n          return $send(list.$each_slice(2), 'map', [], (TMP_33 = function(key, value){var self = TMP_33.$$s || this;\nif (key == null) key = nil;if (value == null) value = nil;\n          return self.$n(\"pair\", [key, value], self.$binary_op_map(key, nil, value))}, TMP_33.$$s = self, TMP_33.$$arity = 2, TMP_33))\n        }\n      }, TMP_Default_pair_list_18_34.$$arity = 1);\n      \n      Opal.defn(self, '$pair_keyword', TMP_Default_pair_keyword_35 = function $$pair_keyword(key_t, value) {\n        var $a, $b, self = this, key_map = nil, pair_map = nil, key = nil;\n\n        \n        $b = self.$pair_keyword_map(key_t, value), $a = Opal.to_ary($b), (key_map = ($a[0] == null ? nil : $a[0])), (pair_map = ($a[1] == null ? nil : $a[1])), $b;\n        key = self.$n(\"sym\", [self.$value(key_t).$to_sym()], key_map);\n        return self.$n(\"pair\", [key, value], pair_map);\n      }, TMP_Default_pair_keyword_35.$$arity = 2);\n      \n      Opal.defn(self, '$pair_quoted', TMP_Default_pair_quoted_36 = function $$pair_quoted(begin_t, parts, end_t, value) {\n        var $a, $b, self = this, pair_map = nil, key = nil;\n\n        \n        $b = self.$pair_quoted_map(begin_t, end_t, value), $a = Opal.to_ary($b), (end_t = ($a[0] == null ? nil : $a[0])), (pair_map = ($a[1] == null ? nil : $a[1])), $b;\n        key = self.$symbol_compose(begin_t, parts, end_t);\n        return self.$n(\"pair\", [key, value], pair_map);\n      }, TMP_Default_pair_quoted_36.$$arity = 4);\n      \n      Opal.defn(self, '$kwsplat', TMP_Default_kwsplat_37 = function $$kwsplat(dstar_t, arg) {\n        var self = this;\n\n        return self.$n(\"kwsplat\", [arg], self.$unary_op_map(dstar_t, arg))\n      }, TMP_Default_kwsplat_37.$$arity = 2);\n      \n      Opal.defn(self, '$associate', TMP_Default_associate_38 = function $$associate(begin_t, pairs, end_t) {\n        var self = this;\n\n        return self.$n(\"hash\", [].concat(Opal.to_a(pairs)), self.$collection_map(begin_t, pairs, end_t))\n      }, TMP_Default_associate_38.$$arity = 3);\n      \n      Opal.defn(self, '$range_inclusive', TMP_Default_range_inclusive_39 = function $$range_inclusive(lhs, dot2_t, rhs) {\n        var self = this;\n\n        return self.$n(\"irange\", [lhs, rhs], self.$binary_op_map(lhs, dot2_t, rhs))\n      }, TMP_Default_range_inclusive_39.$$arity = 3);\n      \n      Opal.defn(self, '$range_exclusive', TMP_Default_range_exclusive_40 = function $$range_exclusive(lhs, dot3_t, rhs) {\n        var self = this;\n\n        return self.$n(\"erange\", [lhs, rhs], self.$binary_op_map(lhs, dot3_t, rhs))\n      }, TMP_Default_range_exclusive_40.$$arity = 3);\n      \n      Opal.defn(self, '$self', TMP_Default_self_41 = function $$self(token) {\n        var self = this;\n\n        return self.$n0(\"self\", self.$token_map(token))\n      }, TMP_Default_self_41.$$arity = 1);\n      \n      Opal.defn(self, '$ident', TMP_Default_ident_42 = function $$ident(token) {\n        var self = this;\n\n        return self.$n(\"ident\", [self.$value(token).$to_sym()], self.$variable_map(token))\n      }, TMP_Default_ident_42.$$arity = 1);\n      \n      Opal.defn(self, '$ivar', TMP_Default_ivar_43 = function $$ivar(token) {\n        var self = this;\n\n        return self.$n(\"ivar\", [self.$value(token).$to_sym()], self.$variable_map(token))\n      }, TMP_Default_ivar_43.$$arity = 1);\n      \n      Opal.defn(self, '$gvar', TMP_Default_gvar_44 = function $$gvar(token) {\n        var self = this;\n\n        return self.$n(\"gvar\", [self.$value(token).$to_sym()], self.$variable_map(token))\n      }, TMP_Default_gvar_44.$$arity = 1);\n      \n      Opal.defn(self, '$cvar', TMP_Default_cvar_45 = function $$cvar(token) {\n        var self = this;\n\n        return self.$n(\"cvar\", [self.$value(token).$to_sym()], self.$variable_map(token))\n      }, TMP_Default_cvar_45.$$arity = 1);\n      \n      Opal.defn(self, '$back_ref', TMP_Default_back_ref_46 = function $$back_ref(token) {\n        var self = this;\n\n        return self.$n(\"back_ref\", [self.$value(token).$to_sym()], self.$token_map(token))\n      }, TMP_Default_back_ref_46.$$arity = 1);\n      \n      Opal.defn(self, '$nth_ref', TMP_Default_nth_ref_47 = function $$nth_ref(token) {\n        var self = this;\n\n        return self.$n(\"nth_ref\", [self.$value(token)], self.$token_map(token))\n      }, TMP_Default_nth_ref_47.$$arity = 1);\n      \n      Opal.defn(self, '$accessible', TMP_Default_accessible_48 = function $$accessible(node) {\n        var $a, self = this, $case = nil, name = nil;\n\n        return (function() {$case = node.$type();\n        if (\"__FILE__\"['$===']($case)) {if ($truthy(self.emit_file_line_as_literals)) {\n          return self.$n(\"str\", [node.$loc().$expression().$source_buffer().$name()], node.$loc().$dup())\n          } else {\n          return node\n        }}\n        else if (\"__LINE__\"['$===']($case)) {if ($truthy(self.emit_file_line_as_literals)) {\n          return self.$n(\"int\", [node.$loc().$expression().$line()], node.$loc().$dup())\n          } else {\n          return node\n        }}\n        else if (\"__ENCODING__\"['$===']($case)) {return self.$n(\"const\", [self.$n(\"const\", [nil, \"Encoding\"], nil), \"UTF_8\"], node.$loc().$dup())}\n        else if (\"ident\"['$===']($case)) {\n        $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), $a;\n        if ($truthy(self.parser.$static_env()['$declared?'](name))) {\n          return node.$updated(\"lvar\")\n          } else {\n          \n          $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), $a;\n          return self.$n(\"send\", [nil, name], self.$var_send_map(node));\n        };}\n        else {return node}})()\n      }, TMP_Default_accessible_48.$$arity = 1);\n      \n      Opal.defn(self, '$const', TMP_Default_const_49 = function(name_t) {\n        var self = this;\n\n        return self.$n(\"const\", [nil, self.$value(name_t).$to_sym()], self.$constant_map(nil, nil, name_t))\n      }, TMP_Default_const_49.$$arity = 1);\n      \n      Opal.defn(self, '$const_global', TMP_Default_const_global_50 = function $$const_global(t_colon3, name_t) {\n        var self = this, cbase = nil;\n\n        \n        cbase = self.$n0(\"cbase\", self.$token_map(t_colon3));\n        return self.$n(\"const\", [cbase, self.$value(name_t).$to_sym()], self.$constant_map(cbase, t_colon3, name_t));\n      }, TMP_Default_const_global_50.$$arity = 2);\n      \n      Opal.defn(self, '$const_fetch', TMP_Default_const_fetch_51 = function $$const_fetch(scope, t_colon2, name_t) {\n        var self = this;\n\n        return self.$n(\"const\", [scope, self.$value(name_t).$to_sym()], self.$constant_map(scope, t_colon2, name_t))\n      }, TMP_Default_const_fetch_51.$$arity = 3);\n      \n      Opal.defn(self, '$__ENCODING__', TMP_Default___ENCODING___52 = function $$__ENCODING__(__ENCODING__t) {\n        var self = this;\n\n        return self.$n0(\"__ENCODING__\", self.$token_map(__ENCODING__t))\n      }, TMP_Default___ENCODING___52.$$arity = 1);\n      \n      Opal.defn(self, '$assignable', TMP_Default_assignable_53 = function $$assignable(node) {\n        var $a, self = this, $case = nil, name = nil;\n\n        return (function() {$case = node.$type();\n        if (\"cvar\"['$===']($case)) {return node.$updated(\"cvasgn\")}\n        else if (\"ivar\"['$===']($case)) {return node.$updated(\"ivasgn\")}\n        else if (\"gvar\"['$===']($case)) {return node.$updated(\"gvasgn\")}\n        else if (\"const\"['$===']($case)) {\n        if ($truthy(self.parser['$in_def?']())) {\n          self.$diagnostic(\"error\", \"dynamic_const\", nil, node.$loc().$expression())};\n        return node.$updated(\"casgn\");}\n        else if (\"ident\"['$===']($case)) {\n        $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), $a;\n        self.parser.$static_env().$declare(name);\n        return node.$updated(\"lvasgn\");}\n        else if (\"nil\"['$===']($case) || \"self\"['$===']($case) || \"true\"['$===']($case) || \"false\"['$===']($case) || \"__FILE__\"['$===']($case) || \"__LINE__\"['$===']($case) || \"__ENCODING__\"['$===']($case)) {return self.$diagnostic(\"error\", \"invalid_assignment\", nil, node.$loc().$expression())}\n        else if (\"back_ref\"['$===']($case) || \"nth_ref\"['$===']($case)) {return self.$diagnostic(\"error\", \"backref_assignment\", nil, node.$loc().$expression())}\n        else { return nil }})()\n      }, TMP_Default_assignable_53.$$arity = 1);\n      \n      Opal.defn(self, '$const_op_assignable', TMP_Default_const_op_assignable_54 = function $$const_op_assignable(node) {\n        var self = this;\n\n        return node.$updated(\"casgn\")\n      }, TMP_Default_const_op_assignable_54.$$arity = 1);\n      \n      Opal.defn(self, '$assign', TMP_Default_assign_55 = function $$assign(lhs, eql_t, rhs) {\n        var self = this;\n\n        return lhs['$<<'](rhs).$updated(nil, nil, $hash2([\"location\"], {\"location\": lhs.$loc().$with_operator(self.$loc(eql_t)).$with_expression(self.$join_exprs(lhs, rhs))}))\n      }, TMP_Default_assign_55.$$arity = 3);\n      \n      Opal.defn(self, '$op_assign', TMP_Default_op_assign_56 = function $$op_assign(lhs, op_t, rhs) {\n        var self = this, $case = nil, operator = nil, source_map = nil;\n\n        return (function() {$case = lhs.$type();\n        if (\"gvasgn\"['$===']($case) || \"ivasgn\"['$===']($case) || \"lvasgn\"['$===']($case) || \"cvasgn\"['$===']($case) || \"casgn\"['$===']($case) || \"send\"['$===']($case) || \"csend\"['$===']($case)) {\n        operator = self.$value(op_t)['$[]']($range(0, -1, false)).$to_sym();\n        source_map = lhs.$loc().$with_operator(self.$loc(op_t)).$with_expression(self.$join_exprs(lhs, rhs));\n        return (function() {$case = operator;\n        if (\"&&\"['$===']($case)) {return self.$n(\"and_asgn\", [lhs, rhs], source_map)}\n        else if (\"||\"['$===']($case)) {return self.$n(\"or_asgn\", [lhs, rhs], source_map)}\n        else {return self.$n(\"op_asgn\", [lhs, operator, rhs], source_map)}})();}\n        else if (\"back_ref\"['$===']($case) || \"nth_ref\"['$===']($case)) {return self.$diagnostic(\"error\", \"backref_assignment\", nil, lhs.$loc().$expression())}\n        else { return nil }})()\n      }, TMP_Default_op_assign_56.$$arity = 3);\n      \n      Opal.defn(self, '$multi_lhs', TMP_Default_multi_lhs_57 = function $$multi_lhs(begin_t, items, end_t) {\n        var self = this;\n\n        return self.$n(\"mlhs\", [].concat(Opal.to_a(items)), self.$collection_map(begin_t, items, end_t))\n      }, TMP_Default_multi_lhs_57.$$arity = 3);\n      \n      Opal.defn(self, '$multi_assign', TMP_Default_multi_assign_58 = function $$multi_assign(lhs, eql_t, rhs) {\n        var self = this;\n\n        return self.$n(\"masgn\", [lhs, rhs], self.$binary_op_map(lhs, eql_t, rhs))\n      }, TMP_Default_multi_assign_58.$$arity = 3);\n      \n      Opal.defn(self, '$def_class', TMP_Default_def_class_59 = function $$def_class(class_t, name, lt_t, superclass, body, end_t) {\n        var self = this;\n\n        return self.$n(\"class\", [name, superclass, body], self.$module_definition_map(class_t, name, lt_t, end_t))\n      }, TMP_Default_def_class_59.$$arity = 6);\n      \n      Opal.defn(self, '$def_sclass', TMP_Default_def_sclass_60 = function $$def_sclass(class_t, lshft_t, expr, body, end_t) {\n        var self = this;\n\n        return self.$n(\"sclass\", [expr, body], self.$module_definition_map(class_t, nil, lshft_t, end_t))\n      }, TMP_Default_def_sclass_60.$$arity = 5);\n      \n      Opal.defn(self, '$def_module', TMP_Default_def_module_61 = function $$def_module(module_t, name, body, end_t) {\n        var self = this;\n\n        return self.$n(\"module\", [name, body], self.$module_definition_map(module_t, name, nil, end_t))\n      }, TMP_Default_def_module_61.$$arity = 4);\n      \n      Opal.defn(self, '$def_method', TMP_Default_def_method_62 = function $$def_method(def_t, name_t, args, body, end_t) {\n        var self = this;\n\n        return self.$n(\"def\", [self.$value(name_t).$to_sym(), args, body], self.$definition_map(def_t, nil, name_t, end_t))\n      }, TMP_Default_def_method_62.$$arity = 5);\n      \n      Opal.defn(self, '$def_singleton', TMP_Default_def_singleton_63 = function $$def_singleton(def_t, definee, dot_t, name_t, args, body, end_t) {\n        var self = this, $case = nil;\n\n        return (function() {$case = definee.$type();\n        if (\"int\"['$===']($case) || \"str\"['$===']($case) || \"dstr\"['$===']($case) || \"sym\"['$===']($case) || \"dsym\"['$===']($case) || \"regexp\"['$===']($case) || \"array\"['$===']($case) || \"hash\"['$===']($case)) {return self.$diagnostic(\"error\", \"singleton_literal\", nil, definee.$loc().$expression())}\n        else {return self.$n(\"defs\", [definee, self.$value(name_t).$to_sym(), args, body], self.$definition_map(def_t, dot_t, name_t, end_t))}})()\n      }, TMP_Default_def_singleton_63.$$arity = 7);\n      \n      Opal.defn(self, '$undef_method', TMP_Default_undef_method_64 = function $$undef_method(undef_t, names) {\n        var self = this;\n\n        return self.$n(\"undef\", [].concat(Opal.to_a(names)), self.$keyword_map(undef_t, nil, names, nil))\n      }, TMP_Default_undef_method_64.$$arity = 2);\n      \n      Opal.defn(self, '$alias', TMP_Default_alias_65 = function $$alias(alias_t, to, from) {\n        var self = this;\n\n        return self.$n(\"alias\", [to, from], self.$keyword_map(alias_t, nil, [to, from], nil))\n      }, TMP_Default_alias_65.$$arity = 3);\n      \n      Opal.defn(self, '$args', TMP_Default_args_66 = function $$args(begin_t, args, end_t, check_args) {\n        var self = this;\n\n        if (check_args == null) {\n          check_args = true;\n        }\n        \n        if ($truthy(check_args)) {\n          args = self.$check_duplicate_args(args)};\n        return self.$n(\"args\", args, self.$collection_map(begin_t, args, end_t));\n      }, TMP_Default_args_66.$$arity = -4);\n      \n      Opal.defn(self, '$arg', TMP_Default_arg_67 = function $$arg(name_t) {\n        var self = this;\n\n        return self.$n(\"arg\", [self.$value(name_t).$to_sym()], self.$variable_map(name_t))\n      }, TMP_Default_arg_67.$$arity = 1);\n      \n      Opal.defn(self, '$optarg', TMP_Default_optarg_68 = function $$optarg(name_t, eql_t, value) {\n        var self = this;\n\n        return self.$n(\"optarg\", [self.$value(name_t).$to_sym(), value], self.$variable_map(name_t).$with_operator(self.$loc(eql_t)).$with_expression(self.$loc(name_t).$join(value.$loc().$expression())))\n      }, TMP_Default_optarg_68.$$arity = 3);\n      \n      Opal.defn(self, '$restarg', TMP_Default_restarg_69 = function $$restarg(star_t, name_t) {\n        var self = this;\n\n        if (name_t == null) {\n          name_t = nil;\n        }\n        if ($truthy(name_t)) {\n          return self.$n(\"restarg\", [self.$value(name_t).$to_sym()], self.$arg_prefix_map(star_t, name_t))\n          } else {\n          return self.$n0(\"restarg\", self.$arg_prefix_map(star_t))\n        }\n      }, TMP_Default_restarg_69.$$arity = -2);\n      \n      Opal.defn(self, '$kwarg', TMP_Default_kwarg_70 = function $$kwarg(name_t) {\n        var self = this;\n\n        return self.$n(\"kwarg\", [self.$value(name_t).$to_sym()], self.$kwarg_map(name_t))\n      }, TMP_Default_kwarg_70.$$arity = 1);\n      \n      Opal.defn(self, '$kwoptarg', TMP_Default_kwoptarg_71 = function $$kwoptarg(name_t, value) {\n        var self = this;\n\n        return self.$n(\"kwoptarg\", [self.$value(name_t).$to_sym(), value], self.$kwarg_map(name_t, value))\n      }, TMP_Default_kwoptarg_71.$$arity = 2);\n      \n      Opal.defn(self, '$kwrestarg', TMP_Default_kwrestarg_72 = function $$kwrestarg(dstar_t, name_t) {\n        var self = this;\n\n        if (name_t == null) {\n          name_t = nil;\n        }\n        if ($truthy(name_t)) {\n          return self.$n(\"kwrestarg\", [self.$value(name_t).$to_sym()], self.$arg_prefix_map(dstar_t, name_t))\n          } else {\n          return self.$n0(\"kwrestarg\", self.$arg_prefix_map(dstar_t))\n        }\n      }, TMP_Default_kwrestarg_72.$$arity = -2);\n      \n      Opal.defn(self, '$shadowarg', TMP_Default_shadowarg_73 = function $$shadowarg(name_t) {\n        var self = this;\n\n        return self.$n(\"shadowarg\", [self.$value(name_t).$to_sym()], self.$variable_map(name_t))\n      }, TMP_Default_shadowarg_73.$$arity = 1);\n      \n      Opal.defn(self, '$blockarg', TMP_Default_blockarg_74 = function $$blockarg(amper_t, name_t) {\n        var self = this;\n\n        return self.$n(\"blockarg\", [self.$value(name_t).$to_sym()], self.$arg_prefix_map(amper_t, name_t))\n      }, TMP_Default_blockarg_74.$$arity = 2);\n      \n      Opal.defn(self, '$procarg0', TMP_Default_procarg0_75 = function $$procarg0(arg) {\n        var self = this;\n\n        if ($truthy(self.$class().$emit_procarg0())) {\n          return arg.$updated(\"procarg0\")\n          } else {\n          return arg\n        }\n      }, TMP_Default_procarg0_75.$$arity = 1);\n      \n      Opal.defn(self, '$arg_expr', TMP_Default_arg_expr_76 = function $$arg_expr(expr) {\n        var self = this;\n\n        if (expr.$type()['$=='](\"lvasgn\")) {\n          return expr.$updated(\"arg\")\n          } else {\n          return self.$n(\"arg_expr\", [expr], expr.$loc().$dup())\n        }\n      }, TMP_Default_arg_expr_76.$$arity = 1);\n      \n      Opal.defn(self, '$restarg_expr', TMP_Default_restarg_expr_77 = function $$restarg_expr(star_t, expr) {\n        var self = this;\n\n        if (expr == null) {\n          expr = nil;\n        }\n        if ($truthy(expr['$nil?']())) {\n          return self.$n0(\"restarg\", self.$token_map(star_t))\n        } else if (expr.$type()['$=='](\"lvasgn\")) {\n          return expr.$updated(\"restarg\")\n          } else {\n          return self.$n(\"restarg_expr\", [expr], expr.$loc().$dup())\n        }\n      }, TMP_Default_restarg_expr_77.$$arity = -2);\n      \n      Opal.defn(self, '$blockarg_expr', TMP_Default_blockarg_expr_78 = function $$blockarg_expr(amper_t, expr) {\n        var self = this;\n\n        if (expr.$type()['$=='](\"lvasgn\")) {\n          return expr.$updated(\"blockarg\")\n          } else {\n          return self.$n(\"blockarg_expr\", [expr], expr.$loc().$dup())\n        }\n      }, TMP_Default_blockarg_expr_78.$$arity = 2);\n      \n      Opal.defn(self, '$objc_kwarg', TMP_Default_objc_kwarg_79 = function $$objc_kwarg(kwname_t, assoc_t, name_t) {\n        var self = this, kwname_l = nil, operator_l = nil;\n\n        \n        kwname_l = self.$loc(kwname_t);\n        if ($truthy(assoc_t['$nil?']())) {\n          \n          kwname_l = kwname_l.$resize($rb_minus(kwname_l.$size(), 1));\n          operator_l = kwname_l.$end().$resize(1);\n          } else {\n          operator_l = self.$loc(assoc_t)\n        };\n        return self.$n(\"objc_kwarg\", [self.$value(kwname_t).$to_sym(), self.$value(name_t).$to_sym()], Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'ObjcKwarg').$new(kwname_l, operator_l, self.$loc(name_t), kwname_l.$join(self.$loc(name_t))));\n      }, TMP_Default_objc_kwarg_79.$$arity = 3);\n      \n      Opal.defn(self, '$objc_restarg', TMP_Default_objc_restarg_80 = function $$objc_restarg(star_t, name) {\n        var self = this;\n\n        if (name == null) {\n          name = nil;\n        }\n        if ($truthy(name['$nil?']())) {\n          return self.$n0(\"restarg\", self.$arg_prefix_map(star_t))\n        } else if (name.$type()['$=='](\"arg\")) {\n          return name.$updated(\"restarg\", nil, $hash2([\"location\"], {\"location\": name.$loc().$with_operator(self.$loc(star_t))}))\n          } else {\n          return self.$n(\"objc_restarg\", [name], self.$unary_op_map(star_t, name))\n        }\n      }, TMP_Default_objc_restarg_80.$$arity = -2);\n      \n      Opal.defn(self, '$call_type_for_dot', TMP_Default_call_type_for_dot_81 = function $$call_type_for_dot(dot_t) {\n        var $a, self = this;\n\n        if ($truthy(($truthy($a = dot_t['$nil?']()['$!']()) ? self.$value(dot_t)['$=='](\"anddot\") : $a))) {\n          return \"csend\"\n          } else {\n          return \"send\"\n        }\n      }, TMP_Default_call_type_for_dot_81.$$arity = 1);\n      \n      Opal.defn(self, '$call_method', TMP_Default_call_method_82 = function $$call_method(receiver, dot_t, selector_t, lparen_t, args, rparen_t) {\n        var self = this, type = nil;\n\n        if (lparen_t == null) {\n          lparen_t = nil;\n        }\n        if (args == null) {\n          args = [];\n        }\n        if (rparen_t == null) {\n          rparen_t = nil;\n        }\n        \n        type = self.$call_type_for_dot(dot_t);\n        if ($truthy(selector_t['$nil?']())) {\n          return self.$n(type, [receiver, \"call\"].concat(Opal.to_a(args)), self.$send_map(receiver, dot_t, nil, lparen_t, args, rparen_t))\n          } else {\n          return self.$n(type, [receiver, self.$value(selector_t).$to_sym()].concat(Opal.to_a(args)), self.$send_map(receiver, dot_t, selector_t, lparen_t, args, rparen_t))\n        };\n      }, TMP_Default_call_method_82.$$arity = -4);\n      \n      Opal.defn(self, '$call_lambda', TMP_Default_call_lambda_83 = function $$call_lambda(lambda_t) {\n        var self = this;\n\n        if ($truthy(self.$class().$emit_lambda())) {\n          return self.$n0(\"lambda\", self.$expr_map(self.$loc(lambda_t)))\n          } else {\n          return self.$n(\"send\", [nil, \"lambda\"], self.$send_map(nil, nil, lambda_t))\n        }\n      }, TMP_Default_call_lambda_83.$$arity = 1);\n      \n      Opal.defn(self, '$block', TMP_Default_block_84 = function $$block(method_call, begin_t, args, body, end_t) {\n        var $a, self = this, _receiver = nil, _selector = nil, call_args = nil, last_arg = nil, actual_send = nil, block = nil;\n\n        \n        $a = [].concat(Opal.to_a(method_call)), (_receiver = ($a[0] == null ? nil : $a[0])), (_selector = ($a[1] == null ? nil : $a[1])), (call_args = $slice.call($a, 2)), $a;\n        if (method_call.$type()['$=='](\"yield\")) {\n          self.$diagnostic(\"error\", \"block_given_to_yield\", nil, method_call.$loc().$keyword(), [self.$loc(begin_t)])};\n        last_arg = call_args.$last();\n        if ($truthy(($truthy($a = last_arg) ? last_arg.$type()['$=='](\"block_pass\") : $a))) {\n          self.$diagnostic(\"error\", \"block_and_blockarg\", nil, last_arg.$loc().$expression(), [self.$loc(begin_t)])};\n        if ($truthy([\"send\", \"csend\", \"super\", \"zsuper\", \"lambda\"]['$include?'](method_call.$type()))) {\n          return self.$n(\"block\", [method_call, args, body], self.$block_map(method_call.$loc().$expression(), begin_t, end_t))\n          } else {\n          \n          $a = [].concat(Opal.to_a(method_call)), (actual_send = ($a[0] == null ? nil : $a[0])), $a;\n          block = self.$n(\"block\", [actual_send, args, body], self.$block_map(actual_send.$loc().$expression(), begin_t, end_t));\n          return self.$n(method_call.$type(), [block], method_call.$loc().$with_expression(self.$join_exprs(method_call, block)));\n        };\n      }, TMP_Default_block_84.$$arity = 5);\n      \n      Opal.defn(self, '$block_pass', TMP_Default_block_pass_85 = function $$block_pass(amper_t, arg) {\n        var self = this;\n\n        return self.$n(\"block_pass\", [arg], self.$unary_op_map(amper_t, arg))\n      }, TMP_Default_block_pass_85.$$arity = 2);\n      \n      Opal.defn(self, '$objc_varargs', TMP_Default_objc_varargs_86 = function $$objc_varargs(pair, rest_of_varargs) {\n        var $a, self = this, value = nil, first_vararg = nil, vararg_array = nil;\n\n        \n        $a = [].concat(Opal.to_a(pair)), (value = ($a[0] == null ? nil : $a[0])), (first_vararg = ($a[1] == null ? nil : $a[1])), $a;\n        vararg_array = self.$array(nil, [first_vararg].concat(Opal.to_a(rest_of_varargs)), nil).$updated(\"objc_varargs\");\n        return pair.$updated(nil, [value, vararg_array], $hash2([\"location\"], {\"location\": pair.$loc().$with_expression(pair.$loc().$expression().$join(vararg_array.$loc().$expression()))}));\n      }, TMP_Default_objc_varargs_86.$$arity = 2);\n      \n      Opal.defn(self, '$attr_asgn', TMP_Default_attr_asgn_87 = function $$attr_asgn(receiver, dot_t, selector_t) {\n        var self = this, method_name = nil, type = nil;\n\n        \n        method_name = $rb_plus(self.$value(selector_t), \"=\").$to_sym();\n        type = self.$call_type_for_dot(dot_t);\n        return self.$n(type, [receiver, method_name], self.$send_map(receiver, dot_t, selector_t));\n      }, TMP_Default_attr_asgn_87.$$arity = 3);\n      \n      Opal.defn(self, '$index', TMP_Default_index_88 = function $$index(receiver, lbrack_t, indexes, rbrack_t) {\n        var self = this;\n\n        return self.$n(\"send\", [receiver, \"[]\"].concat(Opal.to_a(indexes)), self.$send_index_map(receiver, lbrack_t, rbrack_t))\n      }, TMP_Default_index_88.$$arity = 4);\n      \n      Opal.defn(self, '$index_asgn', TMP_Default_index_asgn_89 = function $$index_asgn(receiver, lbrack_t, indexes, rbrack_t) {\n        var self = this;\n\n        return self.$n(\"send\", [receiver, \"[]=\"].concat(Opal.to_a(indexes)), self.$send_index_map(receiver, lbrack_t, rbrack_t))\n      }, TMP_Default_index_asgn_89.$$arity = 4);\n      \n      Opal.defn(self, '$binary_op', TMP_Default_binary_op_90 = function $$binary_op(receiver, operator_t, arg) {\n        var self = this, source_map = nil, operator = nil, method_call = nil;\n\n        \n        source_map = self.$send_binary_op_map(receiver, operator_t, arg);\n        if (self.parser.$version()['$=='](18)) {\n          \n          operator = self.$value(operator_t);\n          if (operator['$=='](\"!=\")) {\n            method_call = self.$n(\"send\", [receiver, \"==\", arg], source_map)\n          } else if (operator['$=='](\"!~\")) {\n            method_call = self.$n(\"send\", [receiver, \"=~\", arg], source_map)};\n          if ($truthy([\"!=\", \"!~\"]['$include?'](operator))) {\n            return self.$n(\"not\", [method_call], self.$expr_map(source_map.$expression()))};};\n        return self.$n(\"send\", [receiver, self.$value(operator_t).$to_sym(), arg], source_map);\n      }, TMP_Default_binary_op_90.$$arity = 3);\n      \n      Opal.defn(self, '$match_op', TMP_Default_match_op_92 = function $$match_op(receiver, match_t, arg) {\n        var TMP_91, self = this, source_map = nil, regexp = nil;\n\n        \n        source_map = self.$send_binary_op_map(receiver, match_t, arg);\n        if ($truthy((regexp = self.$static_regexp_node(receiver)))) {\n          \n          $send(regexp.$names(), 'each', [], (TMP_91 = function(name){var self = TMP_91.$$s || this;\n            if (self.parser == null) self.parser = nil;\nif (name == null) name = nil;\n          return self.parser.$static_env().$declare(name)}, TMP_91.$$s = self, TMP_91.$$arity = 1, TMP_91));\n          return self.$n(\"match_with_lvasgn\", [receiver, arg], source_map);\n          } else {\n          return self.$n(\"send\", [receiver, \"=~\", arg], source_map)\n        };\n      }, TMP_Default_match_op_92.$$arity = 3);\n      \n      Opal.defn(self, '$unary_op', TMP_Default_unary_op_93 = function $$unary_op(op_t, receiver) {\n        var self = this, $case = nil, method = nil;\n\n        \n        $case = self.$value(op_t);\n        if (\"+\"['$===']($case) || \"-\"['$===']($case)) {method = $rb_plus(self.$value(op_t), \"@\")}\n        else {method = self.$value(op_t)};\n        return self.$n(\"send\", [receiver, method.$to_sym()], self.$send_unary_op_map(op_t, receiver));\n      }, TMP_Default_unary_op_93.$$arity = 2);\n      \n      Opal.defn(self, '$not_op', TMP_Default_not_op_94 = function $$not_op(not_t, begin_t, receiver, end_t) {\n        var self = this, nil_node = nil;\n\n        if (begin_t == null) {\n          begin_t = nil;\n        }\n        if (receiver == null) {\n          receiver = nil;\n        }\n        if (end_t == null) {\n          end_t = nil;\n        }\n        if (self.parser.$version()['$=='](18)) {\n          return self.$n(\"not\", [receiver], self.$unary_op_map(not_t, receiver))\n        } else if ($truthy(receiver['$nil?']())) {\n          \n          nil_node = self.$n0(\"begin\", self.$collection_map(begin_t, nil, end_t));\n          return self.$n(\"send\", [nil_node, \"!\"], self.$send_unary_op_map(not_t, nil_node));\n          } else {\n          return self.$n(\"send\", [receiver, \"!\"], self.$send_map(nil, nil, not_t, begin_t, [receiver], end_t))\n        }\n      }, TMP_Default_not_op_94.$$arity = -2);\n      \n      Opal.defn(self, '$logical_op', TMP_Default_logical_op_95 = function $$logical_op(type, lhs, op_t, rhs) {\n        var self = this;\n\n        return self.$n(type, [lhs, rhs], self.$binary_op_map(lhs, op_t, rhs))\n      }, TMP_Default_logical_op_95.$$arity = 4);\n      \n      Opal.defn(self, '$condition', TMP_Default_condition_96 = function $$condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t) {\n        var self = this;\n\n        return self.$n(\"if\", [self.$check_condition(cond), if_true, if_false], self.$condition_map(cond_t, cond, then_t, if_true, else_t, if_false, end_t))\n      }, TMP_Default_condition_96.$$arity = 7);\n      \n      Opal.defn(self, '$condition_mod', TMP_Default_condition_mod_97 = function $$condition_mod(if_true, if_false, cond_t, cond) {\n        var $a, self = this;\n\n        return self.$n(\"if\", [self.$check_condition(cond), if_true, if_false], self.$keyword_mod_map(($truthy($a = if_true) ? $a : if_false), cond_t, cond))\n      }, TMP_Default_condition_mod_97.$$arity = 4);\n      \n      Opal.defn(self, '$ternary', TMP_Default_ternary_98 = function $$ternary(cond, question_t, if_true, colon_t, if_false) {\n        var self = this;\n\n        return self.$n(\"if\", [self.$check_condition(cond), if_true, if_false], self.$ternary_map(cond, question_t, if_true, colon_t, if_false))\n      }, TMP_Default_ternary_98.$$arity = 5);\n      \n      Opal.defn(self, '$when', TMP_Default_when_99 = function $$when(when_t, patterns, then_t, body) {\n        var self = this, children = nil;\n\n        \n        children = patterns['$<<'](body);\n        return self.$n(\"when\", children, self.$keyword_map(when_t, then_t, children, nil));\n      }, TMP_Default_when_99.$$arity = 4);\n      \n      Opal.defn(self, '$case', TMP_Default_case_100 = function(case_t, expr, when_bodies, else_t, else_body, end_t) {\n        var self = this;\n\n        return self.$n(\"case\", [expr].concat(Opal.to_a(when_bodies['$<<'](else_body))), self.$condition_map(case_t, expr, nil, nil, else_t, else_body, end_t))\n      }, TMP_Default_case_100.$$arity = 6);\n      \n      Opal.defn(self, '$loop', TMP_Default_loop_101 = function $$loop(type, keyword_t, cond, do_t, body, end_t) {\n        var self = this;\n\n        return self.$n(type, [self.$check_condition(cond), body], self.$keyword_map(keyword_t, do_t, nil, end_t))\n      }, TMP_Default_loop_101.$$arity = 6);\n      \n      Opal.defn(self, '$loop_mod', TMP_Default_loop_mod_102 = function $$loop_mod(type, body, keyword_t, cond) {\n        var self = this;\n\n        \n        if (body.$type()['$=='](\"kwbegin\")) {\n          type = \"\" + (type) + \"_post\"};\n        return self.$n(type, [self.$check_condition(cond), body], self.$keyword_mod_map(body, keyword_t, cond));\n      }, TMP_Default_loop_mod_102.$$arity = 4);\n      \n      Opal.defn(self, '$for', TMP_Default_for_103 = function(for_t, iterator, in_t, iteratee, do_t, body, end_t) {\n        var self = this;\n\n        return self.$n(\"for\", [iterator, iteratee, body], self.$for_map(for_t, in_t, do_t, end_t))\n      }, TMP_Default_for_103.$$arity = 7);\n      \n      Opal.defn(self, '$keyword_cmd', TMP_Default_keyword_cmd_104 = function $$keyword_cmd(type, keyword_t, lparen_t, args, rparen_t) {\n        var $a, self = this, last_arg = nil;\n\n        if (lparen_t == null) {\n          lparen_t = nil;\n        }\n        if (args == null) {\n          args = [];\n        }\n        if (rparen_t == null) {\n          rparen_t = nil;\n        }\n        \n        if ($truthy((($a = type['$=='](\"yield\")) ? $rb_gt(args.$count(), 0) : type['$=='](\"yield\")))) {\n          \n          last_arg = args.$last();\n          if (last_arg.$type()['$=='](\"block_pass\")) {\n            self.$diagnostic(\"error\", \"block_given_to_yield\", nil, self.$loc(keyword_t), [last_arg.$loc().$expression()])};};\n        return self.$n(type, args, self.$keyword_map(keyword_t, lparen_t, args, rparen_t));\n      }, TMP_Default_keyword_cmd_104.$$arity = -3);\n      \n      Opal.defn(self, '$preexe', TMP_Default_preexe_105 = function $$preexe(preexe_t, lbrace_t, compstmt, rbrace_t) {\n        var self = this;\n\n        return self.$n(\"preexe\", [compstmt], self.$keyword_map(preexe_t, lbrace_t, [], rbrace_t))\n      }, TMP_Default_preexe_105.$$arity = 4);\n      \n      Opal.defn(self, '$postexe', TMP_Default_postexe_106 = function $$postexe(postexe_t, lbrace_t, compstmt, rbrace_t) {\n        var self = this;\n\n        return self.$n(\"postexe\", [compstmt], self.$keyword_map(postexe_t, lbrace_t, [], rbrace_t))\n      }, TMP_Default_postexe_106.$$arity = 4);\n      \n      Opal.defn(self, '$rescue_body', TMP_Default_rescue_body_107 = function $$rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt) {\n        var self = this;\n\n        return self.$n(\"resbody\", [exc_list, exc_var, compound_stmt], self.$rescue_body_map(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt))\n      }, TMP_Default_rescue_body_107.$$arity = 6);\n      \n      Opal.defn(self, '$begin_body', TMP_Default_begin_body_108 = function $$begin_body(compound_stmt, rescue_bodies, else_t, else_, ensure_t, ensure_) {\n        var self = this, statements = nil;\n\n        if (rescue_bodies == null) {\n          rescue_bodies = [];\n        }\n        if (else_t == null) {\n          else_t = nil;\n        }\n        if (else_ == null) {\n          else_ = nil;\n        }\n        if (ensure_t == null) {\n          ensure_t = nil;\n        }\n        if (ensure_ == null) {\n          ensure_ = nil;\n        }\n        \n        if ($truthy(rescue_bodies['$any?']())) {\n          if ($truthy(else_t)) {\n            compound_stmt = self.$n(\"rescue\", [compound_stmt].concat(Opal.to_a($rb_plus(rescue_bodies, [else_]))), self.$eh_keyword_map(compound_stmt, nil, rescue_bodies, else_t, else_))\n            } else {\n            compound_stmt = self.$n(\"rescue\", [compound_stmt].concat(Opal.to_a($rb_plus(rescue_bodies, [nil]))), self.$eh_keyword_map(compound_stmt, nil, rescue_bodies, nil, nil))\n          }\n        } else if ($truthy(else_t)) {\n          \n          statements = [];\n          if ($truthy(compound_stmt['$nil?']()['$!']())) {\n            if (compound_stmt.$type()['$=='](\"begin\")) {\n              statements = $rb_plus(statements, compound_stmt.$children())\n              } else {\n              statements.$push(compound_stmt)\n            }};\n          statements.$push(self.$n(\"begin\", [else_], self.$collection_map(else_t, [else_], nil)));\n          compound_stmt = self.$n(\"begin\", statements, self.$collection_map(nil, statements, nil));};\n        if ($truthy(ensure_t)) {\n          compound_stmt = self.$n(\"ensure\", [compound_stmt, ensure_], self.$eh_keyword_map(compound_stmt, ensure_t, [ensure_], nil, nil))};\n        return compound_stmt;\n      }, TMP_Default_begin_body_108.$$arity = -2);\n      \n      Opal.defn(self, '$compstmt', TMP_Default_compstmt_109 = function $$compstmt(statements) {\n        var self = this;\n\n        return (function() {\n        if ($truthy(statements['$none?']())) {return nil}\n        else if ($truthy(statements['$one?']())) {return statements.$first()}\n        else {return self.$n(\"begin\", statements, self.$collection_map(nil, statements, nil))}})()\n      }, TMP_Default_compstmt_109.$$arity = 1);\n      \n      Opal.defn(self, '$begin', TMP_Default_begin_110 = function $$begin(begin_t, body, end_t) {\n        var $a, $b, $c, self = this;\n\n        if ($truthy(body['$nil?']())) {\n          return self.$n0(\"begin\", self.$collection_map(begin_t, nil, end_t))\n        } else if ($truthy(($truthy($a = body.$type()['$=='](\"mlhs\")) ? $a : ($truthy($b = (($c = body.$type()['$=='](\"begin\")) ? body.$loc().$begin()['$nil?']() : body.$type()['$=='](\"begin\"))) ? body.$loc().$end()['$nil?']() : $b)))) {\n          return self.$n(body.$type(), body.$children(), self.$collection_map(begin_t, body.$children(), end_t))\n          } else {\n          return self.$n(\"begin\", [body], self.$collection_map(begin_t, [body], end_t))\n        }\n      }, TMP_Default_begin_110.$$arity = 3);\n      \n      Opal.defn(self, '$begin_keyword', TMP_Default_begin_keyword_111 = function $$begin_keyword(begin_t, body, end_t) {\n        var $a, $b, self = this;\n\n        if ($truthy(body['$nil?']())) {\n          return self.$n0(\"kwbegin\", self.$collection_map(begin_t, nil, end_t))\n        } else if ($truthy(($truthy($a = (($b = body.$type()['$=='](\"begin\")) ? body.$loc().$begin()['$nil?']() : body.$type()['$=='](\"begin\"))) ? body.$loc().$end()['$nil?']() : $a))) {\n          return self.$n(\"kwbegin\", body.$children(), self.$collection_map(begin_t, body.$children(), end_t))\n          } else {\n          return self.$n(\"kwbegin\", [body], self.$collection_map(begin_t, [body], end_t))\n        }\n      }, TMP_Default_begin_keyword_111.$$arity = 3);\n      self.$private();\n      \n      Opal.defn(self, '$check_condition', TMP_Default_check_condition_112 = function $$check_condition(cond) {\n        var $a, self = this, $case = nil, lhs = nil, rhs = nil, type = nil;\n\n        return (function() {$case = cond.$type();\n        if (\"masgn\"['$===']($case)) {if ($truthy($rb_le(self.parser.$version(), 23))) {\n          return self.$diagnostic(\"error\", \"masgn_as_condition\", nil, cond.$loc().$expression())\n          } else {\n          return nil\n        }}\n        else if (\"begin\"['$===']($case)) {if (cond.$children().$count()['$=='](1)) {\n          return cond.$updated(nil, [self.$check_condition(cond.$children().$last())])\n          } else {\n          return cond\n        }}\n        else if (\"and\"['$===']($case) || \"or\"['$===']($case) || \"irange\"['$===']($case) || \"erange\"['$===']($case)) {\n        $a = [].concat(Opal.to_a(cond)), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;\n        type = (function() {$case = cond.$type();\n        if (\"irange\"['$===']($case)) {return \"iflipflop\"}\n        else if (\"erange\"['$===']($case)) {return \"eflipflop\"}\n        else { return nil }})();\n        if ($truthy(($truthy($a = [\"and\", \"or\"]['$include?'](cond.$type())) ? self.parser.$version()['$=='](18) : $a))) {\n          return cond\n          } else {\n          return cond.$updated(type, [self.$check_condition(lhs), self.$check_condition(rhs)])\n        };}\n        else if (\"regexp\"['$===']($case)) {return self.$n(\"match_current_line\", [cond], self.$expr_map(cond.$loc().$expression()))}\n        else {return cond}})()\n      }, TMP_Default_check_condition_112.$$arity = 1);\n      \n      Opal.defn(self, '$check_duplicate_args', TMP_Default_check_duplicate_args_114 = function $$check_duplicate_args(args, map) {\n        var TMP_113, self = this;\n\n        if (map == null) {\n          map = $hash2([], {});\n        }\n        return $send(args, 'each', [], (TMP_113 = function(this_arg){var self = TMP_113.$$s || this, $a, $case = nil, this_name = nil, that_arg = nil, that_name = nil, $writer = nil;\nif (this_arg == null) this_arg = nil;\n        return (function() {$case = this_arg.$type();\n          if (\"arg\"['$===']($case) || \"optarg\"['$===']($case) || \"restarg\"['$===']($case) || \"blockarg\"['$===']($case) || \"kwarg\"['$===']($case) || \"kwoptarg\"['$===']($case) || \"kwrestarg\"['$===']($case) || \"shadowarg\"['$===']($case) || \"procarg0\"['$===']($case)) {\n          $a = [].concat(Opal.to_a(this_arg)), (this_name = ($a[0] == null ? nil : $a[0])), $a;\n          that_arg = map['$[]'](this_name);\n          $a = [].concat(Opal.to_a(that_arg)), (that_name = ($a[0] == null ? nil : $a[0])), $a;\n          if ($truthy(that_arg['$nil?']())) {\n            \n            $writer = [this_name, this_arg];\n            $send(map, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          } else if ($truthy(self['$arg_name_collides?'](this_name, that_name))) {\n            return self.$diagnostic(\"error\", \"duplicate_argument\", nil, this_arg.$loc().$name(), [that_arg.$loc().$name()])\n            } else {\n            return nil\n          };}\n          else if (\"mlhs\"['$===']($case)) {return self.$check_duplicate_args(this_arg.$children(), map)}\n          else { return nil }})()}, TMP_113.$$s = self, TMP_113.$$arity = 1, TMP_113))\n      }, TMP_Default_check_duplicate_args_114.$$arity = -2);\n      \n      Opal.defn(self, '$arg_name_collides?', TMP_Default_arg_name_collides$q_115 = function(this_name, that_name) {\n        var $a, $b, self = this, $case = nil;\n\n        return (function() {$case = self.parser.$version();\n        if ((18)['$===']($case)) {return this_name['$=='](that_name)}\n        else if ((19)['$===']($case)) {return ($truthy($a = this_name['$!='](\"_\")) ? this_name['$=='](that_name) : $a)}\n        else {return ($truthy($a = ($truthy($b = this_name) ? this_name['$[]'](0)['$!='](\"_\") : $b)) ? this_name['$=='](that_name) : $a)}})()\n      }, TMP_Default_arg_name_collides$q_115.$$arity = 2);\n      \n      Opal.defn(self, '$n', TMP_Default_n_116 = function $$n(type, children, source_map) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'AST'), 'Node').$new(type, children, $hash2([\"location\"], {\"location\": source_map}))\n      }, TMP_Default_n_116.$$arity = 3);\n      \n      Opal.defn(self, '$n0', TMP_Default_n0_117 = function $$n0(type, source_map) {\n        var self = this;\n\n        return self.$n(type, [], source_map)\n      }, TMP_Default_n0_117.$$arity = 2);\n      \n      Opal.defn(self, '$join_exprs', TMP_Default_join_exprs_118 = function $$join_exprs(left_expr, right_expr) {\n        var self = this;\n\n        return left_expr.$loc().$expression().$join(right_expr.$loc().$expression())\n      }, TMP_Default_join_exprs_118.$$arity = 2);\n      \n      Opal.defn(self, '$token_map', TMP_Default_token_map_119 = function $$token_map(token) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map').$new(self.$loc(token))\n      }, TMP_Default_token_map_119.$$arity = 1);\n      \n      Opal.defn(self, '$delimited_string_map', TMP_Default_delimited_string_map_120 = function $$delimited_string_map(string_t) {\n        var self = this, str_range = nil, begin_l = nil, end_l = nil;\n\n        \n        str_range = self.$loc(string_t);\n        begin_l = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Range').$new(str_range.$source_buffer(), str_range.$begin_pos(), $rb_plus(str_range.$begin_pos(), 1));\n        end_l = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Range').$new(str_range.$source_buffer(), $rb_minus(str_range.$end_pos(), 1), str_range.$end_pos());\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Collection').$new(begin_l, end_l, self.$loc(string_t));\n      }, TMP_Default_delimited_string_map_120.$$arity = 1);\n      \n      Opal.defn(self, '$prefix_string_map', TMP_Default_prefix_string_map_121 = function $$prefix_string_map(symbol) {\n        var self = this, str_range = nil, begin_l = nil;\n\n        \n        str_range = self.$loc(symbol);\n        begin_l = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Range').$new(str_range.$source_buffer(), str_range.$begin_pos(), $rb_plus(str_range.$begin_pos(), 1));\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Collection').$new(begin_l, nil, self.$loc(symbol));\n      }, TMP_Default_prefix_string_map_121.$$arity = 1);\n      \n      Opal.defn(self, '$unquoted_map', TMP_Default_unquoted_map_122 = function $$unquoted_map(token) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Collection').$new(nil, nil, self.$loc(token))\n      }, TMP_Default_unquoted_map_122.$$arity = 1);\n      \n      Opal.defn(self, '$pair_keyword_map', TMP_Default_pair_keyword_map_123 = function $$pair_keyword_map(key_t, value_e) {\n        var self = this, key_range = nil, key_l = nil, colon_l = nil;\n\n        \n        key_range = self.$loc(key_t);\n        key_l = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Range').$new(key_range.$source_buffer(), key_range.$begin_pos(), $rb_minus(key_range.$end_pos(), 1));\n        colon_l = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Range').$new(key_range.$source_buffer(), $rb_minus(key_range.$end_pos(), 1), key_range.$end_pos());\n        return [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Collection').$new(nil, nil, key_l), Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Operator').$new(colon_l, key_range.$join(value_e.$loc().$expression()))];\n      }, TMP_Default_pair_keyword_map_123.$$arity = 2);\n      \n      Opal.defn(self, '$pair_quoted_map', TMP_Default_pair_quoted_map_124 = function $$pair_quoted_map(begin_t, end_t, value_e) {\n        var self = this, end_l = nil, quote_l = nil, colon_l = nil;\n\n        \n        end_l = self.$loc(end_t);\n        quote_l = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Range').$new(end_l.$source_buffer(), $rb_minus(end_l.$end_pos(), 2), $rb_minus(end_l.$end_pos(), 1));\n        colon_l = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Range').$new(end_l.$source_buffer(), $rb_minus(end_l.$end_pos(), 1), end_l.$end_pos());\n        return [[self.$value(end_t), quote_l], Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Operator').$new(colon_l, self.$loc(begin_t).$join(value_e.$loc().$expression()))];\n      }, TMP_Default_pair_quoted_map_124.$$arity = 3);\n      \n      Opal.defn(self, '$expr_map', TMP_Default_expr_map_125 = function $$expr_map(loc) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map').$new(loc)\n      }, TMP_Default_expr_map_125.$$arity = 1);\n      \n      Opal.defn(self, '$collection_map', TMP_Default_collection_map_126 = function $$collection_map(begin_t, parts, end_t) {\n        var $a, self = this, expr_l = nil;\n\n        \n        if ($truthy(($truthy($a = begin_t['$nil?']()) ? $a : end_t['$nil?']()))) {\n          if ($truthy(parts['$any?']())) {\n            expr_l = self.$join_exprs(parts.$first(), parts.$last())}\n          } else {\n          expr_l = self.$loc(begin_t).$join(self.$loc(end_t))\n        };\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Collection').$new(self.$loc(begin_t), self.$loc(end_t), expr_l);\n      }, TMP_Default_collection_map_126.$$arity = 3);\n      \n      Opal.defn(self, '$string_map', TMP_Default_string_map_127 = function $$string_map(begin_t, parts, end_t) {\n        var $a, self = this, expr_l = nil;\n\n        if ($truthy(($truthy($a = begin_t) ? self.$value(begin_t)['$start_with?'](\"<<\") : $a))) {\n          \n          if ($truthy(parts['$any?']())) {\n            expr_l = self.$join_exprs(parts.$first(), parts.$last())\n            } else {\n            expr_l = self.$loc(end_t).$begin()\n          };\n          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Heredoc').$new(self.$loc(begin_t), expr_l, self.$loc(end_t));\n          } else {\n          return self.$collection_map(begin_t, parts, end_t)\n        }\n      }, TMP_Default_string_map_127.$$arity = 3);\n      \n      Opal.defn(self, '$regexp_map', TMP_Default_regexp_map_128 = function $$regexp_map(begin_t, end_t, options_e) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Collection').$new(self.$loc(begin_t), self.$loc(end_t), self.$loc(begin_t).$join(options_e.$loc().$expression()))\n      }, TMP_Default_regexp_map_128.$$arity = 3);\n      \n      Opal.defn(self, '$constant_map', TMP_Default_constant_map_129 = function $$constant_map(scope, colon2_t, name_t) {\n        var self = this, expr_l = nil;\n\n        \n        if ($truthy(scope['$nil?']())) {\n          expr_l = self.$loc(name_t)\n          } else {\n          expr_l = scope.$loc().$expression().$join(self.$loc(name_t))\n        };\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Constant').$new(self.$loc(colon2_t), self.$loc(name_t), expr_l);\n      }, TMP_Default_constant_map_129.$$arity = 3);\n      \n      Opal.defn(self, '$variable_map', TMP_Default_variable_map_130 = function $$variable_map(name_t) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Variable').$new(self.$loc(name_t))\n      }, TMP_Default_variable_map_130.$$arity = 1);\n      \n      Opal.defn(self, '$binary_op_map', TMP_Default_binary_op_map_131 = function $$binary_op_map(left_e, op_t, right_e) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Operator').$new(self.$loc(op_t), self.$join_exprs(left_e, right_e))\n      }, TMP_Default_binary_op_map_131.$$arity = 3);\n      \n      Opal.defn(self, '$unary_op_map', TMP_Default_unary_op_map_132 = function $$unary_op_map(op_t, arg_e) {\n        var self = this, expr_l = nil;\n\n        if (arg_e == null) {\n          arg_e = nil;\n        }\n        \n        if ($truthy(arg_e['$nil?']())) {\n          expr_l = self.$loc(op_t)\n          } else {\n          expr_l = self.$loc(op_t).$join(arg_e.$loc().$expression())\n        };\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Operator').$new(self.$loc(op_t), expr_l);\n      }, TMP_Default_unary_op_map_132.$$arity = -2);\n      \n      Opal.defn(self, '$arg_prefix_map', TMP_Default_arg_prefix_map_133 = function $$arg_prefix_map(op_t, name_t) {\n        var self = this, expr_l = nil;\n\n        if (name_t == null) {\n          name_t = nil;\n        }\n        \n        if ($truthy(name_t['$nil?']())) {\n          expr_l = self.$loc(op_t)\n          } else {\n          expr_l = self.$loc(op_t).$join(self.$loc(name_t))\n        };\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Variable').$new(self.$loc(name_t), expr_l);\n      }, TMP_Default_arg_prefix_map_133.$$arity = -2);\n      \n      Opal.defn(self, '$kwarg_map', TMP_Default_kwarg_map_134 = function $$kwarg_map(name_t, value_e) {\n        var self = this, label_range = nil, name_range = nil, expr_l = nil;\n\n        if (value_e == null) {\n          value_e = nil;\n        }\n        \n        label_range = self.$loc(name_t);\n        name_range = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Range').$new(label_range.$source_buffer(), label_range.$begin_pos(), $rb_minus(label_range.$end_pos(), 1));\n        if ($truthy(value_e)) {\n          expr_l = self.$loc(name_t).$join(value_e.$loc().$expression())\n          } else {\n          expr_l = self.$loc(name_t)\n        };\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Variable').$new(name_range, expr_l);\n      }, TMP_Default_kwarg_map_134.$$arity = -2);\n      \n      Opal.defn(self, '$module_definition_map', TMP_Default_module_definition_map_135 = function $$module_definition_map(keyword_t, name_e, operator_t, end_t) {\n        var self = this, name_l = nil;\n\n        \n        if ($truthy(name_e)) {\n          name_l = name_e.$loc().$expression()};\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Definition').$new(self.$loc(keyword_t), self.$loc(operator_t), name_l, self.$loc(end_t));\n      }, TMP_Default_module_definition_map_135.$$arity = 4);\n      \n      Opal.defn(self, '$definition_map', TMP_Default_definition_map_136 = function $$definition_map(keyword_t, operator_t, name_t, end_t) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Definition').$new(self.$loc(keyword_t), self.$loc(operator_t), self.$loc(name_t), self.$loc(end_t))\n      }, TMP_Default_definition_map_136.$$arity = 4);\n      \n      Opal.defn(self, '$send_map', TMP_Default_send_map_137 = function $$send_map(receiver_e, dot_t, selector_t, begin_t, args, end_t) {\n        var self = this, begin_l = nil, end_l = nil;\n\n        if (begin_t == null) {\n          begin_t = nil;\n        }\n        if (args == null) {\n          args = [];\n        }\n        if (end_t == null) {\n          end_t = nil;\n        }\n        \n        if ($truthy(receiver_e)) {\n          begin_l = receiver_e.$loc().$expression()\n        } else if ($truthy(selector_t)) {\n          begin_l = self.$loc(selector_t)};\n        if ($truthy(end_t)) {\n          end_l = self.$loc(end_t)\n        } else if ($truthy(args['$any?']())) {\n          end_l = args.$last().$loc().$expression()\n        } else if ($truthy(selector_t)) {\n          end_l = self.$loc(selector_t)};\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Send').$new(self.$loc(dot_t), self.$loc(selector_t), self.$loc(begin_t), self.$loc(end_t), begin_l.$join(end_l));\n      }, TMP_Default_send_map_137.$$arity = -4);\n      \n      Opal.defn(self, '$var_send_map', TMP_Default_var_send_map_138 = function $$var_send_map(variable_e) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Send').$new(nil, variable_e.$loc().$expression(), nil, nil, variable_e.$loc().$expression())\n      }, TMP_Default_var_send_map_138.$$arity = 1);\n      \n      Opal.defn(self, '$send_binary_op_map', TMP_Default_send_binary_op_map_139 = function $$send_binary_op_map(lhs_e, selector_t, rhs_e) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Send').$new(nil, self.$loc(selector_t), nil, nil, self.$join_exprs(lhs_e, rhs_e))\n      }, TMP_Default_send_binary_op_map_139.$$arity = 3);\n      \n      Opal.defn(self, '$send_unary_op_map', TMP_Default_send_unary_op_map_140 = function $$send_unary_op_map(selector_t, arg_e) {\n        var self = this, expr_l = nil;\n\n        \n        if ($truthy(arg_e['$nil?']())) {\n          expr_l = self.$loc(selector_t)\n          } else {\n          expr_l = self.$loc(selector_t).$join(arg_e.$loc().$expression())\n        };\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Send').$new(nil, self.$loc(selector_t), nil, nil, expr_l);\n      }, TMP_Default_send_unary_op_map_140.$$arity = 2);\n      \n      Opal.defn(self, '$send_index_map', TMP_Default_send_index_map_141 = function $$send_index_map(receiver_e, lbrack_t, rbrack_t) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Send').$new(nil, self.$loc(lbrack_t).$join(self.$loc(rbrack_t)), nil, nil, receiver_e.$loc().$expression().$join(self.$loc(rbrack_t)))\n      }, TMP_Default_send_index_map_141.$$arity = 3);\n      \n      Opal.defn(self, '$block_map', TMP_Default_block_map_142 = function $$block_map(receiver_l, begin_t, end_t) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Collection').$new(self.$loc(begin_t), self.$loc(end_t), receiver_l.$join(self.$loc(end_t)))\n      }, TMP_Default_block_map_142.$$arity = 3);\n      \n      Opal.defn(self, '$keyword_map', TMP_Default_keyword_map_143 = function $$keyword_map(keyword_t, begin_t, args, end_t) {\n        var $a, self = this, end_l = nil;\n\n        \n        args = ($truthy($a = args) ? $a : []);\n        if ($truthy(end_t)) {\n          end_l = self.$loc(end_t)\n        } else if ($truthy(($truthy($a = args['$any?']()) ? args.$last()['$nil?']()['$!']() : $a))) {\n          end_l = args.$last().$loc().$expression()\n        } else if ($truthy(($truthy($a = args['$any?']()) ? $rb_gt(args.$count(), 1) : $a))) {\n          end_l = args['$[]'](-2).$loc().$expression()\n          } else {\n          end_l = self.$loc(keyword_t)\n        };\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Keyword').$new(self.$loc(keyword_t), self.$loc(begin_t), self.$loc(end_t), self.$loc(keyword_t).$join(end_l));\n      }, TMP_Default_keyword_map_143.$$arity = 4);\n      \n      Opal.defn(self, '$keyword_mod_map', TMP_Default_keyword_mod_map_144 = function $$keyword_mod_map(pre_e, keyword_t, post_e) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Keyword').$new(self.$loc(keyword_t), nil, nil, self.$join_exprs(pre_e, post_e))\n      }, TMP_Default_keyword_mod_map_144.$$arity = 3);\n      \n      Opal.defn(self, '$condition_map', TMP_Default_condition_map_145 = function $$condition_map(keyword_t, cond_e, begin_t, body_e, else_t, else_e, end_t) {\n        var $a, self = this, end_l = nil;\n\n        \n        if ($truthy(end_t)) {\n          end_l = self.$loc(end_t)\n        } else if ($truthy(($truthy($a = else_e) ? else_e.$loc().$expression() : $a))) {\n          end_l = else_e.$loc().$expression()\n        } else if ($truthy(self.$loc(else_t))) {\n          end_l = self.$loc(else_t)\n        } else if ($truthy(($truthy($a = body_e) ? body_e.$loc().$expression() : $a))) {\n          end_l = body_e.$loc().$expression()\n        } else if ($truthy(self.$loc(begin_t))) {\n          end_l = self.$loc(begin_t)\n          } else {\n          end_l = cond_e.$loc().$expression()\n        };\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Condition').$new(self.$loc(keyword_t), self.$loc(begin_t), self.$loc(else_t), self.$loc(end_t), self.$loc(keyword_t).$join(end_l));\n      }, TMP_Default_condition_map_145.$$arity = 7);\n      \n      Opal.defn(self, '$ternary_map', TMP_Default_ternary_map_146 = function $$ternary_map(begin_e, question_t, mid_e, colon_t, end_e) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Ternary').$new(self.$loc(question_t), self.$loc(colon_t), self.$join_exprs(begin_e, end_e))\n      }, TMP_Default_ternary_map_146.$$arity = 5);\n      \n      Opal.defn(self, '$for_map', TMP_Default_for_map_147 = function $$for_map(keyword_t, in_t, begin_t, end_t) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'For').$new(self.$loc(keyword_t), self.$loc(in_t), self.$loc(begin_t), self.$loc(end_t), self.$loc(keyword_t).$join(self.$loc(end_t)))\n      }, TMP_Default_for_map_147.$$arity = 4);\n      \n      Opal.defn(self, '$rescue_body_map', TMP_Default_rescue_body_map_148 = function $$rescue_body_map(keyword_t, exc_list_e, assoc_t, exc_var_e, then_t, compstmt_e) {\n        var $a, self = this, end_l = nil;\n\n        \n        if ($truthy(compstmt_e)) {\n          end_l = compstmt_e.$loc().$expression()};\n        if ($truthy(($truthy($a = end_l['$nil?']()) ? then_t : $a))) {\n          end_l = self.$loc(then_t)};\n        if ($truthy(($truthy($a = end_l['$nil?']()) ? exc_var_e : $a))) {\n          end_l = exc_var_e.$loc().$expression()};\n        if ($truthy(($truthy($a = end_l['$nil?']()) ? exc_list_e : $a))) {\n          end_l = exc_list_e.$loc().$expression()};\n        if ($truthy(end_l['$nil?']())) {\n          end_l = self.$loc(keyword_t)};\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'RescueBody').$new(self.$loc(keyword_t), self.$loc(assoc_t), self.$loc(then_t), self.$loc(keyword_t).$join(end_l));\n      }, TMP_Default_rescue_body_map_148.$$arity = 6);\n      \n      Opal.defn(self, '$eh_keyword_map', TMP_Default_eh_keyword_map_149 = function $$eh_keyword_map(compstmt_e, keyword_t, body_es, else_t, else_e) {\n        var self = this, begin_l = nil, end_l = nil;\n\n        \n        if ($truthy(compstmt_e['$nil?']())) {\n          if ($truthy(keyword_t['$nil?']())) {\n            begin_l = body_es.$first().$loc().$expression()\n            } else {\n            begin_l = self.$loc(keyword_t)\n          }\n          } else {\n          begin_l = compstmt_e.$loc().$expression()\n        };\n        if ($truthy(else_t)) {\n          if ($truthy(else_e['$nil?']())) {\n            end_l = self.$loc(else_t)\n            } else {\n            end_l = else_e.$loc().$expression()\n          }\n        } else if ($truthy(body_es.$last()['$nil?']()['$!']())) {\n          end_l = body_es.$last().$loc().$expression()\n          } else {\n          end_l = self.$loc(keyword_t)\n        };\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Map'), 'Condition').$new(self.$loc(keyword_t), nil, self.$loc(else_t), nil, begin_l.$join(end_l));\n      }, TMP_Default_eh_keyword_map_149.$$arity = 5);\n      \n      Opal.defn(self, '$static_string', TMP_Default_static_string_151 = function $$static_string(nodes) {try {\n\n        var TMP_150, self = this;\n\n        return $send(nodes, 'map', [], (TMP_150 = function(node){var self = TMP_150.$$s || this, $case = nil, string = nil;\nif (node == null) node = nil;\n        return (function() {$case = node.$type();\n          if (\"str\"['$===']($case)) {return node.$children()['$[]'](0)}\n          else if (\"begin\"['$===']($case)) {if ($truthy((string = self.$static_string(node.$children())))) {\n            return string\n            } else {\n            Opal.ret(nil)\n          }}\n          else {Opal.ret(nil)}})()}, TMP_150.$$s = self, TMP_150.$$arity = 1, TMP_150)).$join()\n        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n      }, TMP_Default_static_string_151.$$arity = 1);\n      \n      Opal.defn(self, '$static_regexp', TMP_Default_static_regexp_152 = function $$static_regexp(parts, options) {\n        var $a, self = this, source = nil;\n\n        \n        source = self.$static_string(parts);\n        if ($truthy(source['$nil?']())) {\n          return nil};\n        if ($truthy((($a = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n          source = (function() {\n          if ($truthy(options.$children()['$include?'](\"u\"))) {return source.$encode(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8'))}\n          else if ($truthy(options.$children()['$include?'](\"e\"))) {return source.$encode(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'EUC_JP'))}\n          else if ($truthy(options.$children()['$include?'](\"s\"))) {return source.$encode(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'WINDOWS_31J'))}\n          else if ($truthy(options.$children()['$include?'](\"n\"))) {return source.$encode(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'BINARY'))}\n          else {return source}})()};\n        return Opal.const_get_relative($nesting, 'Regexp').$new(source, (function() {if ($truthy(options.$children()['$include?'](\"x\"))) {\n          return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Regexp'), 'EXTENDED')\n          } else {\n          return nil\n        }; return nil; })());\n      }, TMP_Default_static_regexp_152.$$arity = 2);\n      \n      Opal.defn(self, '$static_regexp_node', TMP_Default_static_regexp_node_153 = function $$static_regexp_node(node) {\n        var $a, self = this, parts = nil, options = nil;\n\n        if (node.$type()['$=='](\"regexp\")) {\n          \n          $a = [node.$children()['$[]']($range(0, -2, false)), node.$children()['$[]'](-1)], (parts = $a[0]), (options = $a[1]), $a;\n          return self.$static_regexp(parts, options);\n          } else {\n          return nil\n        }\n      }, TMP_Default_static_regexp_node_153.$$arity = 1);\n      \n      Opal.defn(self, '$collapse_string_parts?', TMP_Default_collapse_string_parts$q_154 = function(parts) {\n        var $a, self = this;\n\n        return ($truthy($a = parts['$one?']()) ? [\"str\", \"dstr\"]['$include?'](parts.$first().$type()) : $a)\n      }, TMP_Default_collapse_string_parts$q_154.$$arity = 1);\n      \n      Opal.defn(self, '$value', TMP_Default_value_155 = function $$value(token) {\n        var self = this;\n\n        return token['$[]'](0)\n      }, TMP_Default_value_155.$$arity = 1);\n      if ($truthy((($a = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n        \n        Opal.defn(self, '$string_value', TMP_Default_string_value_156 = function $$string_value(token) {\n          var self = this;\n\n          \n          if ($truthy(token['$[]'](0)['$valid_encoding?']())) {\n            } else {\n            self.$diagnostic(\"error\", \"invalid_encoding\", nil, token['$[]'](1))\n          };\n          return token['$[]'](0);\n        }, TMP_Default_string_value_156.$$arity = 1)\n        } else {\n        Opal.alias(self, \"string_value\", \"value\")\n      };\n      \n      Opal.defn(self, '$loc', TMP_Default_loc_157 = function $$loc(token) {\n        var $a, self = this;\n\n        if ($truthy(($truthy($a = token) ? token['$[]'](0) : $a))) {\n          return token['$[]'](1)\n          } else {\n          return nil\n        }\n      }, TMP_Default_loc_157.$$arity = 1);\n      return (Opal.defn(self, '$diagnostic', TMP_Default_diagnostic_158 = function $$diagnostic(type, reason, arguments$, location, highlights) {\n        var self = this;\n\n        if (highlights == null) {\n          highlights = [];\n        }\n        \n        self.parser.$diagnostics().$process(Opal.const_get_relative($nesting, 'Diagnostic').$new(type, reason, arguments$, location, highlights));\n        if (type['$=='](\"error\")) {\n          return self.parser.$send(\"yyerror\")\n          } else {\n          return nil\n        };\n      }, TMP_Default_diagnostic_158.$$arity = -5), nil) && 'diagnostic';\n    })(Opal.const_get_relative($nesting, 'Builders'), null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/base\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$default_parser', '$setup_source_buffer', '$default_encoding', '$parse', '$parse_with_comments', '$read', '$new', '$all_errors_are_fatal=', '$diagnostics', '$-', '$ignore_warnings=', '$lambda', '$puts', '$render', '$consumer=', '$respond_to?', '$force_encoding', '$dup', '$==', '$name', '$raw_source=', '$source=', '$private_class_method', '$attr_reader', '$version', '$diagnostics=', '$static_env=', '$parser=', '$class', '$[]', '$reset', '$source_buffer=', '$do_parse', '$comments=', '$comments', '$tokens=', '$!', '$raise', '$tokens', '$>', '$private', '$advance', '$===', '$diagnostic', '$map', '$process', '$yyerror', '$token_to_str']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Base(){};\n      var self = $Base = $klass($base, $super, 'Base', $Base);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Base_parse_1, TMP_Base_parse_with_comments_2, TMP_Base_parse_file_3, TMP_Base_parse_file_with_comments_4, TMP_Base_default_parser_6, TMP_Base_setup_source_buffer_7, TMP_Base_initialize_8, TMP_Base_reset_9, TMP_Base_parse_10, TMP_Base_parse_with_comments_11, TMP_Base_tokenize_12, TMP_Base_in_def$q_13, TMP_Base_next_token_14, TMP_Base_check_kwarg_name_15, TMP_Base_diagnostic_17, TMP_Base_on_error_18;\n\n      def.diagnostics = def.lexer = def.static_env = def.builder = def.def_level = nil;\n      \n      Opal.defs(self, '$parse', TMP_Base_parse_1 = function $$parse(string, file, line) {\n        var self = this, parser = nil, source_buffer = nil;\n\n        if (file == null) {\n          file = \"(string)\";\n        }\n        if (line == null) {\n          line = 1;\n        }\n        \n        parser = self.$default_parser();\n        source_buffer = self.$setup_source_buffer(file, line, string, parser.$default_encoding());\n        return parser.$parse(source_buffer);\n      }, TMP_Base_parse_1.$$arity = -2);\n      Opal.defs(self, '$parse_with_comments', TMP_Base_parse_with_comments_2 = function $$parse_with_comments(string, file, line) {\n        var self = this, parser = nil, source_buffer = nil;\n\n        if (file == null) {\n          file = \"(string)\";\n        }\n        if (line == null) {\n          line = 1;\n        }\n        \n        parser = self.$default_parser();\n        source_buffer = self.$setup_source_buffer(file, line, string, parser.$default_encoding());\n        return parser.$parse_with_comments(source_buffer);\n      }, TMP_Base_parse_with_comments_2.$$arity = -2);\n      Opal.defs(self, '$parse_file', TMP_Base_parse_file_3 = function $$parse_file(filename) {\n        var self = this;\n\n        return self.$parse(Opal.const_get_relative($nesting, 'File').$read(filename), filename)\n      }, TMP_Base_parse_file_3.$$arity = 1);\n      Opal.defs(self, '$parse_file_with_comments', TMP_Base_parse_file_with_comments_4 = function $$parse_file_with_comments(filename) {\n        var self = this;\n\n        return self.$parse_with_comments(Opal.const_get_relative($nesting, 'File').$read(filename), filename)\n      }, TMP_Base_parse_file_with_comments_4.$$arity = 1);\n      Opal.defs(self, '$default_parser', TMP_Base_default_parser_6 = function $$default_parser() {\n        var TMP_5, self = this, parser = nil, $writer = nil;\n\n        \n        parser = self.$new();\n        \n        $writer = [true];\n        $send(parser.$diagnostics(), 'all_errors_are_fatal=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [true];\n        $send(parser.$diagnostics(), 'ignore_warnings=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [$send(self, 'lambda', [], (TMP_5 = function(diagnostic){var self = TMP_5.$$s || this;\n          if ($gvars.stderr == null) $gvars.stderr = nil;\nif (diagnostic == null) diagnostic = nil;\n        return $gvars.stderr.$puts(diagnostic.$render())}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5))];\n        $send(parser.$diagnostics(), 'consumer=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return parser;\n      }, TMP_Base_default_parser_6.$$arity = 0);\n      Opal.defs(self, '$setup_source_buffer', TMP_Base_setup_source_buffer_7 = function $$setup_source_buffer(file, line, string, encoding) {\n        var self = this, source_buffer = nil, $writer = nil;\n\n        \n        if ($truthy(string['$respond_to?'](\"force_encoding\"))) {\n          string = string.$dup().$force_encoding(encoding)};\n        source_buffer = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Buffer').$new(file, line);\n        if (self.$name()['$=='](\"Parser::Ruby18\")) {\n          \n          $writer = [string];\n          $send(source_buffer, 'raw_source=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n          \n          $writer = [string];\n          $send(source_buffer, 'source=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        };\n        return source_buffer;\n      }, TMP_Base_setup_source_buffer_7.$$arity = 4);\n      self.$private_class_method(\"setup_source_buffer\");\n      self.$attr_reader(\"diagnostics\");\n      self.$attr_reader(\"builder\");\n      self.$attr_reader(\"static_env\");\n      self.$attr_reader(\"source_buffer\");\n      \n      Opal.defn(self, '$initialize', TMP_Base_initialize_8 = function $$initialize(builder) {\n        var $a, self = this, $writer = nil;\n\n        if (builder == null) {\n          builder = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Parser'), 'Builders'), 'Default').$new();\n        }\n        \n        self.diagnostics = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Diagnostic'), 'Engine').$new();\n        self.static_env = Opal.const_get_relative($nesting, 'StaticEnvironment').$new();\n        self.lexer = Opal.const_get_relative($nesting, 'Lexer').$new(self.$version());\n        \n        $writer = [self.diagnostics];\n        $send(self.lexer, 'diagnostics=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [self.static_env];\n        $send(self.lexer, 'static_env=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        self.builder = builder;\n        \n        $writer = [self];\n        $send(self.builder, 'parser=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        if ($truthy(($truthy($a = Opal.const_get_qualified(self.$class(), 'Racc_debug_parser')) ? Opal.const_get_relative($nesting, 'ENV')['$[]'](\"RACC_DEBUG\") : $a))) {\n          self.yydebug = true};\n        return self.$reset();\n      }, TMP_Base_initialize_8.$$arity = -1);\n      \n      Opal.defn(self, '$reset', TMP_Base_reset_9 = function $$reset() {\n        var self = this;\n\n        \n        self.source_buffer = nil;\n        self.def_level = 0;\n        self.lexer.$reset();\n        self.static_env.$reset();\n        return self;\n      }, TMP_Base_reset_9.$$arity = 0);\n      \n      Opal.defn(self, '$parse', TMP_Base_parse_10 = function $$parse(source_buffer) {\n        var self = this, $writer = nil;\n\n        return (function() { try {\n        \n        \n        $writer = [source_buffer];\n        $send(self.lexer, 'source_buffer=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        self.source_buffer = source_buffer;\n        return self.$do_parse();\n        } finally {\n          ((self.source_buffer = nil), (($writer = [nil]), $send(self.lexer, 'source_buffer=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n        }; })()\n      }, TMP_Base_parse_10.$$arity = 1);\n      \n      Opal.defn(self, '$parse_with_comments', TMP_Base_parse_with_comments_11 = function $$parse_with_comments(source_buffer) {\n        var self = this, $writer = nil;\n\n        return (function() { try {\n        \n        \n        $writer = [[]];\n        $send(self.lexer, 'comments=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return [self.$parse(source_buffer), self.lexer.$comments()];\n        } finally {\n          (($writer = [nil]), $send(self.lexer, 'comments=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])\n        }; })()\n      }, TMP_Base_parse_with_comments_11.$$arity = 1);\n      \n      Opal.defn(self, '$tokenize', TMP_Base_tokenize_12 = function $$tokenize(source_buffer, recover) {\n        var self = this, $writer = nil, ast = nil;\n\n        if (recover == null) {\n          recover = false;\n        }\n        return (function() { try {\n        \n        \n        $writer = [[]];\n        $send(self.lexer, 'tokens=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [[]];\n        $send(self.lexer, 'comments=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        try {\n          ast = self.$parse(source_buffer)\n        } catch ($err) {\n          if (Opal.rescue($err, [Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Parser'), 'SyntaxError')])) {\n            try {\n              if ($truthy(recover['$!']())) {\n                self.$raise()}\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        };;\n        return [ast, self.lexer.$comments(), self.lexer.$tokens()];\n        } finally {\n          ((($writer = [nil]), $send(self.lexer, 'tokens=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]), (($writer = [nil]), $send(self.lexer, 'comments=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n        }; })()\n      }, TMP_Base_tokenize_12.$$arity = -2);\n      \n      Opal.defn(self, '$in_def?', TMP_Base_in_def$q_13 = function() {\n        var self = this;\n\n        return $rb_gt(self.def_level, 0)\n      }, TMP_Base_in_def$q_13.$$arity = 0);\n      self.$private();\n      \n      Opal.defn(self, '$next_token', TMP_Base_next_token_14 = function $$next_token() {\n        var self = this;\n\n        return self.lexer.$advance()\n      }, TMP_Base_next_token_14.$$arity = 0);\n      \n      Opal.defn(self, '$check_kwarg_name', TMP_Base_check_kwarg_name_15 = function $$check_kwarg_name(name_t) {\n        var self = this, $case = nil;\n\n        return (function() {$case = name_t['$[]'](0);\n        if (/^[a-z_]/['$===']($case)) {return nil}\n        else if (/^[A-Z]/['$===']($case)) {return self.$diagnostic(\"error\", \"argument_const\", nil, name_t)}\n        else { return nil }})()\n      }, TMP_Base_check_kwarg_name_15.$$arity = 1);\n      \n      Opal.defn(self, '$diagnostic', TMP_Base_diagnostic_17 = function $$diagnostic(level, reason, arguments$, location_t, highlights_ts) {\n        var $a, $b, TMP_16, self = this, _ = nil, location = nil, highlights = nil;\n\n        if (highlights_ts == null) {\n          highlights_ts = [];\n        }\n        \n        $b = location_t, $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (location = ($a[1] == null ? nil : $a[1])), $b;\n        highlights = $send(highlights_ts, 'map', [], (TMP_16 = function(token){var self = TMP_16.$$s || this, $c, $d, range = nil;\nif (token == null) token = nil;\n        \n          $d = token, $c = Opal.to_ary($d), (_ = ($c[0] == null ? nil : $c[0])), (range = ($c[1] == null ? nil : $c[1])), $d;\n          return range;}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16));\n        self.diagnostics.$process(Opal.const_get_relative($nesting, 'Diagnostic').$new(level, reason, arguments$, location, highlights));\n        if (level['$=='](\"error\")) {\n          return self.$yyerror()\n          } else {\n          return nil\n        };\n      }, TMP_Base_diagnostic_17.$$arity = -5);\n      return (Opal.defn(self, '$on_error', TMP_Base_on_error_18 = function $$on_error(error_token_id, error_value, value_stack) {\n        var $a, $b, self = this, token_name = nil, _ = nil, location = nil;\n\n        \n        token_name = self.$token_to_str(error_token_id);\n        $b = error_value, $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (location = ($a[1] == null ? nil : $a[1])), $b;\n        return self.diagnostics.$process(Opal.const_get_relative($nesting, 'Diagnostic').$new(\"error\", \"unexpected_token\", $hash2([\"token\"], {\"token\": token_name}), location));\n      }, TMP_Base_on_error_18.$$arity = 3), nil) && 'on_error';\n    })($nesting[0], Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Racc'), 'Parser'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/rewriter\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$new', '$process', '$include?', '$type', '$remove', '$insert_before', '$insert_after', '$replace']);\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Rewriter(){};\n      var self = $Rewriter = $klass($base, $super, 'Rewriter', $Rewriter);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Rewriter_rewrite_1, TMP_Rewriter_assignment$q_2, TMP_Rewriter_remove_3, TMP_Rewriter_insert_before_4, TMP_Rewriter_insert_after_5, TMP_Rewriter_replace_6;\n\n      def.source_rewriter = nil;\n      \n      \n      Opal.defn(self, '$rewrite', TMP_Rewriter_rewrite_1 = function $$rewrite(source_buffer, ast) {\n        var self = this;\n\n        \n        self.source_rewriter = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Source'), 'Rewriter').$new(source_buffer);\n        self.$process(ast);\n        return self.source_rewriter.$process();\n      }, TMP_Rewriter_rewrite_1.$$arity = 2);\n      \n      Opal.defn(self, '$assignment?', TMP_Rewriter_assignment$q_2 = function(node) {\n        var self = this;\n\n        return [\"lvasgn\", \"ivasgn\", \"gvasgn\", \"cvasgn\", \"casgn\"]['$include?'](node.$type())\n      }, TMP_Rewriter_assignment$q_2.$$arity = 1);\n      \n      Opal.defn(self, '$remove', TMP_Rewriter_remove_3 = function $$remove(range) {\n        var self = this;\n\n        return self.source_rewriter.$remove(range)\n      }, TMP_Rewriter_remove_3.$$arity = 1);\n      \n      Opal.defn(self, '$insert_before', TMP_Rewriter_insert_before_4 = function $$insert_before(range, content) {\n        var self = this;\n\n        return self.source_rewriter.$insert_before(range, content)\n      }, TMP_Rewriter_insert_before_4.$$arity = 2);\n      \n      Opal.defn(self, '$insert_after', TMP_Rewriter_insert_after_5 = function $$insert_after(range, content) {\n        var self = this;\n\n        return self.source_rewriter.$insert_after(range, content)\n      }, TMP_Rewriter_insert_after_5.$$arity = 2);\n      return (Opal.defn(self, '$replace', TMP_Rewriter_replace_6 = function $$replace(range, content) {\n        var self = this;\n\n        return self.source_rewriter.$replace(range, content)\n      }, TMP_Rewriter_replace_6.$$arity = 2), nil) && 'replace';\n    })($nesting[0], Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Parser'), 'AST'), 'Processor'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser\"] = function(Opal) {\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $truthy = Opal.truthy, $module = Opal.module;\n\n  Opal.add_stubs(['$require', '$<', '$raise']);\n  \n  self.$require(\"set\");\n  self.$require(\"racc/parser\");\n  self.$require(\"ast\");\n  if ($truthy($rb_lt(Opal.const_get_relative($nesting, 'RUBY_VERSION'), \"1.9\"))) {\n    self.$require(\"parser/compatibility/ruby1_8\")};\n  if ($truthy($rb_lt(Opal.const_get_relative($nesting, 'RUBY_VERSION'), \"2.0\"))) {\n    self.$require(\"parser/compatibility/ruby1_9\")};\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Parser_check_for_encoding_support_1;\n\n    \n    self.$require(\"parser/version\");\n    self.$require(\"parser/messages\");\n    (function($base, $parent_nesting) {\n      var $AST, self = $AST = $module($base, 'AST');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$require(\"parser/ast/node\");\n      self.$require(\"parser/ast/processor\");\n      self.$require(\"parser/meta\");\n    })($nesting[0], $nesting);\n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      self.$require(\"parser/source/buffer\");\n      self.$require(\"parser/source/range\");\n      self.$require(\"parser/source/comment\");\n      self.$require(\"parser/source/comment/associator\");\n      self.$require(\"parser/source/rewriter\");\n      self.$require(\"parser/source/rewriter/action\");\n      self.$require(\"parser/source/map\");\n      self.$require(\"parser/source/map/operator\");\n      self.$require(\"parser/source/map/collection\");\n      self.$require(\"parser/source/map/constant\");\n      self.$require(\"parser/source/map/variable\");\n      self.$require(\"parser/source/map/keyword\");\n      self.$require(\"parser/source/map/definition\");\n      self.$require(\"parser/source/map/send\");\n      self.$require(\"parser/source/map/condition\");\n      self.$require(\"parser/source/map/ternary\");\n      self.$require(\"parser/source/map/for\");\n      self.$require(\"parser/source/map/rescue_body\");\n      self.$require(\"parser/source/map/heredoc\");\n      self.$require(\"parser/source/map/objc_kwarg\");\n    })($nesting[0], $nesting);\n    self.$require(\"parser/syntax_error\");\n    self.$require(\"parser/clobbering_error\");\n    self.$require(\"parser/diagnostic\");\n    self.$require(\"parser/diagnostic/engine\");\n    self.$require(\"parser/static_environment\");\n    self.$require(\"parser/lexer\");\n    self.$require(\"parser/lexer/literal\");\n    self.$require(\"parser/lexer/stack_state\");\n    self.$require(\"parser/lexer/dedenter\");\n    (function($base, $parent_nesting) {\n      var $Builders, self = $Builders = $module($base, 'Builders');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      self.$require(\"parser/builders/default\")\n    })($nesting[0], $nesting);\n    self.$require(\"parser/base\");\n    self.$require(\"parser/rewriter\");\n    Opal.defs(self, '$check_for_encoding_support', TMP_Parser_check_for_encoding_support_1 = function $$check_for_encoding_support() {\n      var $a, self = this;\n\n      if ($truthy((($a = Opal.const_get_relative($nesting, 'Encoding', 'skip_raise')) ? 'constant' : nil))) {\n        return nil\n        } else {\n        return self.$raise(Opal.const_get_relative($nesting, 'RuntimeError'), \"Parsing 1.9 and later versions of Ruby is not supported on 1.8 due to the lack of Encoding support\")\n      }\n    }, TMP_Parser_check_for_encoding_support_1.$$arity = 0);\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"parser/ruby23\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash = Opal.hash;\n\n  Opal.add_stubs(['$require', '$check_for_encoding_support', '$new', '$each', '$split', '$empty?', '$to_i', '$[]=', '$-', '$+', '$compstmt', '$[]', '$<<', '$preexe', '$!', '$nil?', '$diagnostic', '$begin_body', '$state=', '$alias', '$gvar', '$back_ref', '$undef_method', '$condition_mod', '$loop_mod', '$rescue_body', '$postexe', '$multi_assign', '$op_assign', '$index', '$call_method', '$const_op_assignable', '$const_fetch', '$assign', '$array', '$logical_op', '$not_op', '$extend_dynamic', '$unextend', '$block', '$keyword_cmd', '$multi_lhs', '$begin', '$push', '$splat', '$concat', '$assignable', '$index_asgn', '$attr_asgn', '$const_global', '$const', '$symbol', '$range_inclusive', '$range_exclusive', '$binary_op', '$unary_op', '$match_op', '$ternary', '$associate', '$dup', '$cmdarg', '$cmdarg=', '$block_pass', '$clear', '$begin_keyword', '$call_lambda', '$condition', '$cond', '$pop', '$loop', '$case', '$for', '$extend_static', '$push_cmdarg', '$in_def?', '$def_class', '$pop_cmdarg', '$def_sclass', '$def_module', '$def_method', '$def_singleton', '$arg', '$restarg', '$==', '$size', '$procarg0', '$args', '$declare', '$shadowarg', '$lexpop', '$when', '$string_compose', '$dedent_string', '$dedent_level', '$string', '$character', '$xstring_compose', '$regexp_options', '$regexp_compose', '$words_compose', '$word', '$symbols_compose', '$string_internal', '$symbol_internal', '$ivar', '$cvar', '$symbol_compose', '$negate', '$integer', '$float', '$rational', '$complex', '$ident', '$nil', '$self', '$true', '$false', '$__FILE__', '$__LINE__', '$__ENCODING__', '$accessible', '$nth_ref', '$in_kwarg', '$in_kwarg=', '$check_kwarg_name', '$kwoptarg', '$kwarg', '$kwrestarg', '$optarg', '$blockarg', '$pair', '$pair_keyword', '$pair_quoted', '$kwsplat', '$yyerrok']);\n  \n  self.$require(\"racc/parser.rb\");\n  self.$require(\"parser\");\n  Opal.const_get_relative($nesting, 'Parser').$check_for_encoding_support();\n  return (function($base, $parent_nesting) {\n    var $Parser, self = $Parser = $module($base, 'Parser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Ruby23(){};\n      var self = $Ruby23 = $klass($base, $super, 'Ruby23', $Ruby23);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Ruby23_version_1, TMP_Ruby23_default_encoding_2, TMP_Ruby23_3, TMP_Ruby23_5, TMP_Ruby23_7, TMP_Ruby23_9, TMP_Ruby23__reduce_2_11, TMP_Ruby23__reduce_3_12, TMP_Ruby23__reduce_4_13, TMP_Ruby23__reduce_5_14, TMP_Ruby23__reduce_6_15, TMP_Ruby23__reduce_8_16, TMP_Ruby23__reduce_9_17, TMP_Ruby23__reduce_10_18, TMP_Ruby23__reduce_11_19, TMP_Ruby23__reduce_12_20, TMP_Ruby23__reduce_13_21, TMP_Ruby23__reduce_14_22, TMP_Ruby23__reduce_16_23, TMP_Ruby23__reduce_17_24, TMP_Ruby23__reduce_18_25, TMP_Ruby23__reduce_19_26, TMP_Ruby23__reduce_20_27, TMP_Ruby23__reduce_21_28, TMP_Ruby23__reduce_22_29, TMP_Ruby23__reduce_23_30, TMP_Ruby23__reduce_24_31, TMP_Ruby23__reduce_25_32, TMP_Ruby23__reduce_26_33, TMP_Ruby23__reduce_27_34, TMP_Ruby23__reduce_28_35, TMP_Ruby23__reduce_30_36, TMP_Ruby23__reduce_31_37, TMP_Ruby23__reduce_32_38, TMP_Ruby23__reduce_33_39, TMP_Ruby23__reduce_34_40, TMP_Ruby23__reduce_35_41, TMP_Ruby23__reduce_36_42, TMP_Ruby23__reduce_37_43, TMP_Ruby23__reduce_38_44, TMP_Ruby23__reduce_39_45, TMP_Ruby23__reduce_41_46, TMP_Ruby23__reduce_42_47, TMP_Ruby23__reduce_44_48, TMP_Ruby23__reduce_45_49, TMP_Ruby23__reduce_46_50, TMP_Ruby23__reduce_47_51, TMP_Ruby23__reduce_53_52, TMP_Ruby23__reduce_54_53, TMP_Ruby23__reduce_55_54, TMP_Ruby23__reduce_57_55, TMP_Ruby23__reduce_58_56, TMP_Ruby23__reduce_59_57, TMP_Ruby23__reduce_60_58, TMP_Ruby23__reduce_61_59, TMP_Ruby23__reduce_62_60, TMP_Ruby23__reduce_63_61, TMP_Ruby23__reduce_64_62, TMP_Ruby23__reduce_65_63, TMP_Ruby23__reduce_66_64, TMP_Ruby23__reduce_67_65, TMP_Ruby23__reduce_68_66, TMP_Ruby23__reduce_69_67, TMP_Ruby23__reduce_70_68, TMP_Ruby23__reduce_71_69, TMP_Ruby23__reduce_73_70, TMP_Ruby23__reduce_74_71, TMP_Ruby23__reduce_75_72, TMP_Ruby23__reduce_76_73, TMP_Ruby23__reduce_77_74, TMP_Ruby23__reduce_78_75, TMP_Ruby23__reduce_79_76, TMP_Ruby23__reduce_80_77, TMP_Ruby23__reduce_81_78, TMP_Ruby23__reduce_83_79, TMP_Ruby23__reduce_84_80, TMP_Ruby23__reduce_85_81, TMP_Ruby23__reduce_86_82, TMP_Ruby23__reduce_87_83, TMP_Ruby23__reduce_88_84, TMP_Ruby23__reduce_89_85, TMP_Ruby23__reduce_90_86, TMP_Ruby23__reduce_91_87, TMP_Ruby23__reduce_92_88, TMP_Ruby23__reduce_93_89, TMP_Ruby23__reduce_94_90, TMP_Ruby23__reduce_95_91, TMP_Ruby23__reduce_96_92, TMP_Ruby23__reduce_97_93, TMP_Ruby23__reduce_98_94, TMP_Ruby23__reduce_99_95, TMP_Ruby23__reduce_100_96, TMP_Ruby23__reduce_101_97, TMP_Ruby23__reduce_102_98, TMP_Ruby23__reduce_103_99, TMP_Ruby23__reduce_104_100, TMP_Ruby23__reduce_105_101, TMP_Ruby23__reduce_106_102, TMP_Ruby23__reduce_108_103, TMP_Ruby23__reduce_109_104, TMP_Ruby23__reduce_110_105, TMP_Ruby23__reduce_116_106, TMP_Ruby23__reduce_120_107, TMP_Ruby23__reduce_121_108, TMP_Ruby23__reduce_122_109, TMP_Ruby23__reduce_194_110, TMP_Ruby23__reduce_195_111, TMP_Ruby23__reduce_196_112, TMP_Ruby23__reduce_197_113, TMP_Ruby23__reduce_198_114, TMP_Ruby23__reduce_199_115, TMP_Ruby23__reduce_200_116, TMP_Ruby23__reduce_201_117, TMP_Ruby23__reduce_202_118, TMP_Ruby23__reduce_203_119, TMP_Ruby23__reduce_204_120, TMP_Ruby23__reduce_205_121, TMP_Ruby23__reduce_206_122, TMP_Ruby23__reduce_207_123, TMP_Ruby23__reduce_208_124, TMP_Ruby23__reduce_209_125, TMP_Ruby23__reduce_210_126, TMP_Ruby23__reduce_211_127, TMP_Ruby23__reduce_212_128, TMP_Ruby23__reduce_213_129, TMP_Ruby23__reduce_214_130, TMP_Ruby23__reduce_215_131, TMP_Ruby23__reduce_216_132, TMP_Ruby23__reduce_217_133, TMP_Ruby23__reduce_218_134, TMP_Ruby23__reduce_219_135, TMP_Ruby23__reduce_220_136, TMP_Ruby23__reduce_221_137, TMP_Ruby23__reduce_222_138, TMP_Ruby23__reduce_223_139, TMP_Ruby23__reduce_224_140, TMP_Ruby23__reduce_225_141, TMP_Ruby23__reduce_226_142, TMP_Ruby23__reduce_227_143, TMP_Ruby23__reduce_228_144, TMP_Ruby23__reduce_229_145, TMP_Ruby23__reduce_230_146, TMP_Ruby23__reduce_231_147, TMP_Ruby23__reduce_232_148, TMP_Ruby23__reduce_233_149, TMP_Ruby23__reduce_234_150, TMP_Ruby23__reduce_235_151, TMP_Ruby23__reduce_236_152, TMP_Ruby23__reduce_241_153, TMP_Ruby23__reduce_242_154, TMP_Ruby23__reduce_243_155, TMP_Ruby23__reduce_244_156, TMP_Ruby23__reduce_246_157, TMP_Ruby23__reduce_249_158, TMP_Ruby23__reduce_250_159, TMP_Ruby23__reduce_251_160, TMP_Ruby23__reduce_252_161, TMP_Ruby23__reduce_253_162, TMP_Ruby23__reduce_254_163, TMP_Ruby23__reduce_255_164, TMP_Ruby23__reduce_256_165, TMP_Ruby23__reduce_257_166, TMP_Ruby23__reduce_258_167, TMP_Ruby23__reduce_259_168, TMP_Ruby23__reduce_260_169, TMP_Ruby23__reduce_261_170, TMP_Ruby23__reduce_262_171, TMP_Ruby23__reduce_263_172, TMP_Ruby23__reduce_264_173, TMP_Ruby23__reduce_265_174, TMP_Ruby23__reduce_267_175, TMP_Ruby23__reduce_268_176, TMP_Ruby23__reduce_269_177, TMP_Ruby23__reduce_280_178, TMP_Ruby23__reduce_281_179, TMP_Ruby23__reduce_282_180, TMP_Ruby23__reduce_283_181, TMP_Ruby23__reduce_284_182, TMP_Ruby23__reduce_285_183, TMP_Ruby23__reduce_286_184, TMP_Ruby23__reduce_287_185, TMP_Ruby23__reduce_288_186, TMP_Ruby23__reduce_289_187, TMP_Ruby23__reduce_290_188, TMP_Ruby23__reduce_291_189, TMP_Ruby23__reduce_292_190, TMP_Ruby23__reduce_293_191, TMP_Ruby23__reduce_294_192, TMP_Ruby23__reduce_295_193, TMP_Ruby23__reduce_296_194, TMP_Ruby23__reduce_297_195, TMP_Ruby23__reduce_298_196, TMP_Ruby23__reduce_299_197, TMP_Ruby23__reduce_300_198, TMP_Ruby23__reduce_302_199, TMP_Ruby23__reduce_303_200, TMP_Ruby23__reduce_304_201, TMP_Ruby23__reduce_305_202, TMP_Ruby23__reduce_306_203, TMP_Ruby23__reduce_307_204, TMP_Ruby23__reduce_308_205, TMP_Ruby23__reduce_309_206, TMP_Ruby23__reduce_310_207, TMP_Ruby23__reduce_311_208, TMP_Ruby23__reduce_312_209, TMP_Ruby23__reduce_313_210, TMP_Ruby23__reduce_314_211, TMP_Ruby23__reduce_315_212, TMP_Ruby23__reduce_316_213, TMP_Ruby23__reduce_317_214, TMP_Ruby23__reduce_318_215, TMP_Ruby23__reduce_319_216, TMP_Ruby23__reduce_320_217, TMP_Ruby23__reduce_321_218, TMP_Ruby23__reduce_322_219, TMP_Ruby23__reduce_323_220, TMP_Ruby23__reduce_324_221, TMP_Ruby23__reduce_325_222, TMP_Ruby23__reduce_326_223, TMP_Ruby23__reduce_327_224, TMP_Ruby23__reduce_328_225, TMP_Ruby23__reduce_329_226, TMP_Ruby23__reduce_330_227, TMP_Ruby23__reduce_331_228, TMP_Ruby23__reduce_335_229, TMP_Ruby23__reduce_339_230, TMP_Ruby23__reduce_341_231, TMP_Ruby23__reduce_344_232, TMP_Ruby23__reduce_345_233, TMP_Ruby23__reduce_346_234, TMP_Ruby23__reduce_347_235, TMP_Ruby23__reduce_349_236, TMP_Ruby23__reduce_350_237, TMP_Ruby23__reduce_351_238, TMP_Ruby23__reduce_352_239, TMP_Ruby23__reduce_353_240, TMP_Ruby23__reduce_354_241, TMP_Ruby23__reduce_355_242, TMP_Ruby23__reduce_356_243, TMP_Ruby23__reduce_357_244, TMP_Ruby23__reduce_358_245, TMP_Ruby23__reduce_359_246, TMP_Ruby23__reduce_360_247, TMP_Ruby23__reduce_361_248, TMP_Ruby23__reduce_362_249, TMP_Ruby23__reduce_363_250, TMP_Ruby23__reduce_364_251, TMP_Ruby23__reduce_365_252, TMP_Ruby23__reduce_366_253, TMP_Ruby23__reduce_367_254, TMP_Ruby23__reduce_369_255, TMP_Ruby23__reduce_370_256, TMP_Ruby23__reduce_371_257, TMP_Ruby23__reduce_372_258, TMP_Ruby23__reduce_373_259, TMP_Ruby23__reduce_374_260, TMP_Ruby23__reduce_375_261, TMP_Ruby23__reduce_376_262, TMP_Ruby23__reduce_378_263, TMP_Ruby23__reduce_379_264, TMP_Ruby23__reduce_380_265, TMP_Ruby23__reduce_381_266, TMP_Ruby23__reduce_382_267, TMP_Ruby23__reduce_383_268, TMP_Ruby23__reduce_384_269, TMP_Ruby23__reduce_385_270, TMP_Ruby23__reduce_386_271, TMP_Ruby23__reduce_387_272, TMP_Ruby23__reduce_389_273, TMP_Ruby23__reduce_390_274, TMP_Ruby23__reduce_391_275, TMP_Ruby23__reduce_392_276, TMP_Ruby23__reduce_393_277, TMP_Ruby23__reduce_394_278, TMP_Ruby23__reduce_395_279, TMP_Ruby23__reduce_396_280, TMP_Ruby23__reduce_397_281, TMP_Ruby23__reduce_398_282, TMP_Ruby23__reduce_399_283, TMP_Ruby23__reduce_400_284, TMP_Ruby23__reduce_401_285, TMP_Ruby23__reduce_402_286, TMP_Ruby23__reduce_403_287, TMP_Ruby23__reduce_404_288, TMP_Ruby23__reduce_405_289, TMP_Ruby23__reduce_406_290, TMP_Ruby23__reduce_407_291, TMP_Ruby23__reduce_408_292, TMP_Ruby23__reduce_409_293, TMP_Ruby23__reduce_410_294, TMP_Ruby23__reduce_411_295, TMP_Ruby23__reduce_412_296, TMP_Ruby23__reduce_413_297, TMP_Ruby23__reduce_414_298, TMP_Ruby23__reduce_415_299, TMP_Ruby23__reduce_416_300, TMP_Ruby23__reduce_418_301, TMP_Ruby23__reduce_419_302, TMP_Ruby23__reduce_420_303, TMP_Ruby23__reduce_423_304, TMP_Ruby23__reduce_425_305, TMP_Ruby23__reduce_430_306, TMP_Ruby23__reduce_431_307, TMP_Ruby23__reduce_432_308, TMP_Ruby23__reduce_433_309, TMP_Ruby23__reduce_434_310, TMP_Ruby23__reduce_435_311, TMP_Ruby23__reduce_436_312, TMP_Ruby23__reduce_437_313, TMP_Ruby23__reduce_438_314, TMP_Ruby23__reduce_439_315, TMP_Ruby23__reduce_440_316, TMP_Ruby23__reduce_441_317, TMP_Ruby23__reduce_442_318, TMP_Ruby23__reduce_443_319, TMP_Ruby23__reduce_444_320, TMP_Ruby23__reduce_445_321, TMP_Ruby23__reduce_446_322, TMP_Ruby23__reduce_447_323, TMP_Ruby23__reduce_448_324, TMP_Ruby23__reduce_449_325, TMP_Ruby23__reduce_450_326, TMP_Ruby23__reduce_451_327, TMP_Ruby23__reduce_452_328, TMP_Ruby23__reduce_453_329, TMP_Ruby23__reduce_454_330, TMP_Ruby23__reduce_455_331, TMP_Ruby23__reduce_456_332, TMP_Ruby23__reduce_457_333, TMP_Ruby23__reduce_458_334, TMP_Ruby23__reduce_459_335, TMP_Ruby23__reduce_460_336, TMP_Ruby23__reduce_461_337, TMP_Ruby23__reduce_462_338, TMP_Ruby23__reduce_463_339, TMP_Ruby23__reduce_464_340, TMP_Ruby23__reduce_466_341, TMP_Ruby23__reduce_467_342, TMP_Ruby23__reduce_468_343, TMP_Ruby23__reduce_469_344, TMP_Ruby23__reduce_470_345, TMP_Ruby23__reduce_471_346, TMP_Ruby23__reduce_472_347, TMP_Ruby23__reduce_473_348, TMP_Ruby23__reduce_474_349, TMP_Ruby23__reduce_475_350, TMP_Ruby23__reduce_476_351, TMP_Ruby23__reduce_477_352, TMP_Ruby23__reduce_478_353, TMP_Ruby23__reduce_479_354, TMP_Ruby23__reduce_480_355, TMP_Ruby23__reduce_481_356, TMP_Ruby23__reduce_482_357, TMP_Ruby23__reduce_483_358, TMP_Ruby23__reduce_484_359, TMP_Ruby23__reduce_485_360, TMP_Ruby23__reduce_486_361, TMP_Ruby23__reduce_487_362, TMP_Ruby23__reduce_488_363, TMP_Ruby23__reduce_489_364, TMP_Ruby23__reduce_490_365, TMP_Ruby23__reduce_491_366, TMP_Ruby23__reduce_492_367, TMP_Ruby23__reduce_493_368, TMP_Ruby23__reduce_494_369, TMP_Ruby23__reduce_495_370, TMP_Ruby23__reduce_496_371, TMP_Ruby23__reduce_497_372, TMP_Ruby23__reduce_498_373, TMP_Ruby23__reduce_499_374, TMP_Ruby23__reduce_500_375, TMP_Ruby23__reduce_501_376, TMP_Ruby23__reduce_502_377, TMP_Ruby23__reduce_503_378, TMP_Ruby23__reduce_504_379, TMP_Ruby23__reduce_505_380, TMP_Ruby23__reduce_506_381, TMP_Ruby23__reduce_507_382, TMP_Ruby23__reduce_508_383, TMP_Ruby23__reduce_509_384, TMP_Ruby23__reduce_510_385, TMP_Ruby23__reduce_511_386, TMP_Ruby23__reduce_512_387, TMP_Ruby23__reduce_513_388, TMP_Ruby23__reduce_514_389, TMP_Ruby23__reduce_515_390, TMP_Ruby23__reduce_516_391, TMP_Ruby23__reduce_517_392, TMP_Ruby23__reduce_518_393, TMP_Ruby23__reduce_519_394, TMP_Ruby23__reduce_520_395, TMP_Ruby23__reduce_521_396, TMP_Ruby23__reduce_522_397, TMP_Ruby23__reduce_524_398, TMP_Ruby23__reduce_525_399, TMP_Ruby23__reduce_526_400, TMP_Ruby23__reduce_527_401, TMP_Ruby23__reduce_528_402, TMP_Ruby23__reduce_529_403, TMP_Ruby23__reduce_530_404, TMP_Ruby23__reduce_531_405, TMP_Ruby23__reduce_532_406, TMP_Ruby23__reduce_533_407, TMP_Ruby23__reduce_534_408, TMP_Ruby23__reduce_535_409, TMP_Ruby23__reduce_536_410, TMP_Ruby23__reduce_537_411, TMP_Ruby23__reduce_538_412, TMP_Ruby23__reduce_541_413, TMP_Ruby23__reduce_542_414, TMP_Ruby23__reduce_543_415, TMP_Ruby23__reduce_544_416, TMP_Ruby23__reduce_545_417, TMP_Ruby23__reduce_546_418, TMP_Ruby23__reduce_547_419, TMP_Ruby23__reduce_548_420, TMP_Ruby23__reduce_551_421, TMP_Ruby23__reduce_552_422, TMP_Ruby23__reduce_555_423, TMP_Ruby23__reduce_556_424, TMP_Ruby23__reduce_557_425, TMP_Ruby23__reduce_559_426, TMP_Ruby23__reduce_560_427, TMP_Ruby23__reduce_562_428, TMP_Ruby23__reduce_563_429, TMP_Ruby23__reduce_564_430, TMP_Ruby23__reduce_565_431, TMP_Ruby23__reduce_566_432, TMP_Ruby23__reduce_567_433, TMP_Ruby23__reduce_580_434, TMP_Ruby23__reduce_581_435, TMP_Ruby23__reduce_586_436, TMP_Ruby23__reduce_587_437, TMP_Ruby23__reduce_591_438, TMP_Ruby23__reduce_595_439, TMP_Ruby23__reduce_none_440, clist = nil, racc_action_table = nil, arr = nil, idx = nil, racc_action_check = nil, racc_action_pointer = nil, racc_action_default = nil, racc_goto_table = nil, racc_goto_check = nil, racc_goto_pointer = nil, racc_goto_default = nil, racc_reduce_table = nil, racc_reduce_n = nil, racc_shift_n = nil, racc_token_table = nil, racc_nt_base = nil, racc_use_result_var = nil;\n\n      def.builder = def.lexer = def.static_env = def.def_level = nil;\n      \n      \n      Opal.defn(self, '$version', TMP_Ruby23_version_1 = function $$version() {\n        var self = this;\n\n        return 23\n      }, TMP_Ruby23_version_1.$$arity = 0);\n      \n      Opal.defn(self, '$default_encoding', TMP_Ruby23_default_encoding_2 = function $$default_encoding() {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8')\n      }, TMP_Ruby23_default_encoding_2.$$arity = 0);\n      clist = [\"-474,216,217,216,217,214,-97,-474,-474,-474,-286,570,-474,-474,-474\", \"212,-474,270,219,610,647,647,263,570,-474,612,-474,-474,-474,270,582\", \"270,-488,109,583,-98,-474,-474,570,-474,-474,-474,-474,-474,570,570\", \"-97,-98,-105,-105,-286,-104,-96,-83,-104,646,646,529,270,220,528,121\", \"-105,-69,647,814,-474,-474,-474,-474,-474,-474,-474,-474,-474,-474,-474\", \"-474,-474,-474,213,265,-474,-474,-474,609,-474,-474,715,-97,-474,611\", \"-100,-474,-474,220,-474,220,-474,646,-474,206,-474,-474,269,-474,-474\", \"-474,-474,-474,-100,-474,-477,-474,-102,-88,269,-102,269,-477,-477,-477\", \"265,-101,-477,-477,-477,-474,-477,113,-474,-474,-474,-474,112,-474,-477\", \"-474,-477,-477,-477,113,-474,-474,-89,269,112,-91,-477,-477,-103,-477\", \"-477,-477,-477,-477,113,-99,-96,841,-95,112,113,113,-97,-98,-105,112\", \"112,-97,-98,-105,-104,715,813,-101,-99,-104,-477,-477,-477,-477,-477\", \"-477,-477,-477,-477,-477,-477,-477,-477,-477,113,207,-477,-477,-477\", \"112,-477,-477,-571,-91,-477,208,-93,-477,-477,715,-477,-103,-477,113\", \"-477,-91,-477,-477,112,-477,-477,-477,-477,-477,-289,-477,-489,-477\", \"-93,-572,-100,-289,-289,-289,-102,-100,647,-289,-289,-102,-289,-477\", \"-571,-101,-477,-477,-477,-477,-101,-477,215,-477,216,217,446,-91,-477\", \"-477,-91,259,-289,-289,-90,-289,-289,-289,-289,-289,-91,318,-103,646\", \"-93,-474,-92,-103,-572,-99,529,113,-474,531,-99,-98,112,517,-92,-90\", \"216,217,-289,-289,-289,-289,-289,-289,-289,-289,-289,-289,-289,-289\", \"-289,-289,319,769,-289,-289,-289,-477,630,-105,-93,113,-289,-93,-477\", \"-289,112,805,-94,576,-289,220,-289,-93,-289,-289,-90,-289,-289,-289\", \"-289,-289,597,-289,-575,-289,-474,-571,-92,79,-104,-575,-575,-575,220\", \"216,217,-575,-575,-289,-575,80,-289,-289,388,-94,401,-289,113,-575,-100\", \"81,445,112,-289,-103,-90,-568,-488,-90,-575,-575,-477,-575,-575,-575\", \"-575,-575,-92,-90,113,-92,216,217,447,112,550,770,547,546,545,-92,548\", \"91,92,448,599,598,595,219,-575,-575,-575,-575,-575,-575,-575,-575,-575\", \"-575,-575,-575,-575,-575,479,-88,-575,-575,-575,-474,631,91,92,597,-575\", \"-97,-474,-575,113,859,488,-568,-575,112,-575,-474,-575,-575,-489,-575\", \"-575,-575,-575,-575,-102,-575,-575,-575,597,550,597,547,546,545,-568\", \"548,-484,113,490,-569,492,-575,112,-484,-575,-575,-575,-92,832,-575\", \"500,93,94,-575,-575,-575,-575,-101,-575,-575,-575,-68,-575,220,-474\", \"-89,-99,599,598,595,-483,-575,-575,-575,-575,-98,113,-483,503,93,94\", \"112,-575,-575,662,-575,-575,-575,-575,-575,504,-477,599,598,599,598\", \"597,529,-477,597,531,-484,746,-569,748,597,529,-477,511,531,274,955\", \"-575,-575,-575,-575,-575,-575,-575,-575,-575,-575,-575,-575,-575,-575\", \"-569,220,-575,-575,-575,220,771,-575,978,-483,-575,597,517,-575,-575\", \"597,-575,-485,-575,265,-575,625,-575,-575,-485,-575,-575,-575,-575,-575\", \"-477,-575,-575,-575,599,598,600,599,598,602,514,-482,518,599,598,604\", \"240,-575,-482,220,-575,-575,-575,-575,532,-575,533,-575,-289,-95,216\", \"217,-575,-101,492,-289,-289,-289,-91,-104,-289,-289,-289,576,-289,599\", \"598,608,-100,599,598,613,-485,398,-289,-289,-289,390,400,399,566,565\", \"626,580,-289,-289,581,-289,-289,-289,-289,-289,589,212,614,-332,-482\", \"212,-479,-480,211,617,-332,-481,443,-479,-480,836,805,209,-481,-332\", \"-261,444,-289,-289,-289,-289,-289,-289,-289,-289,-289,-289,-289,-289\", \"-289,-289,619,-93,-289,-289,-289,240,772,-289,-486,220,-289,-102,212\", \"-289,-289,-486,-289,623,-289,263,-289,755,-289,-289,-486,-289,-289,-289\", \"-289,-289,213,-289,-332,-289,213,-479,-480,237,-487,624,-481,239,238\", \"265,240,-487,634,-289,836,805,-289,-289,-289,-289,-487,-289,637,-289\", \"-409,240,240,240,-289,-103,240,-409,-409,-409,-90,555,-409,-409,-409\", \"-486,-409,220,237,213,-99,558,239,238,220,-409,-409,-409,740,741,220\", \"-83,742,107,108,666,-409,-409,220,-409,-409,-409,-409,-409,550,-487\", \"547,546,545,212,548,522,677,682,566,565,510,683,550,559,547,546,545\", \"685,548,508,-409,-409,-409,-409,-409,-409,-409,-409,-409,-409,-409,-409\", \"-409,-409,689,701,-409,-409,-409,692,693,-409,695,265,-409,697,699,-409\", \"-409,701,-409,707,-409,708,-409,709,-409,-409,704,-409,-409,-409,-409\", \"-409,-296,-409,-409,-409,213,711,576,-296,-296,-296,718,735,-296,-296\", \"-296,-279,-296,-409,745,749,-409,-409,-279,-409,750,-409,-296,-296,-262\", \"756,479,-279,-409,479,220,774,-296,-296,259,-296,-296,-296,-296,-296\", \"490,492,798,212,677,212,220,265,265,677,520,550,579,547,546,545,240\", \"548,805,444,220,577,-296,-296,-296,-296,-296,-296,-296,-296,-296,-296\", \"-296,-296,-296,-296,-279,220,-296,-296,-296,830,220,-296,805,274,-296\", \"840,701,-296,-296,220,-296,220,-296,849,-296,704,-296,-296,-263,-296\", \"-296,-296,-296,-296,-280,-296,213,-296,213,858,861,-280,-280,-280,692\", \"864,-280,-280,-280,212,-280,-296,866,868,-296,-296,585,-296,870,-296\", \"-280,-280,-280,220,872,587,-296,873,876,878,-280,-280,879,-280,-280\", \"-280,-280,-280,677,-290,881,-290,-261,212,885,887,-290,890,-290,692\", \"937,892,894,896,898,-290,898,-290,220,587,-280,-280,-280,-280,-280,-280\", \"-280,-280,-280,-280,-280,-280,-280,-280,213,212,-280,-280,-280,904,906\", \"-280,937,908,-280,914,917,-280,-280,220,-280,587,-280,921,-280,-264\", \"-280,-280,931,-280,-280,-280,-280,-280,-290,-280,-290,-280,213,938,555\", \"550,212,547,546,545,939,548,948,984,558,-280,949,-575,-280,-280,-280\", \"-280,982,-280,-244,-280,957,959,960,965,-280,-244,-244,-244,213,735\", \"-244,-244,-244,692,-244,968,701,240,970,972,974,566,565,-244,-244,-244\", \"559,934,974,547,546,545,985,548,-244,-244,986,-244,-244,-244,-244,-244\", \"898,-575,898,213,898,991,957,237,-575,-572,-571,239,238,-571,235,236\", \"682,-575,957,1010,1011,1012,-244,-244,-244,-244,-244,-244,-244,-244\", \"-244,-244,-244,-244,-244,-244,-575,974,-244,-244,-244,-289,974,-244\", \"974,265,-244,220,-289,-244,-244,898,-244,-572,-244,957,-244,-289,-244\", \"-244,974,-244,-244,-244,-244,-244,-575,-244,-244,-244,,550,,547,546\", \"545,,548,-289,,,,,-244,,-289,-244,-244,-576,-244,-572,-244,,,-289,-576\", \"-576,-576,-244,,-576,-576,-576,,-576,240,-289,,701,,,,,-576,-576,-576\", \"-576,903,,,,254,255,,-576,-576,,-576,-576,-576,-576,-576,550,,547,546\", \"545,237,548,243,,239,238,-289,235,236,,,241,,242,,,,-576,-576,-576,-576\", \"-576,-576,-576,-576,-576,-576,-576,-576,-576,-576,,701,-576,-576,-576\", \"240,,-576,,,-576,,,-576,-576,,-576,,-576,,-576,,-576,-576,,-576,-576\", \"-576,-576,-576,,-576,-576,-576,,,,237,,,,239,238,,235,236,,-576,,,-576\", \"-576,-576,-576,,-576,-577,-576,,,,,-576,-577,-577,-577,,,-577,-577,-577\", \"240,-577,934,,547,546,545,,548,,-577,-577,-577,-577,,,254,255,,,,-577\", \"-577,,-577,-577,-577,-577,-577,,,,237,,243,,239,238,,235,236,,,241,\", \"242,116,117,118,119,120,-577,-577,-577,-577,-577,-577,-577,-577,-577\", \"-577,-577,-577,-577,-577,,,-577,-577,-577,,,-577,,,-577,,,-577,-577\", \",-577,,-577,,-577,,-577,-577,,-577,-577,-577,-577,-577,,-577,-577,-577\", \"116,117,118,119,120,,,,550,,547,546,545,-577,548,,-577,-577,-577,-577\", \",-577,-244,-577,,,,,-577,-244,-244,-244,,,-244,-244,-244,550,-244,547\", \"546,545,555,548,,701,,-244,-244,,,,558,,,,240,,-244,-244,,-244,-244\", \"-244,-244,-244,116,117,118,119,120,,254,255,553,,550,,547,546,545,555\", \"548,563,562,566,565,,237,,559,558,239,238,,235,236,,,-244,,,,,240,,-244\", \",,,,265,-244,553,536,,220,,,,254,255,563,562,566,565,,,,559,,,,,-244\", \"-244,237,,243,,239,238,,235,236,,,,,-244,,,-244,,,,,-244,5,69,70,71\", \"9,57,-244,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100\", \"102,103,,,19,,,,,635,8,45,7,10,105,104,106,95,56,97,96,98,,99,107,108\", \",91,92,42,43,41,240,244,249,250,251,246,248,256,257,252,253,,233,234\", \",,254,255,,40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236,247\", \"245,241,20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,258,,-238,,,62\", \",81,93,94,292,69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,\", \",,29,28,27,101,100,102,103,,,19,,,,,620,8,45,294,10,105,104,106,95,56\", \"97,96,98,,99,107,108,,91,92,42,43,41,240,244,249,250,251,246,248,256\", \"257,252,253,,233,234,,,254,255,,40,,,296,,,58,59,,,60,,35,237,,243,44\", \"239,238,,235,236,247,245,241,20,242,,,,89,79,82,83,,84,86,85,87,,,,\", \"80,88,,258,,,,,62,,81,93,94,5,69,70,71,9,57,,,,63,64,,,,67,,65,66,68\", \"30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,635,8,45,7,10,105\", \"104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,240,244,249,250,251\", \"246,248,256,257,252,253,,233,234,,,254,255,,40,,,33,,,58,59,,,60,,35\", \"237,,243,44,239,238,,235,236,247,245,241,20,242,,,,89,79,82,83,,84,86\", \"85,87,,,,,80,88,,258,,,,,62,,81,93,94,292,69,70,71,9,57,,,,63,64,,,\", \"67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,8,45\", \"294,10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,240,244\", \"249,250,251,246,248,256,257,252,253,,233,234,,,254,255,,40,,,33,,,58\", \"59,,,60,,35,237,,243,44,239,238,,235,236,247,245,241,20,242,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,258,,,,,62,,81,93,94,292,69,70,71,9,57\", \",,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,\", \",19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42\", \"43,41,240,244,249,250,251,246,248,256,257,252,253,,233,234,,,254,255\", \",40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236,247,245,241,20\", \"242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,258,,,,,62,,81,93,94,292\", \"69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101\", \"100,102,103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107\", \"108,,91,92,42,43,41,240,244,249,250,251,246,248,256,257,252,253,,233\", \"234,,,254,255,,40,,,296,,,58,59,,,60,,35,237,,243,44,239,238,,235,236\", \"247,245,241,20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,258,,,,,62\", \",81,93,94,292,69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,\", \",,29,28,27,101,100,102,103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97\", \"96,98,,99,107,108,,91,92,42,43,41,240,244,249,250,251,246,248,256,257\", \"252,253,,233,234,,,254,255,,40,,,296,,,58,59,,,60,,35,237,,243,44,239\", \"238,,235,236,247,245,241,20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88\", \"220,258,,,,,62,,81,93,94,292,69,70,71,9,57,,,,63,64,,,,67,,65,66,68\", \"30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,8,45,294,10,105\", \"104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,240,244,249,250,251\", \"246,248,256,257,252,253,,233,234,,,254,255,,40,,,33,,,58,59,,,60,,35\", \"237,,243,44,239,238,,235,236,247,245,241,20,242,,,,89,79,82,83,,84,86\", \"85,87,,,,,80,88,,258,,,,,62,,81,93,94,5,69,70,71,9,57,,,,63,64,,,,67\", \",65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,8,45,7\", \"10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,240,244,249\", \"250,251,246,248,256,257,252,253,,233,234,,,254,255,,40,,,33,,,58,59\", \",,60,,35,237,,243,44,239,238,,235,236,247,245,241,20,242,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,258,,,,,62,,81,93,94,292,69,70,71,9,57,,\", \",63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19\", \",,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43\", \"41,240,244,249,250,251,246,248,256,257,252,253,,233,234,,,254,255,,40\", \",,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236,247,245,241,20,242\", \",,,89,79,82,83,,84,86,85,87,,,,,80,88,,258,,,,,62,,81,93,94,292,69,70\", \"71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102\", \"103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107,108,,91\", \"92,42,43,41,240,244,249,250,251,246,248,256,257,252,253,,233,234,,,254\", \"255,,40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236,247,245,241\", \"20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,258,,,,,62,,81,93,94,292\", \"69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101\", \"100,102,103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107\", \"108,,91,92,42,43,41,240,244,249,250,251,246,248,256,257,252,253,,233\", \"234,,,254,255,,40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236\", \"247,245,241,20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,258,,,,,62\", \",81,93,94,292,69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,\", \",,29,28,27,101,100,102,103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97\", \"96,98,,99,107,108,,91,92,42,43,41,240,244,249,250,251,246,248,256,257\", \"252,253,,233,234,,,254,255,,40,,,33,,,58,59,,,60,,35,237,,243,44,239\", \"238,,235,236,247,245,241,20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88\", \",258,,,,,62,,81,93,94,292,69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30\", \"31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,8,45,294,10,105,104\", \"106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,240,244,249,250,251,246\", \"248,256,257,252,253,,233,234,,,254,255,,40,,,33,,,58,59,,,60,,35,237\", \",243,44,239,238,,235,236,247,245,241,20,242,,,,89,79,82,83,,84,86,85\", \"87,,,,,80,88,,258,,,,,62,,81,93,94,292,69,70,71,9,57,,,,63,64,,,,67\", \",65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,8,45,294\", \"10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,240,244,249\", \"250,251,246,248,256,257,252,253,,233,234,,,254,255,,40,,,33,,,58,59\", \",,60,,35,237,,243,44,239,238,,235,236,247,245,241,20,242,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,258,,,,,62,,81,93,94,292,69,70,71,9,57,,\", \",63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19\", \",,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43\", \"41,240,244,249,250,251,246,248,256,257,252,253,,233,234,,,254,255,,40\", \",,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236,247,245,241,20,242\", \",,,89,79,82,83,,84,86,85,87,,,,,80,88,,258,,,,,62,,81,93,94,292,69,70\", \"71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102\", \"103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107,108,,91\", \"92,42,43,41,240,244,249,250,251,246,248,256,257,252,253,,233,234,,,254\", \"255,,40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236,247,245,241\", \"20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,258,,,,,62,,81,93,94,292\", \"69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101\", \"100,102,103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107\", \"108,,91,92,42,43,41,240,244,249,250,251,246,248,256,257,252,253,,-596\", \"-596,,,254,255,,40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236\", \"247,245,241,20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,550,,547,546\", \"545,62,548,81,93,94,292,69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31\", \"72,73,,,,,701,29,28,27,101,100,102,103,,,19,,,,,,8,45,294,10,105,104\", \"106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,240,244,249,250,251,246\", \"248,256,257,252,253,,-596,-596,,,254,255,,40,,,33,,,58,59,,,60,,35,237\", \",243,44,239,238,,235,236,247,245,241,20,242,,,,89,79,82,83,,84,86,85\", \"87,,,,,80,88,,,,,,,62,,81,93,94,292,69,70,71,9,57,,,,63,64,,,,67,,65\", \"66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,8,45,294,10\", \"105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,240,-596,-596\", \"-596,-596,246,248,,,-596,-596,,,,,,254,255,,40,,,33,,,58,59,,,60,,35\", \"237,,243,44,239,238,,235,236,247,245,241,20,242,,,,89,79,82,83,,84,86\", \"85,87,,,,,80,88,,,,,,,62,,81,93,94,292,69,70,71,9,57,,,,63,64,,,,67\", \",65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,8,45,294\", \"10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,240,,,,,,\", \",,,,,,,,,254,255,,40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235\", \"236,,,241,20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81\", \"93,94,292,69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29\", \"28,27,101,100,102,103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96\", \"98,,99,107,108,,91,92,42,43,41,240,,,,,,,,,,,,,,,,254,255,,40,,,33,\", \",58,59,,,60,,35,237,,243,44,239,238,,235,236,,,241,20,242,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93,94,292,69,70,71,9,57,,,,63\", \"64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,\", \",,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41\", \"240,-596,-596,-596,-596,246,248,,,-596,-596,,,,,,254,255,,40,,,33,,\", \"58,59,,,60,,35,237,,243,44,239,238,,235,236,247,245,241,20,242,,,,89\", \"79,82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93,94,292,69,70,71,9,57\", \",,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,\", \",19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42\", \"43,41,240,-596,-596,-596,-596,246,248,,,-596,-596,,,,,,254,255,,40,\", \",33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236,247,245,241,20,242\", \",,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93,94,292,69,70,71\", \"9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102\", \"103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107,108,,91\", \"92,42,43,41,240,-596,-596,-596,-596,246,248,,,-596,-596,,,,,,254,255\", \",40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236,247,245,241,20\", \"242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93,94,292,69\", \"70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100\", \"102,103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107,108\", \",91,92,42,43,41,240,-596,-596,-596,-596,246,248,,,-596,-596,,,,,,254\", \"255,,40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236,247,245,241\", \"20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93,94,292\", \"69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101\", \"100,102,103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107\", \"108,,91,92,42,43,41,240,-596,-596,-596,-596,246,248,,,-596,-596,,,,\", \",254,255,,40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236,247\", \"245,241,20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93\", \"94,292,69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28\", \"27,101,100,102,103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98\", \",99,107,108,,91,92,42,43,41,240,244,249,250,251,246,248,,,252,253,,\", \",,,254,255,,40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236,247\", \"245,241,20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93\", \"94,292,69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28\", \"27,101,100,102,103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96,98\", \",99,107,108,,91,92,42,43,41,240,244,249,250,251,246,248,256,,252,253\", \",,,,,254,255,,40,,,33,,,58,59,,,60,,35,237,,243,44,239,238,,235,236\", \"247,245,241,20,242,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81\", \"93,94,292,69,70,71,9,57,,,,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29\", \"28,27,101,100,102,103,,,19,,,,,,8,45,294,10,105,104,106,95,56,97,96\", \"98,,99,107,108,,91,92,42,43,41,240,,,,,,,,,,,,,,,,254,255,,40,,,33,\", \",58,59,,,60,,35,237,,243,44,239,238,,235,236,,,,20,,,,,89,79,82,83,\", \"84,86,85,87,,,,,80,88,,,,,,,62,,81,93,94,292,69,70,71,9,57,,,,63,64\", \",,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,\", \"8,45,294,10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,\", \",,,,,,,,,,,,,,,,,,40,,,33,,,58,59,,,60,,35,,,,44,,,,,,,,,20,,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93,94,69,70,71,9,57,,,,63\", \"64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,\", \",,,8,45,7,10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41\", \",,,,,,,,,,,,,,,,,,,40,,,33,,,58,59,,,60,,35,,,,44,,,,,,,,,20,,,,,89\", \"79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,\", \"67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,232,,,,,,,45\", \",,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,\", \",,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,\", \"84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66\", \"68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,232,,,,,,,45,,,105,104\", \"106,95,56,97,96,98,286,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,\", \",225,,,231,,,58,59,,,60,,283,,281,,44,,,287,,,,,,230,,,,,89,284,82,83\", \",84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66\", \"68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,232,,,,,,,45,,,105,104\", \"106,95,56,97,96,98,286,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,\", \",225,,,231,,,58,59,,,60,,283,,281,,44,,,287,,,,,,230,,,,,89,284,82,83\", \",84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66\", \"68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,232,,,,,,,45,,,105,104\", \"106,95,56,97,96,98,286,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,\", \",225,,,231,,,58,59,,,60,,283,,281,,44,,,287,,,,,,230,,,,,89,284,82,83\", \",84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66\", \"68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,309,,\", \"105,104,106,95,56,97,96,98,,99,107,108,,91,92,,,315,,,,,,,,,,,,,,,,\", \",,,305,,,301,,,58,59,,,60,,300,,,,,,,,,,,,,,,,,,89,79,82,83,,84,86,85\", \"87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312\", \"72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,309,,,105,104,106\", \"95,56,97,96,98,,99,107,108,,91,92,,,315,,,,,,,,,,,,,,,,,,,,305,,,231\", \",,58,59,,,60,,,550,,547,546,545,555,548,,,,,,,,,558,,89,79,82,83,,84\", \"86,85,87,,,,,80,88,,,,317,,553,62,,81,93,94,69,70,71,,57,566,565,,63\", \"64,559,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103\", \",,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43\", \"41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,\", \",89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64\", \",,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232\", \",,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,\", \",,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67\", \",65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,\", \",45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,\", \",,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65\", \"66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45\", \",,105,104,106,95,56,97,96,98,286,99,107,108,,91,92,42,43,41,,,,,,,,\", \",,,,,,,,,,,225,,,231,,,58,59,,,60,,283,,,,44,,,287,,,,,,230,,,,,89,284\", \"82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67\", \",65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,\", \",45,,,105,104,106,95,56,97,96,98,286,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,287,,,,,,230,,,,,89\", \"284,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,\", \",67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,,45\", \",,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,\", \",,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84\", \"86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68\", \"30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,,45,,,105,104,106\", \"95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,\", \"231,,,58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85,87,,,\", \",80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73\", \",,,,,29,28,27,101,100,102,103,,,19,,,,,,,45,,,105,104,106,95,56,97,96\", \"98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59\", \",,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,113,\", \",,,112,62,,81,93,94,69,70,71,,57,,,,63,64,,,,67,,65,66,68,311,312,72\", \"73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,309,,,105,104,106,95\", \"56,97,96,98,,99,107,108,,91,92,,,315,,,,,,,,,,,,,,,,,,,,350,,,33,,,58\", \"59,,,60,,35,,,,,,,,,,,,,,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69\", \"70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308\", \"314,101,100,102,103,,,232,,,,,,,309,,,105,104,106,355,56,97,96,356,\", \"99,107,108,,91,92,,,315,,,,,,,,,,,,,,,,,362,,,357,,,231,,,58,59,,,60\", \",,,,,,,,,,,,,,,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62\", \"57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101\", \"100,102,103,,,232,,,,,,,309,,,105,104,106,355,56,97,96,356,,99,107,108\", \",91,92,,,315,,,,,,,,,,,,,,,,,,,,357,,,231,,,58,59,,,60,,,550,,547,546\", \"545,555,548,,,,,,,,,558,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,,,553\", \"62,,81,93,94,69,70,71,9,57,566,565,,63,64,559,,,67,,65,66,68,30,31,72\", \"73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,8,45,7,10,105,104,106,95\", \"56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,40,,,33,\", \",58,59,,,60,,35,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85,87,,,,,80\", \"88,,,,,,390,62,,81,93,94,69,70,71,,57,,,,63,64,,,,67,,65,66,68,30,31\", \"72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,,45,,,105,104,106,95,56\", \"97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,\", \"58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85,87,,,,,80,88\", \",,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29\", \"28,27,101,100,102,103,,,19,,,,,,,45,,,105,104,106,95,56,97,96,98,,99\", \"107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,\", \",,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71\", \"62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100\", \"102,103,,,19,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92\", \"42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,20\", \",,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63\", \"64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,\", \",,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93,94,69,70,71,9,57,,,,63,64\", \",,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,\", \"8,45,,10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,40,,,33,,,58,59,,,60,,35,,,,44,,,,,,,,,20,,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65\", \"66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,232,,,,,,,45,,,105\", \"104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,\", \",,225,,,231,,,58,59,,,60,,406,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84\", \"86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68\", \"30,31,72,73,,,,,,29,28,27,101,100,102,103,,,232,,,,,,,45,,,105,104,106\", \"95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,\", \"231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,\", \",,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73\", \",,,,,29,28,27,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97\", \"96,98,286,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,\", \"58,59,,,60,,283,,281,,44,,,287,,,,,,230,,,,,89,284,82,83,,84,86,85,87\", \",,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72\", \"73,,,,,,29,28,27,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56\", \"97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,\", \"58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88\", \",,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29\", \"28,27,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99\", \"107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,406\", \",,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71\", \"62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100\", \"102,103,,,19,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92\", \"42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,20\", \",,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63\", \"64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,\", \",,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65\", \"66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,,45,,,105\", \"104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,\", \",,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85\", \"87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31\", \"72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,,45,,,105,104,106,95,56\", \"97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,\", \"58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85,87,,,,,80,88\", \"220,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,\", \",,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97\", \"96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58\", \"59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,\", \",,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307\", \"308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98\", \",99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60\", \",,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70\", \"71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314\", \"101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107\", \"108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44\", \",,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57\", \"81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100\", \"102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91\", \"92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,\", \",,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93\", \"94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102\", \"103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42\", \"43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230\", \",,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63\", \"64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,\", \"232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41\", \",,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89\", \"79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,\", \"67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,\", \",,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67\", \",65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,\", \",45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,\", \",,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65\", \"66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45\", \",,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,\", \",,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,\", \"84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66\", \"68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105\", \"104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,\", \",,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86\", \"85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311\", \"312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104\", \"106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225\", \",,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87\", \",,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72\", \"73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95\", \"56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231\", \",,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80\", \"88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,\", \",,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97\", \"96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58\", \"59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,\", \",,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307\", \"308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98\", \",99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60\", \",,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70\", \"71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314\", \"101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107\", \"108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44\", \",,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57\", \"81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100\", \"102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91\", \"92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,\", \",,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93\", \"94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102\", \"103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42\", \"43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230\", \",,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63\", \"64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,\", \"232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41\", \",,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89\", \"79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,\", \"67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,\", \",,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67\", \",65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,\", \",45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,\", \",,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65\", \"66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45\", \",,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,\", \",,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,\", \"84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66\", \"68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105\", \"104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,\", \",,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86\", \"85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311\", \"312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104\", \"106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225\", \",,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87\", \",,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72\", \"73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95\", \"56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231\", \",,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80\", \"88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,\", \",,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97\", \"96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58\", \"59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,\", \",,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307\", \"308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98\", \",99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60\", \",,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70\", \"71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314\", \"101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107\", \"108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44\", \",,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57\", \"81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102\", \"103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,286,99,107,108,,91,92\", \"42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,283,,281,,44,,,287\", \",,,,,230,,,,,89,284,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81\", \"93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103\", \",,232,,,,,,,45,,,105,104,106,95,56,97,96,98,286,99,107,108,,91,92,42\", \"43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,283,,281,,44,,,287\", \",,,,,230,,,,,89,284,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81\", \"93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103\", \",,232,,,,,,,45,,,105,104,106,95,56,97,96,98,286,99,107,108,,91,92,42\", \"43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,283,,281,,44,,,287\", \",,,,,230,,,,,89,284,82,83,,84,86,85,87,,,,,80,88,220,,,69,70,71,62,57\", \"81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100\", \"102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91\", \"92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,\", \",,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93\", \"94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102\", \"103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42\", \"43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230\", \",,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63\", \"64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,\", \"232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41\", \",,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89\", \"79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,\", \"67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,\", \",,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93,94,69,70,71,9,57,,,,63\", \"64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,\", \",,,8,45,,10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,\", \",,,,,,,,,,,,,,,,,,40,,,33,,,58,59,,,60,,35,,,,44,,,,,,,,,20,,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67\", \",65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,\", \",309,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,,,315,,,,,,,,,\", \",,,,,,,,,,305,,,231,,,58,59,,,60,,,550,,547,546,545,555,548,,,,,,,,\", \"558,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,506,,553,62,,81,93,94,69\", \"70,71,,57,566,565,,63,64,559,,,67,,65,66,68,311,312,72,73,,,,,,307,308\", \"314,101,100,102,103,,,232,,,,,,,309,,,105,104,106,95,56,97,96,98,,99\", \"107,108,,91,92,,,315,,,,,,,,,,,,,,,,,,,,305,,,301,,,58,59,,,60,,,,,\", \",,,,,,,,,,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81\", \"93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102\", \"103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42\", \"43,41,,,,,,,,,,,,,,,,,,,,225,,,231,522,,58,59,,,60,,,,,,44,,,,,,,,,230\", \",,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63\", \"64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,\", \",,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65\", \"66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,,45,,,105\", \"104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,\", \",,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85\", \"87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31\", \"72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,,45,,,105,104,106,95,56\", \"97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,\", \"58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85,87,,,,,80,88\", \",,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29\", \"28,27,101,100,102,103,,,19,,,,,,,45,,,105,104,106,95,56,97,96,98,,99\", \"107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,\", \",,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71\", \"62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100\", \"102,103,,,19,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92\", \"42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,20\", \",,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63\", \"64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,\", \"232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41\", \",,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89\", \"79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,\", \"67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,232,,,,,,,45\", \",,105,104,106,95,56,97,96,98,286,99,107,108,,91,92,42,43,41,,,,,,,,\", \",,,,,,,,,,,225,,,231,,,58,59,,,60,,283,,281,,44,,,287,,,,,,230,,,,,89\", \"284,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,\", \",67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,\", \",,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,\", \",,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67\", \",65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,\", \",45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,\", \",,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65\", \"66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45\", \",,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,\", \",,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,\", \"84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66\", \"68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105\", \"104,106,95,56,97,96,98,286,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,\", \",,,,,225,,,231,,,58,59,,,60,,659,,281,,44,,,287,,,,,,230,,,,,89,284\", \"82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67\", \",65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,\", \",45,,,105,104,106,95,56,97,96,98,286,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,281,,44,,,287,,,,,,230,,,,\", \"89,284,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64\", \",,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232\", \",,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,\", \",,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93,94,69,70,71,9,57,,,,63\", \"64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,\", \",,,8,45,294,10,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41\", \",,,,,,,,,,,,,,,,,,,40,,,33,,,58,59,,,60,,35,,,,44,,,,,,,,,20,,,,,89\", \"79,82,83,,84,86,85,87,,,,,80,88,,,,,,390,62,,81,93,94,69,70,71,,57,\", \",,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103\", \",,232,,,,,,,309,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,,,315\", \",,,,,,,,,,,,,,,,,,,305,,,301,,,58,59,,,60,,,,,,,,,,,,,,,,,,,,89,79,82\", \"83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65\", \"66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,232,,,,,,,45,,,105\", \"104,106,95,56,97,96,98,286,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,\", \",,,,,225,,,231,,,58,59,,,60,,283,,281,,44,,,287,,,,,,230,,,,,89,284\", \"82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67\", \",65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,\", \",309,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,,,315,,,,,,,,,\", \",,,,,,,,,,305,,,301,,,58,59,,,60,,,,,,,,,,,,,,,,,,,,89,79,82,83,,84\", \"86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68\", \"311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105\", \"104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,\", \",,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86\", \"85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311\", \"312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104\", \"106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225\", \",,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87\", \",,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72\", \"73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,,45,,,105,104,106,95,56,97\", \"96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58\", \"59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,\", \",69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307\", \"308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98\", \"286,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59\", \",,60,,659,,,,44,,,287,,,,,,230,,,,,89,284,82,83,,84,86,85,87,,,,,80\", \"88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,\", \",,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97\", \"96,98,286,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,\", \"58,59,,,60,,,,,,44,,,287,,,,,,230,,,,,89,284,82,83,,84,86,85,87,,,,\", \"80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73\", \",,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56\", \"97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,\", \"58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88\", \",,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,\", \"307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96\", \"98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59\", \",,60,,283,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,\", \",,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29\", \"28,27,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,286\", \"99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60\", \",283,,281,,44,,,287,,,,,,230,,,,,89,284,82,83,,84,86,85,87,,,,,80,88\", \",,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29\", \"28,27,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,286\", \"99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60\", \",283,,281,,44,,,287,,,,,,230,,,,,89,284,82,83,,84,86,85,87,,,,,80,88\", \",,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,\", \"307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96\", \"98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59\", \",,60,,753,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,\", \",,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307\", \"308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98\", \",99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60\", \",,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70\", \"71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314\", \"101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,286,99,107\", \"108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,659,\", \"281,,44,,,287,,,,,,230,,,,,89,284,82,83,,84,86,85,87,,,,,80,88,,,,69\", \"70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308\", \"314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,286\", \"99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60\", \",,,281,,44,,,287,,,,,,230,,,,,89,284,82,83,,84,86,85,87,,,,,80,88,,\", \",69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28\", \"27,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107\", \"108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44\", \",,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57\", \"81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102\", \"103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42\", \"43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230\", \",,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63\", \"64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,232,\", \",,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,\", \",,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67\", \",65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,232,,,,,,,45,\", \",105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,\", \",,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84\", \"86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68\", \"30,31,72,73,,,,,,29,28,27,101,100,102,103,,,232,,,,,,,45,,,105,104,106\", \"95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,\", \"231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,\", \",,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72\", \"73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95\", \"56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231\", \",,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80\", \"88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,\", \",,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97\", \"96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58\", \"59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,\", \",,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307\", \"308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98\", \",99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60\", \",,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70\", \"71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314\", \"101,100,102,103,,,232,,,,,,,309,,,105,104,106,95,56,97,96,98,,99,107\", \"108,,91,92,,,315,,,,,,,,,,,,,,,,,,,,305,,,301,,,58,59,,,60,,,,,,,,,\", \",,,,,,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93\", \"94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102\", \"103,,,232,,,,,,,309,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92\", \",,315,,,,,,,,,,,,,,,,,,,,305,,,301,,,58,59,,,60,,,,,,,,,,,,,,,,,,,,89\", \"79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,\", \"67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,\", \",,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,406,,,,44,,,,,,,,,230,,,,,89\", \"79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,\", \"67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,\", \",,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67\", \",65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,,45,,\", \"105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,\", \",,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84\", \"86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68\", \"30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,,45,,,105,104,106\", \"95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,\", \"231,,,58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85,87,,,\", \",80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73\", \",,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56\", \"97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,\", \"58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88\", \",,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29\", \"28,27,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99\", \"107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,\", \",,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71\", \"62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314\", \"101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107\", \"108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44\", \",,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57\", \"81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100\", \"102,103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91\", \"92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,\", \",,230,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93\", \"94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102\", \"103,,,232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42\", \"43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230\", \",,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63\", \"64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,\", \"232,,,,,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41\", \",,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89\", \"79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,\", \"67,,65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,\", \",,,,45,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,\", \",,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79\", \"82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67\", \",65,66,68,311,312,72,73,,,,,,307,308,314,101,100,102,103,,,232,,,,,\", \",309,,,105,104,106,95,56,97,96,98,,99,107,108,,91,92,,,315,,,,,,,,,\", \",,,,,,,,,,875,,,231,,,58,59,,,60,,,,,,,,,,,,,,,,,,,,89,79,82,83,,84\", \"86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68\", \"30,31,72,73,,,,,,29,28,27,101,100,102,103,,,19,,,,,,,45,,,105,104,106\", \"95,56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,\", \"231,,,58,59,,,60,,,,,,44,,,,,,,,,20,,,,,89,79,82,83,,84,86,85,87,,,\", \",80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73\", \",,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56\", \"97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,\", \"58,59,,,60,,659,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80\", \"88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,\", \",,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95,56,97\", \"96,98,286,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,\", \"58,59,,,60,,,,281,,44,,,287,,,,,,230,,,,,89,284,82,83,,84,86,85,87,\", \",,,80,88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72\", \"73,,,,,,307,308,314,101,100,102,103,,,232,,,,,,,45,,,105,104,106,95\", \"56,97,96,98,,99,107,108,,91,92,42,43,41,,,,,,,,,,,,,,,,,,,,225,,,231\", \",,58,59,,,60,,,,,,44,,,,,,,,,230,,,,,89,79,82,83,,84,86,85,87,,,,,80\", \"88,,,,69,70,71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,\", \",,,307,308,314,101,100,102,103,,,232,,,,,,,309,,,105,104,106,95,56,97\", \"96,98,,99,107,108,,91,92,,,315,,,,,,,,,,,,,,,,,,,,875,,,231,,,58,59\", \",,60,,,,,,,,,,,,,,,,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70\", \"71,62,57,81,93,94,63,64,,,,67,,65,66,68,311,312,72,73,,,,,,307,308,314\", \"101,100,102,103,,,232,,,,,,,309,,,105,104,106,95,56,97,96,98,,99,107\", \"108,,91,92,,,315,,,,,,,,,,,,,,,,,,,,945,,,231,,,58,59,,,60,,,,,,,,,\", \",,,,,,,,,,89,79,82,83,,84,86,85,87,,,,,80,88,,,,69,70,71,62,57,81,93\", \"94,63,64,,,,67,,65,66,68,30,31,72,73,,,,,,29,28,27,101,100,102,103,\", \",232,,,,,,,45,,,105,104,106,95,56,97,96,98,286,99,107,108,,91,92,42\", \"43,41,,,,,,,,,,,,,,,,,,,,225,,,231,,,58,59,,,60,,283,,281,,44,,,287\", \",,,,,230,,,,,89,284,82,83,,84,86,85,87,,,,,80,88,,,,,,,62,,81,93,94\", \"173,184,174,197,170,190,180,179,200,201,195,178,177,172,198,202,203\", \"182,171,185,189,191,183,176,,,,192,199,194,193,186,196,181,169,188,187\", \",,,,,168,175,166,167,163,164,165,124,126,123,,125,,,,,,,,157,158,,154\", \"136,137,138,145,142,144,,,139,140,,,,159,160,146,147,,,,,,,,,,,,,,151\", \"150,,135,156,153,152,161,148,149,143,141,133,155,134,,,162,89,,,,,,\", \",,,,,,,88,173,184,174,197,170,190,180,179,200,201,195,178,177,172,198\", \"202,203,182,171,185,189,191,183,176,,,,192,199,194,193,186,196,181,169\", \"188,187,,,,,,168,175,166,167,163,164,165,124,126,,,125,,,,,,,,157,158\", \",154,136,137,138,145,142,144,,,139,140,,,,159,160,146,147,,,,,,,,,,\", \",,,151,150,,135,156,153,152,161,148,149,143,141,133,155,134,,,162,89\", \",,,,,,,,,,,,,88,173,184,174,197,170,190,180,179,200,201,195,178,177\", \"172,198,202,203,182,171,185,189,191,183,176,,,,192,199,194,193,186,196\", \"181,169,188,187,,,,,,168,175,166,167,163,164,165,124,126,,,125,,,,,\", \",,157,158,,154,136,137,138,145,142,144,,,139,140,,,,159,160,146,147\", \",,,,,,,,,,,,,151,150,,135,156,153,152,161,148,149,143,141,133,155,134\", \",,162,89,,,,,,,,,,,,,,88,173,184,174,197,170,190,180,179,200,201,195\", \"178,177,172,198,202,203,182,171,185,189,191,183,176,,,,192,199,194,193\", \"186,196,181,169,188,187,,,,,,168,175,166,167,163,164,165,124,126,,,125\", \",,,,,,,157,158,,154,136,137,138,145,142,144,,,139,140,,,,159,160,146\", \"147,,,,,,,,,,,,,,151,150,,135,156,153,152,161,148,149,143,141,133,155\", \"134,,,162,89,,,,,,,,,,,,,,88,173,184,174,197,170,190,180,179,200,201\", \"195,178,177,172,198,202,203,182,171,185,189,191,183,176,,,,192,199,194\", \"373,372,374,371,169,188,187,,,,,,168,175,166,167,368,369,370,366,126\", \"97,96,367,,99,,,,,,157,158,,154,136,137,138,145,142,144,,,139,140,,\", \",159,160,146,147,,,,,,378,,,,,,,,151,150,,135,156,153,152,161,148,149\", \"143,141,133,155,134,,,162,173,184,174,197,170,190,180,179,200,201,195\", \"178,177,172,198,202,203,182,171,185,189,191,183,176,,,,192,199,194,193\", \"186,196,181,169,188,187,,,,,,168,175,166,167,163,164,165,124,126,,,125\", \",,,,,,,157,158,,154,136,137,138,145,142,144,,,139,140,,,,159,160,146\", \"147,,,,,,,,,,,,,,151,150,,135,156,153,152,161,148,149,143,141,133,155\", \"134,415,419,162,,416,,,,,,,,157,158,,154,136,137,138,145,142,144,,,139\", \"140,,,,159,160,146,147,,,,,,265,,,,,,,,151,150,,135,156,153,152,161\", \"148,149,143,141,133,155,134,422,426,162,,421,,,,,,,,157,158,,154,136\", \"137,138,145,142,144,,,139,140,,,,159,160,146,147,,,,,,265,,,,,,,,151\", \"150,,135,156,153,152,161,148,149,143,141,133,155,134,477,419,162,,478\", \",,,,,,,157,158,,154,136,137,138,145,142,144,,,139,140,,,,159,160,146\", \"147,,,,,,,,,,,,,,151,150,,135,156,153,152,161,148,149,143,141,133,155\", \"134,638,419,162,,639,,,,,,,,157,158,,154,136,137,138,145,142,144,,,139\", \"140,,,,159,160,146,147,,,,,,265,,,,,,,,151,150,,135,156,153,152,161\", \"148,149,143,141,133,155,134,640,426,162,,641,,,,,,,,157,158,,154,136\", \"137,138,145,142,144,,,139,140,,,,159,160,146,147,,,,,,265,,,,,,,,151\", \"150,,135,156,153,152,161,148,149,143,141,133,155,134,670,419,162,,671\", \",,,,,,,157,158,,154,136,137,138,145,142,144,,,139,140,,,,159,160,146\", \"147,,,,,,265,,,,,,,,151,150,,135,156,153,152,161,148,149,143,141,133\", \"155,134,673,426,162,,674,,,,,,,,157,158,,154,136,137,138,145,142,144\", \",,139,140,,,,159,160,146,147,,,,,,265,,,,,,,,151,150,,135,156,153,152\", \"161,148,149,143,141,133,155,134,638,419,162,,639,,,,,,,,157,158,,154\", \"136,137,138,145,142,144,,,139,140,,,,159,160,146,147,,,,,,265,,,,,,\", \",151,150,,135,156,153,152,161,148,149,143,141,133,155,134,640,426,162\", \",641,,,,,,,,157,158,,154,136,137,138,145,142,144,,,139,140,,,,159,160\", \"146,147,,,,,,265,,,,,,,,151,150,,135,156,153,152,161,148,149,143,141\", \"133,155,134,721,419,162,,722,,,,,,,,157,158,,154,136,137,138,145,142\", \"144,,,139,140,,,,159,160,146,147,,,,,,265,,,,,,,,151,150,,135,156,153\", \"152,161,148,149,143,141,133,155,134,723,426,162,,724,,,,,,,,157,158\", \",154,136,137,138,145,142,144,,,139,140,,,,159,160,146,147,,,,,,265,\", \",,,,,,151,150,,135,156,153,152,161,148,149,143,141,133,155,134,726,426\", \"162,,727,,,,,,,,157,158,,154,136,137,138,145,142,144,,,139,140,,,,159\", \"160,146,147,,,,,,265,,,,,,,,151,150,,135,156,153,152,161,148,149,143\", \"141,133,155,134,477,419,162,,478,,,,,,,,157,158,,154,136,137,138,145\", \"142,144,,,139,140,,,,159,160,146,147,,,,,,265,,,,,,,,151,150,,135,156\", \"153,152,161,148,149,143,141,133,155,134,980,426,162,,979,,,,,,,,157\", \"158,,154,136,137,138,145,142,144,,,139,140,,,,159,160,146,147,,,,,,265\", \",,,,,,,151,150,,135,156,153,152,161,148,149,143,141,133,155,134,1003\", \"419,162,,1004,,,,,,,,157,158,,154,136,137,138,145,142,144,,,139,140\", \",,,159,160,146,147,,,,,,265,,,,,,,,151,150,,135,156,153,152,161,148\", \"149,143,141,133,155,134,1005,426,162,,1006,,,,,,,,157,158,,154,136,137\", \"138,145,142,144,,,139,140,,,,159,160,146,147,,,,,,265,,,,,,,,151,150\", \",135,156,153,152,161,148,149,143,141,133,155,134,,550,162,547,546,545\", \"555,548,,550,,547,546,545,555,548,558,,,,,,,,558,,550,,547,546,545,555\", \"548,,,,,,553,,,558,,,,,553,563,562,566,565,,,,559,563,562,566,565,,\", \",559,553,,550,,547,546,545,555,548,563,562,566,565,,,,559,558,,550,\", \"547,546,545,555,548,,550,,547,546,545,555,548,558,,,,,553,,,558,,,,\", \",563,562,566,565,,,,559,553,,,,,,,,553,563,562,566,565,,,,559,563,562\", \"566,565,,,550,559,547,546,545,555,548,,550,,547,546,545,555,548,558\", \",,,,,,,558,,550,,547,546,545,555,548,,,,,,553,,,558,,,,,553,563,562\", \"566,565,,,,559,563,562,566,565,,,,559,553,,550,,547,546,545,555,548\", \",,566,565,,,,559,558,,550,,547,546,545,555,548,550,,547,546,545,555\", \"548,,558,,,,,553,,558,,550,,547,546,545,555,548,566,565,,,,559,553,\", \"558,,,,,553,,563,562,566,565,,,,559,,566,565,,,,559,553,,550,,547,546\", \"545,555,548,,,566,565,,,,559,558,,550,,547,546,545,555,548,550,,547\", \"546,545,555,548,,558,,,,,553,,558,,,,,,,,,566,565,,,,559,553,,,,,,,553\", \",,,566,565,,,,559,,566,565,,,,559\"];\n      racc_action_table = (arr = Opal.const_get_qualified('::', 'Array').$new(25163, nil));\n      idx = 0;\n      $send(clist, 'each', [], (TMP_Ruby23_3 = function(str){var self = TMP_Ruby23_3.$$s || this, TMP_4;\nif (str == null) str = nil;\n      return $send(str.$split(\",\", -1), 'each', [], (TMP_4 = function(i){var self = TMP_4.$$s || this, $writer = nil;\nif (i == null) i = nil;\n        \n          if ($truthy(i['$empty?']())) {\n            } else {\n            \n            $writer = [idx, i.$to_i()];\n            $send(arr, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };\n          return (idx = $rb_plus(idx, 1));}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4))}, TMP_Ruby23_3.$$s = self, TMP_Ruby23_3.$$arity = 1, TMP_Ruby23_3));\n      clist = [\"95,439,439,594,594,15,347,95,95,95,58,340,95,95,95,24,95,26,19,385,475\", \"483,24,341,95,386,95,95,95,61,357,650,223,1,357,348,95,95,719,95,95\", \"95,95,95,884,907,942,943,946,351,58,580,15,665,985,475,483,330,310,19\", \"330,7,15,665,484,687,95,95,95,95,95,95,95,95,95,95,95,95,95,95,24,26\", \"95,95,95,385,95,95,572,223,95,386,721,95,95,439,95,594,95,484,95,10\", \"95,95,26,95,95,95,95,95,1003,95,98,95,1004,347,61,722,650,98,98,98,310\", \"1005,98,98,98,95,98,340,95,95,95,95,340,95,98,95,98,98,98,341,95,95\", \"348,310,341,670,98,98,1006,98,98,98,98,98,719,1017,351,719,580,719,884\", \"907,942,943,946,884,907,942,943,946,985,573,687,723,843,985,98,98,98\", \"98,98,98,98,98,98,98,98,98,98,98,572,12,98,98,98,572,98,98,1005,721\", \"98,13,671,98,98,844,98,724,98,3,98,670,98,98,3,98,98,98,98,98,421,98\", \"224,98,722,1006,1003,421,421,421,1004,1003,651,421,421,1004,421,98,723\", \"1005,98,98,98,98,1005,98,16,98,680,680,226,670,98,98,670,22,421,421\", \"800,421,421,421,421,421,670,37,1006,651,671,366,673,1006,724,1017,331\", \"573,366,331,1017,224,573,445,723,843,590,590,421,421,421,421,421,421\", \"421,421,421,421,421,421,421,421,40,638,421,421,421,367,421,226,671,844\", \"421,671,367,421,844,912,724,912,421,45,421,671,421,421,800,421,421,421\", \"421,421,380,421,422,421,366,673,673,77,445,422,422,422,680,17,17,422\", \"422,421,422,77,421,421,109,421,204,421,290,422,638,77,225,290,421,421\", \"800,355,38,800,422,422,367,422,422,422,422,422,673,800,590,673,339,339\", \"227,590,704,639,704,704,704,673,704,41,41,228,380,380,380,232,422,422\", \"422,422,422,422,422,422,422,422,422,422,422,422,264,38,422,422,422,355\", \"422,315,315,494,422,38,355,422,344,773,278,355,422,344,422,355,422,422\", \"39,422,422,422,422,422,639,422,422,422,605,903,607,903,903,903,355,903\", \"368,847,279,356,282,422,847,368,422,422,640,422,704,422,294,41,41,640\", \"640,640,422,422,640,640,640,295,640,297,355,39,773,494,494,494,369,640\", \"640,640,640,39,852,369,298,315,315,852,640,640,494,640,640,640,640,640\", \"299,356,605,605,607,607,381,334,356,382,334,368,605,356,607,383,686\", \"356,305,686,308,903,640,640,640,640,640,640,640,640,640,640,640,640\", \"640,640,356,309,640,640,640,932,640,640,932,369,640,384,319,640,640\", \"387,640,370,640,314,640,415,640,640,370,640,640,640,640,640,356,640\", \"640,640,381,381,381,382,382,382,316,371,320,383,383,383,323,640,371\", \"328,640,640,640,640,332,640,333,640,641,319,525,525,640,640,335,641\", \"641,641,415,319,641,641,641,345,641,384,384,384,415,387,387,387,370\", \"123,641,641,641,346,123,123,692,692,416,350,641,641,352,641,641,641\", \"641,641,361,14,396,46,371,222,372,373,14,402,46,374,222,372,373,710\", \"710,14,374,46,405,222,641,641,641,641,641,641,641,641,641,641,641,641\", \"641,641,407,416,641,641,641,451,641,641,302,411,641,416,376,641,641\", \"302,641,413,641,376,641,621,641,641,302,641,641,641,641,641,14,641,46\", \"641,222,372,373,451,303,414,374,451,451,423,452,303,431,641,993,993\", \"641,641,641,641,303,641,441,641,27,453,454,455,641,641,456,27,27,27\", \"621,689,27,27,27,302,27,481,452,376,621,689,452,452,485,27,27,27,598\", \"598,501,502,598,598,598,505,27,27,507,27,27,27,27,27,832,303,832,832\", \"832,304,832,512,515,523,689,689,304,524,553,689,553,553,553,526,553\", \"304,27,27,27,27,27,27,27,27,27,27,27,27,27,27,538,832,27,27,27,539,541\", \"27,542,27,27,543,552,27,27,553,27,560,27,564,27,567,27,27,553,27,27\", \"27,27,27,28,27,27,27,304,569,574,28,28,28,575,592,28,28,28,306,28,27\", \"602,610,27,27,306,27,612,27,28,28,618,622,627,306,27,632,642,644,28\", \"28,649,28,28,28,28,28,656,658,664,321,667,349,669,672,675,676,321,701\", \"349,701,701,701,679,701,681,321,684,349,28,28,28,28,28,28,28,28,28,28\", \"28,28,28,28,306,688,28,28,28,703,705,28,712,28,28,717,701,28,28,720\", \"28,729,28,733,28,701,28,28,752,28,28,28,28,28,56,28,321,28,349,757,775\", \"56,56,56,776,778,56,56,56,359,56,28,779,780,28,28,359,28,782,28,56,56\", \"56,783,784,359,28,785,789,793,56,56,794,56,56,56,56,56,799,511,803,583\", \"806,874,807,810,511,815,583,816,874,820,821,823,824,511,826,583,829\", \"874,56,56,56,56,56,56,56,56,56,56,56,56,56,56,359,936,56,56,56,831,834\", \"56,936,837,56,846,850,56,56,851,56,936,56,854,56,855,56,56,871,56,56\", \"56,56,56,511,56,583,56,874,875,861,904,944,904,904,904,877,904,888,944\", \"861,56,889,726,56,56,56,56,944,56,417,56,905,909,910,916,56,417,417\", \"417,936,920,417,417,417,922,417,925,904,470,926,927,928,861,861,417\", \"417,417,861,872,930,872,872,872,945,872,417,417,950,417,417,417,417\", \"417,951,726,952,944,953,954,956,470,726,979,980,470,470,726,470,470\", \"981,726,992,994,995,996,417,417,417,417,417,417,417,417,417,417,417\", \"417,417,417,726,997,417,417,417,674,998,417,999,417,417,1002,674,417\", \"417,1007,417,674,417,1008,417,674,417,417,1019,417,417,417,417,417,726\", \"417,417,417,,830,,830,830,830,,830,727,,,,,417,,727,417,417,426,417\", \"727,417,,,727,426,426,426,417,,426,426,426,,426,461,674,,830,,,,,426\", \"426,426,426,830,,,,461,461,,426,426,,426,426,426,426,426,955,,955,955\", \"955,461,955,461,,461,461,727,461,461,,,461,,461,,,,426,426,426,426,426\", \"426,426,426,426,426,426,426,426,426,,955,426,426,426,471,,426,,,426\", \",,426,426,,426,,426,,426,,426,426,,426,426,426,426,426,,426,426,426\", \",,,471,,,,471,471,,471,471,,426,,,426,426,426,426,,426,427,426,,,,,426\", \"427,427,427,,,427,427,427,462,427,978,,978,978,978,,978,,427,427,427\", \"427,,,462,462,,,,427,427,,427,427,427,427,427,,,,462,,462,,462,462,\", \"462,462,,,462,,462,6,6,6,6,6,427,427,427,427,427,427,427,427,427,427\", \"427,427,427,427,,,427,427,427,,,427,,,427,,,427,427,,427,,427,,427,\", \"427,427,,427,427,427,427,427,,427,427,427,293,293,293,293,293,,,,957\", \",957,957,957,427,957,,427,427,427,427,,427,476,427,,,,,427,476,476,476\", \",,476,476,476,646,476,646,646,646,646,646,,957,,476,476,,,,646,,,,459\", \",476,476,,476,476,476,476,476,499,499,499,499,499,,459,459,646,,338\", \",338,338,338,338,338,646,646,646,646,,459,,646,338,459,459,,459,459\", \",,476,,,,,457,,476,,,,,476,476,338,338,,646,,,,457,457,338,338,338,338\", \",,,338,,,,,476,476,457,,457,,457,457,,457,457,,,,,476,,,476,,,,,476\", \"0,0,0,0,0,0,476,,,0,0,,,,0,,0,0,0,0,0,0,0,,,,,,0,0,0,0,0,0,0,,,0,,,\", \",434,0,0,0,0,0,0,0,0,0,0,0,0,,0,0,0,,0,0,0,0,0,434,434,434,434,434,434\", \"434,434,434,434,434,,434,434,,,434,434,,0,,,0,,,0,0,,,0,,0,434,,434\", \"0,434,434,,434,434,434,434,434,0,434,,,,0,0,0,0,,0,0,0,0,,,,,0,0,,434\", \",434,,,0,,0,0,0,33,33,33,33,33,33,,,,33,33,,,,33,,33,33,33,33,33,33\", \"33,,,,,,33,33,33,33,33,33,33,,,33,,,,,410,33,33,33,33,33,33,33,33,33\", \"33,33,33,,33,33,33,,33,33,33,33,33,410,410,410,410,410,410,410,410,410\", \"410,410,,410,410,,,410,410,,33,,,33,,,33,33,,,33,,33,410,,410,33,410\", \"410,,410,410,410,410,410,33,410,,,,33,33,33,33,,33,33,33,33,,,,,33,33\", \",410,,,,,33,,33,33,33,121,121,121,121,121,121,,,,121,121,,,,121,,121\", \"121,121,121,121,121,121,,,,,,121,121,121,121,121,121,121,,,121,,,,,643\", \"121,121,121,121,121,121,121,121,121,121,121,121,,121,121,121,,121,121\", \"121,121,121,643,643,643,643,643,643,643,643,643,643,643,,643,643,,,643\", \"643,,121,,,121,,,121,121,,,121,,121,643,,643,121,643,643,,643,643,643\", \"643,643,121,643,,,,121,121,121,121,,121,121,121,121,,,,,121,121,,643\", \",,,,121,,121,121,121,206,206,206,206,206,206,,,,206,206,,,,206,,206\", \"206,206,206,206,206,206,,,,,,206,206,206,206,206,206,206,,,206,,,,,\", \"206,206,206,206,206,206,206,206,206,206,206,206,,206,206,206,,206,206\", \"206,206,206,21,21,21,21,21,21,21,21,21,21,21,,21,21,,,21,21,,206,,,206\", \",,206,206,,,206,,206,21,,21,206,21,21,,21,21,21,21,21,206,21,,,,206\", \"206,206,206,,206,206,206,206,,,,,206,206,,21,,,,,206,,206,206,206,231\", \"231,231,231,231,231,,,,231,231,,,,231,,231,231,231,231,231,231,231,\", \",,,,231,231,231,231,231,231,231,,,231,,,,,,231,231,231,231,231,231,231\", \"231,231,231,231,231,,231,231,231,,231,231,231,231,231,276,276,276,276\", \"276,276,276,276,276,276,276,,276,276,,,276,276,,231,,,231,,,231,231\", \",,231,,231,276,,276,231,276,276,,276,276,276,276,276,231,276,,,,231\", \"231,231,231,,231,231,231,231,,,,,231,231,,276,,,,,231,,231,231,231,296\", \"296,296,296,296,296,,,,296,296,,,,296,,296,296,296,296,296,296,296,\", \",,,,296,296,296,296,296,296,296,,,296,,,,,,296,296,296,296,296,296,296\", \"296,296,296,296,296,,296,296,296,,296,296,296,296,296,429,429,429,429\", \"429,429,429,429,429,429,429,,429,429,,,429,429,,296,,,296,,,296,296\", \",,296,,296,429,,429,296,429,429,,429,429,429,429,429,296,429,,,,296\", \"296,296,296,,296,296,296,296,,,,,296,296,,429,,,,,296,,296,296,296,301\", \"301,301,301,301,301,,,,301,301,,,,301,,301,301,301,301,301,301,301,\", \",,,,301,301,301,301,301,301,301,,,301,,,,,,301,301,301,301,301,301,301\", \"301,301,301,301,301,,301,301,301,,301,301,301,301,301,474,474,474,474\", \"474,474,474,474,474,474,474,,474,474,,,474,474,,301,,,301,,,301,301\", \",,301,,301,474,,474,301,474,474,,474,474,474,474,474,301,474,,,,301\", \"301,301,301,,301,301,301,301,,,,,301,301,474,474,,,,,301,,301,301,301\", \"326,326,326,326,326,326,,,,326,326,,,,326,,326,326,326,326,326,326,326\", \",,,,,326,326,326,326,326,326,326,,,326,,,,,,326,326,326,326,326,326\", \"326,326,326,326,326,326,,326,326,326,,326,326,326,326,326,521,521,521\", \"521,521,521,521,521,521,521,521,,521,521,,,521,521,,326,,,326,,,326\", \"326,,,326,,326,521,,521,326,521,521,,521,521,521,521,521,326,521,,,\", \"326,326,326,326,,326,326,326,326,,,,,326,326,,521,,,,,326,,326,326,326\", \"500,500,500,500,500,500,,,,500,500,,,,500,,500,500,500,500,500,500,500\", \",,,,,500,500,500,500,500,500,500,,,500,,,,,,500,500,500,500,500,500\", \"500,500,500,500,500,500,,500,500,500,,500,500,500,500,500,678,678,678\", \"678,678,678,678,678,678,678,678,,678,678,,,678,678,,500,,,500,,,500\", \"500,,,500,,500,678,,678,500,678,678,,678,678,678,678,678,500,678,,,\", \"500,500,500,500,,500,500,500,500,,,,,500,500,,678,,,,,500,,500,500,500\", \"568,568,568,568,568,568,,,,568,568,,,,568,,568,568,568,568,568,568,568\", \",,,,,568,568,568,568,568,568,568,,,568,,,,,,568,568,568,568,568,568\", \"568,568,568,568,568,568,,568,568,568,,568,568,568,568,568,754,754,754\", \"754,754,754,754,754,754,754,754,,754,754,,,754,754,,568,,,568,,,568\", \"568,,,568,,568,754,,754,568,754,754,,754,754,754,754,754,568,754,,,\", \"568,568,568,568,,568,568,568,568,,,,,568,568,,754,,,,,568,,568,568,568\", \"571,571,571,571,571,571,,,,571,571,,,,571,,571,571,571,571,571,571,571\", \",,,,,571,571,571,571,571,571,571,,,571,,,,,,571,571,571,571,571,571\", \"571,571,571,571,571,571,,571,571,571,,571,571,571,571,571,759,759,759\", \"759,759,759,759,759,759,759,759,,759,759,,,759,759,,571,,,571,,,571\", \"571,,,571,,571,759,,759,571,759,759,,759,759,759,759,759,571,759,,,\", \"571,571,571,571,,571,571,571,571,,,,,571,571,,759,,,,,571,,571,571,571\", \"591,591,591,591,591,591,,,,591,591,,,,591,,591,591,591,591,591,591,591\", \",,,,,591,591,591,591,591,591,591,,,591,,,,,,591,591,591,591,591,591\", \"591,591,591,591,591,591,,591,591,591,,591,591,591,591,591,761,761,761\", \"761,761,761,761,761,761,761,761,,761,761,,,761,761,,591,,,591,,,591\", \"591,,,591,,591,761,,761,591,761,761,,761,761,761,761,761,591,761,,,\", \"591,591,591,591,,591,591,591,591,,,,,591,591,,761,,,,,591,,591,591,591\", \"648,648,648,648,648,648,,,,648,648,,,,648,,648,648,648,648,648,648,648\", \",,,,,648,648,648,648,648,648,648,,,648,,,,,,648,648,648,648,648,648\", \"648,648,648,648,648,648,,648,648,648,,648,648,648,648,648,764,764,764\", \"764,764,764,764,764,764,764,764,,764,764,,,764,764,,648,,,648,,,648\", \"648,,,648,,648,764,,764,648,764,764,,764,764,764,764,764,648,764,,,\", \"648,648,648,648,,648,648,648,648,,,,,648,648,,764,,,,,648,,648,648,648\", \"653,653,653,653,653,653,,,,653,653,,,,653,,653,653,653,653,653,653,653\", \",,,,,653,653,653,653,653,653,653,,,653,,,,,,653,653,653,653,653,653\", \"653,653,653,653,653,653,,653,653,653,,653,653,653,653,653,766,766,766\", \"766,766,766,766,766,766,766,766,,766,766,,,766,766,,653,,,653,,,653\", \"653,,,653,,653,766,,766,653,766,766,,766,766,766,766,766,653,766,,,\", \"653,653,653,653,,653,653,653,653,,,,,653,653,,766,,,,,653,,653,653,653\", \"654,654,654,654,654,654,,,,654,654,,,,654,,654,654,654,654,654,654,654\", \",,,,,654,654,654,654,654,654,654,,,654,,,,,,654,654,654,654,654,654\", \"654,654,654,654,654,654,,654,654,654,,654,654,654,654,654,768,768,768\", \"768,768,768,768,768,768,768,768,,768,768,,,768,768,,654,,,654,,,654\", \"654,,,654,,654,768,,768,654,768,768,,768,768,768,768,768,654,768,,,\", \"654,654,654,654,,654,654,654,654,,,,,654,654,,768,,,,,654,,654,654,654\", \"730,730,730,730,730,730,,,,730,730,,,,730,,730,730,730,730,730,730,730\", \",,,,,730,730,730,730,730,730,730,,,730,,,,,,730,730,730,730,730,730\", \"730,730,730,730,730,730,,730,730,730,,730,730,730,730,730,857,857,857\", \"857,857,857,857,857,857,857,857,,857,857,,,857,857,,730,,,730,,,730\", \"730,,,730,,730,857,,857,730,857,857,,857,857,857,857,857,730,857,,,\", \"730,730,730,730,,730,730,730,730,,,,,730,730,,857,,,,,730,,730,730,730\", \"734,734,734,734,734,734,,,,734,734,,,,734,,734,734,734,734,734,734,734\", \",,,,,734,734,734,734,734,734,734,,,734,,,,,,734,734,734,734,734,734\", \"734,734,734,734,734,734,,734,734,734,,734,734,734,734,734,860,860,860\", \"860,860,860,860,860,860,860,860,,860,860,,,860,860,,734,,,734,,,734\", \"734,,,734,,734,860,,860,734,860,860,,860,860,860,860,860,734,860,,,\", \"734,734,734,734,,734,734,734,734,,,,,734,734,,860,,,,,734,,734,734,734\", \"744,744,744,744,744,744,,,,744,744,,,,744,,744,744,744,744,744,744,744\", \",,,,,744,744,744,744,744,744,744,,,744,,,,,,744,744,744,744,744,744\", \"744,744,744,744,744,744,,744,744,744,,744,744,744,744,744,449,449,449\", \"449,449,449,449,449,449,449,449,,449,449,,,449,449,,744,,,744,,,744\", \"744,,,744,,744,449,,449,744,449,449,,449,449,449,449,449,744,449,,,\", \"744,744,744,744,,744,744,744,744,,,,,744,744,,991,,991,991,991,744,991\", \"744,744,744,792,792,792,792,792,792,,,,792,792,,,,792,,792,792,792,792\", \"792,792,792,,,,,991,792,792,792,792,792,792,792,,,792,,,,,,792,792,792\", \"792,792,792,792,792,792,792,792,792,,792,792,792,,792,792,792,792,792\", \"450,450,450,450,450,450,450,450,450,450,450,,450,450,,,450,450,,792\", \",,792,,,792,792,,,792,,792,450,,450,792,450,450,,450,450,450,450,450\", \"792,450,,,,792,792,792,792,,792,792,792,792,,,,,792,792,,,,,,,792,,792\", \"792,792,805,805,805,805,805,805,,,,805,805,,,,805,,805,805,805,805,805\", \"805,805,,,,,,805,805,805,805,805,805,805,,,805,,,,,,805,805,805,805\", \"805,805,805,805,805,805,805,805,,805,805,805,,805,805,805,805,805,460\", \"460,460,460,460,460,460,,,460,460,,,,,,460,460,,805,,,805,,,805,805\", \",,805,,805,460,,460,805,460,460,,460,460,460,460,460,805,460,,,,805\", \"805,805,805,,805,805,805,805,,,,,805,805,,,,,,,805,,805,805,805,813\", \"813,813,813,813,813,,,,813,813,,,,813,,813,813,813,813,813,813,813,\", \",,,,813,813,813,813,813,813,813,,,813,,,,,,813,813,813,813,813,813,813\", \"813,813,813,813,813,,813,813,813,,813,813,813,813,813,463,,,,,,,,,,\", \",,,,,463,463,,813,,,813,,,813,813,,,813,,813,463,,463,813,463,463,,463\", \"463,,,463,813,463,,,,813,813,813,813,,813,813,813,813,,,,,813,813,,\", \",,,,813,,813,813,813,814,814,814,814,814,814,,,,814,814,,,,814,,814\", \"814,814,814,814,814,814,,,,,,814,814,814,814,814,814,814,,,814,,,,,\", \"814,814,814,814,814,814,814,814,814,814,814,814,,814,814,814,,814,814\", \"814,814,814,464,,,,,,,,,,,,,,,,464,464,,814,,,814,,,814,814,,,814,,814\", \"464,,464,814,464,464,,464,464,,,464,814,464,,,,814,814,814,814,,814\", \"814,814,814,,,,,814,814,,,,,,,814,,814,814,814,838,838,838,838,838,838\", \",,,838,838,,,,838,,838,838,838,838,838,838,838,,,,,,838,838,838,838\", \"838,838,838,,,838,,,,,,838,838,838,838,838,838,838,838,838,838,838,838\", \",838,838,838,,838,838,838,838,838,465,465,465,465,465,465,465,,,465\", \"465,,,,,,465,465,,838,,,838,,,838,838,,,838,,838,465,,465,838,465,465\", \",465,465,465,465,465,838,465,,,,838,838,838,838,,838,838,838,838,,,\", \",838,838,,,,,,,838,,838,838,838,839,839,839,839,839,839,,,,839,839,\", \",,839,,839,839,839,839,839,839,839,,,,,,839,839,839,839,839,839,839\", \",,839,,,,,,839,839,839,839,839,839,839,839,839,839,839,839,,839,839\", \"839,,839,839,839,839,839,466,466,466,466,466,466,466,,,466,466,,,,,\", \"466,466,,839,,,839,,,839,839,,,839,,839,466,,466,839,466,466,,466,466\", \"466,466,466,839,466,,,,839,839,839,839,,839,839,839,839,,,,,839,839\", \",,,,,,839,,839,839,839,842,842,842,842,842,842,,,,842,842,,,,842,,842\", \"842,842,842,842,842,842,,,,,,842,842,842,842,842,842,842,,,842,,,,,\", \"842,842,842,842,842,842,842,842,842,842,842,842,,842,842,842,,842,842\", \"842,842,842,467,467,467,467,467,467,467,,,467,467,,,,,,467,467,,842\", \",,842,,,842,842,,,842,,842,467,,467,842,467,467,,467,467,467,467,467\", \"842,467,,,,842,842,842,842,,842,842,842,842,,,,,842,842,,,,,,,842,,842\", \"842,842,848,848,848,848,848,848,,,,848,848,,,,848,,848,848,848,848,848\", \"848,848,,,,,,848,848,848,848,848,848,848,,,848,,,,,,848,848,848,848\", \"848,848,848,848,848,848,848,848,,848,848,848,,848,848,848,848,848,468\", \"468,468,468,468,468,468,,,468,468,,,,,,468,468,,848,,,848,,,848,848\", \",,848,,848,468,,468,848,468,468,,468,468,468,468,468,848,468,,,,848\", \"848,848,848,,848,848,848,848,,,,,848,848,,,,,,,848,,848,848,848,881\", \"881,881,881,881,881,,,,881,881,,,,881,,881,881,881,881,881,881,881,\", \",,,,881,881,881,881,881,881,881,,,881,,,,,,881,881,881,881,881,881,881\", \"881,881,881,881,881,,881,881,881,,881,881,881,881,881,469,469,469,469\", \"469,469,469,,,469,469,,,,,,469,469,,881,,,881,,,881,881,,,881,,881,469\", \",469,881,469,469,,469,469,469,469,469,881,469,,,,881,881,881,881,,881\", \"881,881,881,,,,,881,881,,,,,,,881,,881,881,881,941,941,941,941,941,941\", \",,,941,941,,,,941,,941,941,941,941,941,941,941,,,,,,941,941,941,941\", \"941,941,941,,,941,,,,,,941,941,941,941,941,941,941,941,941,941,941,941\", \",941,941,941,,941,941,941,941,941,472,472,472,472,472,472,472,,,472\", \"472,,,,,,472,472,,941,,,941,,,941,941,,,941,,941,472,,472,941,472,472\", \",472,472,472,472,472,941,472,,,,941,941,941,941,,941,941,941,941,,,\", \",941,941,,,,,,,941,,941,941,941,958,958,958,958,958,958,,,,958,958,\", \",,958,,958,958,958,958,958,958,958,,,,,,958,958,958,958,958,958,958\", \",,958,,,,,,958,958,958,958,958,958,958,958,958,958,958,958,,958,958\", \"958,,958,958,958,958,958,473,473,473,473,473,473,473,473,,473,473,,\", \",,,473,473,,958,,,958,,,958,958,,,958,,958,473,,473,958,473,473,,473\", \"473,473,473,473,958,473,,,,958,958,958,958,,958,958,958,958,,,,,958\", \"958,,,,,,,958,,958,958,958,964,964,964,964,964,964,,,,964,964,,,,964\", \",964,964,964,964,964,964,964,,,,,,964,964,964,964,964,964,964,,,964\", \",,,,,964,964,964,964,964,964,964,964,964,964,964,964,,964,964,964,,964\", \"964,964,964,964,458,,,,,,,,,,,,,,,,458,458,,964,,,964,,,964,964,,,964\", \",964,458,,458,964,458,458,,458,458,,,,964,,,,,964,964,964,964,,964,964\", \"964,964,,,,,964,964,,,,,,,964,,964,964,964,966,966,966,966,966,966,\", \",,966,966,,,,966,,966,966,966,966,966,966,966,,,,,,966,966,966,966,966\", \"966,966,,,966,,,,,,966,966,966,966,966,966,966,966,966,966,966,966,\", \"966,966,966,,966,966,966,966,966,,,,,,,,,,,,,,,,,,,,966,,,966,,,966\", \"966,,,966,,966,,,,966,,,,,,,,,966,,,,,966,966,966,966,,966,966,966,966\", \",,,,966,966,,,,,,,966,,966,966,966,5,5,5,5,5,,,,5,5,,,,5,,5,5,5,5,5\", \"5,5,,,,,,5,5,5,5,5,5,5,,,5,,,,,,5,5,5,5,5,5,5,5,5,5,5,5,,5,5,5,,5,5\", \"5,5,5,,,,,,,,,,,,,,,,,,,,5,,,5,,,5,5,,,5,,5,,,,5,,,,,,,,,5,,,,,5,5,5\", \"5,,5,5,5,5,,,,,5,5,,,,20,20,20,5,20,5,5,5,20,20,,,,20,,20,20,20,20,20\", \"20,20,,,,,,20,20,20,20,20,20,20,,,20,,,,,,,20,,,20,20,20,20,20,20,20\", \"20,,20,20,20,,20,20,20,20,20,,,,,,,,,,,,,,,,,,,,20,,,20,,,20,20,,,20\", \",,,,,20,,,,,,,,,20,,,,,20,20,20,20,,20,20,20,20,,,,,20,20,,,,29,29,29\", \"20,29,20,20,20,29,29,,,,29,,29,29,29,29,29,29,29,,,,,,29,29,29,29,29\", \"29,29,,,29,,,,,,,29,,,29,29,29,29,29,29,29,29,29,29,29,29,,29,29,29\", \"29,29,,,,,,,,,,,,,,,,,,,,29,,,29,,,29,29,,,29,,29,,29,,29,,,29,,,,,\", \"29,,,,,29,29,29,29,,29,29,29,29,,,,,29,29,,,,30,30,30,29,30,29,29,29\", \"30,30,,,,30,,30,30,30,30,30,30,30,,,,,,30,30,30,30,30,30,30,,,30,,,\", \",,,30,,,30,30,30,30,30,30,30,30,30,30,30,30,,30,30,30,30,30,,,,,,,,\", \",,,,,,,,,,,30,,,30,,,30,30,,,30,,30,,30,,30,,,30,,,,,,30,,,,,30,30,30\", \"30,,30,30,30,30,,,,,30,30,,,,31,31,31,30,31,30,30,30,31,31,,,,31,,31\", \"31,31,31,31,31,31,,,,,,31,31,31,31,31,31,31,,,31,,,,,,,31,,,31,31,31\", \"31,31,31,31,31,31,31,31,31,,31,31,31,31,31,,,,,,,,,,,,,,,,,,,,31,,,31\", \",,31,31,,,31,,31,,31,,31,,,31,,,,,,31,,,,,31,31,31,31,,31,31,31,31,\", \",,,31,31,,,,34,34,34,31,34,31,31,31,34,34,,,,34,,34,34,34,34,34,34,34\", \",,,,,34,34,34,34,34,34,34,,,34,,,,,,,34,,,34,34,34,34,34,34,34,34,,34\", \"34,34,,34,34,,,34,,,,,,,,,,,,,,,,,,,,34,,,34,,,34,34,,,34,,34,,,,,,\", \",,,,,,,,,,,34,34,34,34,,34,34,34,34,,,,,34,34,,,,35,35,35,34,35,34,34\", \"34,35,35,,,,35,,35,35,35,35,35,35,35,,,,,,35,35,35,35,35,35,35,,,35\", \",,,,,,35,,,35,35,35,35,35,35,35,35,,35,35,35,,35,35,,,35,,,,,,,,,,,\", \",,,,,,,,35,,,35,,,35,35,,,35,,,697,,697,697,697,697,697,,,,,,,,,697\", \",35,35,35,35,,35,35,35,35,,,,,35,35,,,,35,,697,35,,35,35,35,42,42,42\", \",42,697,697,,42,42,697,,,42,,42,42,42,42,42,42,42,,,,,,42,42,42,42,42\", \"42,42,,,42,,,,,,,42,,,42,42,42,42,42,42,42,42,,42,42,42,,42,42,42,42\", \"42,,,,,,,,,,,,,,,,,,,,42,,,42,,,42,42,,,42,,,,,,42,,,,,,,,,42,,,,,42\", \"42,42,42,,42,42,42,42,,,,,42,42,,,,43,43,43,42,43,42,42,42,43,43,,,\", \"43,,43,43,43,43,43,43,43,,,,,,43,43,43,43,43,43,43,,,43,,,,,,,43,,,43\", \"43,43,43,43,43,43,43,,43,43,43,,43,43,43,43,43,,,,,,,,,,,,,,,,,,,,43\", \",,43,,,43,43,,,43,,,,,,43,,,,,,,,,43,,,,,43,43,43,43,,43,43,43,43,,\", \",,43,43,,,,44,44,44,43,44,43,43,43,44,44,,,,44,,44,44,44,44,44,44,44\", \",,,,,44,44,44,44,44,44,44,,,44,,,,,,,44,,,44,44,44,44,44,44,44,44,,44\", \"44,44,,44,44,44,44,44,,,,,,,,,,,,,,,,,,,,44,,,44,,,44,44,,,44,,,,,,44\", \",,,,,,,,44,,,,,44,44,44,44,,44,44,44,44,,,,,44,44,,,,59,59,59,44,59\", \"44,44,44,59,59,,,,59,,59,59,59,59,59,59,59,,,,,,59,59,59,59,59,59,59\", \",,59,,,,,,,59,,,59,59,59,59,59,59,59,59,59,59,59,59,,59,59,59,59,59\", \",,,,,,,,,,,,,,,,,,,59,,,59,,,59,59,,,59,,59,,,,59,,,59,,,,,,59,,,,,59\", \"59,59,59,,59,59,59,59,,,,,59,59,,,,60,60,60,59,60,59,59,59,60,60,,,\", \"60,,60,60,60,60,60,60,60,,,,,,60,60,60,60,60,60,60,,,60,,,,,,,60,,,60\", \"60,60,60,60,60,60,60,60,60,60,60,,60,60,60,60,60,,,,,,,,,,,,,,,,,,,\", \"60,,,60,,,60,60,,,60,,,,,,60,,,60,,,,,,60,,,,,60,60,60,60,,60,60,60\", \"60,,,,,60,60,,,,63,63,63,60,63,60,60,60,63,63,,,,63,,63,63,63,63,63\", \"63,63,,,,,,63,63,63,63,63,63,63,,,63,,,,,,,63,,,63,63,63,63,63,63,63\", \"63,,63,63,63,,63,63,63,63,63,,,,,,,,,,,,,,,,,,,,63,,,63,,,63,63,,,63\", \",,,,,63,,,,,,,,,63,,,,,63,63,63,63,,63,63,63,63,,,,,63,63,,,,64,64,64\", \"63,64,63,63,63,64,64,,,,64,,64,64,64,64,64,64,64,,,,,,64,64,64,64,64\", \"64,64,,,64,,,,,,,64,,,64,64,64,64,64,64,64,64,,64,64,64,,64,64,64,64\", \"64,,,,,,,,,,,,,,,,,,,,64,,,64,,,64,64,,,64,,,,,,64,,,,,,,,,64,,,,,64\", \"64,64,64,,64,64,64,64,,,,,64,64,,,,67,67,67,64,67,64,64,64,67,67,,,\", \"67,,67,67,67,67,67,67,67,,,,,,67,67,67,67,67,67,67,,,67,,,,,,,67,,,67\", \"67,67,67,67,67,67,67,,67,67,67,,67,67,67,67,67,,,,,,,,,,,,,,,,,,,,67\", \",,67,,,67,67,,,67,,,,,,67,,,,,,,,,67,,,,,67,67,67,67,,67,67,67,67,,\", \",,67,67,67,,,,,67,67,,67,67,67,68,68,68,,68,,,,68,68,,,,68,,68,68,68\", \"68,68,68,68,,,,,,68,68,68,68,68,68,68,,,68,,,,,,,68,,,68,68,68,68,68\", \"68,68,68,,68,68,68,,68,68,,,68,,,,,,,,,,,,,,,,,,,,68,,,68,,,68,68,,\", \"68,,68,,,,,,,,,,,,,,,,,,68,68,68,68,,68,68,68,68,,,,,68,68,,,,69,69\", \"69,68,69,68,68,68,69,69,,,,69,,69,69,69,69,69,69,69,,,,,,69,69,69,69\", \"69,69,69,,,69,,,,,,,69,,,69,69,69,69,69,69,69,69,,69,69,69,,69,69,,\", \"69,,,,,,,,,,,,,,,,,69,,,69,,,69,,,69,69,,,69,,,,,,,,,,,,,,,,,,,,69,69\", \"69,69,,69,69,69,69,,,,,69,69,,,,70,70,70,69,70,69,69,69,70,70,,,,70\", \",70,70,70,70,70,70,70,,,,,,70,70,70,70,70,70,70,,,70,,,,,,,70,,,70,70\", \"70,70,70,70,70,70,,70,70,70,,70,70,,,70,,,,,,,,,,,,,,,,,,,,70,,,70,\", \",70,70,,,70,,,868,,868,868,868,868,868,,,,,,,,,868,,70,70,70,70,,70\", \"70,70,70,,,,,70,70,,,,,,868,70,,70,70,70,111,111,111,111,111,868,868\", \",111,111,868,,,111,,111,111,111,111,111,111,111,,,,,,111,111,111,111\", \"111,111,111,,,111,,,,,,111,111,111,111,111,111,111,111,111,111,111,111\", \",111,111,111,,111,111,111,111,111,,,,,,,,,,,,,,,,,,,,111,,,111,,,111\", \"111,,,111,,111,,,,111,,,,,,,,,111,,,,,111,111,111,111,,111,111,111,111\", \",,,,111,111,,,,,,111,111,,111,111,111,116,116,116,,116,,,,116,116,,\", \",116,,116,116,116,116,116,116,116,,,,,,116,116,116,116,116,116,116,\", \",116,,,,,,,116,,,116,116,116,116,116,116,116,116,,116,116,116,,116,116\", \"116,116,116,,,,,,,,,,,,,,,,,,,,116,,,116,,,116,116,,,116,,,,,,116,,\", \",,,,,,116,,,,,116,116,116,116,,116,116,116,116,,,,,116,116,,,,117,117\", \"117,116,117,116,116,116,117,117,,,,117,,117,117,117,117,117,117,117\", \",,,,,117,117,117,117,117,117,117,,,117,,,,,,,117,,,117,117,117,117,117\", \"117,117,117,,117,117,117,,117,117,117,117,117,,,,,,,,,,,,,,,,,,,,117\", \",,117,,,117,117,,,117,,,,,,117,,,,,,,,,117,,,,,117,117,117,117,,117\", \"117,117,117,,,,,117,117,,,,118,118,118,117,118,117,117,117,118,118,\", \",,118,,118,118,118,118,118,118,118,,,,,,118,118,118,118,118,118,118\", \",,118,,,,,,,118,,,118,118,118,118,118,118,118,118,,118,118,118,,118\", \"118,118,118,118,,,,,,,,,,,,,,,,,,,,118,,,118,,,118,118,,,118,,,,,,118\", \",,,,,,,,118,,,,,118,118,118,118,,118,118,118,118,,,,,118,118,,,,119\", \"119,119,118,119,118,118,118,119,119,,,,119,,119,119,119,119,119,119\", \"119,,,,,,119,119,119,119,119,119,119,,,119,,,,,,,119,,,119,119,119,119\", \"119,119,119,119,,119,119,119,,119,119,119,119,119,,,,,,,,,,,,,,,,,,\", \",119,,,119,,,119,119,,,119,,,,,,119,,,,,,,,,119,,,,,119,119,119,119\", \",119,119,119,119,,,,,119,119,,,,,,,119,,119,119,119,120,120,120,120\", \"120,,,,120,120,,,,120,,120,120,120,120,120,120,120,,,,,,120,120,120\", \"120,120,120,120,,,120,,,,,,120,120,,120,120,120,120,120,120,120,120\", \"120,,120,120,120,,120,120,120,120,120,,,,,,,,,,,,,,,,,,,,120,,,120,\", \",120,120,,,120,,120,,,,120,,,,,,,,,120,,,,,120,120,120,120,,120,120\", \"120,120,,,,,120,120,,,,207,207,207,120,207,120,120,120,207,207,,,,207\", \",207,207,207,207,207,207,207,,,,,,207,207,207,207,207,207,207,,,207\", \",,,,,,207,,,207,207,207,207,207,207,207,207,,207,207,207,,207,207,207\", \"207,207,,,,,,,,,,,,,,,,,,,,207,,,207,,,207,207,,,207,,207,,,,207,,,\", \",,,,,207,,,,,207,207,207,207,,207,207,207,207,,,,,207,207,,,,208,208\", \"208,207,208,207,207,207,208,208,,,,208,,208,208,208,208,208,208,208\", \",,,,,208,208,208,208,208,208,208,,,208,,,,,,,208,,,208,208,208,208,208\", \"208,208,208,,208,208,208,,208,208,208,208,208,,,,,,,,,,,,,,,,,,,,208\", \",,208,,,208,208,,,208,,,,,,208,,,,,,,,,208,,,,,208,208,208,208,,208\", \"208,208,208,,,,,208,208,,,,209,209,209,208,209,208,208,208,209,209,\", \",,209,,209,209,209,209,209,209,209,,,,,,209,209,209,209,209,209,209\", \",,209,,,,,,,209,,,209,209,209,209,209,209,209,209,209,209,209,209,,209\", \"209,209,209,209,,,,,,,,,,,,,,,,,,,,209,,,209,,,209,209,,,209,,209,,209\", \",209,,,209,,,,,,209,,,,,209,209,209,209,,209,209,209,209,,,,,209,209\", \",,,214,214,214,209,214,209,209,209,214,214,,,,214,,214,214,214,214,214\", \"214,214,,,,,,214,214,214,214,214,214,214,,,214,,,,,,,214,,,214,214,214\", \"214,214,214,214,214,,214,214,214,,214,214,214,214,214,,,,,,,,,,,,,,\", \",,,,,214,,,214,,,214,214,,,214,,,,,,214,,,,,,,,,214,,,,,214,214,214\", \"214,,214,214,214,214,,,,,214,214,,,,215,215,215,214,215,214,214,214\", \"215,215,,,,215,,215,215,215,215,215,215,215,,,,,,215,215,215,215,215\", \"215,215,,,215,,,,,,,215,,,215,215,215,215,215,215,215,215,,215,215,215\", \",215,215,215,215,215,,,,,,,,,,,,,,,,,,,,215,,,215,,,215,215,,,215,,215\", \",,,215,,,,,,,,,215,,,,,215,215,215,215,,215,215,215,215,,,,,215,215\", \",,,216,216,216,215,216,215,215,215,216,216,,,,216,,216,216,216,216,216\", \"216,216,,,,,,216,216,216,216,216,216,216,,,216,,,,,,,216,,,216,216,216\", \"216,216,216,216,216,,216,216,216,,216,216,216,216,216,,,,,,,,,,,,,,\", \",,,,,216,,,216,,,216,216,,,216,,,,,,216,,,,,,,,,216,,,,,216,216,216\", \"216,,216,216,216,216,,,,,216,216,,,,217,217,217,216,217,216,216,216\", \"217,217,,,,217,,217,217,217,217,217,217,217,,,,,,217,217,217,217,217\", \"217,217,,,217,,,,,,,217,,,217,217,217,217,217,217,217,217,,217,217,217\", \",217,217,217,217,217,,,,,,,,,,,,,,,,,,,,217,,,217,,,217,217,,,217,,\", \",,,217,,,,,,,,,217,,,,,217,217,217,217,,217,217,217,217,,,,,217,217\", \",,,218,218,218,217,218,217,217,217,218,218,,,,218,,218,218,218,218,218\", \"218,218,,,,,,218,218,218,218,218,218,218,,,218,,,,,,,218,,,218,218,218\", \"218,218,218,218,218,,218,218,218,,218,218,218,218,218,,,,,,,,,,,,,,\", \",,,,,218,,,218,,,218,218,,,218,,,,,,218,,,,,,,,,218,,,,,218,218,218\", \"218,,218,218,218,218,,,,,218,218,,,,219,219,219,218,219,218,218,218\", \"219,219,,,,219,,219,219,219,219,219,219,219,,,,,,219,219,219,219,219\", \"219,219,,,219,,,,,,,219,,,219,219,219,219,219,219,219,219,,219,219,219\", \",219,219,219,219,219,,,,,,,,,,,,,,,,,,,,219,,,219,,,219,219,,,219,,\", \",,,219,,,,,,,,,219,,,,,219,219,219,219,,219,219,219,219,,,,,219,219\", \"219,,,230,230,230,219,230,219,219,219,230,230,,,,230,,230,230,230,230\", \"230,230,230,,,,,,230,230,230,230,230,230,230,,,230,,,,,,,230,,,230,230\", \"230,230,230,230,230,230,,230,230,230,,230,230,230,230,230,,,,,,,,,,\", \",,,,,,,,,230,,,230,,,230,230,,,230,,,,,,230,,,,,,,,,230,,,,,230,230\", \"230,230,,230,230,230,230,,,,,230,230,,,,233,233,233,230,233,230,230\", \"230,233,233,,,,233,,233,233,233,233,233,233,233,,,,,,233,233,233,233\", \"233,233,233,,,233,,,,,,,233,,,233,233,233,233,233,233,233,233,,233,233\", \"233,,233,233,233,233,233,,,,,,,,,,,,,,,,,,,,233,,,233,,,233,233,,,233\", \",,,,,233,,,,,,,,,233,,,,,233,233,233,233,,233,233,233,233,,,,,233,233\", \",,,234,234,234,233,234,233,233,233,234,234,,,,234,,234,234,234,234,234\", \"234,234,,,,,,234,234,234,234,234,234,234,,,234,,,,,,,234,,,234,234,234\", \"234,234,234,234,234,,234,234,234,,234,234,234,234,234,,,,,,,,,,,,,,\", \",,,,,234,,,234,,,234,234,,,234,,,,,,234,,,,,,,,,234,,,,,234,234,234\", \"234,,234,234,234,234,,,,,234,234,,,,235,235,235,234,235,234,234,234\", \"235,235,,,,235,,235,235,235,235,235,235,235,,,,,,235,235,235,235,235\", \"235,235,,,235,,,,,,,235,,,235,235,235,235,235,235,235,235,,235,235,235\", \",235,235,235,235,235,,,,,,,,,,,,,,,,,,,,235,,,235,,,235,235,,,235,,\", \",,,235,,,,,,,,,235,,,,,235,235,235,235,,235,235,235,235,,,,,235,235\", \",,,236,236,236,235,236,235,235,235,236,236,,,,236,,236,236,236,236,236\", \"236,236,,,,,,236,236,236,236,236,236,236,,,236,,,,,,,236,,,236,236,236\", \"236,236,236,236,236,,236,236,236,,236,236,236,236,236,,,,,,,,,,,,,,\", \",,,,,236,,,236,,,236,236,,,236,,,,,,236,,,,,,,,,236,,,,,236,236,236\", \"236,,236,236,236,236,,,,,236,236,,,,237,237,237,236,237,236,236,236\", \"237,237,,,,237,,237,237,237,237,237,237,237,,,,,,237,237,237,237,237\", \"237,237,,,237,,,,,,,237,,,237,237,237,237,237,237,237,237,,237,237,237\", \",237,237,237,237,237,,,,,,,,,,,,,,,,,,,,237,,,237,,,237,237,,,237,,\", \",,,237,,,,,,,,,237,,,,,237,237,237,237,,237,237,237,237,,,,,237,237\", \",,,238,238,238,237,238,237,237,237,238,238,,,,238,,238,238,238,238,238\", \"238,238,,,,,,238,238,238,238,238,238,238,,,238,,,,,,,238,,,238,238,238\", \"238,238,238,238,238,,238,238,238,,238,238,238,238,238,,,,,,,,,,,,,,\", \",,,,,238,,,238,,,238,238,,,238,,,,,,238,,,,,,,,,238,,,,,238,238,238\", \"238,,238,238,238,238,,,,,238,238,,,,239,239,239,238,239,238,238,238\", \"239,239,,,,239,,239,239,239,239,239,239,239,,,,,,239,239,239,239,239\", \"239,239,,,239,,,,,,,239,,,239,239,239,239,239,239,239,239,,239,239,239\", \",239,239,239,239,239,,,,,,,,,,,,,,,,,,,,239,,,239,,,239,239,,,239,,\", \",,,239,,,,,,,,,239,,,,,239,239,239,239,,239,239,239,239,,,,,239,239\", \",,,240,240,240,239,240,239,239,239,240,240,,,,240,,240,240,240,240,240\", \"240,240,,,,,,240,240,240,240,240,240,240,,,240,,,,,,,240,,,240,240,240\", \"240,240,240,240,240,,240,240,240,,240,240,240,240,240,,,,,,,,,,,,,,\", \",,,,,240,,,240,,,240,240,,,240,,,,,,240,,,,,,,,,240,,,,,240,240,240\", \"240,,240,240,240,240,,,,,240,240,,,,241,241,241,240,241,240,240,240\", \"241,241,,,,241,,241,241,241,241,241,241,241,,,,,,241,241,241,241,241\", \"241,241,,,241,,,,,,,241,,,241,241,241,241,241,241,241,241,,241,241,241\", \",241,241,241,241,241,,,,,,,,,,,,,,,,,,,,241,,,241,,,241,241,,,241,,\", \",,,241,,,,,,,,,241,,,,,241,241,241,241,,241,241,241,241,,,,,241,241\", \",,,242,242,242,241,242,241,241,241,242,242,,,,242,,242,242,242,242,242\", \"242,242,,,,,,242,242,242,242,242,242,242,,,242,,,,,,,242,,,242,242,242\", \"242,242,242,242,242,,242,242,242,,242,242,242,242,242,,,,,,,,,,,,,,\", \",,,,,242,,,242,,,242,242,,,242,,,,,,242,,,,,,,,,242,,,,,242,242,242\", \"242,,242,242,242,242,,,,,242,242,,,,243,243,243,242,243,242,242,242\", \"243,243,,,,243,,243,243,243,243,243,243,243,,,,,,243,243,243,243,243\", \"243,243,,,243,,,,,,,243,,,243,243,243,243,243,243,243,243,,243,243,243\", \",243,243,243,243,243,,,,,,,,,,,,,,,,,,,,243,,,243,,,243,243,,,243,,\", \",,,243,,,,,,,,,243,,,,,243,243,243,243,,243,243,243,243,,,,,243,243\", \",,,244,244,244,243,244,243,243,243,244,244,,,,244,,244,244,244,244,244\", \"244,244,,,,,,244,244,244,244,244,244,244,,,244,,,,,,,244,,,244,244,244\", \"244,244,244,244,244,,244,244,244,,244,244,244,244,244,,,,,,,,,,,,,,\", \",,,,,244,,,244,,,244,244,,,244,,,,,,244,,,,,,,,,244,,,,,244,244,244\", \"244,,244,244,244,244,,,,,244,244,,,,245,245,245,244,245,244,244,244\", \"245,245,,,,245,,245,245,245,245,245,245,245,,,,,,245,245,245,245,245\", \"245,245,,,245,,,,,,,245,,,245,245,245,245,245,245,245,245,,245,245,245\", \",245,245,245,245,245,,,,,,,,,,,,,,,,,,,,245,,,245,,,245,245,,,245,,\", \",,,245,,,,,,,,,245,,,,,245,245,245,245,,245,245,245,245,,,,,245,245\", \",,,246,246,246,245,246,245,245,245,246,246,,,,246,,246,246,246,246,246\", \"246,246,,,,,,246,246,246,246,246,246,246,,,246,,,,,,,246,,,246,246,246\", \"246,246,246,246,246,,246,246,246,,246,246,246,246,246,,,,,,,,,,,,,,\", \",,,,,246,,,246,,,246,246,,,246,,,,,,246,,,,,,,,,246,,,,,246,246,246\", \"246,,246,246,246,246,,,,,246,246,,,,247,247,247,246,247,246,246,246\", \"247,247,,,,247,,247,247,247,247,247,247,247,,,,,,247,247,247,247,247\", \"247,247,,,247,,,,,,,247,,,247,247,247,247,247,247,247,247,,247,247,247\", \",247,247,247,247,247,,,,,,,,,,,,,,,,,,,,247,,,247,,,247,247,,,247,,\", \",,,247,,,,,,,,,247,,,,,247,247,247,247,,247,247,247,247,,,,,247,247\", \",,,248,248,248,247,248,247,247,247,248,248,,,,248,,248,248,248,248,248\", \"248,248,,,,,,248,248,248,248,248,248,248,,,248,,,,,,,248,,,248,248,248\", \"248,248,248,248,248,,248,248,248,,248,248,248,248,248,,,,,,,,,,,,,,\", \",,,,,248,,,248,,,248,248,,,248,,,,,,248,,,,,,,,,248,,,,,248,248,248\", \"248,,248,248,248,248,,,,,248,248,,,,249,249,249,248,249,248,248,248\", \"249,249,,,,249,,249,249,249,249,249,249,249,,,,,,249,249,249,249,249\", \"249,249,,,249,,,,,,,249,,,249,249,249,249,249,249,249,249,,249,249,249\", \",249,249,249,249,249,,,,,,,,,,,,,,,,,,,,249,,,249,,,249,249,,,249,,\", \",,,249,,,,,,,,,249,,,,,249,249,249,249,,249,249,249,249,,,,,249,249\", \",,,250,250,250,249,250,249,249,249,250,250,,,,250,,250,250,250,250,250\", \"250,250,,,,,,250,250,250,250,250,250,250,,,250,,,,,,,250,,,250,250,250\", \"250,250,250,250,250,,250,250,250,,250,250,250,250,250,,,,,,,,,,,,,,\", \",,,,,250,,,250,,,250,250,,,250,,,,,,250,,,,,,,,,250,,,,,250,250,250\", \"250,,250,250,250,250,,,,,250,250,,,,251,251,251,250,251,250,250,250\", \"251,251,,,,251,,251,251,251,251,251,251,251,,,,,,251,251,251,251,251\", \"251,251,,,251,,,,,,,251,,,251,251,251,251,251,251,251,251,,251,251,251\", \",251,251,251,251,251,,,,,,,,,,,,,,,,,,,,251,,,251,,,251,251,,,251,,\", \",,,251,,,,,,,,,251,,,,,251,251,251,251,,251,251,251,251,,,,,251,251\", \",,,252,252,252,251,252,251,251,251,252,252,,,,252,,252,252,252,252,252\", \"252,252,,,,,,252,252,252,252,252,252,252,,,252,,,,,,,252,,,252,252,252\", \"252,252,252,252,252,,252,252,252,,252,252,252,252,252,,,,,,,,,,,,,,\", \",,,,,252,,,252,,,252,252,,,252,,,,,,252,,,,,,,,,252,,,,,252,252,252\", \"252,,252,252,252,252,,,,,252,252,,,,253,253,253,252,253,252,252,252\", \"253,253,,,,253,,253,253,253,253,253,253,253,,,,,,253,253,253,253,253\", \"253,253,,,253,,,,,,,253,,,253,253,253,253,253,253,253,253,,253,253,253\", \",253,253,253,253,253,,,,,,,,,,,,,,,,,,,,253,,,253,,,253,253,,,253,,\", \",,,253,,,,,,,,,253,,,,,253,253,253,253,,253,253,253,253,,,,,253,253\", \",,,254,254,254,253,254,253,253,253,254,254,,,,254,,254,254,254,254,254\", \"254,254,,,,,,254,254,254,254,254,254,254,,,254,,,,,,,254,,,254,254,254\", \"254,254,254,254,254,,254,254,254,,254,254,254,254,254,,,,,,,,,,,,,,\", \",,,,,254,,,254,,,254,254,,,254,,,,,,254,,,,,,,,,254,,,,,254,254,254\", \"254,,254,254,254,254,,,,,254,254,,,,255,255,255,254,255,254,254,254\", \"255,255,,,,255,,255,255,255,255,255,255,255,,,,,,255,255,255,255,255\", \"255,255,,,255,,,,,,,255,,,255,255,255,255,255,255,255,255,,255,255,255\", \",255,255,255,255,255,,,,,,,,,,,,,,,,,,,,255,,,255,,,255,255,,,255,,\", \",,,255,,,,,,,,,255,,,,,255,255,255,255,,255,255,255,255,,,,,255,255\", \",,,256,256,256,255,256,255,255,255,256,256,,,,256,,256,256,256,256,256\", \"256,256,,,,,,256,256,256,256,256,256,256,,,256,,,,,,,256,,,256,256,256\", \"256,256,256,256,256,,256,256,256,,256,256,256,256,256,,,,,,,,,,,,,,\", \",,,,,256,,,256,,,256,256,,,256,,,,,,256,,,,,,,,,256,,,,,256,256,256\", \"256,,256,256,256,256,,,,,256,256,,,,257,257,257,256,257,256,256,256\", \"257,257,,,,257,,257,257,257,257,257,257,257,,,,,,257,257,257,257,257\", \"257,257,,,257,,,,,,,257,,,257,257,257,257,257,257,257,257,,257,257,257\", \",257,257,257,257,257,,,,,,,,,,,,,,,,,,,,257,,,257,,,257,257,,,257,,\", \",,,257,,,,,,,,,257,,,,,257,257,257,257,,257,257,257,257,,,,,257,257\", \",,,258,258,258,257,258,257,257,257,258,258,,,,258,,258,258,258,258,258\", \"258,258,,,,,,258,258,258,258,258,258,258,,,258,,,,,,,258,,,258,258,258\", \"258,258,258,258,258,,258,258,258,,258,258,258,258,258,,,,,,,,,,,,,,\", \",,,,,258,,,258,,,258,258,,,258,,,,,,258,,,,,,,,,258,,,,,258,258,258\", \"258,,258,258,258,258,,,,,258,258,,,,265,265,265,258,265,258,258,258\", \"265,265,,,,265,,265,265,265,265,265,265,265,,,,,,265,265,265,265,265\", \"265,265,,,265,,,,,,,265,,,265,265,265,265,265,265,265,265,265,265,265\", \"265,,265,265,265,265,265,,,,,,,,,,,,,,,,,,,,265,,,265,,,265,265,,,265\", \",265,,265,,265,,,265,,,,,,265,,,,,265,265,265,265,,265,265,265,265,\", \",,,265,265,,,,266,266,266,265,266,265,265,265,266,266,,,,266,,266,266\", \"266,266,266,266,266,,,,,,266,266,266,266,266,266,266,,,266,,,,,,,266\", \",,266,266,266,266,266,266,266,266,266,266,266,266,,266,266,266,266,266\", \",,,,,,,,,,,,,,,,,,,266,,,266,,,266,266,,,266,,266,,266,,266,,,266,,\", \",,,266,,,,,266,266,266,266,,266,266,266,266,,,,,266,266,,,,274,274,274\", \"266,274,266,266,266,274,274,,,,274,,274,274,274,274,274,274,274,,,,\", \",274,274,274,274,274,274,274,,,274,,,,,,,274,,,274,274,274,274,274,274\", \"274,274,274,274,274,274,,274,274,274,274,274,,,,,,,,,,,,,,,,,,,,274\", \",,274,,,274,274,,,274,,274,,274,,274,,,274,,,,,,274,,,,,274,274,274\", \"274,,274,274,274,274,,,,,274,274,274,,,281,281,281,274,281,274,274,274\", \"281,281,,,,281,,281,281,281,281,281,281,281,,,,,,281,281,281,281,281\", \"281,281,,,281,,,,,,,281,,,281,281,281,281,281,281,281,281,,281,281,281\", \",281,281,281,281,281,,,,,,,,,,,,,,,,,,,,281,,,281,,,281,281,,,281,,\", \",,,281,,,,,,,,,281,,,,,281,281,281,281,,281,281,281,281,,,,,281,281\", \",,,283,283,283,281,283,281,281,281,283,283,,,,283,,283,283,283,283,283\", \"283,283,,,,,,283,283,283,283,283,283,283,,,283,,,,,,,283,,,283,283,283\", \"283,283,283,283,283,,283,283,283,,283,283,283,283,283,,,,,,,,,,,,,,\", \",,,,,283,,,283,,,283,283,,,283,,,,,,283,,,,,,,,,283,,,,,283,283,283\", \"283,,283,283,283,283,,,,,283,283,,,,286,286,286,283,286,283,283,283\", \"286,286,,,,286,,286,286,286,286,286,286,286,,,,,,286,286,286,286,286\", \"286,286,,,286,,,,,,,286,,,286,286,286,286,286,286,286,286,,286,286,286\", \",286,286,286,286,286,,,,,,,,,,,,,,,,,,,,286,,,286,,,286,286,,,286,,\", \",,,286,,,,,,,,,286,,,,,286,286,286,286,,286,286,286,286,,,,,286,286\", \",,,287,287,287,286,287,286,286,286,287,287,,,,287,,287,287,287,287,287\", \"287,287,,,,,,287,287,287,287,287,287,287,,,287,,,,,,,287,,,287,287,287\", \"287,287,287,287,287,,287,287,287,,287,287,287,287,287,,,,,,,,,,,,,,\", \",,,,,287,,,287,,,287,287,,,287,,,,,,287,,,,,,,,,287,,,,,287,287,287\", \"287,,287,287,287,287,,,,,287,287,,,,,,,287,,287,287,287,292,292,292\", \"292,292,,,,292,292,,,,292,,292,292,292,292,292,292,292,,,,,,292,292\", \"292,292,292,292,292,,,292,,,,,,292,292,,292,292,292,292,292,292,292\", \"292,292,,292,292,292,,292,292,292,292,292,,,,,,,,,,,,,,,,,,,,292,,,292\", \",,292,292,,,292,,292,,,,292,,,,,,,,,292,,,,,292,292,292,292,,292,292\", \"292,292,,,,,292,292,,,,300,300,300,292,300,292,292,292,300,300,,,,300\", \",300,300,300,300,300,300,300,,,,,,300,300,300,300,300,300,300,,,300\", \",,,,,,300,,,300,300,300,300,300,300,300,300,,300,300,300,,300,300,,\", \"300,,,,,,,,,,,,,,,,,,,,300,,,300,,,300,300,,,300,,,894,,894,894,894\", \"894,894,,,,,,,,,894,,300,300,300,300,,300,300,300,300,,,,,300,300,,\", \",300,,894,300,,300,300,300,317,317,317,,317,894,894,,317,317,894,,,317\", \",317,317,317,317,317,317,317,,,,,,317,317,317,317,317,317,317,,,317\", \",,,,,,317,,,317,317,317,317,317,317,317,317,,317,317,317,,317,317,,\", \"317,,,,,,,,,,,,,,,,,,,,317,,,317,,,317,317,,,317,,,,,,,,,,,,,,,,,,,\", \"317,317,317,317,,317,317,317,317,,,,,317,317,,,,325,325,325,317,325\", \"317,317,317,325,325,,,,325,,325,325,325,325,325,325,325,,,,,,325,325\", \"325,325,325,325,325,,,325,,,,,,,325,,,325,325,325,325,325,325,325,325\", \",325,325,325,,325,325,325,325,325,,,,,,,,,,,,,,,,,,,,325,,,325,325,\", \"325,325,,,325,,,,,,325,,,,,,,,,325,,,,,325,325,325,325,,325,325,325\", \"325,,,,,325,325,,,,327,327,327,325,327,325,325,325,327,327,,,,327,,327\", \"327,327,327,327,327,327,,,,,,327,327,327,327,327,327,327,,,327,,,,,\", \",327,,,327,327,327,327,327,327,327,327,,327,327,327,,327,327,327,327\", \"327,,,,,,,,,,,,,,,,,,,,327,,,327,,,327,327,,,327,,,,,,327,,,,,,,,,327\", \",,,,327,327,327,327,,327,327,327,327,,,,,327,327,,,,342,342,342,327\", \"342,327,327,327,342,342,,,,342,,342,342,342,342,342,342,342,,,,,,342\", \"342,342,342,342,342,342,,,342,,,,,,,342,,,342,342,342,342,342,342,342\", \"342,,342,342,342,,342,342,342,342,342,,,,,,,,,,,,,,,,,,,,342,,,342,\", \",342,342,,,342,,,,,,342,,,,,,,,,342,,,,,342,342,342,342,,342,342,342\", \"342,,,,,342,342,,,,343,343,343,342,343,342,342,342,343,343,,,,343,,343\", \"343,343,343,343,343,343,,,,,,343,343,343,343,343,343,343,,,343,,,,,\", \",343,,,343,343,343,343,343,343,343,343,,343,343,343,,343,343,343,343\", \"343,,,,,,,,,,,,,,,,,,,,343,,,343,,,343,343,,,343,,,,,,343,,,,,,,,,343\", \",,,,343,343,343,343,,343,343,343,343,,,,,343,343,,,,362,362,362,343\", \"362,343,343,343,362,362,,,,362,,362,362,362,362,362,362,362,,,,,,362\", \"362,362,362,362,362,362,,,362,,,,,,,362,,,362,362,362,362,362,362,362\", \"362,,362,362,362,,362,362,362,362,362,,,,,,,,,,,,,,,,,,,,362,,,362,\", \",362,362,,,362,,,,,,362,,,,,,,,,362,,,,,362,362,362,362,,362,362,362\", \"362,,,,,362,362,,,,378,378,378,362,378,362,362,362,378,378,,,,378,,378\", \"378,378,378,378,378,378,,,,,,378,378,378,378,378,378,378,,,378,,,,,\", \",378,,,378,378,378,378,378,378,378,378,,378,378,378,,378,378,378,378\", \"378,,,,,,,,,,,,,,,,,,,,378,,,378,,,378,378,,,378,,,,,,378,,,,,,,,,378\", \",,,,378,378,378,378,,378,378,378,378,,,,,378,378,,,,406,406,406,378\", \"406,378,378,378,406,406,,,,406,,406,406,406,406,406,406,406,,,,,,406\", \"406,406,406,406,406,406,,,406,,,,,,,406,,,406,406,406,406,406,406,406\", \"406,,406,406,406,,406,406,406,406,406,,,,,,,,,,,,,,,,,,,,406,,,406,\", \",406,406,,,406,,,,,,406,,,,,,,,,406,,,,,406,406,406,406,,406,406,406\", \"406,,,,,406,406,,,,444,444,444,406,444,406,406,406,444,444,,,,444,,444\", \"444,444,444,444,444,444,,,,,,444,444,444,444,444,444,444,,,444,,,,,\", \",444,,,444,444,444,444,444,444,444,444,444,444,444,444,,444,444,444\", \"444,444,,,,,,,,,,,,,,,,,,,,444,,,444,,,444,444,,,444,,444,,444,,444\", \",,444,,,,,,444,,,,,444,444,444,444,,444,444,444,444,,,,,444,444,,,,446\", \"446,446,444,446,444,444,444,446,446,,,,446,,446,446,446,446,446,446\", \"446,,,,,,446,446,446,446,446,446,446,,,446,,,,,,,446,,,446,446,446,446\", \"446,446,446,446,,446,446,446,,446,446,446,446,446,,,,,,,,,,,,,,,,,,\", \",446,,,446,,,446,446,,,446,,,,,,446,,,,,,,,,446,,,,,446,446,446,446\", \",446,446,446,446,,,,,446,446,,,,447,447,447,446,447,446,446,446,447\", \"447,,,,447,,447,447,447,447,447,447,447,,,,,,447,447,447,447,447,447\", \"447,,,447,,,,,,,447,,,447,447,447,447,447,447,447,447,,447,447,447,\", \"447,447,447,447,447,,,,,,,,,,,,,,,,,,,,447,,,447,,,447,447,,,447,,,\", \",,447,,,,,,,,,447,,,,,447,447,447,447,,447,447,447,447,,,,,447,447,\", \",,448,448,448,447,448,447,447,447,448,448,,,,448,,448,448,448,448,448\", \"448,448,,,,,,448,448,448,448,448,448,448,,,448,,,,,,,448,,,448,448,448\", \"448,448,448,448,448,,448,448,448,,448,448,448,448,448,,,,,,,,,,,,,,\", \",,,,,448,,,448,,,448,448,,,448,,,,,,448,,,,,,,,,448,,,,,448,448,448\", \"448,,448,448,448,448,,,,,448,448,,,,488,488,488,448,488,448,448,448\", \"488,488,,,,488,,488,488,488,488,488,488,488,,,,,,488,488,488,488,488\", \"488,488,,,488,,,,,,,488,,,488,488,488,488,488,488,488,488,488,488,488\", \"488,,488,488,488,488,488,,,,,,,,,,,,,,,,,,,,488,,,488,,,488,488,,,488\", \",488,,488,,488,,,488,,,,,,488,,,,,488,488,488,488,,488,488,488,488,\", \",,,488,488,,,,490,490,490,488,490,488,488,488,490,490,,,,490,,490,490\", \"490,490,490,490,490,,,,,,490,490,490,490,490,490,490,,,490,,,,,,,490\", \",,490,490,490,490,490,490,490,490,490,490,490,490,,490,490,490,490,490\", \",,,,,,,,,,,,,,,,,,,490,,,490,,,490,490,,,490,,,,490,,490,,,490,,,,,\", \"490,,,,,490,490,490,490,,490,490,490,490,,,,,490,490,,,,492,492,492\", \"490,492,490,490,490,492,492,,,,492,,492,492,492,492,492,492,492,,,,\", \",492,492,492,492,492,492,492,,,492,,,,,,,492,,,492,492,492,492,492,492\", \"492,492,,492,492,492,,492,492,492,492,492,,,,,,,,,,,,,,,,,,,,492,,,492\", \",,492,492,,,492,,,,,,492,,,,,,,,,492,,,,,492,492,492,492,,492,492,492\", \"492,,,,,492,492,,,,,,,492,,492,492,492,498,498,498,498,498,,,,498,498\", \",,,498,,498,498,498,498,498,498,498,,,,,,498,498,498,498,498,498,498\", \",,498,,,,,,498,498,498,498,498,498,498,498,498,498,498,498,,498,498\", \"498,,498,498,498,498,498,,,,,,,,,,,,,,,,,,,,498,,,498,,,498,498,,,498\", \",498,,,,498,,,,,,,,,498,,,,,498,498,498,498,,498,498,498,498,,,,,498\", \"498,,,,,,498,498,,498,498,498,506,506,506,,506,,,,506,506,,,,506,,506\", \"506,506,506,506,506,506,,,,,,506,506,506,506,506,506,506,,,506,,,,,\", \",506,,,506,506,506,506,506,506,506,506,,506,506,506,,506,506,,,506,\", \",,,,,,,,,,,,,,,,,,506,,,506,,,506,506,,,506,,,,,,,,,,,,,,,,,,,,506,506\", \"506,506,,506,506,506,506,,,,,506,506,,,,508,508,508,506,508,506,506\", \"506,508,508,,,,508,,508,508,508,508,508,508,508,,,,,,508,508,508,508\", \"508,508,508,,,508,,,,,,,508,,,508,508,508,508,508,508,508,508,508,508\", \"508,508,,508,508,508,508,508,,,,,,,,,,,,,,,,,,,,508,,,508,,,508,508\", \",,508,,508,,508,,508,,,508,,,,,,508,,,,,508,508,508,508,,508,508,508\", \"508,,,,,508,508,,,,514,514,514,508,514,508,508,508,514,514,,,,514,,514\", \"514,514,514,514,514,514,,,,,,514,514,514,514,514,514,514,,,514,,,,,\", \",514,,,514,514,514,514,514,514,514,514,,514,514,514,,514,514,,,514,\", \",,,,,,,,,,,,,,,,,,514,,,514,,,514,514,,,514,,,,,,,,,,,,,,,,,,,,514,514\", \"514,514,,514,514,514,514,,,,,514,514,,,,517,517,517,514,517,514,514\", \"514,517,517,,,,517,,517,517,517,517,517,517,517,,,,,,517,517,517,517\", \"517,517,517,,,517,,,,,,,517,,,517,517,517,517,517,517,517,517,,517,517\", \"517,,517,517,517,517,517,,,,,,,,,,,,,,,,,,,,517,,,517,,,517,517,,,517\", \",,,,,517,,,,,,,,,517,,,,,517,517,517,517,,517,517,517,517,,,,,517,517\", \",,,518,518,518,517,518,517,517,517,518,518,,,,518,,518,518,518,518,518\", \"518,518,,,,,,518,518,518,518,518,518,518,,,518,,,,,,,518,,,518,518,518\", \"518,518,518,518,518,,518,518,518,,518,518,518,518,518,,,,,,,,,,,,,,\", \",,,,,518,,,518,,,518,518,,,518,,,,,,518,,,,,,,,,518,,,,,518,518,518\", \"518,,518,518,518,518,,,,,518,518,,,,522,522,522,518,522,518,518,518\", \"522,522,,,,522,,522,522,522,522,522,522,522,,,,,,522,522,522,522,522\", \"522,522,,,522,,,,,,,522,,,522,522,522,522,522,522,522,522,,522,522,522\", \",522,522,522,522,522,,,,,,,,,,,,,,,,,,,,522,,,522,,,522,522,,,522,,\", \",,,522,,,,,,,,,522,,,,,522,522,522,522,,522,522,522,522,,,,,522,522\", \",,,528,528,528,522,528,522,522,522,528,528,,,,528,,528,528,528,528,528\", \"528,528,,,,,,528,528,528,528,528,528,528,,,528,,,,,,,528,,,528,528,528\", \"528,528,528,528,528,528,528,528,528,,528,528,528,528,528,,,,,,,,,,,\", \",,,,,,,,528,,,528,,,528,528,,,528,,528,,,,528,,,528,,,,,,528,,,,,528\", \"528,528,528,,528,528,528,528,,,,,528,528,,,,531,531,531,528,531,528\", \"528,528,531,531,,,,531,,531,531,531,531,531,531,531,,,,,,531,531,531\", \"531,531,531,531,,,531,,,,,,,531,,,531,531,531,531,531,531,531,531,531\", \"531,531,531,,531,531,531,531,531,,,,,,,,,,,,,,,,,,,,531,,,531,,,531\", \"531,,,531,,,,,,531,,,531,,,,,,531,,,,,531,531,531,531,,531,531,531,531\", \",,,,531,531,,,,556,556,556,531,556,531,531,531,556,556,,,,556,,556,556\", \"556,556,556,556,556,,,,,,556,556,556,556,556,556,556,,,556,,,,,,,556\", \",,556,556,556,556,556,556,556,556,,556,556,556,,556,556,556,556,556\", \",,,,,,,,,,,,,,,,,,,556,,,556,,,556,556,,,556,,,,,,556,,,,,,,,,556,,\", \",,556,556,556,556,,556,556,556,556,,,,,556,556,,,,576,576,576,556,576\", \"556,556,556,576,576,,,,576,,576,576,576,576,576,576,576,,,,,,576,576\", \"576,576,576,576,576,,,576,,,,,,,576,,,576,576,576,576,576,576,576,576\", \",576,576,576,,576,576,576,576,576,,,,,,,,,,,,,,,,,,,,576,,,576,,,576\", \"576,,,576,,576,,,,576,,,,,,,,,576,,,,,576,576,576,576,,576,576,576,576\", \",,,,576,576,,,,577,577,577,576,577,576,576,576,577,577,,,,577,,577,577\", \"577,577,577,577,577,,,,,,577,577,577,577,577,577,577,,,577,,,,,,,577\", \",,577,577,577,577,577,577,577,577,577,577,577,577,,577,577,577,577,577\", \",,,,,,,,,,,,,,,,,,,577,,,577,,,577,577,,,577,,577,,577,,577,,,577,,\", \",,,577,,,,,577,577,577,577,,577,577,577,577,,,,,577,577,,,,587,587,587\", \"577,587,577,577,577,587,587,,,,587,,587,587,587,587,587,587,587,,,,\", \",587,587,587,587,587,587,587,,,587,,,,,,,587,,,587,587,587,587,587,587\", \"587,587,587,587,587,587,,587,587,587,587,587,,,,,,,,,,,,,,,,,,,,587\", \",,587,,,587,587,,,587,,587,,587,,587,,,587,,,,,,587,,,,,587,587,587\", \"587,,587,587,587,587,,,,,587,587,,,,619,619,619,587,619,587,587,587\", \"619,619,,,,619,,619,619,619,619,619,619,619,,,,,,619,619,619,619,619\", \"619,619,,,619,,,,,,,619,,,619,619,619,619,619,619,619,619,,619,619,619\", \",619,619,619,619,619,,,,,,,,,,,,,,,,,,,,619,,,619,,,619,619,,,619,,619\", \",,,619,,,,,,,,,619,,,,,619,619,619,619,,619,619,619,619,,,,,619,619\", \",,,620,620,620,619,620,619,619,619,620,620,,,,620,,620,620,620,620,620\", \"620,620,,,,,,620,620,620,620,620,620,620,,,620,,,,,,,620,,,620,620,620\", \"620,620,620,620,620,,620,620,620,,620,620,620,620,620,,,,,,,,,,,,,,\", \",,,,,620,,,620,,,620,620,,,620,,,,,,620,,,,,,,,,620,,,,,620,620,620\", \"620,,620,620,620,620,,,,,620,620,,,,623,623,623,620,623,620,620,620\", \"623,623,,,,623,,623,623,623,623,623,623,623,,,,,,623,623,623,623,623\", \"623,623,,,623,,,,,,,623,,,623,623,623,623,623,623,623,623,623,623,623\", \"623,,623,623,623,623,623,,,,,,,,,,,,,,,,,,,,623,,,623,,,623,623,,,623\", \",623,,623,,623,,,623,,,,,,623,,,,,623,623,623,623,,623,623,623,623,\", \",,,623,623,,,,624,624,624,623,624,623,623,623,624,624,,,,624,,624,624\", \"624,624,624,624,624,,,,,,624,624,624,624,624,624,624,,,624,,,,,,,624\", \",,624,624,624,624,624,624,624,624,624,624,624,624,,624,624,624,624,624\", \",,,,,,,,,,,,,,,,,,,624,,,624,,,624,624,,,624,,,,624,,624,,,624,,,,,\", \"624,,,,,624,624,624,624,,624,624,624,624,,,,,624,624,,,,625,625,625\", \"624,625,624,624,624,625,625,,,,625,,625,625,625,625,625,625,625,,,,\", \",625,625,625,625,625,625,625,,,625,,,,,,,625,,,625,625,625,625,625,625\", \"625,625,,625,625,625,,625,625,625,625,625,,,,,,,,,,,,,,,,,,,,625,,,625\", \",,625,625,,,625,,,,,,625,,,,,,,,,625,,,,,625,625,625,625,,625,625,625\", \"625,,,,,625,625,,,,626,626,626,625,626,625,625,625,626,626,,,,626,,626\", \"626,626,626,626,626,626,,,,,,626,626,626,626,626,626,626,,,626,,,,,\", \",626,,,626,626,626,626,626,626,626,626,,626,626,626,,626,626,626,626\", \"626,,,,,,,,,,,,,,,,,,,,626,,,626,,,626,626,,,626,,,,,,626,,,,,,,,,626\", \",,,,626,626,626,626,,626,626,626,626,,,,,626,626,,,,630,630,630,626\", \"630,626,626,626,630,630,,,,630,,630,630,630,630,630,630,630,,,,,,630\", \"630,630,630,630,630,630,,,630,,,,,,,630,,,630,630,630,630,630,630,630\", \"630,,630,630,630,,630,630,630,630,630,,,,,,,,,,,,,,,,,,,,630,,,630,\", \",630,630,,,630,,,,,,630,,,,,,,,,630,,,,,630,630,630,630,,630,630,630\", \"630,,,,,630,630,,,,631,631,631,630,631,630,630,630,631,631,,,,631,,631\", \"631,631,631,631,631,631,,,,,,631,631,631,631,631,631,631,,,631,,,,,\", \",631,,,631,631,631,631,631,631,631,631,,631,631,631,,631,631,631,631\", \"631,,,,,,,,,,,,,,,,,,,,631,,,631,,,631,631,,,631,,,,,,631,,,,,,,,,631\", \",,,,631,631,631,631,,631,631,631,631,,,,,631,631,,,,634,634,634,631\", \"634,631,631,631,634,634,,,,634,,634,634,634,634,634,634,634,,,,,,634\", \"634,634,634,634,634,634,,,634,,,,,,,634,,,634,634,634,634,634,634,634\", \"634,,634,634,634,,634,634,634,634,634,,,,,,,,,,,,,,,,,,,,634,,,634,\", \",634,634,,,634,,,,,,634,,,,,,,,,634,,,,,634,634,634,634,,634,634,634\", \"634,,,,,634,634,,,,635,635,635,634,635,634,634,634,635,635,,,,635,,635\", \"635,635,635,635,635,635,,,,,,635,635,635,635,635,635,635,,,635,,,,,\", \",635,,,635,635,635,635,635,635,635,635,,635,635,635,,635,635,635,635\", \"635,,,,,,,,,,,,,,,,,,,,635,,,635,,,635,635,,,635,,,,,,635,,,,,,,,,635\", \",,,,635,635,635,635,,635,635,635,635,,,,,635,635,,,,659,659,659,635\", \"659,635,635,635,659,659,,,,659,,659,659,659,659,659,659,659,,,,,,659\", \"659,659,659,659,659,659,,,659,,,,,,,659,,,659,659,659,659,659,659,659\", \"659,,659,659,659,,659,659,659,659,659,,,,,,,,,,,,,,,,,,,,659,,,659,\", \",659,659,,,659,,,,,,659,,,,,,,,,659,,,,,659,659,659,659,,659,659,659\", \"659,,,,,659,659,,,,662,662,662,659,662,659,659,659,662,662,,,,662,,662\", \"662,662,662,662,662,662,,,,,,662,662,662,662,662,662,662,,,662,,,,,\", \",662,,,662,662,662,662,662,662,662,662,,662,662,662,,662,662,662,662\", \"662,,,,,,,,,,,,,,,,,,,,662,,,662,,,662,662,,,662,,,,,,662,,,,,,,,,662\", \",,,,662,662,662,662,,662,662,662,662,,,,,662,662,,,,666,666,666,662\", \"666,662,662,662,666,666,,,,666,,666,666,666,666,666,666,666,,,,,,666\", \"666,666,666,666,666,666,,,666,,,,,,,666,,,666,666,666,666,666,666,666\", \"666,,666,666,666,,666,666,,,666,,,,,,,,,,,,,,,,,,,,666,,,666,,,666,666\", \",,666,,,,,,,,,,,,,,,,,,,,666,666,666,666,,666,666,666,666,,,,,666,666\", \",,,677,677,677,666,677,666,666,666,677,677,,,,677,,677,677,677,677,677\", \"677,677,,,,,,677,677,677,677,677,677,677,,,677,,,,,,,677,,,677,677,677\", \"677,677,677,677,677,,677,677,677,,677,677,,,677,,,,,,,,,,,,,,,,,,,,677\", \",,677,,,677,677,,,677,,,,,,,,,,,,,,,,,,,,677,677,677,677,,677,677,677\", \"677,,,,,677,677,,,,682,682,682,677,682,677,677,677,682,682,,,,682,,682\", \"682,682,682,682,682,682,,,,,,682,682,682,682,682,682,682,,,682,,,,,\", \",682,,,682,682,682,682,682,682,682,682,,682,682,682,,682,682,682,682\", \"682,,,,,,,,,,,,,,,,,,,,682,,,682,,,682,682,,,682,,682,,,,682,,,,,,,\", \",682,,,,,682,682,682,682,,682,682,682,682,,,,,682,682,,,,699,699,699\", \"682,699,682,682,682,699,699,,,,699,,699,699,699,699,699,699,699,,,,\", \",699,699,699,699,699,699,699,,,699,,,,,,,699,,,699,699,699,699,699,699\", \"699,699,,699,699,699,,699,699,699,699,699,,,,,,,,,,,,,,,,,,,,699,,,699\", \",,699,699,,,699,,,,,,699,,,,,,,,,699,,,,,699,699,699,699,,699,699,699\", \"699,,,,,699,699,,,,725,725,725,699,725,699,699,699,725,725,,,,725,,725\", \"725,725,725,725,725,725,,,,,,725,725,725,725,725,725,725,,,725,,,,,\", \",725,,,725,725,725,725,725,725,725,725,,725,725,725,,725,725,725,725\", \"725,,,,,,,,,,,,,,,,,,,,725,,,725,,,725,725,,,725,,,,,,725,,,,,,,,,725\", \",,,,725,725,725,725,,725,725,725,725,,,,,725,725,,,,731,731,731,725\", \"731,725,725,725,731,731,,,,731,,731,731,731,731,731,731,731,,,,,,731\", \"731,731,731,731,731,731,,,731,,,,,,,731,,,731,731,731,731,731,731,731\", \"731,,731,731,731,,731,731,731,731,731,,,,,,,,,,,,,,,,,,,,731,,,731,\", \",731,731,,,731,,,,,,731,,,,,,,,,731,,,,,731,731,731,731,,731,731,731\", \"731,,,,,731,731,,,,753,753,753,731,753,731,731,731,753,753,,,,753,,753\", \"753,753,753,753,753,753,,,,,,753,753,753,753,753,753,753,,,753,,,,,\", \",753,,,753,753,753,753,753,753,753,753,,753,753,753,,753,753,753,753\", \"753,,,,,,,,,,,,,,,,,,,,753,,,753,,,753,753,,,753,,,,,,753,,,,,,,,,753\", \",,,,753,753,753,753,,753,753,753,753,,,,,753,753,,,,755,755,755,753\", \"755,753,753,753,755,755,,,,755,,755,755,755,755,755,755,755,,,,,,755\", \"755,755,755,755,755,755,,,755,,,,,,,755,,,755,755,755,755,755,755,755\", \"755,,755,755,755,,755,755,755,755,755,,,,,,,,,,,,,,,,,,,,755,,,755,\", \",755,755,,,755,,,,,,755,,,,,,,,,755,,,,,755,755,755,755,,755,755,755\", \"755,,,,,755,755,,,,769,769,769,755,769,755,755,755,769,769,,,,769,,769\", \"769,769,769,769,769,769,,,,,,769,769,769,769,769,769,769,,,769,,,,,\", \",769,,,769,769,769,769,769,769,769,769,,769,769,769,,769,769,769,769\", \"769,,,,,,,,,,,,,,,,,,,,769,,,769,,,769,769,,,769,,,,,,769,,,,,,,,,769\", \",,,,769,769,769,769,,769,769,769,769,,,,,769,769,,,,770,770,770,769\", \"770,769,769,769,770,770,,,,770,,770,770,770,770,770,770,770,,,,,,770\", \"770,770,770,770,770,770,,,770,,,,,,,770,,,770,770,770,770,770,770,770\", \"770,,770,770,770,,770,770,770,770,770,,,,,,,,,,,,,,,,,,,,770,,,770,\", \",770,770,,,770,,,,,,770,,,,,,,,,770,,,,,770,770,770,770,,770,770,770\", \"770,,,,,770,770,,,,771,771,771,770,771,770,770,770,771,771,,,,771,,771\", \"771,771,771,771,771,771,,,,,,771,771,771,771,771,771,771,,,771,,,,,\", \",771,,,771,771,771,771,771,771,771,771,,771,771,771,,771,771,771,771\", \"771,,,,,,,,,,,,,,,,,,,,771,,,771,,,771,771,,,771,,,,,,771,,,,,,,,,771\", \",,,,771,771,771,771,,771,771,771,771,,,,,771,771,,,,772,772,772,771\", \"772,771,771,771,772,772,,,,772,,772,772,772,772,772,772,772,,,,,,772\", \"772,772,772,772,772,772,,,772,,,,,,,772,,,772,772,772,772,772,772,772\", \"772,,772,772,772,,772,772,772,772,772,,,,,,,,,,,,,,,,,,,,772,,,772,\", \",772,772,,,772,,,,,,772,,,,,,,,,772,,,,,772,772,772,772,,772,772,772\", \"772,,,,,772,772,,,,774,774,774,772,774,772,772,772,774,774,,,,774,,774\", \"774,774,774,774,774,774,,,,,,774,774,774,774,774,774,774,,,774,,,,,\", \",774,,,774,774,774,774,774,774,774,774,,774,774,774,,774,774,774,774\", \"774,,,,,,,,,,,,,,,,,,,,774,,,774,,,774,774,,,774,,,,,,774,,,,,,,,,774\", \",,,,774,774,774,774,,774,774,774,774,,,,,774,774,,,,786,786,786,774\", \"786,774,774,774,786,786,,,,786,,786,786,786,786,786,786,786,,,,,,786\", \"786,786,786,786,786,786,,,786,,,,,,,786,,,786,786,786,786,786,786,786\", \"786,,786,786,786,,786,786,,,786,,,,,,,,,,,,,,,,,,,,786,,,786,,,786,786\", \",,786,,,,,,,,,,,,,,,,,,,,786,786,786,786,,786,786,786,786,,,,,786,786\", \",,,836,836,836,786,836,786,786,786,836,836,,,,836,,836,836,836,836,836\", \"836,836,,,,,,836,836,836,836,836,836,836,,,836,,,,,,,836,,,836,836,836\", \"836,836,836,836,836,,836,836,836,,836,836,836,836,836,,,,,,,,,,,,,,\", \",,,,,836,,,836,,,836,836,,,836,,,,,,836,,,,,,,,,836,,,,,836,836,836\", \"836,,836,836,836,836,,,,,836,836,,,,841,841,841,836,841,836,836,836\", \"841,841,,,,841,,841,841,841,841,841,841,841,,,,,,841,841,841,841,841\", \"841,841,,,841,,,,,,,841,,,841,841,841,841,841,841,841,841,,841,841,841\", \",841,841,841,841,841,,,,,,,,,,,,,,,,,,,,841,,,841,,,841,841,,,841,,841\", \",,,841,,,,,,,,,841,,,,,841,841,841,841,,841,841,841,841,,,,,841,841\", \",,,858,858,858,841,858,841,841,841,858,858,,,,858,,858,858,858,858,858\", \"858,858,,,,,,858,858,858,858,858,858,858,,,858,,,,,,,858,,,858,858,858\", \"858,858,858,858,858,858,858,858,858,,858,858,858,858,858,,,,,,,,,,,\", \",,,,,,,,858,,,858,,,858,858,,,858,,,,858,,858,,,858,,,,,,858,,,,,858\", \"858,858,858,,858,858,858,858,,,,,858,858,,,,859,859,859,858,859,858\", \"858,858,859,859,,,,859,,859,859,859,859,859,859,859,,,,,,859,859,859\", \"859,859,859,859,,,859,,,,,,,859,,,859,859,859,859,859,859,859,859,,859\", \"859,859,,859,859,859,859,859,,,,,,,,,,,,,,,,,,,,859,,,859,,,859,859\", \",,859,,,,,,859,,,,,,,,,859,,,,,859,859,859,859,,859,859,859,859,,,,\", \"859,859,,,,873,873,873,859,873,859,859,859,873,873,,,,873,,873,873,873\", \"873,873,873,873,,,,,,873,873,873,873,873,873,873,,,873,,,,,,,873,,,873\", \"873,873,873,873,873,873,873,,873,873,873,,873,873,,,873,,,,,,,,,,,,\", \",,,,,,,873,,,873,,,873,873,,,873,,,,,,,,,,,,,,,,,,,,873,873,873,873\", \",873,873,873,873,,,,,873,873,,,,885,885,885,873,885,873,873,873,885\", \"885,,,,885,,885,885,885,885,885,885,885,,,,,,885,885,885,885,885,885\", \"885,,,885,,,,,,,885,,,885,885,885,885,885,885,885,885,,885,885,885,\", \"885,885,,,885,,,,,,,,,,,,,,,,,,,,885,,,885,,,885,885,,,885,,,,,,,,,\", \",,,,,,,,,,885,885,885,885,,885,885,885,885,,,,,885,885,,,,982,982,982\", \"885,982,885,885,885,982,982,,,,982,,982,982,982,982,982,982,982,,,,\", \",982,982,982,982,982,982,982,,,982,,,,,,,982,,,982,982,982,982,982,982\", \"982,982,982,982,982,982,,982,982,982,982,982,,,,,,,,,,,,,,,,,,,,982\", \",,982,,,982,982,,,982,,982,,982,,982,,,982,,,,,,982,,,,,982,982,982\", \"982,,982,982,982,982,,,,,982,982,,,,,,,982,,982,982,982,8,8,8,8,8,8\", \"8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,,,,8,8,8,8,8,8,8,8,8,8,,,,,,8,8\", \"8,8,8,8,8,8,8,8,,8,,,,,,,,8,8,,8,8,8,8,8,8,8,,,8,8,,,,8,8,8,8,,,,,,\", \",,,,,,,8,8,,8,8,8,8,8,8,8,8,8,8,8,8,,,8,8,,,,,,,,,,,,,,8,9,9,9,9,9,9\", \"9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,,,,9,9,9,9,9,9,9,9,9,9,,,,,,9,9\", \"9,9,9,9,9,9,9,,,9,,,,,,,,9,9,,9,9,9,9,9,9,9,,,9,9,,,,9,9,9,9,,,,,,,\", \",,,,,,9,9,,9,9,9,9,9,9,9,9,9,9,9,9,,,9,9,,,,,,,,,,,,,,9,397,397,397\", \"397,397,397,397,397,397,397,397,397,397,397,397,397,397,397,397,397\", \"397,397,397,397,,,,397,397,397,397,397,397,397,397,397,397,,,,,,397\", \"397,397,397,397,397,397,397,397,,,397,,,,,,,,397,397,,397,397,397,397\", \"397,397,397,,,397,397,,,,397,397,397,397,,,,,,,,,,,,,,397,397,,397,397\", \"397,397,397,397,397,397,397,397,397,397,,,397,397,,,,,,,,,,,,,,397,616\", \"616,616,616,616,616,616,616,616,616,616,616,616,616,616,616,616,616\", \"616,616,616,616,616,616,,,,616,616,616,616,616,616,616,616,616,616,\", \",,,,616,616,616,616,616,616,616,616,616,,,616,,,,,,,,616,616,,616,616\", \"616,616,616,616,616,,,616,616,,,,616,616,616,616,,,,,,,,,,,,,,616,616\", \",616,616,616,616,616,616,616,616,616,616,616,616,,,616,616,,,,,,,,,\", \",,,,616,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71\", \"71,71,71,71,,,,71,71,71,71,71,71,71,71,71,71,,,,,,71,71,71,71,71,71\", \"71,71,71,71,71,71,,71,,,,,,71,71,,71,71,71,71,71,71,71,,,71,71,,,,71\", \"71,71,71,,,,,,71,,,,,,,,71,71,,71,71,71,71,71,71,71,71,71,71,71,71,\", \",71,737,737,737,737,737,737,737,737,737,737,737,737,737,737,737,737\", \"737,737,737,737,737,737,737,737,,,,737,737,737,737,737,737,737,737,737\", \"737,,,,,,737,737,737,737,737,737,737,737,737,,,737,,,,,,,,737,737,,737\", \"737,737,737,737,737,737,,,737,737,,,,737,737,737,737,,,,,,,,,,,,,,737\", \"737,,737,737,737,737,737,737,737,737,737,737,737,737,210,210,737,,210\", \",,,,,,,210,210,,210,210,210,210,210,210,210,,,210,210,,,,210,210,210\", \"210,,,,,,210,,,,,,,,210,210,,210,210,210,210,210,210,210,210,210,210\", \"210,210,211,211,210,,211,,,,,,,,211,211,,211,211,211,211,211,211,211\", \",,211,211,,,,211,211,211,211,,,,,,211,,,,,,,,211,211,,211,211,211,211\", \"211,211,211,211,211,211,211,211,261,261,211,,261,,,,,,,,261,261,,261\", \"261,261,261,261,261,261,,,261,261,,,,261,261,261,261,,,,,,,,,,,,,,261\", \"261,,261,261,261,261,261,261,261,261,261,261,261,261,442,442,261,,442\", \",,,,,,,442,442,,442,442,442,442,442,442,442,,,442,442,,,,442,442,442\", \"442,,,,,,442,,,,,,,,442,442,,442,442,442,442,442,442,442,442,442,442\", \"442,442,443,443,442,,443,,,,,,,,443,443,,443,443,443,443,443,443,443\", \",,443,443,,,,443,443,443,443,,,,,,443,,,,,,,,443,443,,443,443,443,443\", \"443,443,443,443,443,443,443,443,509,509,443,,509,,,,,,,,509,509,,509\", \"509,509,509,509,509,509,,,509,509,,,,509,509,509,509,,,,,,509,,,,,,\", \",509,509,,509,509,509,509,509,509,509,509,509,509,509,509,510,510,509\", \",510,,,,,,,,510,510,,510,510,510,510,510,510,510,,,510,510,,,,510,510\", \"510,510,,,,,,510,,,,,,,,510,510,,510,510,510,510,510,510,510,510,510\", \"510,510,510,519,519,510,,519,,,,,,,,519,519,,519,519,519,519,519,519\", \"519,,,519,519,,,,519,519,519,519,,,,,,519,,,,,,,,519,519,,519,519,519\", \"519,519,519,519,519,519,519,519,519,520,520,519,,520,,,,,,,,520,520\", \",520,520,520,520,520,520,520,,,520,520,,,,520,520,520,520,,,,,,520,\", \",,,,,,520,520,,520,520,520,520,520,520,520,520,520,520,520,520,578,578\", \"520,,578,,,,,,,,578,578,,578,578,578,578,578,578,578,,,578,578,,,,578\", \"578,578,578,,,,,,578,,,,,,,,578,578,,578,578,578,578,578,578,578,578\", \"578,578,578,578,579,579,578,,579,,,,,,,,579,579,,579,579,579,579,579\", \"579,579,,,579,579,,,,579,579,579,579,,,,,,579,,,,,,,,579,579,,579,579\", \"579,579,579,579,579,579,579,579,579,579,585,585,579,,585,,,,,,,,585\", \"585,,585,585,585,585,585,585,585,,,585,585,,,,585,585,585,585,,,,,,585\", \",,,,,,,585,585,,585,585,585,585,585,585,585,585,585,585,585,585,586\", \"586,585,,586,,,,,,,,586,586,,586,586,586,586,586,586,586,,,586,586,\", \",,586,586,586,586,,,,,,586,,,,,,,,586,586,,586,586,586,586,586,586,586\", \"586,586,586,586,586,937,937,586,,937,,,,,,,,937,937,,937,937,937,937\", \"937,937,937,,,937,937,,,,937,937,937,937,,,,,,937,,,,,,,,937,937,,937\", \"937,937,937,937,937,937,937,937,937,937,937,983,983,937,,983,,,,,,,\", \"983,983,,983,983,983,983,983,983,983,,,983,983,,,,983,983,983,983,,\", \",,,983,,,,,,,,983,983,,983,983,983,983,983,983,983,983,983,983,983,983\", \"984,984,983,,984,,,,,,,,984,984,,984,984,984,984,984,984,984,,,984,984\", \",,,984,984,984,984,,,,,,984,,,,,,,,984,984,,984,984,984,984,984,984\", \"984,984,984,984,984,984,,536,984,536,536,536,536,536,,693,,693,693,693\", \"693,693,536,,,,,,,,693,,695,,695,695,695,695,695,,,,,,536,,,695,,,,\", \"693,536,536,536,536,,,,536,693,693,693,693,,,,693,695,,735,,735,735\", \"735,735,735,695,695,695,695,,,,695,735,,736,,736,736,736,736,736,,864\", \",864,864,864,864,864,736,,,,,735,,,864,,,,,,735,735,735,735,,,,735,736\", \",,,,,,,864,736,736,736,736,,,,736,864,864,864,864,,,866,864,866,866\", \"866,866,866,,892,,892,892,892,892,892,866,,,,,,,,892,,896,,896,896,896\", \"896,896,,,,,,866,,,896,,,,,892,866,866,866,866,,,,866,892,892,892,892\", \",,,892,896,,898,,898,898,898,898,898,,,896,896,,,,896,898,,968,,968\", \"968,968,968,968,970,,970,970,970,970,970,,968,,,,,898,,970,,972,,972\", \"972,972,972,972,898,898,,,,898,968,,972,,,,,970,,968,968,968,968,,,\", \"968,,970,970,,,,970,972,,974,,974,974,974,974,974,,,972,972,,,,972,974\", \",986,,986,986,986,986,986,1012,,1012,1012,1012,1012,1012,,986,,,,,974\", \",1012,,,,,,,,,974,974,,,,974,986,,,,,,,1012,,,,986,986,,,,986,,1012\", \"1012,,,,1012\"];\n      racc_action_check = (arr = Opal.const_get_qualified('::', 'Array').$new(25163, nil));\n      idx = 0;\n      $send(clist, 'each', [], (TMP_Ruby23_5 = function(str){var self = TMP_Ruby23_5.$$s || this, TMP_6;\nif (str == null) str = nil;\n      return $send(str.$split(\",\", -1), 'each', [], (TMP_6 = function(i){var self = TMP_6.$$s || this, $writer = nil;\nif (i == null) i = nil;\n        \n          if ($truthy(i['$empty?']())) {\n            } else {\n            \n            $writer = [idx, i.$to_i()];\n            $send(arr, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };\n          return (idx = $rb_plus(idx, 1));}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6))}, TMP_Ruby23_5.$$s = self, TMP_Ruby23_5.$$arity = 1, TMP_Ruby23_5));\n      racc_action_pointer = [1637, 33, nil, 81, nil, 5976, 1388, -51, 23086, 23214, -11, nil, 50, 117, 572, -81, 105, 309, nil, -71, 6107, 2057, 230, nil, -62, nil, -8, 742, 852, 6238, 6369, 6500, nil, 1777, 6631, 6762, nil, 134, 282, 352, 247, 332, 6901, 7032, 7163, 191, 574, nil, nil, nil, nil, nil, nil, nil, nil, nil, 962, nil, -80, 7294, 7425, 4, nil, 7556, 7687, nil, nil, 7818, 7957, 8088, 8219, 23598, nil, nil, nil, nil, nil, 223, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 0, nil, nil, 112, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 354, nil, 8358, nil, nil, nil, nil, 8497, 8628, 8759, 8890, 9029, 1917, nil, 576, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 223, nil, 2057, 9160, 9291, 9422, 23772, 23833, nil, nil, 9553, 9684, 9815, 9946, 10077, 10208, nil, nil, 576, -54, 138, 307, 166, 241, 309, nil, 10339, 2197, 310, 10470, 10601, 10732, 10863, 10994, 11125, 11256, 11387, 11518, 11649, 11780, 11911, 12042, 12173, 12304, 12435, 12566, 12697, 12828, 12959, 13090, 13221, 13352, 13483, 13614, 13745, nil, nil, 23894, nil, nil, 318, 13876, 14007, nil, nil, nil, nil, nil, nil, nil, 14138, nil, 2197, nil, 297, 325, nil, 14269, 373, 14400, nil, nil, 14531, 14662, nil, nil, 228, nil, 14801, 1441, 358, 338, 2337, 353, 408, 377, 14932, 2477, 615, 645, 714, 473, 790, nil, 441, 417, 33, nil, nil, nil, 476, 360, 453, 15071, nil, 472, 522, 822, nil, 526, nil, 15202, 2617, 15333, 465, nil, -73, 146, 506, 489, 387, 523, nil, nil, 1505, 346, -1, 11, 15464, 15595, 298, 603, 498, -18, 11, 824, 584, 25, 618, nil, nil, 342, 434, -21, nil, 900, nil, 541, 15726, nil, nil, nil, 194, 230, 379, 413, 486, 510, 577, 578, 582, nil, 619, nil, 15857, nil, 272, 456, 459, 465, 497, -41, -35, 501, nil, nil, nil, nil, nil, nil, nil, nil, 537, 23342, nil, nil, nil, nil, 544, nil, nil, 535, 15988, 551, nil, nil, 1777, 563, nil, 568, 590, 481, 552, 1098, nil, nil, nil, 222, 334, 638, nil, nil, 1230, 1366, nil, 2337, nil, 587, nil, nil, 1637, nil, nil, nil, nil, -35, nil, 650, 23955, 24016, 16119, 197, 16250, 16381, 16512, 4017, 4157, 623, 662, 677, 678, 679, 682, 1518, 5697, 1470, 4297, 1181, 1315, 4437, 4577, 4717, 4857, 4997, 5137, 5277, 1051, 1249, 5417, 5557, 2477, -54, 1502, nil, nil, nil, nil, 629, nil, -53, -10, 636, nil, nil, 16643, nil, 16774, nil, 16905, nil, 363, nil, nil, nil, 17044, 1507, 2757, 642, 640, nil, nil, 644, 17183, 650, 17314, 24077, 24138, 930, 704, nil, 17445, 661, nil, 17576, 17707, 24199, 24260, 2617, 17838, 788, 790, 570, 715, nil, 17969, nil, nil, 18100, nil, nil, nil, nil, 24749, nil, 689, 694, nil, 695, 697, 700, nil, nil, nil, nil, nil, nil, nil, nil, 691, 749, nil, nil, 18231, nil, nil, nil, 788, nil, nil, nil, 790, nil, nil, 792, 2897, 845, nil, 3037, 62, 147, 842, 853, 18362, 18493, 24321, 24382, 27, nil, nil, 932, nil, 24443, 24504, 18624, nil, nil, 250, 3177, 774, nil, -33, nil, nil, nil, 717, nil, nil, nil, 751, nil, nil, 388, nil, 390, nil, nil, 737, nil, 742, nil, nil, nil, 23470, nil, 747, 18755, 18886, 619, 787, 19017, 19148, 19279, 19410, 786, nil, nil, 19541, 19672, 789, nil, 19803, 19934, nil, nil, 217, 301, 466, 604, 756, 1917, 755, nil, 1466, nil, 3317, 863, 6, 160, nil, 3457, 3597, nil, 763, nil, 810, 20065, nil, nil, 20196, nil, 785, -80, 20327, 767, nil, 772, 123, 180, 814, 248, 1106, 815, 772, 20458, 2757, 846, 214, 900, 20589, nil, 786, nil, 396, 37, 803, 697, nil, nil, 537, 24757, nil, 24774, nil, 6809, nil, 20720, nil, 856, nil, 804, 335, 808, nil, nil, nil, nil, 650, nil, 926, nil, nil, nil, nil, 934, nil, 26, 817, 68, 93, 151, 185, 20851, 1066, 1143, nil, 819, 3737, 20982, nil, 942, 3877, 24813, 24830, 23711, nil, nil, nil, nil, nil, nil, 4017, nil, nil, nil, nil, nil, nil, nil, 823, 21113, 2897, 21244, nil, 834, nil, 3037, nil, 3177, nil, nil, 3317, nil, 3457, nil, 3597, 21375, 21506, 21637, 21768, 343, 21899, 835, 839, nil, 840, 847, 848, nil, 877, 861, 857, 852, 22030, nil, nil, 987, nil, nil, 4157, 884, 991, nil, nil, nil, nil, 873, 236, nil, nil, 1000, nil, 4297, 877, 925, nil, nil, 923, nil, nil, 4437, 4577, 925, 884, nil, nil, nil, 886, 887, nil, 888, 889, nil, 891, nil, nil, 896, 1162, 914, 735, nil, 1039, nil, 22161, 1042, 4717, 4857, nil, 22292, 4997, 152, 181, nil, 1044, 327, 5137, nil, 1045, 927, 366, nil, 934, 930, nil, 3737, 22423, 22554, 3877, 1022, nil, nil, 24838, nil, 24890, nil, 8266, nil, nil, 957, 1076, 22685, 934, 1022, nil, 971, nil, nil, nil, 5277, nil, nil, 32, 22816, nil, nil, 973, 1081, nil, nil, 24898, nil, 14979, nil, 24915, nil, 24954, nil, nil, nil, nil, 398, 1028, 967, nil, 33, nil, 1092, 1093, nil, 303, nil, nil, nil, 1094, nil, nil, nil, 1020, nil, 980, nil, nil, 982, 985, 986, 987, nil, 995, nil, 421, nil, nil, nil, 966, 24565, nil, nil, nil, 5417, 34, 35, 1003, 1077, 36, nil, nil, nil, 1003, 1009, 1011, 1013, 1014, 1223, 1015, 1437, 5557, nil, nil, nil, nil, nil, 5697, nil, 5837, nil, 24971, nil, 24978, nil, 24995, nil, 25034, nil, nil, nil, 1332, 1062, 1063, 1151, 22947, 24626, 24687, 42, 25051, nil, nil, nil, nil, 4097, 1027, 719, 1152, 1153, 1030, 1046, 1051, 1053, nil, nil, 1059, 98, 102, 111, 138, 1060, 1064, nil, nil, nil, 25058, nil, nil, nil, nil, 145, nil, 1069, nil];\n      racc_action_default = [-3, -596, -1, -582, -4, -596, -7, -596, -596, -596, -596, -29, -596, -596, -596, -279, -596, -40, -43, -584, -596, -48, -50, -51, -52, -56, -256, -256, -256, -293, -328, -329, -68, -11, -72, -80, -82, -596, -486, -487, -596, -596, -596, -596, -596, -584, -237, -270, -271, -272, -273, -274, -275, -276, -277, -278, -570, -281, -283, -595, -560, -301, -389, -596, -596, -306, -309, -582, -596, -596, -596, -596, -330, -331, -427, -428, -429, -430, -431, -452, -434, -435, -454, -456, -439, -444, -448, -450, -466, -454, -468, -470, -471, -472, -473, -568, -475, -476, -569, -478, -479, -480, -481, -482, -483, -484, -485, -490, -491, -596, -2, -583, -591, -592, -593, -6, -596, -596, -596, -596, -596, -3, -17, -596, -111, -112, -113, -114, -115, -116, -117, -118, -119, -123, -124, -125, -126, -127, -128, -129, -130, -131, -132, -133, -134, -135, -136, -137, -138, -139, -140, -141, -142, -143, -144, -145, -146, -147, -148, -149, -150, -151, -152, -153, -154, -155, -156, -157, -158, -159, -160, -161, -162, -163, -164, -165, -166, -167, -168, -169, -170, -171, -172, -173, -174, -175, -176, -177, -178, -179, -180, -181, -182, -183, -184, -185, -186, -187, -188, -189, -190, -191, -192, -193, -22, -120, -11, -596, -596, -246, -596, -596, -580, -581, -596, -596, -596, -596, -596, -584, -585, -47, -596, -486, -487, -596, -279, -596, -596, -229, -596, -11, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -596, -396, -398, -596, -578, -579, -57, -246, -596, -300, -402, -411, -413, -63, -408, -64, -584, -65, -238, -251, -260, -260, -255, -596, -261, -596, -452, -562, -596, -596, -66, -67, -582, -12, -596, -15, -596, -70, -11, -584, -596, -73, -76, -11, -88, -89, -596, -596, -96, -293, -296, -584, -596, -328, -329, -332, -409, -596, -78, -596, -84, -290, -469, -596, -214, -215, -230, -596, -11, -596, -584, -239, -588, -588, -596, -596, -588, -596, -302, -303, -518, -49, -596, -596, -596, -596, -582, -596, -583, -486, -487, -596, -596, -279, -596, -342, -343, -106, -107, -596, -109, -596, -279, -494, -596, -486, -487, -321, -111, -112, -153, -154, -155, -171, -176, -183, -186, -323, -596, -558, -596, -432, -596, -596, -596, -596, -596, -596, -596, -596, 1021, -5, -594, -23, -24, -25, -26, -27, -596, -596, -19, -20, -21, -121, -596, -30, -39, -266, -596, -596, -265, -31, -196, -584, -247, -260, -260, -571, -572, -256, -406, -573, -574, -572, -571, -256, -405, -407, -573, -574, -37, -204, -38, -596, -41, -42, -194, -261, -44, -45, -46, -584, -299, -596, -596, -596, -246, -290, -596, -596, -596, -205, -206, -207, -208, -209, -210, -211, -212, -216, -217, -218, -219, -220, -221, -222, -223, -224, -225, -226, -227, -228, -231, -232, -233, -234, -584, -378, -256, -571, -572, -54, -58, -584, -257, -378, -378, -584, -295, -252, -596, -253, -596, -258, -596, -262, -596, -565, -567, -10, -583, -14, -3, -584, -69, -288, -85, -74, -596, -584, -246, -596, -596, -95, -596, -469, -596, -81, -86, -596, -596, -596, -596, -235, -596, -419, -596, -284, -596, -240, -590, -589, -242, -590, -291, -292, -561, -390, -518, -393, -557, -557, -501, -503, -503, -503, -517, -519, -520, -521, -522, -523, -524, -525, -526, -596, -528, -530, -532, -537, -539, -540, -542, -547, -549, -550, -552, -553, -554, -596, -11, -333, -334, -11, -596, -596, -596, -596, -596, -246, -596, -596, -290, -314, -106, -107, -108, -596, -596, -246, -317, -492, -596, -11, -496, -325, -584, -433, -453, -458, -596, -460, -436, -455, -596, -457, -438, -596, -441, -596, -443, -446, -596, -447, -596, -467, -8, -18, -596, -28, -269, -596, -596, -410, -596, -248, -250, -596, -596, -59, -245, -403, -596, -596, -61, -404, -596, -596, -298, -586, -571, -572, -571, -572, -584, -194, -596, -379, -584, -381, -11, -53, -399, -378, -243, -11, -11, -294, -260, -259, -263, -596, -563, -564, -596, -13, -596, -71, -596, -77, -83, -584, -571, -572, -244, -575, -94, -596, -79, -596, -203, -213, -584, -595, -595, -282, -584, -287, -588, -596, -584, -596, -499, -500, -596, -596, -510, -596, -513, -596, -515, -596, -344, -596, -346, -348, -355, -584, -531, -541, -551, -555, -595, -335, -595, -307, -336, -337, -310, -596, -313, -596, -584, -571, -572, -575, -289, -596, -106, -107, -110, -584, -11, -596, -319, -596, -11, -518, -518, -596, -559, -459, -462, -463, -464, -465, -11, -437, -440, -442, -445, -449, -451, -122, -267, -596, -197, -596, -587, -260, -33, -199, -34, -200, -60, -35, -202, -36, -201, -62, -195, -596, -596, -596, -596, -410, -596, -557, -557, -360, -362, -362, -362, -377, -596, -584, -383, -526, -534, -535, -545, -596, -401, -400, -11, -596, -596, -254, -264, -566, -16, -75, -410, -87, -297, -595, -340, -11, -420, -595, -421, -422, -596, -241, -391, -11, -11, -596, -557, -538, -556, -502, -503, -503, -529, -503, -503, -548, -503, -526, -543, -584, -596, -353, -596, -527, -596, -338, -596, -596, -11, -11, -312, -596, -11, -410, -596, -410, -596, -596, -11, -322, -596, -584, -596, -326, -596, -268, -32, -198, -249, -596, -236, -596, -358, -359, -368, -370, -596, -373, -596, -375, -380, -596, -596, -596, -533, -596, -397, -596, -412, -414, -9, -11, -426, -341, -596, -596, -424, -285, -596, -596, -392, -498, -596, -506, -596, -508, -596, -511, -596, -514, -516, -345, -347, -351, -596, -356, -304, -596, -305, -596, -596, -263, -595, -315, -318, -493, -596, -324, -495, -497, -496, -461, -557, -536, -361, -362, -362, -362, -362, -546, -362, -382, -584, -385, -387, -388, -544, -596, -290, -55, -425, -11, -486, -487, -596, -596, -279, -423, -394, -395, -503, -503, -503, -503, -349, -596, -354, -596, -11, -308, -311, -415, -416, -417, -11, -320, -11, -357, -596, -365, -596, -367, -596, -371, -596, -374, -376, -384, -596, -289, -575, -419, -246, -596, -596, -290, -596, -504, -507, -509, -512, -596, -352, -595, -596, -596, -362, -362, -362, -362, -386, -418, -584, -571, -572, -575, -289, -503, -350, -339, -316, -327, -596, -363, -366, -369, -372, -410, -505, -362, -364];\n      clist = [\"218,277,277,277,14,375,278,278,278,14,313,313,336,411,268,272,260,122\", \"205,2,681,210,329,575,222,433,325,6,127,127,834,262,6,222,222,222,330\", \"14,304,304,130,130,568,571,313,313,313,340,341,261,489,344,660,299,132\", \"132,417,423,515,264,271,273,221,480,657,111,657,222,222,481,408,222\", \"349,359,359,537,734,114,430,320,279,279,279,527,530,690,691,534,825\", \"822,584,127,110,660,316,115,440,713,716,902,391,392,393,394,295,297\", \"803,476,782,380,331,334,275,288,289,14,779,1,705,648,222,222,222,222\", \"14,14,544,653,654,621,780,929,381,933,935,361,365,837,6,387,396,114\", \"905,605,607,880,663,395,6,204,815,486,354,404,397,651,345,616,332,650\", \"524,377,333,337,352,588,376,326,327,684,328,342,838,343,502,839,725\", \"821,964,823,730,277,848,591,407,489,660,592,601,603,606,606,407,737\", \"601,920,781,783,418,657,657,389,932,535,812,338,687,475,483,484,14,222\", \"222,222,956,961,807,884,222,222,222,222,222,222,379,382,902,383,384\", \"442,385,427,386,929,739,14,744,277,277,1000,935,731,820,278,817,871\", \"277,667,642,403,409,278,717,923,,676,428,432,,,822,,,,,992,829,,,222\", \"222,,,688,,,313,26,222,,,,26,,,825,,,417,423,512,,,313,822,792,14,26\", \"268,,14,1008,272,,304,14,26,26,26,526,26,509,669,1009,494,,636,279,728\", \"499,,304,862,863,544,279,572,573,519,,14,222,,,925,,516,962,,,26,26\", \",,26,,222,222,926,482,927,,498,513,,672,578,485,652,505,773,,655,891\", \"114,672,222,295,501,913,822,,295,507,,,950,,665,497,,720,222,262,668\", \",,800,26,,,729,622,26,26,26,26,26,26,,,593,,,966,628,615,799,,,,633\", \"747,,747,298,277,127,114,,660,842,,,672,733,762,795,,130,418,767,672\", \"574,657,13,,,843,811,13,,,132,433,,,845,222,,627,,996,,,644,632,,,,\", \"339,339,427,628,339,,,13,967,,738,851,852,,,,,1001,,277,,313,26,26,26\", \"26,,,,313,26,26,26,26,26,26,418,,,,,14,,14,,,418,26,649,304,,222,,339\", \"339,339,339,304,664,,,,544,544,516,222,6,795,,427,,,516,,,,,,656,427\", \",26,26,,808,13,,,277,,26,,719,,13,13,802,,277,,,,,846,,418,,850,26,\", \",14,26,418,14,,,26,686,,222,833,,,,941,,402,,963,222,,,,14,700,,,427\", \",791,,26,26,427,,,,958,,,,298,436,437,438,439,,26,26,,,622,,751,,784\", \",222,222,,,,222,222,127,,222,26,,13,313,790,,809,714,714,130,,622,,14\", \"313,,26,,14,14,407,628,,132,633,732,810,13,758,760,784,304,853,763,765\", \"757,,432,,298,,,304,916,298,15,516,,,552,15,,,,,,,801,,,,,622,,,,,901\", \",,844,622,,,,,847,,15,306,306,1017,26,,,,525,,13,918,222,,13,,,14,222\", \"13,,14,,339,339,,,700,,,831,14,,,,351,360,360,,,127,16,222,590,13,313\", \"16,784,,882,,,,886,,,,,26,594,26,,,,,,,,26,1002,,,,874,16,,,,15,14,856\", \",26,995,335,,,15,15,,,,14,,,,,,,,14,14,,907,,,,,,353,,,672,,,,,,,,,776\", \",222,,14,14,,26,14,,26,313,,,14,,26,,,,,,,313,,,26,,,,26,16,,38,,700\", \",700,38,936,16,16,,816,,,,14,552,,,944,15,,,,,,,,,,,,26,26,38,302,302\", \"26,26,,,26,,977,,15,,,714,,680,915,,,,26,919,,,,26,26,,13,,13,,,,347\", \"363,363,363,,,14,954,700,405,,710,983,,712,277,,435,427,,,,,14,,16,\", \",,14,778,14,418,,431,,,15,,,,15,,38,622,306,15,222,,,16,,38,38,,,,785\", \",700,,700,306,26,13,427,,13,26,26,,15,26,,,,,,,824,,826,26,491,,493\", \",13,495,496,,789,,26,,700,793,794,,,,,,,552,,552,,,,,16,,,922,16,,776\", \",776,16,776,,694,696,698,,,,,26,,,,,,,,38,,,,,26,13,16,552,552,,13,13\", \"26,26,,777,,,,,,,,,38,,,,,,,,,,,26,,26,26,,,26,,,,339,,26,854,,,339\", \",,,,,,818,,,818,,,,,,,,618,,,,,,,865,867,869,,26,,776,,776,38,776,13\", \"776,38,,13,,302,38,,877,,,,,13,,,15,,15,,,883,302,928,306,930,,,,888\", \"889,38,306,,,,,,776,,,786,,,,,,,785,951,785,952,26,953,909,910,,,912\", \",,13,,658,,335,,661,339,26,,,,,13,26,552,26,,,,,13,13,,,15,,,15,16,\", \"16,26,,,,940,,,,,,658,,,335,13,13,15,,13,,,,,743,13,,,,39,,,,997,39\", \"998,,999,,706,,,,969,971,973,975,,976,,818,1007,,777,,777,,777,13,435\", \"785,,39,303,303,981,,,16,,,16,,,15,,,1019,,15,15,,993,893,895,,897,899\", \"994,900,,16,306,,,,,348,364,364,364,,752,306,,,658,335,,,,38,,38,1013\", \"1014,1015,1016,13,302,,,,,,,,302,,,,,,,431,13,,1020,,,39,13,796,13,\", \"797,,,16,39,39,,,16,16,,15,777,,777,15,777,,777,786,806,,786,,786,15\", \"786,,,,,,,,,,38,828,,38,,,,,,,,,,,,,,,,,777,,,38,,,,,,,,360,987,988\", \"989,990,,15,,,,,,,,,,,,16,15,,,16,39,855,,,15,15,,,,16,,,,,,,,,,,,,\", \",,39,38,,,15,15,38,38,15,,1018,786,,786,15,786,,786,,302,,,,,,,,,,,302\", \",16,,,,,,,360,,,,,,16,,15,,,,946,,16,16,786,,,,,,39,,,911,39,,,,303\", \"39,,,,,,,,16,16,,335,16,38,,,303,38,16,,,,,,,39,,38,,,,,,,,,,15,,,,\", \",,,,,,,,,16,,,15,947,,,,,15,,15,,,,,,,363,,,,,,38,,,,,,,,,,,,,38,,,\", \",,,,38,38,,,,,,,,,,,,,,16,,,,,,,,,,38,38,,,38,,,16,,,38,,,16,,16,,,\", \",,,,,,,,,,,,,,,,363,,,,,,,,38,,,,942,,,,,,,,,,,,,,,,,,,,,,,,,,,,,39\", \",39,,,,,,303,,,,,,,,303,,,,,,,,,,,38,,,,,,,,,,,,,,,,,38,,,,,,38,,38\", \",,,,,,,,,,,,,,,,,39,,,39,,,,,,,,,,,,,,,,,,,,39,,,,,,,,,,,,,,,,,,,,,\", \",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,39,,,,,39,39,,,,,,,,,,,,303,,,,,\", \",229,,,,303,,,,,276,276,276,,,,,,,,,,,322,323,324,,,,,,,,,,,,,,,276\", \"276,,,,,,,,,,,,,,,,,39,,,,39,,,,,,,,,,39,,,,,,,,,,,,,,,,,,,,,,,,,,,\", \",,,,,,,,,,,,,,364,,,,,,39,,,,,,,,,,,,,39,,,,,,,,39,39,,,,,,,,,,,,,,\", \",,,,,,,,,39,39,,,39,,,,,,39,,,,,,,,,,,,276,410,276,,,,,429,434,,,,,364\", \",,,,,,,39,,229,,943,449,450,451,452,453,454,455,456,457,458,459,460\", \"461,462,463,464,465,466,467,468,469,470,471,472,473,474,,,,,,,276,276\", \",,,,,,,276,,,,,,,276,,276,,,276,276,39,,,,,,,,,,,,,,,,,39,,,,,,39,,39\", \",,,,,,,,,,,521,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\", \",,,,,,,,,,,,,,,,,,,,,,,,,,,276,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\", \"276,,429,643,410,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,276,,276,,276\", \",,,,,,,,,,,,,,,276,,,,,,,,,678,679,,,,,,,,,,276,,,276,,,,,,,,,,,,,,\", \",,,,,,,,,,276,,,,,,,,,,,,,,,,,,,,276,276,,,,,,,,,,276,,,,,,,,,,,,,,\", \",,,,,,,,,,,,,,,,,276,754,,,276,276,759,761,,,,764,766,,,643,768,,,,\", \",,,,,,,,,,,,,,,,,,,276,,,276,,,,,,,,,,,,,,,,,,,,276,,,,,,,,,,,,,,,,\", \"276,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,276,,857,,\", \",,,,,,,,,,,759,761,766,764,,860,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\", \",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,276,,,,,,,,,,,,,,,,,276,857,,,,,,,,,,\", \",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\", \",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,276\"];\n      racc_goto_table = (arr = Opal.const_get_qualified('::', 'Array').$new(2923, nil));\n      idx = 0;\n      $send(clist, 'each', [], (TMP_Ruby23_7 = function(str){var self = TMP_Ruby23_7.$$s || this, TMP_8;\nif (str == null) str = nil;\n      return $send(str.$split(\",\", -1), 'each', [], (TMP_8 = function(i){var self = TMP_8.$$s || this, $writer = nil;\nif (i == null) i = nil;\n        \n          if ($truthy(i['$empty?']())) {\n            } else {\n            \n            $writer = [idx, i.$to_i()];\n            $send(arr, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };\n          return (idx = $rb_plus(idx, 1));}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8))}, TMP_Ruby23_7.$$s = self, TMP_Ruby23_7.$$arity = 1, TMP_Ruby23_7));\n      clist = [\"32,34,34,34,22,57,69,69,69,22,65,65,87,23,72,72,139,15,15,2,10,25,68\", \"93,22,18,32,7,58,58,91,25,7,22,22,22,69,22,22,22,61,61,90,90,65,65,65\", \"17,17,37,74,17,177,50,62,62,38,38,52,39,39,39,20,40,75,6,75,22,22,23\", \"28,22,22,22,22,138,97,96,28,64,71,71,71,70,70,122,122,70,173,168,55\", \"58,4,177,51,5,48,92,92,115,17,17,17,17,46,47,11,38,130,150,71,71,45\", \"45,45,22,127,1,117,41,22,22,22,22,22,22,162,41,41,24,128,174,151,132\", \"133,56,56,11,7,151,2,96,118,154,154,12,14,7,7,16,130,48,19,29,31,43\", \"4,63,67,73,8,85,86,89,94,95,98,99,100,101,102,103,104,105,48,106,107\", \"128,108,128,109,34,110,111,69,74,177,112,155,155,155,155,69,113,155\", \"114,119,125,72,75,75,5,131,134,135,136,137,140,142,143,22,22,22,22,118\", \"144,145,146,22,22,22,22,22,22,149,152,115,153,156,25,157,58,158,174\", \"159,22,160,34,34,132,133,161,166,69,170,130,34,52,23,20,20,69,93,171\", \",52,20,20,,,168,,,,,118,117,,,22,22,,,138,,,65,42,22,,,,42,,,173,,,38\", \"38,32,,,65,168,41,22,42,72,,22,118,72,,22,22,42,42,42,32,42,25,23,91\", \"150,,48,71,55,7,,22,122,122,162,71,17,17,25,,22,22,,,127,,50,11,,,42\", \"42,,,42,,22,22,128,45,128,,6,64,,38,25,45,48,51,24,,48,122,96,38,22\", \"46,47,92,168,,46,47,,,128,,48,4,,23,22,25,48,,,24,42,,,23,32,42,42,42\", \"42,42,42,,,37,,,97,72,15,52,,,,72,155,,155,9,34,58,96,,177,90,,,38,8\", \"40,74,,61,72,40,38,4,75,21,,,24,70,21,,,62,18,,,24,22,,39,,128,,,32\", \"39,,,,,30,30,58,72,30,,,21,122,,48,138,138,,,,,10,,34,,65,42,42,42,42\", \",,,65,42,42,42,42,42,42,72,,,,,22,,22,,,72,42,39,22,,22,,30,30,30,30\", \"22,2,,,,162,162,50,22,7,74,,58,,,50,,,,,,71,58,,42,42,,28,21,,,34,,42\", \",69,,21,21,48,,34,,,,,8,,72,,8,42,,,22,42,72,22,,,42,71,,22,48,,,,90\", \",9,,93,22,,,,22,116,,,58,,87,,42,42,58,,,,90,,,,9,30,30,30,30,,42,42\", \",,32,,15,,32,,22,22,,,,22,22,58,,22,42,,21,65,139,,68,96,96,61,,32,\", \"22,65,,42,,22,22,69,72,,62,72,96,32,21,20,20,32,22,57,20,20,71,,20,\", \"9,,,22,8,9,26,50,,,167,26,,,,,,,50,,,,,32,,,,,48,,,17,32,,,,,17,,26\", \"26,26,24,42,,,,30,,21,48,22,,21,,,22,22,21,,22,,30,30,,,116,,,116,22\", \",,,26,26,26,,,58,27,22,30,21,65,27,32,,68,,,,68,,,,,42,30,42,,,,,,,\", \"42,23,,,,22,27,,,,26,22,20,,42,8,66,,,26,26,,,,22,,,,,,,,22,22,,17,\", \",,,,27,,,38,,,,,,,,,121,,22,,22,22,,42,22,,42,65,,,22,,42,,,,,,,65,\", \",42,,,,42,27,,53,,116,,116,53,22,27,27,,121,,,,22,167,,,22,26,,,,,,\", \",,,,,42,42,53,53,53,42,42,,,42,,32,,26,,,96,,30,96,,,,42,96,,,,42,42\", \",21,,21,,,,53,53,53,53,,,22,116,116,66,,9,25,,9,34,,66,58,,,,,22,,27\", \",,,22,126,22,72,,27,,,26,,,,26,,53,32,26,26,22,,,27,,53,53,,,,167,,116\", \",116,26,42,21,58,,21,42,42,,26,42,,,,,,,126,,126,42,66,,66,,21,66,66\", \",9,,42,,116,9,9,,,,,,,167,,167,,,,,27,,,121,27,,121,,121,27,121,,165\", \"165,165,,,,,42,,,,,,,,53,,,,,42,21,27,167,167,,21,21,42,42,,123,,,,\", \",,,,53,,,,,,,,,,,42,,42,42,,,42,,,,30,,42,9,,,30,,,,,,,123,,,123,,,\", \",,,,66,,,,,,,124,124,124,,42,,121,,121,53,121,21,121,53,,21,,53,53,\", \"9,,,,,21,,,26,,26,,,9,53,126,26,126,,,,9,9,53,26,,,,,,121,,,169,,,,\", \",,167,126,167,126,42,126,9,9,,,9,,,21,,66,,66,,66,30,42,,,,,21,42,167\", \"42,,,,,21,21,,,26,,,26,27,,27,42,,,,9,,,,,,66,,,66,21,21,26,,21,,,,\", \"26,21,,,,54,,,,126,54,126,,126,,66,,,,124,124,124,124,,124,,123,126\", \",123,,123,,123,21,66,167,,54,54,54,9,,,27,,,27,,,26,,,126,,26,26,,9\", \"165,165,,165,165,9,165,,27,26,,,,,54,54,54,54,,66,26,,,66,66,,,,53,\", \"53,124,124,124,124,21,53,,,,,,,,53,,,,,,,27,21,,124,,,54,21,66,21,,66\", \",,27,54,54,,,27,27,,26,123,,123,26,123,,123,169,66,,169,,169,26,169\", \",,,,,,,,,53,66,,53,,,,,,,,,,,,,,,,,123,,,53,,,,,,,,26,165,165,165,165\", \",26,,,,,,,,,,,,27,26,,,27,54,66,,,26,26,,,,27,,,,,,,,,,,,,,,,54,53,\", \",26,26,53,53,26,,165,169,,169,26,169,,169,,53,,,,,,,,,,,53,,27,,,,,\", \",26,,,,,,27,,26,,,,26,,27,27,169,,,,,,54,,,66,54,,,,54,54,,,,,,,,27\", \"27,,66,27,53,,,54,53,27,,,,,,,54,,53,,,,,,,,,,26,,,,,,,,,,,,,,27,,,26\", \"27,,,,,26,,26,,,,,,,53,,,,,,53,,,,,,,,,,,,,53,,,,,,,,53,53,,,,,,,,,\", \",,,,27,,,,,,,,,,53,53,,,53,,,27,,,53,,,27,,27,,,,,,,,,,,,,,,,,,,,53\", \",,,,,,,53,,,,53,,,,,,,,,,,,,,,,,,,,,,,,,,,,,54,,54,,,,,,54,,,,,,,,54\", \",,,,,,,,,,53,,,,,,,,,,,,,,,,,53,,,,,,53,,53,,,,,,,,,,,,,,,,,,54,,,54\", \",,,,,,,,,,,,,,,,,,,54,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\", \",,,,,,,,,,54,,,,,54,54,,,,,,,,,,,,54,,,,,,,33,,,,54,,,,,33,33,33,,,\", \",,,,,,,33,33,33,,,,,,,,,,,,,,,33,33,,,,,,,,,,,,,,,,,54,,,,54,,,,,,,\", \",,54,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,54,,,,,,54,,,,,,,,,,,\", \",54,,,,,,,,54,54,,,,,,,,,,,,,,,,,,,,,,,,54,54,,,54,,,,,,54,,,,,,,,,\", \",,33,33,33,,,,,33,33,,,,,54,,,,,,,,54,,33,,54,33,33,33,33,33,33,33,33\", \"33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,,,,,,,33,33,,\", \",,,,,33,,,,,,,33,,33,,,33,33,54,,,,,,,,,,,,,,,,,54,,,,,,54,,54,,,,,\", \",,,,,,33,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\", \",,,,,,,,,,,,,,,,,,,,,33,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,33,,33\", \"33,33,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,33,,33,,33,,,,,,,,,,,,\", \",,,33,,,,,,,,,33,33,,,,,,,,,,33,,,33,,,,,,,,,,,,,,,,,,,,,,,,,33,,,,\", \",,,,,,,,,,,,,,,33,33,,,,,,,,,,33,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,33,33\", \",,33,33,33,33,,,,33,33,,,33,33,,,,,,,,,,,,,,,,,,,,,,,,33,,,33,,,,,,\", \",,,,,,,,,,,,,33,,,,,,,,,,,,,,,,,33,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\", \",,,,,,,,,,,,,,,,,,,,33,,33,,,,,,,,,,,,,,33,33,33,33,,33,,,,,,,,,,,,\", \",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,33,,,,,,,,,,,\", \",,,,,33,33,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\", \",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,33\"];\n      racc_goto_check = (arr = Opal.const_get_qualified('::', 'Array').$new(2923, nil));\n      idx = 0;\n      $send(clist, 'each', [], (TMP_Ruby23_9 = function(str){var self = TMP_Ruby23_9.$$s || this, TMP_10;\nif (str == null) str = nil;\n      return $send(str.$split(\",\", -1), 'each', [], (TMP_10 = function(i){var self = TMP_10.$$s || this, $writer = nil;\nif (i == null) i = nil;\n        \n          if ($truthy(i['$empty?']())) {\n            } else {\n            \n            $writer = [idx, i.$to_i()];\n            $send(arr, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };\n          return (idx = $rb_plus(idx, 1));}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10))}, TMP_Ruby23_9.$$s = self, TMP_Ruby23_9.$$arity = 1, TMP_Ruby23_9));\n      racc_goto_pointer = [nil, 117, 19, nil, 89, 90, 62, 27, -166, 382, -503, -575, -658, nil, -352, 9, 140, -16, -190, 84, 42, 435, 4, -196, -282, 7, 684, 758, -137, -54, 398, 32, -19, 1940, -28, nil, nil, 25, -154, 33, -201, -356, 277, -324, nil, 83, 71, 72, -123, nil, 19, 59, -259, 871, 1287, -267, 66, -66, 20, nil, nil, 32, 46, -244, 38, -24, 741, 99, -37, -23, -247, 51, -12, -317, -229, -424, nil, nil, nil, nil, nil, nil, nil, nil, nil, 90, 102, -49, nil, 101, -298, -680, -475, -322, 96, -196, 74, -516, 95, 110, 110, -356, 112, 106, -541, 107, -541, -405, -735, -408, -550, -182, -188, -400, -658, -731, 43, -435, -690, -450, nil, 192, -453, 447, 376, -449, 323, -530, -516, nil, -538, -670, -739, -738, -135, -483, 143, -329, -263, -6, -52, nil, -61, -61, -697, -466, -590, nil, nil, 147, 30, 50, 142, 143, -240, -193, 143, 144, 145, -364, -363, -348, -212, nil, nil, 521, -451, 350, -604, 561, -445, -608, nil, -607, -735, nil, nil, -438];\n      racc_goto_default = [nil, nil, nil, 3, nil, 4, 346, 293, nil, 523, nil, 835, nil, 290, 291, nil, nil, nil, 11, 12, 18, 228, 321, nil, nil, 586, 226, 227, nil, nil, 17, nil, 441, 21, 22, 23, 24, nil, 675, nil, nil, nil, 310, nil, 25, 412, 32, nil, nil, 34, 37, 36, nil, 223, 224, 358, nil, 129, 420, 128, 131, 75, 76, nil, 90, 46, 282, nil, 804, 413, nil, 414, 425, 629, 487, 280, 266, 47, 48, 49, 50, 51, 52, 53, 54, 55, nil, 267, 61, nil, nil, nil, nil, nil, nil, nil, 569, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 702, 551, nil, 703, 924, 775, 539, nil, 540, nil, nil, 541, nil, 543, 645, nil, nil, nil, 549, nil, nil, nil, nil, nil, nil, nil, 424, nil, nil, nil, nil, nil, 74, 77, 78, nil, nil, nil, nil, nil, 596, nil, nil, nil, nil, nil, nil, 819, 736, 538, nil, 542, 827, 554, 556, 557, 787, 560, 561, 788, 564, 567, 285];\n      racc_reduce_table = [0, 0, \"racc_error\", 1, 146, \"_reduce_none\", 2, 147, \"_reduce_2\", 0, 148, \"_reduce_3\", 1, 148, \"_reduce_4\", 3, 148, \"_reduce_5\", 2, 148, \"_reduce_6\", 1, 150, \"_reduce_none\", 4, 150, \"_reduce_8\", 4, 153, \"_reduce_9\", 2, 154, \"_reduce_10\", 0, 158, \"_reduce_11\", 1, 158, \"_reduce_12\", 3, 158, \"_reduce_13\", 2, 158, \"_reduce_14\", 1, 159, \"_reduce_none\", 4, 159, \"_reduce_16\", 0, 176, \"_reduce_17\", 4, 152, \"_reduce_18\", 3, 152, \"_reduce_19\", 3, 152, \"_reduce_20\", 3, 152, \"_reduce_21\", 2, 152, \"_reduce_22\", 3, 152, \"_reduce_23\", 3, 152, \"_reduce_24\", 3, 152, \"_reduce_25\", 3, 152, \"_reduce_26\", 3, 152, \"_reduce_27\", 4, 152, \"_reduce_28\", 1, 152, \"_reduce_none\", 3, 152, \"_reduce_30\", 3, 152, \"_reduce_31\", 6, 152, \"_reduce_32\", 5, 152, \"_reduce_33\", 5, 152, \"_reduce_34\", 5, 152, \"_reduce_35\", 5, 152, \"_reduce_36\", 3, 152, \"_reduce_37\", 3, 152, \"_reduce_38\", 3, 152, \"_reduce_39\", 1, 152, \"_reduce_none\", 3, 163, \"_reduce_41\", 3, 163, \"_reduce_42\", 1, 175, \"_reduce_none\", 3, 175, \"_reduce_44\", 3, 175, \"_reduce_45\", 3, 175, \"_reduce_46\", 2, 175, \"_reduce_47\", 1, 175, \"_reduce_none\", 1, 162, \"_reduce_none\", 1, 165, \"_reduce_none\", 1, 165, \"_reduce_none\", 1, 180, \"_reduce_none\", 4, 180, \"_reduce_53\", 0, 188, \"_reduce_54\", 5, 185, \"_reduce_55\", 1, 187, \"_reduce_none\", 2, 179, \"_reduce_57\", 3, 179, \"_reduce_58\", 4, 179, \"_reduce_59\", 5, 179, \"_reduce_60\", 4, 179, \"_reduce_61\", 5, 179, \"_reduce_62\", 2, 179, \"_reduce_63\", 2, 179, \"_reduce_64\", 2, 179, \"_reduce_65\", 2, 179, \"_reduce_66\", 2, 179, \"_reduce_67\", 1, 164, \"_reduce_68\", 3, 164, \"_reduce_69\", 1, 192, \"_reduce_70\", 3, 192, \"_reduce_71\", 1, 191, \"_reduce_none\", 2, 191, \"_reduce_73\", 3, 191, \"_reduce_74\", 5, 191, \"_reduce_75\", 2, 191, \"_reduce_76\", 4, 191, \"_reduce_77\", 2, 191, \"_reduce_78\", 4, 191, \"_reduce_79\", 1, 191, \"_reduce_80\", 3, 191, \"_reduce_81\", 1, 195, \"_reduce_none\", 3, 195, \"_reduce_83\", 2, 194, \"_reduce_84\", 3, 194, \"_reduce_85\", 1, 197, \"_reduce_86\", 3, 197, \"_reduce_87\", 1, 196, \"_reduce_88\", 1, 196, \"_reduce_89\", 4, 196, \"_reduce_90\", 3, 196, \"_reduce_91\", 3, 196, \"_reduce_92\", 3, 196, \"_reduce_93\", 3, 196, \"_reduce_94\", 2, 196, \"_reduce_95\", 1, 196, \"_reduce_96\", 1, 172, \"_reduce_97\", 1, 172, \"_reduce_98\", 4, 172, \"_reduce_99\", 3, 172, \"_reduce_100\", 3, 172, \"_reduce_101\", 3, 172, \"_reduce_102\", 3, 172, \"_reduce_103\", 2, 172, \"_reduce_104\", 1, 172, \"_reduce_105\", 1, 200, \"_reduce_106\", 1, 200, \"_reduce_none\", 2, 201, \"_reduce_108\", 1, 201, \"_reduce_109\", 3, 201, \"_reduce_110\", 1, 202, \"_reduce_none\", 1, 202, \"_reduce_none\", 1, 202, \"_reduce_none\", 1, 202, \"_reduce_none\", 1, 202, \"_reduce_none\", 1, 205, \"_reduce_116\", 1, 205, \"_reduce_none\", 1, 160, \"_reduce_none\", 1, 160, \"_reduce_none\", 1, 161, \"_reduce_120\", 0, 208, \"_reduce_121\", 4, 161, \"_reduce_122\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 203, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 1, 204, \"_reduce_none\", 3, 178, \"_reduce_194\", 5, 178, \"_reduce_195\", 3, 178, \"_reduce_196\", 5, 178, \"_reduce_197\", 6, 178, \"_reduce_198\", 5, 178, \"_reduce_199\", 5, 178, \"_reduce_200\", 5, 178, \"_reduce_201\", 5, 178, \"_reduce_202\", 4, 178, \"_reduce_203\", 3, 178, \"_reduce_204\", 3, 178, \"_reduce_205\", 3, 178, \"_reduce_206\", 3, 178, \"_reduce_207\", 3, 178, \"_reduce_208\", 3, 178, \"_reduce_209\", 3, 178, \"_reduce_210\", 3, 178, \"_reduce_211\", 3, 178, \"_reduce_212\", 4, 178, \"_reduce_213\", 2, 178, \"_reduce_214\", 2, 178, \"_reduce_215\", 3, 178, \"_reduce_216\", 3, 178, \"_reduce_217\", 3, 178, \"_reduce_218\", 3, 178, \"_reduce_219\", 3, 178, \"_reduce_220\", 3, 178, \"_reduce_221\", 3, 178, \"_reduce_222\", 3, 178, \"_reduce_223\", 3, 178, \"_reduce_224\", 3, 178, \"_reduce_225\", 3, 178, \"_reduce_226\", 3, 178, \"_reduce_227\", 3, 178, \"_reduce_228\", 2, 178, \"_reduce_229\", 2, 178, \"_reduce_230\", 3, 178, \"_reduce_231\", 3, 178, \"_reduce_232\", 3, 178, \"_reduce_233\", 3, 178, \"_reduce_234\", 3, 178, \"_reduce_235\", 6, 178, \"_reduce_236\", 1, 178, \"_reduce_none\", 1, 211, \"_reduce_none\", 1, 212, \"_reduce_none\", 2, 212, \"_reduce_none\", 4, 212, \"_reduce_241\", 2, 212, \"_reduce_242\", 3, 217, \"_reduce_243\", 0, 218, \"_reduce_244\", 1, 218, \"_reduce_none\", 0, 168, \"_reduce_246\", 1, 168, \"_reduce_none\", 2, 168, \"_reduce_none\", 4, 168, \"_reduce_249\", 2, 168, \"_reduce_250\", 1, 190, \"_reduce_251\", 2, 190, \"_reduce_252\", 2, 190, \"_reduce_253\", 4, 190, \"_reduce_254\", 1, 190, \"_reduce_255\", 0, 221, \"_reduce_256\", 2, 184, \"_reduce_257\", 2, 220, \"_reduce_258\", 2, 219, \"_reduce_259\", 0, 219, \"_reduce_260\", 1, 214, \"_reduce_261\", 2, 214, \"_reduce_262\", 3, 214, \"_reduce_263\", 4, 214, \"_reduce_264\", 1, 174, \"_reduce_265\", 1, 174, \"_reduce_none\", 3, 173, \"_reduce_267\", 4, 173, \"_reduce_268\", 2, 173, \"_reduce_269\", 1, 210, \"_reduce_none\", 1, 210, \"_reduce_none\", 1, 210, \"_reduce_none\", 1, 210, \"_reduce_none\", 1, 210, \"_reduce_none\", 1, 210, \"_reduce_none\", 1, 210, \"_reduce_none\", 1, 210, \"_reduce_none\", 1, 210, \"_reduce_none\", 1, 210, \"_reduce_none\", 1, 210, \"_reduce_280\", 0, 244, \"_reduce_281\", 4, 210, \"_reduce_282\", 0, 245, \"_reduce_283\", 0, 246, \"_reduce_284\", 6, 210, \"_reduce_285\", 0, 247, \"_reduce_286\", 4, 210, \"_reduce_287\", 3, 210, \"_reduce_288\", 3, 210, \"_reduce_289\", 2, 210, \"_reduce_290\", 3, 210, \"_reduce_291\", 3, 210, \"_reduce_292\", 1, 210, \"_reduce_293\", 4, 210, \"_reduce_294\", 3, 210, \"_reduce_295\", 1, 210, \"_reduce_296\", 5, 210, \"_reduce_297\", 4, 210, \"_reduce_298\", 3, 210, \"_reduce_299\", 2, 210, \"_reduce_300\", 1, 210, \"_reduce_none\", 2, 210, \"_reduce_302\", 2, 210, \"_reduce_303\", 6, 210, \"_reduce_304\", 6, 210, \"_reduce_305\", 0, 248, \"_reduce_306\", 0, 249, \"_reduce_307\", 7, 210, \"_reduce_308\", 0, 250, \"_reduce_309\", 0, 251, \"_reduce_310\", 7, 210, \"_reduce_311\", 5, 210, \"_reduce_312\", 4, 210, \"_reduce_313\", 0, 252, \"_reduce_314\", 0, 253, \"_reduce_315\", 9, 210, \"_reduce_316\", 0, 254, \"_reduce_317\", 6, 210, \"_reduce_318\", 0, 255, \"_reduce_319\", 7, 210, \"_reduce_320\", 0, 256, \"_reduce_321\", 5, 210, \"_reduce_322\", 0, 257, \"_reduce_323\", 6, 210, \"_reduce_324\", 0, 258, \"_reduce_325\", 0, 259, \"_reduce_326\", 9, 210, \"_reduce_327\", 1, 210, \"_reduce_328\", 1, 210, \"_reduce_329\", 1, 210, \"_reduce_330\", 1, 210, \"_reduce_331\", 1, 167, \"_reduce_none\", 1, 235, \"_reduce_none\", 1, 235, \"_reduce_none\", 2, 235, \"_reduce_335\", 1, 237, \"_reduce_none\", 1, 237, \"_reduce_none\", 1, 236, \"_reduce_none\", 5, 236, \"_reduce_339\", 1, 156, \"_reduce_none\", 2, 156, \"_reduce_341\", 1, 239, \"_reduce_none\", 1, 239, \"_reduce_none\", 1, 260, \"_reduce_344\", 3, 260, \"_reduce_345\", 1, 263, \"_reduce_346\", 3, 263, \"_reduce_347\", 1, 262, \"_reduce_none\", 4, 262, \"_reduce_349\", 6, 262, \"_reduce_350\", 3, 262, \"_reduce_351\", 5, 262, \"_reduce_352\", 2, 262, \"_reduce_353\", 4, 262, \"_reduce_354\", 1, 262, \"_reduce_355\", 3, 262, \"_reduce_356\", 4, 264, \"_reduce_357\", 2, 264, \"_reduce_358\", 2, 264, \"_reduce_359\", 1, 264, \"_reduce_360\", 2, 269, \"_reduce_361\", 0, 269, \"_reduce_362\", 6, 270, \"_reduce_363\", 8, 270, \"_reduce_364\", 4, 270, \"_reduce_365\", 6, 270, \"_reduce_366\", 4, 270, \"_reduce_367\", 2, 270, \"_reduce_none\", 6, 270, \"_reduce_369\", 2, 270, \"_reduce_370\", 4, 270, \"_reduce_371\", 6, 270, \"_reduce_372\", 2, 270, \"_reduce_373\", 4, 270, \"_reduce_374\", 2, 270, \"_reduce_375\", 4, 270, \"_reduce_376\", 1, 270, \"_reduce_none\", 0, 186, \"_reduce_378\", 1, 186, \"_reduce_379\", 3, 274, \"_reduce_380\", 1, 274, \"_reduce_381\", 4, 274, \"_reduce_382\", 1, 275, \"_reduce_383\", 4, 275, \"_reduce_384\", 1, 276, \"_reduce_385\", 3, 276, \"_reduce_386\", 1, 277, \"_reduce_387\", 1, 277, \"_reduce_none\", 0, 281, \"_reduce_389\", 0, 282, \"_reduce_390\", 4, 234, \"_reduce_391\", 4, 279, \"_reduce_392\", 1, 279, \"_reduce_393\", 3, 280, \"_reduce_394\", 3, 280, \"_reduce_395\", 0, 285, \"_reduce_396\", 5, 284, \"_reduce_397\", 2, 181, \"_reduce_398\", 4, 181, \"_reduce_399\", 5, 181, \"_reduce_400\", 5, 181, \"_reduce_401\", 2, 233, \"_reduce_402\", 4, 233, \"_reduce_403\", 4, 233, \"_reduce_404\", 3, 233, \"_reduce_405\", 3, 233, \"_reduce_406\", 3, 233, \"_reduce_407\", 2, 233, \"_reduce_408\", 1, 233, \"_reduce_409\", 4, 233, \"_reduce_410\", 0, 287, \"_reduce_411\", 5, 232, \"_reduce_412\", 0, 288, \"_reduce_413\", 5, 232, \"_reduce_414\", 5, 238, \"_reduce_415\", 1, 289, \"_reduce_416\", 1, 289, \"_reduce_none\", 6, 155, \"_reduce_418\", 0, 155, \"_reduce_419\", 1, 290, \"_reduce_420\", 1, 290, \"_reduce_none\", 1, 290, \"_reduce_none\", 2, 291, \"_reduce_423\", 1, 291, \"_reduce_none\", 2, 157, \"_reduce_425\", 1, 157, \"_reduce_none\", 1, 222, \"_reduce_none\", 1, 222, \"_reduce_none\", 1, 222, \"_reduce_none\", 1, 223, \"_reduce_430\", 1, 293, \"_reduce_431\", 2, 293, \"_reduce_432\", 3, 294, \"_reduce_433\", 1, 294, \"_reduce_434\", 1, 294, \"_reduce_435\", 3, 224, \"_reduce_436\", 4, 225, \"_reduce_437\", 3, 226, \"_reduce_438\", 0, 298, \"_reduce_439\", 3, 298, \"_reduce_440\", 1, 299, \"_reduce_441\", 2, 299, \"_reduce_442\", 3, 228, \"_reduce_443\", 0, 301, \"_reduce_444\", 3, 301, \"_reduce_445\", 3, 227, \"_reduce_446\", 3, 229, \"_reduce_447\", 0, 302, \"_reduce_448\", 3, 302, \"_reduce_449\", 0, 303, \"_reduce_450\", 3, 303, \"_reduce_451\", 0, 295, \"_reduce_452\", 2, 295, \"_reduce_453\", 0, 296, \"_reduce_454\", 2, 296, \"_reduce_455\", 0, 297, \"_reduce_456\", 2, 297, \"_reduce_457\", 1, 300, \"_reduce_458\", 2, 300, \"_reduce_459\", 0, 305, \"_reduce_460\", 4, 300, \"_reduce_461\", 1, 304, \"_reduce_462\", 1, 304, \"_reduce_463\", 1, 304, \"_reduce_464\", 1, 304, \"_reduce_none\", 1, 206, \"_reduce_466\", 3, 207, \"_reduce_467\", 1, 292, \"_reduce_468\", 2, 292, \"_reduce_469\", 1, 209, \"_reduce_470\", 1, 209, \"_reduce_471\", 1, 209, \"_reduce_472\", 1, 209, \"_reduce_473\", 1, 198, \"_reduce_474\", 1, 198, \"_reduce_475\", 1, 198, \"_reduce_476\", 1, 198, \"_reduce_477\", 1, 198, \"_reduce_478\", 1, 199, \"_reduce_479\", 1, 199, \"_reduce_480\", 1, 199, \"_reduce_481\", 1, 199, \"_reduce_482\", 1, 199, \"_reduce_483\", 1, 199, \"_reduce_484\", 1, 199, \"_reduce_485\", 1, 230, \"_reduce_486\", 1, 230, \"_reduce_487\", 1, 166, \"_reduce_488\", 1, 166, \"_reduce_489\", 1, 171, \"_reduce_490\", 1, 171, \"_reduce_491\", 0, 306, \"_reduce_492\", 4, 240, \"_reduce_493\", 0, 240, \"_reduce_494\", 3, 242, \"_reduce_495\", 0, 308, \"_reduce_496\", 3, 242, \"_reduce_497\", 4, 307, \"_reduce_498\", 2, 307, \"_reduce_499\", 2, 307, \"_reduce_500\", 1, 307, \"_reduce_501\", 2, 310, \"_reduce_502\", 0, 310, \"_reduce_503\", 6, 283, \"_reduce_504\", 8, 283, \"_reduce_505\", 4, 283, \"_reduce_506\", 6, 283, \"_reduce_507\", 4, 283, \"_reduce_508\", 6, 283, \"_reduce_509\", 2, 283, \"_reduce_510\", 4, 283, \"_reduce_511\", 6, 283, \"_reduce_512\", 2, 283, \"_reduce_513\", 4, 283, \"_reduce_514\", 2, 283, \"_reduce_515\", 4, 283, \"_reduce_516\", 1, 283, \"_reduce_517\", 0, 283, \"_reduce_518\", 1, 278, \"_reduce_519\", 1, 278, \"_reduce_520\", 1, 278, \"_reduce_521\", 1, 278, \"_reduce_522\", 1, 261, \"_reduce_none\", 1, 261, \"_reduce_524\", 1, 312, \"_reduce_525\", 1, 313, \"_reduce_526\", 3, 313, \"_reduce_527\", 1, 271, \"_reduce_528\", 3, 271, \"_reduce_529\", 1, 314, \"_reduce_530\", 2, 315, \"_reduce_531\", 1, 315, \"_reduce_532\", 2, 316, \"_reduce_533\", 1, 316, \"_reduce_534\", 1, 265, \"_reduce_535\", 3, 265, \"_reduce_536\", 1, 309, \"_reduce_537\", 3, 309, \"_reduce_538\", 1, 317, \"_reduce_none\", 1, 317, \"_reduce_none\", 2, 266, \"_reduce_541\", 1, 266, \"_reduce_542\", 3, 318, \"_reduce_543\", 3, 319, \"_reduce_544\", 1, 272, \"_reduce_545\", 3, 272, \"_reduce_546\", 1, 311, \"_reduce_547\", 3, 311, \"_reduce_548\", 1, 320, \"_reduce_none\", 1, 320, \"_reduce_none\", 2, 273, \"_reduce_551\", 1, 273, \"_reduce_552\", 1, 321, \"_reduce_none\", 1, 321, \"_reduce_none\", 2, 268, \"_reduce_555\", 2, 267, \"_reduce_556\", 0, 267, \"_reduce_557\", 1, 243, \"_reduce_none\", 3, 243, \"_reduce_559\", 0, 231, \"_reduce_560\", 2, 231, \"_reduce_none\", 1, 216, \"_reduce_562\", 3, 216, \"_reduce_563\", 3, 322, \"_reduce_564\", 2, 322, \"_reduce_565\", 4, 322, \"_reduce_566\", 2, 322, \"_reduce_567\", 1, 189, \"_reduce_none\", 1, 189, \"_reduce_none\", 1, 189, \"_reduce_none\", 1, 183, \"_reduce_none\", 1, 183, \"_reduce_none\", 1, 183, \"_reduce_none\", 1, 183, \"_reduce_none\", 1, 286, \"_reduce_none\", 1, 286, \"_reduce_none\", 1, 286, \"_reduce_none\", 1, 182, \"_reduce_none\", 1, 182, \"_reduce_none\", 1, 170, \"_reduce_580\", 1, 170, \"_reduce_581\", 0, 149, \"_reduce_none\", 1, 149, \"_reduce_none\", 0, 177, \"_reduce_none\", 1, 177, \"_reduce_none\", 2, 193, \"_reduce_586\", 2, 169, \"_reduce_587\", 0, 215, \"_reduce_none\", 1, 215, \"_reduce_none\", 1, 215, \"_reduce_none\", 1, 241, \"_reduce_591\", 1, 241, \"_reduce_none\", 1, 151, \"_reduce_none\", 2, 151, \"_reduce_none\", 0, 213, \"_reduce_595\"];\n      racc_reduce_n = 596;\n      racc_shift_n = 1021;\n      racc_token_table = $hash(false, 0, \"error\", 1, \"kCLASS\", 2, \"kMODULE\", 3, \"kDEF\", 4, \"kUNDEF\", 5, \"kBEGIN\", 6, \"kRESCUE\", 7, \"kENSURE\", 8, \"kEND\", 9, \"kIF\", 10, \"kUNLESS\", 11, \"kTHEN\", 12, \"kELSIF\", 13, \"kELSE\", 14, \"kCASE\", 15, \"kWHEN\", 16, \"kWHILE\", 17, \"kUNTIL\", 18, \"kFOR\", 19, \"kBREAK\", 20, \"kNEXT\", 21, \"kREDO\", 22, \"kRETRY\", 23, \"kIN\", 24, \"kDO\", 25, \"kDO_COND\", 26, \"kDO_BLOCK\", 27, \"kDO_LAMBDA\", 28, \"kRETURN\", 29, \"kYIELD\", 30, \"kSUPER\", 31, \"kSELF\", 32, \"kNIL\", 33, \"kTRUE\", 34, \"kFALSE\", 35, \"kAND\", 36, \"kOR\", 37, \"kNOT\", 38, \"kIF_MOD\", 39, \"kUNLESS_MOD\", 40, \"kWHILE_MOD\", 41, \"kUNTIL_MOD\", 42, \"kRESCUE_MOD\", 43, \"kALIAS\", 44, \"kDEFINED\", 45, \"klBEGIN\", 46, \"klEND\", 47, \"k__LINE__\", 48, \"k__FILE__\", 49, \"k__ENCODING__\", 50, \"tIDENTIFIER\", 51, \"tFID\", 52, \"tGVAR\", 53, \"tIVAR\", 54, \"tCONSTANT\", 55, \"tLABEL\", 56, \"tCVAR\", 57, \"tNTH_REF\", 58, \"tBACK_REF\", 59, \"tSTRING_CONTENT\", 60, \"tINTEGER\", 61, \"tFLOAT\", 62, \"tUPLUS\", 63, \"tUMINUS\", 64, \"tUMINUS_NUM\", 65, \"tPOW\", 66, \"tCMP\", 67, \"tEQ\", 68, \"tEQQ\", 69, \"tNEQ\", 70, \"tGEQ\", 71, \"tLEQ\", 72, \"tANDOP\", 73, \"tOROP\", 74, \"tMATCH\", 75, \"tNMATCH\", 76, \"tDOT\", 77, \"tDOT2\", 78, \"tDOT3\", 79, \"tAREF\", 80, \"tASET\", 81, \"tLSHFT\", 82, \"tRSHFT\", 83, \"tCOLON2\", 84, \"tCOLON3\", 85, \"tOP_ASGN\", 86, \"tASSOC\", 87, \"tLPAREN\", 88, \"tLPAREN2\", 89, \"tRPAREN\", 90, \"tLPAREN_ARG\", 91, \"tLBRACK\", 92, \"tLBRACK2\", 93, \"tRBRACK\", 94, \"tLBRACE\", 95, \"tLBRACE_ARG\", 96, \"tSTAR\", 97, \"tSTAR2\", 98, \"tAMPER\", 99, \"tAMPER2\", 100, \"tTILDE\", 101, \"tPERCENT\", 102, \"tDIVIDE\", 103, \"tDSTAR\", 104, \"tPLUS\", 105, \"tMINUS\", 106, \"tLT\", 107, \"tGT\", 108, \"tPIPE\", 109, \"tBANG\", 110, \"tCARET\", 111, \"tLCURLY\", 112, \"tRCURLY\", 113, \"tBACK_REF2\", 114, \"tSYMBEG\", 115, \"tSTRING_BEG\", 116, \"tXSTRING_BEG\", 117, \"tREGEXP_BEG\", 118, \"tREGEXP_OPT\", 119, \"tWORDS_BEG\", 120, \"tQWORDS_BEG\", 121, \"tSYMBOLS_BEG\", 122, \"tQSYMBOLS_BEG\", 123, \"tSTRING_DBEG\", 124, \"tSTRING_DVAR\", 125, \"tSTRING_END\", 126, \"tSTRING_DEND\", 127, \"tSTRING\", 128, \"tSYMBOL\", 129, \"tNL\", 130, \"tEH\", 131, \"tCOLON\", 132, \"tCOMMA\", 133, \"tSPACE\", 134, \"tSEMI\", 135, \"tLAMBDA\", 136, \"tLAMBEG\", 137, \"tCHARACTER\", 138, \"tRATIONAL\", 139, \"tIMAGINARY\", 140, \"tLABEL_END\", 141, \"tANDDOT\", 142, \"tEQL\", 143, \"tLOWEST\", 144);\n      racc_nt_base = 145;\n      racc_use_result_var = true;\n      Opal.const_set($nesting[0], 'Racc_arg', [racc_action_table, racc_action_check, racc_action_default, racc_action_pointer, racc_goto_table, racc_goto_check, racc_goto_default, racc_goto_pointer, racc_nt_base, racc_reduce_table, racc_token_table, racc_shift_n, racc_reduce_n, racc_use_result_var]);\n      Opal.const_set($nesting[0], 'Racc_token_to_s_table', [\"$end\", \"error\", \"kCLASS\", \"kMODULE\", \"kDEF\", \"kUNDEF\", \"kBEGIN\", \"kRESCUE\", \"kENSURE\", \"kEND\", \"kIF\", \"kUNLESS\", \"kTHEN\", \"kELSIF\", \"kELSE\", \"kCASE\", \"kWHEN\", \"kWHILE\", \"kUNTIL\", \"kFOR\", \"kBREAK\", \"kNEXT\", \"kREDO\", \"kRETRY\", \"kIN\", \"kDO\", \"kDO_COND\", \"kDO_BLOCK\", \"kDO_LAMBDA\", \"kRETURN\", \"kYIELD\", \"kSUPER\", \"kSELF\", \"kNIL\", \"kTRUE\", \"kFALSE\", \"kAND\", \"kOR\", \"kNOT\", \"kIF_MOD\", \"kUNLESS_MOD\", \"kWHILE_MOD\", \"kUNTIL_MOD\", \"kRESCUE_MOD\", \"kALIAS\", \"kDEFINED\", \"klBEGIN\", \"klEND\", \"k__LINE__\", \"k__FILE__\", \"k__ENCODING__\", \"tIDENTIFIER\", \"tFID\", \"tGVAR\", \"tIVAR\", \"tCONSTANT\", \"tLABEL\", \"tCVAR\", \"tNTH_REF\", \"tBACK_REF\", \"tSTRING_CONTENT\", \"tINTEGER\", \"tFLOAT\", \"tUPLUS\", \"tUMINUS\", \"tUMINUS_NUM\", \"tPOW\", \"tCMP\", \"tEQ\", \"tEQQ\", \"tNEQ\", \"tGEQ\", \"tLEQ\", \"tANDOP\", \"tOROP\", \"tMATCH\", \"tNMATCH\", \"tDOT\", \"tDOT2\", \"tDOT3\", \"tAREF\", \"tASET\", \"tLSHFT\", \"tRSHFT\", \"tCOLON2\", \"tCOLON3\", \"tOP_ASGN\", \"tASSOC\", \"tLPAREN\", \"tLPAREN2\", \"tRPAREN\", \"tLPAREN_ARG\", \"tLBRACK\", \"tLBRACK2\", \"tRBRACK\", \"tLBRACE\", \"tLBRACE_ARG\", \"tSTAR\", \"tSTAR2\", \"tAMPER\", \"tAMPER2\", \"tTILDE\", \"tPERCENT\", \"tDIVIDE\", \"tDSTAR\", \"tPLUS\", \"tMINUS\", \"tLT\", \"tGT\", \"tPIPE\", \"tBANG\", \"tCARET\", \"tLCURLY\", \"tRCURLY\", \"tBACK_REF2\", \"tSYMBEG\", \"tSTRING_BEG\", \"tXSTRING_BEG\", \"tREGEXP_BEG\", \"tREGEXP_OPT\", \"tWORDS_BEG\", \"tQWORDS_BEG\", \"tSYMBOLS_BEG\", \"tQSYMBOLS_BEG\", \"tSTRING_DBEG\", \"tSTRING_DVAR\", \"tSTRING_END\", \"tSTRING_DEND\", \"tSTRING\", \"tSYMBOL\", \"tNL\", \"tEH\", \"tCOLON\", \"tCOMMA\", \"tSPACE\", \"tSEMI\", \"tLAMBDA\", \"tLAMBEG\", \"tCHARACTER\", \"tRATIONAL\", \"tIMAGINARY\", \"tLABEL_END\", \"tANDDOT\", \"tEQL\", \"tLOWEST\", \"$start\", \"program\", \"top_compstmt\", \"top_stmts\", \"opt_terms\", \"top_stmt\", \"terms\", \"stmt\", \"bodystmt\", \"compstmt\", \"opt_rescue\", \"opt_else\", \"opt_ensure\", \"stmts\", \"stmt_or_begin\", \"fitem\", \"undef_list\", \"expr_value\", \"command_asgn\", \"mlhs\", \"command_call\", \"var_lhs\", \"primary_value\", \"opt_call_args\", \"rbracket\", \"call_op\", \"backref\", \"lhs\", \"mrhs\", \"mrhs_arg\", \"expr\", \"@1\", \"opt_nl\", \"arg\", \"command\", \"block_command\", \"block_call\", \"dot_or_colon\", \"operation2\", \"command_args\", \"cmd_brace_block\", \"opt_block_param\", \"fcall\", \"@2\", \"operation\", \"call_args\", \"mlhs_basic\", \"mlhs_inner\", \"rparen\", \"mlhs_head\", \"mlhs_item\", \"mlhs_node\", \"mlhs_post\", \"user_variable\", \"keyword_variable\", \"cname\", \"cpath\", \"fname\", \"op\", \"reswords\", \"fsym\", \"symbol\", \"dsym\", \"@3\", \"simple_numeric\", \"primary\", \"arg_value\", \"aref_args\", \"none\", \"args\", \"trailer\", \"assocs\", \"paren_args\", \"opt_paren_args\", \"opt_block_arg\", \"block_arg\", \"@4\", \"literal\", \"strings\", \"xstring\", \"regexp\", \"words\", \"qwords\", \"symbols\", \"qsymbols\", \"var_ref\", \"assoc_list\", \"brace_block\", \"method_call\", \"lambda\", \"then\", \"if_tail\", \"do\", \"case_body\", \"for_var\", \"superclass\", \"term\", \"f_arglist\", \"singleton\", \"@5\", \"@6\", \"@7\", \"@8\", \"@9\", \"@10\", \"@11\", \"@12\", \"@13\", \"@14\", \"@15\", \"@16\", \"@17\", \"@18\", \"@19\", \"@20\", \"f_marg\", \"f_norm_arg\", \"f_margs\", \"f_marg_list\", \"block_args_tail\", \"f_block_kwarg\", \"f_kwrest\", \"opt_f_block_arg\", \"f_block_arg\", \"opt_block_args_tail\", \"block_param\", \"f_arg\", \"f_block_optarg\", \"f_rest_arg\", \"block_param_def\", \"opt_bv_decl\", \"bv_decls\", \"bvar\", \"f_bad_arg\", \"f_larglist\", \"lambda_body\", \"@21\", \"@22\", \"f_args\", \"do_block\", \"@23\", \"operation3\", \"@24\", \"@25\", \"cases\", \"exc_list\", \"exc_var\", \"numeric\", \"string\", \"string1\", \"string_contents\", \"xstring_contents\", \"regexp_contents\", \"word_list\", \"word\", \"string_content\", \"symbol_list\", \"qword_list\", \"qsym_list\", \"string_dvar\", \"@26\", \"@27\", \"args_tail\", \"@28\", \"f_kwarg\", \"opt_args_tail\", \"f_optarg\", \"f_arg_asgn\", \"f_arg_item\", \"f_label\", \"f_kw\", \"f_block_kw\", \"kwrest_mark\", \"f_opt\", \"f_block_opt\", \"restarg_mark\", \"blkarg_mark\", \"assoc\"]);\n      Opal.const_set($nesting[0], 'Racc_debug_parser', false);\n      \n      Opal.defn(self, '$_reduce_2', TMP_Ruby23__reduce_2_11 = function $$_reduce_2(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$compstmt(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_2_11.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_3', TMP_Ruby23__reduce_3_12 = function $$_reduce_3(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_3_12.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_4', TMP_Ruby23__reduce_4_13 = function $$_reduce_4(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_4_13.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_5', TMP_Ruby23__reduce_5_14 = function $$_reduce_5(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_5_14.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_6', TMP_Ruby23__reduce_6_15 = function $$_reduce_6(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](1)];\n        return result;\n      }, TMP_Ruby23__reduce_6_15.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_8', TMP_Ruby23__reduce_8_16 = function $$_reduce_8(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$preexe(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_8_16.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_9', TMP_Ruby23__reduce_9_17 = function $$_reduce_9(val, _values, result) {\n        var $a, $b, self = this, rescue_bodies = nil, else_t = nil, else_ = nil, ensure_t = nil, ensure_ = nil;\n\n        \n        rescue_bodies = val['$[]'](1);\n        $b = val['$[]'](2), $a = Opal.to_ary($b), (else_t = ($a[0] == null ? nil : $a[0])), (else_ = ($a[1] == null ? nil : $a[1])), $b;\n        $b = val['$[]'](3), $a = Opal.to_ary($b), (ensure_t = ($a[0] == null ? nil : $a[0])), (ensure_ = ($a[1] == null ? nil : $a[1])), $b;\n        if ($truthy(($truthy($a = rescue_bodies['$empty?']()) ? else_['$nil?']()['$!']() : $a))) {\n          self.$diagnostic(\"warning\", \"useless_else\", nil, else_t)};\n        result = self.builder.$begin_body(val['$[]'](0), rescue_bodies, else_t, else_, ensure_t, ensure_);\n        return result;\n      }, TMP_Ruby23__reduce_9_17.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_10', TMP_Ruby23__reduce_10_18 = function $$_reduce_10(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$compstmt(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_10_18.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_11', TMP_Ruby23__reduce_11_19 = function $$_reduce_11(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_11_19.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_12', TMP_Ruby23__reduce_12_20 = function $$_reduce_12(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_12_20.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_13', TMP_Ruby23__reduce_13_21 = function $$_reduce_13(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_13_21.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_14', TMP_Ruby23__reduce_14_22 = function $$_reduce_14(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](1)];\n        return result;\n      }, TMP_Ruby23__reduce_14_22.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_16', TMP_Ruby23__reduce_16_23 = function $$_reduce_16(val, _values, result) {\n        var self = this;\n\n        \n        self.$diagnostic(\"error\", \"begin_in_method\", nil, val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_16_23.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_17', TMP_Ruby23__reduce_17_24 = function $$_reduce_17(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [\"expr_fname\"];\n        $send(self.lexer, 'state=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return result;\n      }, TMP_Ruby23__reduce_17_24.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_18', TMP_Ruby23__reduce_18_25 = function $$_reduce_18(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$alias(val['$[]'](0), val['$[]'](1), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_18_25.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_19', TMP_Ruby23__reduce_19_26 = function $$_reduce_19(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$alias(val['$[]'](0), self.builder.$gvar(val['$[]'](1)), self.builder.$gvar(val['$[]'](2)));\n        return result;\n      }, TMP_Ruby23__reduce_19_26.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_20', TMP_Ruby23__reduce_20_27 = function $$_reduce_20(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$alias(val['$[]'](0), self.builder.$gvar(val['$[]'](1)), self.builder.$back_ref(val['$[]'](2)));\n        return result;\n      }, TMP_Ruby23__reduce_20_27.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_21', TMP_Ruby23__reduce_21_28 = function $$_reduce_21(val, _values, result) {\n        var self = this;\n\n        \n        self.$diagnostic(\"error\", \"nth_ref_alias\", nil, val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_21_28.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_22', TMP_Ruby23__reduce_22_29 = function $$_reduce_22(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$undef_method(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_22_29.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_23', TMP_Ruby23__reduce_23_30 = function $$_reduce_23(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$condition_mod(val['$[]'](0), nil, val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_23_30.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_24', TMP_Ruby23__reduce_24_31 = function $$_reduce_24(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$condition_mod(nil, val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_24_31.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_25', TMP_Ruby23__reduce_25_32 = function $$_reduce_25(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$loop_mod(\"while\", val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_25_32.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_26', TMP_Ruby23__reduce_26_33 = function $$_reduce_26(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$loop_mod(\"until\", val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_26_33.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_27', TMP_Ruby23__reduce_27_34 = function $$_reduce_27(val, _values, result) {\n        var self = this, rescue_body = nil;\n\n        \n        rescue_body = self.builder.$rescue_body(val['$[]'](1), nil, nil, nil, nil, val['$[]'](2));\n        result = self.builder.$begin_body(val['$[]'](0), [rescue_body]);\n        return result;\n      }, TMP_Ruby23__reduce_27_34.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_28', TMP_Ruby23__reduce_28_35 = function $$_reduce_28(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$postexe(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_28_35.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_30', TMP_Ruby23__reduce_30_36 = function $$_reduce_30(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$multi_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_30_36.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_31', TMP_Ruby23__reduce_31_37 = function $$_reduce_31(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$op_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_31_37.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_32', TMP_Ruby23__reduce_32_38 = function $$_reduce_32(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$op_assign(self.builder.$index(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3)), val['$[]'](4), val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_32_38.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_33', TMP_Ruby23__reduce_33_39 = function $$_reduce_33(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_33_39.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_34', TMP_Ruby23__reduce_34_40 = function $$_reduce_34(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_34_40.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_35', TMP_Ruby23__reduce_35_41 = function $$_reduce_35(val, _values, result) {\n        var self = this, const$ = nil;\n\n        \n        const$ = self.builder.$const_op_assignable(self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2)));\n        result = self.builder.$op_assign(const$, val['$[]'](3), val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_35_41.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_36', TMP_Ruby23__reduce_36_42 = function $$_reduce_36(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_36_42.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_37', TMP_Ruby23__reduce_37_43 = function $$_reduce_37(val, _values, result) {\n        var self = this;\n\n        \n        self.builder.$op_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_37_43.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_38', TMP_Ruby23__reduce_38_44 = function $$_reduce_38(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assign(val['$[]'](0), val['$[]'](1), self.builder.$array(nil, val['$[]'](2), nil));\n        return result;\n      }, TMP_Ruby23__reduce_38_44.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_39', TMP_Ruby23__reduce_39_45 = function $$_reduce_39(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$multi_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_39_45.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_41', TMP_Ruby23__reduce_41_46 = function $$_reduce_41(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_41_46.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_42', TMP_Ruby23__reduce_42_47 = function $$_reduce_42(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_42_47.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_44', TMP_Ruby23__reduce_44_48 = function $$_reduce_44(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$logical_op(\"and\", val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_44_48.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_45', TMP_Ruby23__reduce_45_49 = function $$_reduce_45(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$logical_op(\"or\", val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_45_49.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_46', TMP_Ruby23__reduce_46_50 = function $$_reduce_46(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$not_op(val['$[]'](0), nil, val['$[]'](2), nil);\n        return result;\n      }, TMP_Ruby23__reduce_46_50.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_47', TMP_Ruby23__reduce_47_51 = function $$_reduce_47(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$not_op(val['$[]'](0), nil, val['$[]'](1), nil);\n        return result;\n      }, TMP_Ruby23__reduce_47_51.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_53', TMP_Ruby23__reduce_53_52 = function $$_reduce_53(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);\n        return result;\n      }, TMP_Ruby23__reduce_53_52.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_54', TMP_Ruby23__reduce_54_53 = function $$_reduce_54(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$extend_dynamic();\n        return result;\n      }, TMP_Ruby23__reduce_54_53.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_55', TMP_Ruby23__reduce_55_54 = function $$_reduce_55(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0), val['$[]'](2), val['$[]'](3), val['$[]'](4)];\n        self.static_env.$unextend();\n        return result;\n      }, TMP_Ruby23__reduce_55_54.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_57', TMP_Ruby23__reduce_57_55 = function $$_reduce_57(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$call_method(nil, nil, val['$[]'](0), nil, val['$[]'](1), nil);\n        return result;\n      }, TMP_Ruby23__reduce_57_55.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_58', TMP_Ruby23__reduce_58_56 = function $$_reduce_58(val, _values, result) {\n        var $a, $b, self = this, method_call = nil, begin_t = nil, args = nil, body = nil, end_t = nil;\n\n        \n        method_call = self.builder.$call_method(nil, nil, val['$[]'](0), nil, val['$[]'](1), nil);\n        $b = val['$[]'](2), $a = Opal.to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;\n        result = self.builder.$block(method_call, begin_t, args, body, end_t);\n        return result;\n      }, TMP_Ruby23__reduce_58_56.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_59', TMP_Ruby23__reduce_59_57 = function $$_reduce_59(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);\n        return result;\n      }, TMP_Ruby23__reduce_59_57.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_60', TMP_Ruby23__reduce_60_58 = function $$_reduce_60(val, _values, result) {\n        var $a, $b, self = this, method_call = nil, begin_t = nil, args = nil, body = nil, end_t = nil;\n\n        \n        method_call = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);\n        $b = val['$[]'](4), $a = Opal.to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;\n        result = self.builder.$block(method_call, begin_t, args, body, end_t);\n        return result;\n      }, TMP_Ruby23__reduce_60_58.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_61', TMP_Ruby23__reduce_61_59 = function $$_reduce_61(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);\n        return result;\n      }, TMP_Ruby23__reduce_61_59.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_62', TMP_Ruby23__reduce_62_60 = function $$_reduce_62(val, _values, result) {\n        var $a, $b, self = this, method_call = nil, begin_t = nil, args = nil, body = nil, end_t = nil;\n\n        \n        method_call = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);\n        $b = val['$[]'](4), $a = Opal.to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;\n        result = self.builder.$block(method_call, begin_t, args, body, end_t);\n        return result;\n      }, TMP_Ruby23__reduce_62_60.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_63', TMP_Ruby23__reduce_63_61 = function $$_reduce_63(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"super\", val['$[]'](0), nil, val['$[]'](1), nil);\n        return result;\n      }, TMP_Ruby23__reduce_63_61.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_64', TMP_Ruby23__reduce_64_62 = function $$_reduce_64(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"yield\", val['$[]'](0), nil, val['$[]'](1), nil);\n        return result;\n      }, TMP_Ruby23__reduce_64_62.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_65', TMP_Ruby23__reduce_65_63 = function $$_reduce_65(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"return\", val['$[]'](0), nil, val['$[]'](1), nil);\n        return result;\n      }, TMP_Ruby23__reduce_65_63.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_66', TMP_Ruby23__reduce_66_64 = function $$_reduce_66(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"break\", val['$[]'](0), nil, val['$[]'](1), nil);\n        return result;\n      }, TMP_Ruby23__reduce_66_64.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_67', TMP_Ruby23__reduce_67_65 = function $$_reduce_67(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"next\", val['$[]'](0), nil, val['$[]'](1), nil);\n        return result;\n      }, TMP_Ruby23__reduce_67_65.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_68', TMP_Ruby23__reduce_68_66 = function $$_reduce_68(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$multi_lhs(nil, val['$[]'](0), nil);\n        return result;\n      }, TMP_Ruby23__reduce_68_66.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_69', TMP_Ruby23__reduce_69_67 = function $$_reduce_69(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$begin(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_69_67.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_70', TMP_Ruby23__reduce_70_68 = function $$_reduce_70(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$multi_lhs(nil, val['$[]'](0), nil);\n        return result;\n      }, TMP_Ruby23__reduce_70_68.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_71', TMP_Ruby23__reduce_71_69 = function $$_reduce_71(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$multi_lhs(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_71_69.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_73', TMP_Ruby23__reduce_73_70 = function $$_reduce_73(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$push(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_73_70.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_74', TMP_Ruby23__reduce_74_71 = function $$_reduce_74(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$push(self.builder.$splat(val['$[]'](1), val['$[]'](2)));\n        return result;\n      }, TMP_Ruby23__reduce_74_71.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_75', TMP_Ruby23__reduce_75_72 = function $$_reduce_75(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$push(self.builder.$splat(val['$[]'](1), val['$[]'](2))).$concat(val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_75_72.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_76', TMP_Ruby23__reduce_76_73 = function $$_reduce_76(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$push(self.builder.$splat(val['$[]'](1)));\n        return result;\n      }, TMP_Ruby23__reduce_76_73.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_77', TMP_Ruby23__reduce_77_74 = function $$_reduce_77(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$push(self.builder.$splat(val['$[]'](1))).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_77_74.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_78', TMP_Ruby23__reduce_78_75 = function $$_reduce_78(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$splat(val['$[]'](0), val['$[]'](1))];\n        return result;\n      }, TMP_Ruby23__reduce_78_75.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_79', TMP_Ruby23__reduce_79_76 = function $$_reduce_79(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$splat(val['$[]'](0), val['$[]'](1))].concat(Opal.to_a(val['$[]'](3)));\n        return result;\n      }, TMP_Ruby23__reduce_79_76.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_80', TMP_Ruby23__reduce_80_77 = function $$_reduce_80(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$splat(val['$[]'](0))];\n        return result;\n      }, TMP_Ruby23__reduce_80_77.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_81', TMP_Ruby23__reduce_81_78 = function $$_reduce_81(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$splat(val['$[]'](0))].concat(Opal.to_a(val['$[]'](2)));\n        return result;\n      }, TMP_Ruby23__reduce_81_78.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_83', TMP_Ruby23__reduce_83_79 = function $$_reduce_83(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$begin(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_83_79.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_84', TMP_Ruby23__reduce_84_80 = function $$_reduce_84(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_84_80.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_85', TMP_Ruby23__reduce_85_81 = function $$_reduce_85(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_85_81.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_86', TMP_Ruby23__reduce_86_82 = function $$_reduce_86(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_86_82.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_87', TMP_Ruby23__reduce_87_83 = function $$_reduce_87(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_87_83.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_88', TMP_Ruby23__reduce_88_84 = function $$_reduce_88(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_88_84.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_89', TMP_Ruby23__reduce_89_85 = function $$_reduce_89(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_89_85.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_90', TMP_Ruby23__reduce_90_86 = function $$_reduce_90(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$index_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_90_86.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_91', TMP_Ruby23__reduce_91_87 = function $$_reduce_91(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_91_87.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_92', TMP_Ruby23__reduce_92_88 = function $$_reduce_92(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_92_88.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_93', TMP_Ruby23__reduce_93_89 = function $$_reduce_93(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_93_89.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_94', TMP_Ruby23__reduce_94_90 = function $$_reduce_94(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2)));\n        return result;\n      }, TMP_Ruby23__reduce_94_90.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_95', TMP_Ruby23__reduce_95_91 = function $$_reduce_95(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(self.builder.$const_global(val['$[]'](0), val['$[]'](1)));\n        return result;\n      }, TMP_Ruby23__reduce_95_91.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_96', TMP_Ruby23__reduce_96_92 = function $$_reduce_96(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_96_92.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_97', TMP_Ruby23__reduce_97_93 = function $$_reduce_97(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_97_93.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_98', TMP_Ruby23__reduce_98_94 = function $$_reduce_98(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_98_94.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_99', TMP_Ruby23__reduce_99_95 = function $$_reduce_99(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$index_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_99_95.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_100', TMP_Ruby23__reduce_100_96 = function $$_reduce_100(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_100_96.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_101', TMP_Ruby23__reduce_101_97 = function $$_reduce_101(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_101_97.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_102', TMP_Ruby23__reduce_102_98 = function $$_reduce_102(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$attr_asgn(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_102_98.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_103', TMP_Ruby23__reduce_103_99 = function $$_reduce_103(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2)));\n        return result;\n      }, TMP_Ruby23__reduce_103_99.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_104', TMP_Ruby23__reduce_104_100 = function $$_reduce_104(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(self.builder.$const_global(val['$[]'](0), val['$[]'](1)));\n        return result;\n      }, TMP_Ruby23__reduce_104_100.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_105', TMP_Ruby23__reduce_105_101 = function $$_reduce_105(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_105_101.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_106', TMP_Ruby23__reduce_106_102 = function $$_reduce_106(val, _values, result) {\n        var self = this;\n\n        \n        self.$diagnostic(\"error\", \"module_name_const\", nil, val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_106_102.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_108', TMP_Ruby23__reduce_108_103 = function $$_reduce_108(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$const_global(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_108_103.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_109', TMP_Ruby23__reduce_109_104 = function $$_reduce_109(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$const(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_109_104.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_110', TMP_Ruby23__reduce_110_105 = function $$_reduce_110(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_110_105.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_116', TMP_Ruby23__reduce_116_106 = function $$_reduce_116(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$symbol(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_116_106.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_120', TMP_Ruby23__reduce_120_107 = function $$_reduce_120(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_120_107.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_121', TMP_Ruby23__reduce_121_108 = function $$_reduce_121(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [\"expr_fname\"];\n        $send(self.lexer, 'state=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return result;\n      }, TMP_Ruby23__reduce_121_108.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_122', TMP_Ruby23__reduce_122_109 = function $$_reduce_122(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_122_109.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_194', TMP_Ruby23__reduce_194_110 = function $$_reduce_194(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_194_110.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_195', TMP_Ruby23__reduce_195_111 = function $$_reduce_195(val, _values, result) {\n        var self = this, rescue_body = nil, rescue_ = nil;\n\n        \n        rescue_body = self.builder.$rescue_body(val['$[]'](3), nil, nil, nil, nil, val['$[]'](4));\n        rescue_ = self.builder.$begin_body(val['$[]'](2), [rescue_body]);\n        result = self.builder.$assign(val['$[]'](0), val['$[]'](1), rescue_);\n        return result;\n      }, TMP_Ruby23__reduce_195_111.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_196', TMP_Ruby23__reduce_196_112 = function $$_reduce_196(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$op_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_196_112.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_197', TMP_Ruby23__reduce_197_113 = function $$_reduce_197(val, _values, result) {\n        var self = this, rescue_body = nil, rescue_ = nil;\n\n        \n        rescue_body = self.builder.$rescue_body(val['$[]'](3), nil, nil, nil, nil, val['$[]'](4));\n        rescue_ = self.builder.$begin_body(val['$[]'](2), [rescue_body]);\n        result = self.builder.$op_assign(val['$[]'](0), val['$[]'](1), rescue_);\n        return result;\n      }, TMP_Ruby23__reduce_197_113.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_198', TMP_Ruby23__reduce_198_114 = function $$_reduce_198(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$op_assign(self.builder.$index(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3)), val['$[]'](4), val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_198_114.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_199', TMP_Ruby23__reduce_199_115 = function $$_reduce_199(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_199_115.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_200', TMP_Ruby23__reduce_200_116 = function $$_reduce_200(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_200_116.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_201', TMP_Ruby23__reduce_201_117 = function $$_reduce_201(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$op_assign(self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2)), val['$[]'](3), val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_201_117.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_202', TMP_Ruby23__reduce_202_118 = function $$_reduce_202(val, _values, result) {\n        var self = this, const$ = nil;\n\n        \n        const$ = self.builder.$const_op_assignable(self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2)));\n        result = self.builder.$op_assign(const$, val['$[]'](3), val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_202_118.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_203', TMP_Ruby23__reduce_203_119 = function $$_reduce_203(val, _values, result) {\n        var self = this, const$ = nil;\n\n        \n        const$ = self.builder.$const_op_assignable(self.builder.$const_global(val['$[]'](0), val['$[]'](1)));\n        result = self.builder.$op_assign(const$, val['$[]'](2), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_203_119.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_204', TMP_Ruby23__reduce_204_120 = function $$_reduce_204(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$op_assign(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_204_120.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_205', TMP_Ruby23__reduce_205_121 = function $$_reduce_205(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$range_inclusive(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_205_121.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_206', TMP_Ruby23__reduce_206_122 = function $$_reduce_206(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$range_exclusive(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_206_122.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_207', TMP_Ruby23__reduce_207_123 = function $$_reduce_207(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_207_123.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_208', TMP_Ruby23__reduce_208_124 = function $$_reduce_208(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_208_124.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_209', TMP_Ruby23__reduce_209_125 = function $$_reduce_209(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_209_125.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_210', TMP_Ruby23__reduce_210_126 = function $$_reduce_210(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_210_126.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_211', TMP_Ruby23__reduce_211_127 = function $$_reduce_211(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_211_127.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_212', TMP_Ruby23__reduce_212_128 = function $$_reduce_212(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_212_128.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_213', TMP_Ruby23__reduce_213_129 = function $$_reduce_213(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$unary_op(val['$[]'](0), self.builder.$binary_op(val['$[]'](1), val['$[]'](2), val['$[]'](3)));\n        return result;\n      }, TMP_Ruby23__reduce_213_129.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_214', TMP_Ruby23__reduce_214_130 = function $$_reduce_214(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$unary_op(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_214_130.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_215', TMP_Ruby23__reduce_215_131 = function $$_reduce_215(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$unary_op(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_215_131.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_216', TMP_Ruby23__reduce_216_132 = function $$_reduce_216(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_216_132.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_217', TMP_Ruby23__reduce_217_133 = function $$_reduce_217(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_217_133.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_218', TMP_Ruby23__reduce_218_134 = function $$_reduce_218(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_218_134.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_219', TMP_Ruby23__reduce_219_135 = function $$_reduce_219(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_219_135.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_220', TMP_Ruby23__reduce_220_136 = function $$_reduce_220(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_220_136.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_221', TMP_Ruby23__reduce_221_137 = function $$_reduce_221(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_221_137.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_222', TMP_Ruby23__reduce_222_138 = function $$_reduce_222(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_222_138.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_223', TMP_Ruby23__reduce_223_139 = function $$_reduce_223(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_223_139.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_224', TMP_Ruby23__reduce_224_140 = function $$_reduce_224(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_224_140.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_225', TMP_Ruby23__reduce_225_141 = function $$_reduce_225(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_225_141.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_226', TMP_Ruby23__reduce_226_142 = function $$_reduce_226(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_226_142.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_227', TMP_Ruby23__reduce_227_143 = function $$_reduce_227(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$match_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_227_143.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_228', TMP_Ruby23__reduce_228_144 = function $$_reduce_228(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_228_144.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_229', TMP_Ruby23__reduce_229_145 = function $$_reduce_229(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$not_op(val['$[]'](0), nil, val['$[]'](1), nil);\n        return result;\n      }, TMP_Ruby23__reduce_229_145.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_230', TMP_Ruby23__reduce_230_146 = function $$_reduce_230(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$unary_op(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_230_146.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_231', TMP_Ruby23__reduce_231_147 = function $$_reduce_231(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_231_147.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_232', TMP_Ruby23__reduce_232_148 = function $$_reduce_232(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$binary_op(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_232_148.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_233', TMP_Ruby23__reduce_233_149 = function $$_reduce_233(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$logical_op(\"and\", val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_233_149.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_234', TMP_Ruby23__reduce_234_150 = function $$_reduce_234(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$logical_op(\"or\", val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_234_150.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_235', TMP_Ruby23__reduce_235_151 = function $$_reduce_235(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"defined?\", val['$[]'](0), nil, [val['$[]'](2)], nil);\n        return result;\n      }, TMP_Ruby23__reduce_235_151.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_236', TMP_Ruby23__reduce_236_152 = function $$_reduce_236(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$ternary(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](4), val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_236_152.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_241', TMP_Ruby23__reduce_241_153 = function $$_reduce_241(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](self.builder.$associate(nil, val['$[]'](2), nil));\n        return result;\n      }, TMP_Ruby23__reduce_241_153.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_242', TMP_Ruby23__reduce_242_154 = function $$_reduce_242(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$associate(nil, val['$[]'](0), nil)];\n        return result;\n      }, TMP_Ruby23__reduce_242_154.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_243', TMP_Ruby23__reduce_243_155 = function $$_reduce_243(val, _values, result) {\n        var self = this;\n\n        \n        result = val;\n        return result;\n      }, TMP_Ruby23__reduce_243_155.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_244', TMP_Ruby23__reduce_244_156 = function $$_reduce_244(val, _values, result) {\n        var self = this;\n\n        \n        result = [nil, [], nil];\n        return result;\n      }, TMP_Ruby23__reduce_244_156.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_246', TMP_Ruby23__reduce_246_157 = function $$_reduce_246(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_246_157.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_249', TMP_Ruby23__reduce_249_158 = function $$_reduce_249(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](self.builder.$associate(nil, val['$[]'](2), nil));\n        return result;\n      }, TMP_Ruby23__reduce_249_158.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_250', TMP_Ruby23__reduce_250_159 = function $$_reduce_250(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$associate(nil, val['$[]'](0), nil)];\n        return result;\n      }, TMP_Ruby23__reduce_250_159.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_251', TMP_Ruby23__reduce_251_160 = function $$_reduce_251(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_251_160.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_252', TMP_Ruby23__reduce_252_161 = function $$_reduce_252(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_252_161.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_253', TMP_Ruby23__reduce_253_162 = function $$_reduce_253(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$associate(nil, val['$[]'](0), nil)];\n        result.$concat(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_253_162.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_254', TMP_Ruby23__reduce_254_163 = function $$_reduce_254(val, _values, result) {\n        var self = this, assocs = nil;\n\n        \n        assocs = self.builder.$associate(nil, val['$[]'](2), nil);\n        result = val['$[]'](0)['$<<'](assocs);\n        result.$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_254_163.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_255', TMP_Ruby23__reduce_255_164 = function $$_reduce_255(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_255_164.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_256', TMP_Ruby23__reduce_256_165 = function $$_reduce_256(val, _values, result) {\n        var self = this;\n\n        \n        result = self.lexer.$cmdarg().$dup();\n        self.lexer.$cmdarg().$push(true);\n        return result;\n      }, TMP_Ruby23__reduce_256_165.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_257', TMP_Ruby23__reduce_257_166 = function $$_reduce_257(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [val['$[]'](0)];\n        $send(self.lexer, 'cmdarg=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        result = val['$[]'](1);\n        return result;\n      }, TMP_Ruby23__reduce_257_166.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_258', TMP_Ruby23__reduce_258_167 = function $$_reduce_258(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$block_pass(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_258_167.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_259', TMP_Ruby23__reduce_259_168 = function $$_reduce_259(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](1)];\n        return result;\n      }, TMP_Ruby23__reduce_259_168.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_260', TMP_Ruby23__reduce_260_169 = function $$_reduce_260(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_260_169.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_261', TMP_Ruby23__reduce_261_170 = function $$_reduce_261(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_261_170.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_262', TMP_Ruby23__reduce_262_171 = function $$_reduce_262(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$splat(val['$[]'](0), val['$[]'](1))];\n        return result;\n      }, TMP_Ruby23__reduce_262_171.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_263', TMP_Ruby23__reduce_263_172 = function $$_reduce_263(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_263_172.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_264', TMP_Ruby23__reduce_264_173 = function $$_reduce_264(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](self.builder.$splat(val['$[]'](2), val['$[]'](3)));\n        return result;\n      }, TMP_Ruby23__reduce_264_173.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_265', TMP_Ruby23__reduce_265_174 = function $$_reduce_265(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$array(nil, val['$[]'](0), nil);\n        return result;\n      }, TMP_Ruby23__reduce_265_174.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_267', TMP_Ruby23__reduce_267_175 = function $$_reduce_267(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_267_175.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_268', TMP_Ruby23__reduce_268_176 = function $$_reduce_268(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](self.builder.$splat(val['$[]'](2), val['$[]'](3)));\n        return result;\n      }, TMP_Ruby23__reduce_268_176.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_269', TMP_Ruby23__reduce_269_177 = function $$_reduce_269(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$splat(val['$[]'](0), val['$[]'](1))];\n        return result;\n      }, TMP_Ruby23__reduce_269_177.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_280', TMP_Ruby23__reduce_280_178 = function $$_reduce_280(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$call_method(nil, nil, val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_280_178.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_281', TMP_Ruby23__reduce_281_179 = function $$_reduce_281(val, _values, result) {\n        var self = this;\n\n        \n        result = self.lexer.$cmdarg().$dup();\n        self.lexer.$cmdarg().$clear();\n        return result;\n      }, TMP_Ruby23__reduce_281_179.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_282', TMP_Ruby23__reduce_282_180 = function $$_reduce_282(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [val['$[]'](1)];\n        $send(self.lexer, 'cmdarg=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        result = self.builder.$begin_keyword(val['$[]'](0), val['$[]'](2), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_282_180.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_283', TMP_Ruby23__reduce_283_181 = function $$_reduce_283(val, _values, result) {\n        var self = this;\n\n        \n        result = self.lexer.$cmdarg().$dup();\n        self.lexer.$cmdarg().$clear();\n        return result;\n      }, TMP_Ruby23__reduce_283_181.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_284', TMP_Ruby23__reduce_284_182 = function $$_reduce_284(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [\"expr_endarg\"];\n        $send(self.lexer, 'state=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return result;\n      }, TMP_Ruby23__reduce_284_182.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_285', TMP_Ruby23__reduce_285_183 = function $$_reduce_285(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [val['$[]'](1)];\n        $send(self.lexer, 'cmdarg=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        result = self.builder.$begin(val['$[]'](0), val['$[]'](2), val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_285_183.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_286', TMP_Ruby23__reduce_286_184 = function $$_reduce_286(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [\"expr_endarg\"];\n        $send(self.lexer, 'state=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return result;\n      }, TMP_Ruby23__reduce_286_184.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_287', TMP_Ruby23__reduce_287_185 = function $$_reduce_287(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$begin(val['$[]'](0), nil, val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_287_185.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_288', TMP_Ruby23__reduce_288_186 = function $$_reduce_288(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$begin(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_288_186.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_289', TMP_Ruby23__reduce_289_187 = function $$_reduce_289(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$const_fetch(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_289_187.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_290', TMP_Ruby23__reduce_290_188 = function $$_reduce_290(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$const_global(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_290_188.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_291', TMP_Ruby23__reduce_291_189 = function $$_reduce_291(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$array(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_291_189.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_292', TMP_Ruby23__reduce_292_190 = function $$_reduce_292(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$associate(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_292_190.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_293', TMP_Ruby23__reduce_293_191 = function $$_reduce_293(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"return\", val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_293_191.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_294', TMP_Ruby23__reduce_294_192 = function $$_reduce_294(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"yield\", val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_294_192.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_295', TMP_Ruby23__reduce_295_193 = function $$_reduce_295(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"yield\", val['$[]'](0), val['$[]'](1), [], val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_295_193.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_296', TMP_Ruby23__reduce_296_194 = function $$_reduce_296(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"yield\", val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_296_194.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_297', TMP_Ruby23__reduce_297_195 = function $$_reduce_297(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"defined?\", val['$[]'](0), val['$[]'](2), [val['$[]'](3)], val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_297_195.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_298', TMP_Ruby23__reduce_298_196 = function $$_reduce_298(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$not_op(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_298_196.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_299', TMP_Ruby23__reduce_299_197 = function $$_reduce_299(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$not_op(val['$[]'](0), val['$[]'](1), nil, val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_299_197.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_300', TMP_Ruby23__reduce_300_198 = function $$_reduce_300(val, _values, result) {\n        var $a, $b, self = this, method_call = nil, begin_t = nil, args = nil, body = nil, end_t = nil;\n\n        \n        method_call = self.builder.$call_method(nil, nil, val['$[]'](0));\n        $b = val['$[]'](1), $a = Opal.to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;\n        result = self.builder.$block(method_call, begin_t, args, body, end_t);\n        return result;\n      }, TMP_Ruby23__reduce_300_198.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_302', TMP_Ruby23__reduce_302_199 = function $$_reduce_302(val, _values, result) {\n        var $a, $b, self = this, begin_t = nil, args = nil, body = nil, end_t = nil;\n\n        \n        $b = val['$[]'](1), $a = Opal.to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;\n        result = self.builder.$block(val['$[]'](0), begin_t, args, body, end_t);\n        return result;\n      }, TMP_Ruby23__reduce_302_199.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_303', TMP_Ruby23__reduce_303_200 = function $$_reduce_303(val, _values, result) {\n        var $a, $b, $c, self = this, lambda_call = nil, args = nil, begin_t = nil, body = nil, end_t = nil;\n\n        \n        lambda_call = self.builder.$call_lambda(val['$[]'](0));\n        $b = val['$[]'](1), $a = Opal.to_ary($b), (args = ($a[0] == null ? nil : $a[0])), ($c = Opal.to_ary(($a[1] == null ? nil : $a[1])), (begin_t = ($c[0] == null ? nil : $c[0])), (body = ($c[1] == null ? nil : $c[1])), (end_t = ($c[2] == null ? nil : $c[2]))), $b;\n        result = self.builder.$block(lambda_call, begin_t, args, body, end_t);\n        return result;\n      }, TMP_Ruby23__reduce_303_200.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_304', TMP_Ruby23__reduce_304_201 = function $$_reduce_304(val, _values, result) {\n        var $a, $b, self = this, else_t = nil, else_ = nil;\n\n        \n        $b = val['$[]'](4), $a = Opal.to_ary($b), (else_t = ($a[0] == null ? nil : $a[0])), (else_ = ($a[1] == null ? nil : $a[1])), $b;\n        result = self.builder.$condition(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3), else_t, else_, val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_304_201.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_305', TMP_Ruby23__reduce_305_202 = function $$_reduce_305(val, _values, result) {\n        var $a, $b, self = this, else_t = nil, else_ = nil;\n\n        \n        $b = val['$[]'](4), $a = Opal.to_ary($b), (else_t = ($a[0] == null ? nil : $a[0])), (else_ = ($a[1] == null ? nil : $a[1])), $b;\n        result = self.builder.$condition(val['$[]'](0), val['$[]'](1), val['$[]'](2), else_, else_t, val['$[]'](3), val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_305_202.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_306', TMP_Ruby23__reduce_306_203 = function $$_reduce_306(val, _values, result) {\n        var self = this;\n\n        \n        self.lexer.$cond().$push(true);\n        return result;\n      }, TMP_Ruby23__reduce_306_203.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_307', TMP_Ruby23__reduce_307_204 = function $$_reduce_307(val, _values, result) {\n        var self = this;\n\n        \n        self.lexer.$cond().$pop();\n        return result;\n      }, TMP_Ruby23__reduce_307_204.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_308', TMP_Ruby23__reduce_308_205 = function $$_reduce_308(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$loop(\"while\", val['$[]'](0), val['$[]'](2), val['$[]'](3), val['$[]'](5), val['$[]'](6));\n        return result;\n      }, TMP_Ruby23__reduce_308_205.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_309', TMP_Ruby23__reduce_309_206 = function $$_reduce_309(val, _values, result) {\n        var self = this;\n\n        \n        self.lexer.$cond().$push(true);\n        return result;\n      }, TMP_Ruby23__reduce_309_206.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_310', TMP_Ruby23__reduce_310_207 = function $$_reduce_310(val, _values, result) {\n        var self = this;\n\n        \n        self.lexer.$cond().$pop();\n        return result;\n      }, TMP_Ruby23__reduce_310_207.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_311', TMP_Ruby23__reduce_311_208 = function $$_reduce_311(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$loop(\"until\", val['$[]'](0), val['$[]'](2), val['$[]'](3), val['$[]'](5), val['$[]'](6));\n        return result;\n      }, TMP_Ruby23__reduce_311_208.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_312', TMP_Ruby23__reduce_312_209 = function $$_reduce_312(val, _values, result) {\n        var $a, $b, $c, self = this, when_bodies = nil, else_t = nil, else_body = nil;\n\n        \n        $a = [].concat(Opal.to_a(val['$[]'](3))), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (when_bodies = $slice.call($a, 0, $b)), ($c = Opal.to_ary(($a[$b] == null ? nil : $a[$b])), (else_t = ($c[0] == null ? nil : $c[0])), (else_body = ($c[1] == null ? nil : $c[1]))), $a;\n        result = self.builder.$case(val['$[]'](0), val['$[]'](1), when_bodies, else_t, else_body, val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_312_209.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_313', TMP_Ruby23__reduce_313_210 = function $$_reduce_313(val, _values, result) {\n        var $a, $b, $c, self = this, when_bodies = nil, else_t = nil, else_body = nil;\n\n        \n        $a = [].concat(Opal.to_a(val['$[]'](2))), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (when_bodies = $slice.call($a, 0, $b)), ($c = Opal.to_ary(($a[$b] == null ? nil : $a[$b])), (else_t = ($c[0] == null ? nil : $c[0])), (else_body = ($c[1] == null ? nil : $c[1]))), $a;\n        result = self.builder.$case(val['$[]'](0), nil, when_bodies, else_t, else_body, val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_313_210.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_314', TMP_Ruby23__reduce_314_211 = function $$_reduce_314(val, _values, result) {\n        var self = this;\n\n        \n        self.lexer.$cond().$push(true);\n        return result;\n      }, TMP_Ruby23__reduce_314_211.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_315', TMP_Ruby23__reduce_315_212 = function $$_reduce_315(val, _values, result) {\n        var self = this;\n\n        \n        self.lexer.$cond().$pop();\n        return result;\n      }, TMP_Ruby23__reduce_315_212.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_316', TMP_Ruby23__reduce_316_213 = function $$_reduce_316(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$for(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](4), val['$[]'](5), val['$[]'](7), val['$[]'](8));\n        return result;\n      }, TMP_Ruby23__reduce_316_213.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_317', TMP_Ruby23__reduce_317_214 = function $$_reduce_317(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$extend_static();\n        self.lexer.$push_cmdarg();\n        return result;\n      }, TMP_Ruby23__reduce_317_214.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_318', TMP_Ruby23__reduce_318_215 = function $$_reduce_318(val, _values, result) {\n        var $a, $b, self = this, lt_t = nil, superclass = nil;\n\n        \n        if ($truthy(self['$in_def?']())) {\n          self.$diagnostic(\"error\", \"class_in_def\", nil, val['$[]'](0))};\n        $b = val['$[]'](2), $a = Opal.to_ary($b), (lt_t = ($a[0] == null ? nil : $a[0])), (superclass = ($a[1] == null ? nil : $a[1])), $b;\n        result = self.builder.$def_class(val['$[]'](0), val['$[]'](1), lt_t, superclass, val['$[]'](4), val['$[]'](5));\n        self.lexer.$pop_cmdarg();\n        self.static_env.$unextend();\n        return result;\n      }, TMP_Ruby23__reduce_318_215.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_319', TMP_Ruby23__reduce_319_216 = function $$_reduce_319(val, _values, result) {\n        var self = this;\n\n        \n        result = self.def_level;\n        self.def_level = 0;\n        self.static_env.$extend_static();\n        self.lexer.$push_cmdarg();\n        return result;\n      }, TMP_Ruby23__reduce_319_216.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_320', TMP_Ruby23__reduce_320_217 = function $$_reduce_320(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$def_sclass(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](5), val['$[]'](6));\n        self.lexer.$pop_cmdarg();\n        self.static_env.$unextend();\n        self.def_level = val['$[]'](4);\n        return result;\n      }, TMP_Ruby23__reduce_320_217.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_321', TMP_Ruby23__reduce_321_218 = function $$_reduce_321(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$extend_static();\n        self.lexer.$push_cmdarg();\n        return result;\n      }, TMP_Ruby23__reduce_321_218.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_322', TMP_Ruby23__reduce_322_219 = function $$_reduce_322(val, _values, result) {\n        var self = this;\n\n        \n        if ($truthy(self['$in_def?']())) {\n          self.$diagnostic(\"error\", \"module_in_def\", nil, val['$[]'](0))};\n        result = self.builder.$def_module(val['$[]'](0), val['$[]'](1), val['$[]'](3), val['$[]'](4));\n        self.lexer.$pop_cmdarg();\n        self.static_env.$unextend();\n        return result;\n      }, TMP_Ruby23__reduce_322_219.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_323', TMP_Ruby23__reduce_323_220 = function $$_reduce_323(val, _values, result) {\n        var self = this;\n\n        \n        self.def_level = $rb_plus(self.def_level, 1);\n        self.static_env.$extend_static();\n        self.lexer.$push_cmdarg();\n        return result;\n      }, TMP_Ruby23__reduce_323_220.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_324', TMP_Ruby23__reduce_324_221 = function $$_reduce_324(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$def_method(val['$[]'](0), val['$[]'](1), val['$[]'](3), val['$[]'](4), val['$[]'](5));\n        self.lexer.$pop_cmdarg();\n        self.static_env.$unextend();\n        self.def_level = $rb_minus(self.def_level, 1);\n        return result;\n      }, TMP_Ruby23__reduce_324_221.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_325', TMP_Ruby23__reduce_325_222 = function $$_reduce_325(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [\"expr_fname\"];\n        $send(self.lexer, 'state=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return result;\n      }, TMP_Ruby23__reduce_325_222.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_326', TMP_Ruby23__reduce_326_223 = function $$_reduce_326(val, _values, result) {\n        var self = this;\n\n        \n        self.def_level = $rb_plus(self.def_level, 1);\n        self.static_env.$extend_static();\n        self.lexer.$push_cmdarg();\n        return result;\n      }, TMP_Ruby23__reduce_326_223.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_327', TMP_Ruby23__reduce_327_224 = function $$_reduce_327(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$def_singleton(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](4), val['$[]'](6), val['$[]'](7), val['$[]'](8));\n        self.lexer.$pop_cmdarg();\n        self.static_env.$unextend();\n        self.def_level = $rb_minus(self.def_level, 1);\n        return result;\n      }, TMP_Ruby23__reduce_327_224.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_328', TMP_Ruby23__reduce_328_225 = function $$_reduce_328(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"break\", val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_328_225.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_329', TMP_Ruby23__reduce_329_226 = function $$_reduce_329(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"next\", val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_329_226.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_330', TMP_Ruby23__reduce_330_227 = function $$_reduce_330(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"redo\", val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_330_227.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_331', TMP_Ruby23__reduce_331_228 = function $$_reduce_331(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"retry\", val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_331_228.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_335', TMP_Ruby23__reduce_335_229 = function $$_reduce_335(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](1);\n        return result;\n      }, TMP_Ruby23__reduce_335_229.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_339', TMP_Ruby23__reduce_339_230 = function $$_reduce_339(val, _values, result) {\n        var $a, $b, self = this, else_t = nil, else_ = nil;\n\n        \n        $b = val['$[]'](4), $a = Opal.to_ary($b), (else_t = ($a[0] == null ? nil : $a[0])), (else_ = ($a[1] == null ? nil : $a[1])), $b;\n        result = [val['$[]'](0), self.builder.$condition(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3), else_t, else_, nil)];\n        return result;\n      }, TMP_Ruby23__reduce_339_230.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_341', TMP_Ruby23__reduce_341_231 = function $$_reduce_341(val, _values, result) {\n        var self = this;\n\n        \n        result = val;\n        return result;\n      }, TMP_Ruby23__reduce_341_231.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_344', TMP_Ruby23__reduce_344_232 = function $$_reduce_344(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$arg(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_344_232.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_345', TMP_Ruby23__reduce_345_233 = function $$_reduce_345(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$multi_lhs(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_345_233.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_346', TMP_Ruby23__reduce_346_234 = function $$_reduce_346(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_346_234.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_347', TMP_Ruby23__reduce_347_235 = function $$_reduce_347(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_347_235.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_349', TMP_Ruby23__reduce_349_236 = function $$_reduce_349(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$push(self.builder.$restarg(val['$[]'](2), val['$[]'](3)));\n        return result;\n      }, TMP_Ruby23__reduce_349_236.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_350', TMP_Ruby23__reduce_350_237 = function $$_reduce_350(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$push(self.builder.$restarg(val['$[]'](2), val['$[]'](3))).$concat(val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_350_237.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_351', TMP_Ruby23__reduce_351_238 = function $$_reduce_351(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$push(self.builder.$restarg(val['$[]'](2)));\n        return result;\n      }, TMP_Ruby23__reduce_351_238.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_352', TMP_Ruby23__reduce_352_239 = function $$_reduce_352(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$push(self.builder.$restarg(val['$[]'](2))).$concat(val['$[]'](4));\n        return result;\n      }, TMP_Ruby23__reduce_352_239.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_353', TMP_Ruby23__reduce_353_240 = function $$_reduce_353(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$restarg(val['$[]'](0), val['$[]'](1))];\n        return result;\n      }, TMP_Ruby23__reduce_353_240.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_354', TMP_Ruby23__reduce_354_241 = function $$_reduce_354(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$restarg(val['$[]'](0), val['$[]'](1))].concat(Opal.to_a(val['$[]'](3)));\n        return result;\n      }, TMP_Ruby23__reduce_354_241.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_355', TMP_Ruby23__reduce_355_242 = function $$_reduce_355(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$restarg(val['$[]'](0))];\n        return result;\n      }, TMP_Ruby23__reduce_355_242.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_356', TMP_Ruby23__reduce_356_243 = function $$_reduce_356(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$restarg(val['$[]'](0))].concat(Opal.to_a(val['$[]'](2)));\n        return result;\n      }, TMP_Ruby23__reduce_356_243.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_357', TMP_Ruby23__reduce_357_244 = function $$_reduce_357(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_357_244.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_358', TMP_Ruby23__reduce_358_245 = function $$_reduce_358(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_358_245.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_359', TMP_Ruby23__reduce_359_246 = function $$_reduce_359(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_359_246.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_360', TMP_Ruby23__reduce_360_247 = function $$_reduce_360(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_360_247.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_361', TMP_Ruby23__reduce_361_248 = function $$_reduce_361(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](1);\n        return result;\n      }, TMP_Ruby23__reduce_361_248.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_362', TMP_Ruby23__reduce_362_249 = function $$_reduce_362(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_362_249.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_363', TMP_Ruby23__reduce_363_250 = function $$_reduce_363(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_363_250.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_364', TMP_Ruby23__reduce_364_251 = function $$_reduce_364(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](6)).$concat(val['$[]'](7));\n        return result;\n      }, TMP_Ruby23__reduce_364_251.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_365', TMP_Ruby23__reduce_365_252 = function $$_reduce_365(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_365_252.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_366', TMP_Ruby23__reduce_366_253 = function $$_reduce_366(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_366_253.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_367', TMP_Ruby23__reduce_367_254 = function $$_reduce_367(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_367_254.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_369', TMP_Ruby23__reduce_369_255 = function $$_reduce_369(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_369_255.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_370', TMP_Ruby23__reduce_370_256 = function $$_reduce_370(val, _values, result) {\n        var $a, self = this;\n\n        \n        if ($truthy(($truthy($a = val['$[]'](1)['$empty?']()) ? val['$[]'](0).$size()['$=='](1) : $a))) {\n          result = [self.builder.$procarg0(val['$[]'](0)['$[]'](0))]\n          } else {\n          result = val['$[]'](0).$concat(val['$[]'](1))\n        };\n        return result;\n      }, TMP_Ruby23__reduce_370_256.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_371', TMP_Ruby23__reduce_371_257 = function $$_reduce_371(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_371_257.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_372', TMP_Ruby23__reduce_372_258 = function $$_reduce_372(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_372_258.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_373', TMP_Ruby23__reduce_373_259 = function $$_reduce_373(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_373_259.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_374', TMP_Ruby23__reduce_374_260 = function $$_reduce_374(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_374_260.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_375', TMP_Ruby23__reduce_375_261 = function $$_reduce_375(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_375_261.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_376', TMP_Ruby23__reduce_376_262 = function $$_reduce_376(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_376_262.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_378', TMP_Ruby23__reduce_378_263 = function $$_reduce_378(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$args(nil, [], nil);\n        return result;\n      }, TMP_Ruby23__reduce_378_263.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_379', TMP_Ruby23__reduce_379_264 = function $$_reduce_379(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [\"expr_value\"];\n        $send(self.lexer, 'state=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return result;\n      }, TMP_Ruby23__reduce_379_264.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_380', TMP_Ruby23__reduce_380_265 = function $$_reduce_380(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$args(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_380_265.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_381', TMP_Ruby23__reduce_381_266 = function $$_reduce_381(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$args(val['$[]'](0), [], val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_381_266.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_382', TMP_Ruby23__reduce_382_267 = function $$_reduce_382(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$args(val['$[]'](0), val['$[]'](1).$concat(val['$[]'](2)), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_382_267.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_383', TMP_Ruby23__reduce_383_268 = function $$_reduce_383(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_383_268.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_384', TMP_Ruby23__reduce_384_269 = function $$_reduce_384(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](2);\n        return result;\n      }, TMP_Ruby23__reduce_384_269.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_385', TMP_Ruby23__reduce_385_270 = function $$_reduce_385(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_385_270.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_386', TMP_Ruby23__reduce_386_271 = function $$_reduce_386(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_386_271.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_387', TMP_Ruby23__reduce_387_272 = function $$_reduce_387(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$declare(val['$[]'](0)['$[]'](0));\n        result = self.builder.$shadowarg(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_387_272.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_389', TMP_Ruby23__reduce_389_273 = function $$_reduce_389(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$extend_dynamic();\n        return result;\n      }, TMP_Ruby23__reduce_389_273.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_390', TMP_Ruby23__reduce_390_274 = function $$_reduce_390(val, _values, result) {\n        var self = this;\n\n        \n        result = self.lexer.$cmdarg().$dup();\n        self.lexer.$cmdarg().$clear();\n        return result;\n      }, TMP_Ruby23__reduce_390_274.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_391', TMP_Ruby23__reduce_391_275 = function $$_reduce_391(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [val['$[]'](2)];\n        $send(self.lexer, 'cmdarg=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        self.lexer.$cmdarg().$lexpop();\n        result = [val['$[]'](1), val['$[]'](3)];\n        self.static_env.$unextend();\n        return result;\n      }, TMP_Ruby23__reduce_391_275.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_392', TMP_Ruby23__reduce_392_276 = function $$_reduce_392(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$args(val['$[]'](0), val['$[]'](1).$concat(val['$[]'](2)), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_392_276.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_393', TMP_Ruby23__reduce_393_277 = function $$_reduce_393(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$args(nil, val['$[]'](0), nil);\n        return result;\n      }, TMP_Ruby23__reduce_393_277.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_394', TMP_Ruby23__reduce_394_278 = function $$_reduce_394(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0), val['$[]'](1), val['$[]'](2)];\n        return result;\n      }, TMP_Ruby23__reduce_394_278.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_395', TMP_Ruby23__reduce_395_279 = function $$_reduce_395(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0), val['$[]'](1), val['$[]'](2)];\n        return result;\n      }, TMP_Ruby23__reduce_395_279.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_396', TMP_Ruby23__reduce_396_280 = function $$_reduce_396(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$extend_dynamic();\n        return result;\n      }, TMP_Ruby23__reduce_396_280.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_397', TMP_Ruby23__reduce_397_281 = function $$_reduce_397(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0), val['$[]'](2), val['$[]'](3), val['$[]'](4)];\n        self.static_env.$unextend();\n        return result;\n      }, TMP_Ruby23__reduce_397_281.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_398', TMP_Ruby23__reduce_398_282 = function $$_reduce_398(val, _values, result) {\n        var $a, $b, self = this, begin_t = nil, block_args = nil, body = nil, end_t = nil;\n\n        \n        $b = val['$[]'](1), $a = Opal.to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (block_args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;\n        result = self.builder.$block(val['$[]'](0), begin_t, block_args, body, end_t);\n        return result;\n      }, TMP_Ruby23__reduce_398_282.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_399', TMP_Ruby23__reduce_399_283 = function $$_reduce_399(val, _values, result) {\n        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;\n\n        \n        $b = val['$[]'](3), $a = Opal.to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;\n        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), lparen_t, args, rparen_t);\n        return result;\n      }, TMP_Ruby23__reduce_399_283.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_400', TMP_Ruby23__reduce_400_284 = function $$_reduce_400(val, _values, result) {\n        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil, method_call = nil, begin_t = nil, body = nil, end_t = nil;\n\n        \n        $b = val['$[]'](3), $a = Opal.to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;\n        method_call = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), lparen_t, args, rparen_t);\n        $b = val['$[]'](4), $a = Opal.to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;\n        result = self.builder.$block(method_call, begin_t, args, body, end_t);\n        return result;\n      }, TMP_Ruby23__reduce_400_284.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_401', TMP_Ruby23__reduce_401_285 = function $$_reduce_401(val, _values, result) {\n        var $a, $b, self = this, method_call = nil, begin_t = nil, args = nil, body = nil, end_t = nil;\n\n        \n        method_call = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), nil, val['$[]'](3), nil);\n        $b = val['$[]'](4), $a = Opal.to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), (end_t = ($a[3] == null ? nil : $a[3])), $b;\n        result = self.builder.$block(method_call, begin_t, args, body, end_t);\n        return result;\n      }, TMP_Ruby23__reduce_401_285.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_402', TMP_Ruby23__reduce_402_286 = function $$_reduce_402(val, _values, result) {\n        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;\n\n        \n        $b = val['$[]'](1), $a = Opal.to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;\n        result = self.builder.$call_method(nil, nil, val['$[]'](0), lparen_t, args, rparen_t);\n        return result;\n      }, TMP_Ruby23__reduce_402_286.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_403', TMP_Ruby23__reduce_403_287 = function $$_reduce_403(val, _values, result) {\n        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;\n\n        \n        $b = val['$[]'](3), $a = Opal.to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;\n        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), lparen_t, args, rparen_t);\n        return result;\n      }, TMP_Ruby23__reduce_403_287.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_404', TMP_Ruby23__reduce_404_288 = function $$_reduce_404(val, _values, result) {\n        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;\n\n        \n        $b = val['$[]'](3), $a = Opal.to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;\n        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2), lparen_t, args, rparen_t);\n        return result;\n      }, TMP_Ruby23__reduce_404_288.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_405', TMP_Ruby23__reduce_405_289 = function $$_reduce_405(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_405_289.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_406', TMP_Ruby23__reduce_406_290 = function $$_reduce_406(val, _values, result) {\n        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;\n\n        \n        $b = val['$[]'](2), $a = Opal.to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;\n        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), nil, lparen_t, args, rparen_t);\n        return result;\n      }, TMP_Ruby23__reduce_406_290.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_407', TMP_Ruby23__reduce_407_291 = function $$_reduce_407(val, _values, result) {\n        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;\n\n        \n        $b = val['$[]'](2), $a = Opal.to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;\n        result = self.builder.$call_method(val['$[]'](0), val['$[]'](1), nil, lparen_t, args, rparen_t);\n        return result;\n      }, TMP_Ruby23__reduce_407_291.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_408', TMP_Ruby23__reduce_408_292 = function $$_reduce_408(val, _values, result) {\n        var $a, $b, self = this, lparen_t = nil, args = nil, rparen_t = nil;\n\n        \n        $b = val['$[]'](1), $a = Opal.to_ary($b), (lparen_t = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (rparen_t = ($a[2] == null ? nil : $a[2])), $b;\n        result = self.builder.$keyword_cmd(\"super\", val['$[]'](0), lparen_t, args, rparen_t);\n        return result;\n      }, TMP_Ruby23__reduce_408_292.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_409', TMP_Ruby23__reduce_409_293 = function $$_reduce_409(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$keyword_cmd(\"zsuper\", val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_409_293.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_410', TMP_Ruby23__reduce_410_294 = function $$_reduce_410(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$index(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_410_294.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_411', TMP_Ruby23__reduce_411_295 = function $$_reduce_411(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$extend_dynamic();\n        return result;\n      }, TMP_Ruby23__reduce_411_295.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_412', TMP_Ruby23__reduce_412_296 = function $$_reduce_412(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0), val['$[]'](2), val['$[]'](3), val['$[]'](4)];\n        self.static_env.$unextend();\n        return result;\n      }, TMP_Ruby23__reduce_412_296.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_413', TMP_Ruby23__reduce_413_297 = function $$_reduce_413(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$extend_dynamic();\n        return result;\n      }, TMP_Ruby23__reduce_413_297.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_414', TMP_Ruby23__reduce_414_298 = function $$_reduce_414(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0), val['$[]'](2), val['$[]'](3), val['$[]'](4)];\n        self.static_env.$unextend();\n        return result;\n      }, TMP_Ruby23__reduce_414_298.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_415', TMP_Ruby23__reduce_415_299 = function $$_reduce_415(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$when(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3))].concat(Opal.to_a(val['$[]'](4)));\n        return result;\n      }, TMP_Ruby23__reduce_415_299.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_416', TMP_Ruby23__reduce_416_300 = function $$_reduce_416(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_416_300.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_418', TMP_Ruby23__reduce_418_301 = function $$_reduce_418(val, _values, result) {\n        var $a, $b, self = this, assoc_t = nil, exc_var = nil, exc_list = nil;\n\n        \n        $b = val['$[]'](2), $a = Opal.to_ary($b), (assoc_t = ($a[0] == null ? nil : $a[0])), (exc_var = ($a[1] == null ? nil : $a[1])), $b;\n        if ($truthy(val['$[]'](1))) {\n          exc_list = self.builder.$array(nil, val['$[]'](1), nil)};\n        result = [self.builder.$rescue_body(val['$[]'](0), exc_list, assoc_t, exc_var, val['$[]'](3), val['$[]'](4))].concat(Opal.to_a(val['$[]'](5)));\n        return result;\n      }, TMP_Ruby23__reduce_418_301.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_419', TMP_Ruby23__reduce_419_302 = function $$_reduce_419(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_419_302.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_420', TMP_Ruby23__reduce_420_303 = function $$_reduce_420(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_420_303.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_423', TMP_Ruby23__reduce_423_304 = function $$_reduce_423(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0), val['$[]'](1)];\n        return result;\n      }, TMP_Ruby23__reduce_423_304.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_425', TMP_Ruby23__reduce_425_305 = function $$_reduce_425(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0), val['$[]'](1)];\n        return result;\n      }, TMP_Ruby23__reduce_425_305.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_430', TMP_Ruby23__reduce_430_306 = function $$_reduce_430(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$string_compose(nil, val['$[]'](0), nil);\n        return result;\n      }, TMP_Ruby23__reduce_430_306.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_431', TMP_Ruby23__reduce_431_307 = function $$_reduce_431(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_431_307.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_432', TMP_Ruby23__reduce_432_308 = function $$_reduce_432(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_432_308.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_433', TMP_Ruby23__reduce_433_309 = function $$_reduce_433(val, _values, result) {\n        var self = this, string = nil;\n\n        \n        string = self.builder.$string_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        result = self.builder.$dedent_string(string, self.lexer.$dedent_level());\n        return result;\n      }, TMP_Ruby23__reduce_433_309.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_434', TMP_Ruby23__reduce_434_310 = function $$_reduce_434(val, _values, result) {\n        var self = this, string = nil;\n\n        \n        string = self.builder.$string(val['$[]'](0));\n        result = self.builder.$dedent_string(string, self.lexer.$dedent_level());\n        return result;\n      }, TMP_Ruby23__reduce_434_310.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_435', TMP_Ruby23__reduce_435_311 = function $$_reduce_435(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$character(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_435_311.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_436', TMP_Ruby23__reduce_436_312 = function $$_reduce_436(val, _values, result) {\n        var self = this, string = nil;\n\n        \n        string = self.builder.$xstring_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        result = self.builder.$dedent_string(string, self.lexer.$dedent_level());\n        return result;\n      }, TMP_Ruby23__reduce_436_312.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_437', TMP_Ruby23__reduce_437_313 = function $$_reduce_437(val, _values, result) {\n        var self = this, opts = nil;\n\n        \n        opts = self.builder.$regexp_options(val['$[]'](3));\n        result = self.builder.$regexp_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2), opts);\n        return result;\n      }, TMP_Ruby23__reduce_437_313.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_438', TMP_Ruby23__reduce_438_314 = function $$_reduce_438(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$words_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_438_314.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_439', TMP_Ruby23__reduce_439_315 = function $$_reduce_439(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_439_315.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_440', TMP_Ruby23__reduce_440_316 = function $$_reduce_440(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](self.builder.$word(val['$[]'](1)));\n        return result;\n      }, TMP_Ruby23__reduce_440_316.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_441', TMP_Ruby23__reduce_441_317 = function $$_reduce_441(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_441_317.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_442', TMP_Ruby23__reduce_442_318 = function $$_reduce_442(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_442_318.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_443', TMP_Ruby23__reduce_443_319 = function $$_reduce_443(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$symbols_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_443_319.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_444', TMP_Ruby23__reduce_444_320 = function $$_reduce_444(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_444_320.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_445', TMP_Ruby23__reduce_445_321 = function $$_reduce_445(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](self.builder.$word(val['$[]'](1)));\n        return result;\n      }, TMP_Ruby23__reduce_445_321.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_446', TMP_Ruby23__reduce_446_322 = function $$_reduce_446(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$words_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_446_322.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_447', TMP_Ruby23__reduce_447_323 = function $$_reduce_447(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$symbols_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_447_323.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_448', TMP_Ruby23__reduce_448_324 = function $$_reduce_448(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_448_324.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_449', TMP_Ruby23__reduce_449_325 = function $$_reduce_449(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](self.builder.$string_internal(val['$[]'](1)));\n        return result;\n      }, TMP_Ruby23__reduce_449_325.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_450', TMP_Ruby23__reduce_450_326 = function $$_reduce_450(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_450_326.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_451', TMP_Ruby23__reduce_451_327 = function $$_reduce_451(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](self.builder.$symbol_internal(val['$[]'](1)));\n        return result;\n      }, TMP_Ruby23__reduce_451_327.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_452', TMP_Ruby23__reduce_452_328 = function $$_reduce_452(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_452_328.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_453', TMP_Ruby23__reduce_453_329 = function $$_reduce_453(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_453_329.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_454', TMP_Ruby23__reduce_454_330 = function $$_reduce_454(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_454_330.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_455', TMP_Ruby23__reduce_455_331 = function $$_reduce_455(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_455_331.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_456', TMP_Ruby23__reduce_456_332 = function $$_reduce_456(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_456_332.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_457', TMP_Ruby23__reduce_457_333 = function $$_reduce_457(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_457_333.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_458', TMP_Ruby23__reduce_458_334 = function $$_reduce_458(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$string_internal(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_458_334.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_459', TMP_Ruby23__reduce_459_335 = function $$_reduce_459(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](1);\n        return result;\n      }, TMP_Ruby23__reduce_459_335.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_460', TMP_Ruby23__reduce_460_336 = function $$_reduce_460(val, _values, result) {\n        var self = this;\n\n        \n        self.lexer.$cond().$push(false);\n        self.lexer.$cmdarg().$push(false);\n        return result;\n      }, TMP_Ruby23__reduce_460_336.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_461', TMP_Ruby23__reduce_461_337 = function $$_reduce_461(val, _values, result) {\n        var self = this;\n\n        \n        self.lexer.$cond().$lexpop();\n        self.lexer.$cmdarg().$lexpop();\n        result = self.builder.$begin(val['$[]'](0), val['$[]'](2), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_461_337.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_462', TMP_Ruby23__reduce_462_338 = function $$_reduce_462(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$gvar(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_462_338.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_463', TMP_Ruby23__reduce_463_339 = function $$_reduce_463(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$ivar(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_463_339.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_464', TMP_Ruby23__reduce_464_340 = function $$_reduce_464(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$cvar(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_464_340.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_466', TMP_Ruby23__reduce_466_341 = function $$_reduce_466(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$symbol(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_466_341.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_467', TMP_Ruby23__reduce_467_342 = function $$_reduce_467(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$symbol_compose(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_467_342.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_468', TMP_Ruby23__reduce_468_343 = function $$_reduce_468(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0);\n        return result;\n      }, TMP_Ruby23__reduce_468_343.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_469', TMP_Ruby23__reduce_469_344 = function $$_reduce_469(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$negate(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_469_344.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_470', TMP_Ruby23__reduce_470_345 = function $$_reduce_470(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$integer(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_470_345.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_471', TMP_Ruby23__reduce_471_346 = function $$_reduce_471(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$float(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_471_346.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_472', TMP_Ruby23__reduce_472_347 = function $$_reduce_472(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$rational(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_472_347.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_473', TMP_Ruby23__reduce_473_348 = function $$_reduce_473(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$complex(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_473_348.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_474', TMP_Ruby23__reduce_474_349 = function $$_reduce_474(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$ident(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_474_349.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_475', TMP_Ruby23__reduce_475_350 = function $$_reduce_475(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$ivar(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_475_350.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_476', TMP_Ruby23__reduce_476_351 = function $$_reduce_476(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$gvar(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_476_351.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_477', TMP_Ruby23__reduce_477_352 = function $$_reduce_477(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$const(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_477_352.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_478', TMP_Ruby23__reduce_478_353 = function $$_reduce_478(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$cvar(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_478_353.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_479', TMP_Ruby23__reduce_479_354 = function $$_reduce_479(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$nil(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_479_354.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_480', TMP_Ruby23__reduce_480_355 = function $$_reduce_480(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$self(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_480_355.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_481', TMP_Ruby23__reduce_481_356 = function $$_reduce_481(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$true(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_481_356.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_482', TMP_Ruby23__reduce_482_357 = function $$_reduce_482(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$false(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_482_357.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_483', TMP_Ruby23__reduce_483_358 = function $$_reduce_483(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$__FILE__(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_483_358.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_484', TMP_Ruby23__reduce_484_359 = function $$_reduce_484(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$__LINE__(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_484_359.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_485', TMP_Ruby23__reduce_485_360 = function $$_reduce_485(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$__ENCODING__(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_485_360.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_486', TMP_Ruby23__reduce_486_361 = function $$_reduce_486(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$accessible(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_486_361.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_487', TMP_Ruby23__reduce_487_362 = function $$_reduce_487(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$accessible(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_487_362.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_488', TMP_Ruby23__reduce_488_363 = function $$_reduce_488(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_488_363.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_489', TMP_Ruby23__reduce_489_364 = function $$_reduce_489(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$assignable(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_489_364.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_490', TMP_Ruby23__reduce_490_365 = function $$_reduce_490(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$nth_ref(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_490_365.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_491', TMP_Ruby23__reduce_491_366 = function $$_reduce_491(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$back_ref(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_491_366.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_492', TMP_Ruby23__reduce_492_367 = function $$_reduce_492(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [\"expr_value\"];\n        $send(self.lexer, 'state=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return result;\n      }, TMP_Ruby23__reduce_492_367.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_493', TMP_Ruby23__reduce_493_368 = function $$_reduce_493(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0), val['$[]'](2)];\n        return result;\n      }, TMP_Ruby23__reduce_493_368.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_494', TMP_Ruby23__reduce_494_369 = function $$_reduce_494(val, _values, result) {\n        var self = this;\n\n        \n        result = nil;\n        return result;\n      }, TMP_Ruby23__reduce_494_369.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_495', TMP_Ruby23__reduce_495_370 = function $$_reduce_495(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        result = self.builder.$args(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        \n        $writer = [\"expr_value\"];\n        $send(self.lexer, 'state=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return result;\n      }, TMP_Ruby23__reduce_495_370.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_496', TMP_Ruby23__reduce_496_371 = function $$_reduce_496(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        result = self.lexer.$in_kwarg();\n        \n        $writer = [true];\n        $send(self.lexer, 'in_kwarg=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return result;\n      }, TMP_Ruby23__reduce_496_371.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_497', TMP_Ruby23__reduce_497_372 = function $$_reduce_497(val, _values, result) {\n        var self = this, $writer = nil;\n\n        \n        \n        $writer = [val['$[]'](0)];\n        $send(self.lexer, 'in_kwarg=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        result = self.builder.$args(nil, val['$[]'](1), nil);\n        return result;\n      }, TMP_Ruby23__reduce_497_372.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_498', TMP_Ruby23__reduce_498_373 = function $$_reduce_498(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_498_373.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_499', TMP_Ruby23__reduce_499_374 = function $$_reduce_499(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_499_374.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_500', TMP_Ruby23__reduce_500_375 = function $$_reduce_500(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_500_375.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_501', TMP_Ruby23__reduce_501_376 = function $$_reduce_501(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_501_376.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_502', TMP_Ruby23__reduce_502_377 = function $$_reduce_502(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](1);\n        return result;\n      }, TMP_Ruby23__reduce_502_377.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_503', TMP_Ruby23__reduce_503_378 = function $$_reduce_503(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_503_378.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_504', TMP_Ruby23__reduce_504_379 = function $$_reduce_504(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_504_379.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_505', TMP_Ruby23__reduce_505_380 = function $$_reduce_505(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](6)).$concat(val['$[]'](7));\n        return result;\n      }, TMP_Ruby23__reduce_505_380.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_506', TMP_Ruby23__reduce_506_381 = function $$_reduce_506(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_506_381.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_507', TMP_Ruby23__reduce_507_382 = function $$_reduce_507(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_507_382.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_508', TMP_Ruby23__reduce_508_383 = function $$_reduce_508(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_508_383.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_509', TMP_Ruby23__reduce_509_384 = function $$_reduce_509(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_509_384.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_510', TMP_Ruby23__reduce_510_385 = function $$_reduce_510(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_510_385.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_511', TMP_Ruby23__reduce_511_386 = function $$_reduce_511(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_511_386.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_512', TMP_Ruby23__reduce_512_387 = function $$_reduce_512(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](4)).$concat(val['$[]'](5));\n        return result;\n      }, TMP_Ruby23__reduce_512_387.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_513', TMP_Ruby23__reduce_513_388 = function $$_reduce_513(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_513_388.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_514', TMP_Ruby23__reduce_514_389 = function $$_reduce_514(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_514_389.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_515', TMP_Ruby23__reduce_515_390 = function $$_reduce_515(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_515_390.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_516', TMP_Ruby23__reduce_516_391 = function $$_reduce_516(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0).$concat(val['$[]'](2)).$concat(val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_516_391.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_517', TMP_Ruby23__reduce_517_392 = function $$_reduce_517(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0);\n        return result;\n      }, TMP_Ruby23__reduce_517_392.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_518', TMP_Ruby23__reduce_518_393 = function $$_reduce_518(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_518_393.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_519', TMP_Ruby23__reduce_519_394 = function $$_reduce_519(val, _values, result) {\n        var self = this;\n\n        \n        self.$diagnostic(\"error\", \"argument_const\", nil, val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_519_394.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_520', TMP_Ruby23__reduce_520_395 = function $$_reduce_520(val, _values, result) {\n        var self = this;\n\n        \n        self.$diagnostic(\"error\", \"argument_ivar\", nil, val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_520_395.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_521', TMP_Ruby23__reduce_521_396 = function $$_reduce_521(val, _values, result) {\n        var self = this;\n\n        \n        self.$diagnostic(\"error\", \"argument_gvar\", nil, val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_521_396.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_522', TMP_Ruby23__reduce_522_397 = function $$_reduce_522(val, _values, result) {\n        var self = this;\n\n        \n        self.$diagnostic(\"error\", \"argument_cvar\", nil, val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_522_397.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_524', TMP_Ruby23__reduce_524_398 = function $$_reduce_524(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$declare(val['$[]'](0)['$[]'](0));\n        result = val['$[]'](0);\n        return result;\n      }, TMP_Ruby23__reduce_524_398.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_525', TMP_Ruby23__reduce_525_399 = function $$_reduce_525(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0);\n        return result;\n      }, TMP_Ruby23__reduce_525_399.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_526', TMP_Ruby23__reduce_526_400 = function $$_reduce_526(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$arg(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_526_400.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_527', TMP_Ruby23__reduce_527_401 = function $$_reduce_527(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$multi_lhs(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_527_401.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_528', TMP_Ruby23__reduce_528_402 = function $$_reduce_528(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_528_402.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_529', TMP_Ruby23__reduce_529_403 = function $$_reduce_529(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_529_403.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_530', TMP_Ruby23__reduce_530_404 = function $$_reduce_530(val, _values, result) {\n        var self = this;\n\n        \n        self.$check_kwarg_name(val['$[]'](0));\n        self.static_env.$declare(val['$[]'](0)['$[]'](0));\n        result = val['$[]'](0);\n        return result;\n      }, TMP_Ruby23__reduce_530_404.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_531', TMP_Ruby23__reduce_531_405 = function $$_reduce_531(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$kwoptarg(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_531_405.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_532', TMP_Ruby23__reduce_532_406 = function $$_reduce_532(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$kwarg(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_532_406.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_533', TMP_Ruby23__reduce_533_407 = function $$_reduce_533(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$kwoptarg(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_533_407.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_534', TMP_Ruby23__reduce_534_408 = function $$_reduce_534(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$kwarg(val['$[]'](0));\n        return result;\n      }, TMP_Ruby23__reduce_534_408.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_535', TMP_Ruby23__reduce_535_409 = function $$_reduce_535(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_535_409.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_536', TMP_Ruby23__reduce_536_410 = function $$_reduce_536(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_536_410.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_537', TMP_Ruby23__reduce_537_411 = function $$_reduce_537(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_537_411.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_538', TMP_Ruby23__reduce_538_412 = function $$_reduce_538(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_538_412.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_541', TMP_Ruby23__reduce_541_413 = function $$_reduce_541(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$declare(val['$[]'](1)['$[]'](0));\n        result = [self.builder.$kwrestarg(val['$[]'](0), val['$[]'](1))];\n        return result;\n      }, TMP_Ruby23__reduce_541_413.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_542', TMP_Ruby23__reduce_542_414 = function $$_reduce_542(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$kwrestarg(val['$[]'](0))];\n        return result;\n      }, TMP_Ruby23__reduce_542_414.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_543', TMP_Ruby23__reduce_543_415 = function $$_reduce_543(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$optarg(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_543_415.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_544', TMP_Ruby23__reduce_544_416 = function $$_reduce_544(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$optarg(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_544_416.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_545', TMP_Ruby23__reduce_545_417 = function $$_reduce_545(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_545_417.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_546', TMP_Ruby23__reduce_546_418 = function $$_reduce_546(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_546_418.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_547', TMP_Ruby23__reduce_547_419 = function $$_reduce_547(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_547_419.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_548', TMP_Ruby23__reduce_548_420 = function $$_reduce_548(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_548_420.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_551', TMP_Ruby23__reduce_551_421 = function $$_reduce_551(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$declare(val['$[]'](1)['$[]'](0));\n        result = [self.builder.$restarg(val['$[]'](0), val['$[]'](1))];\n        return result;\n      }, TMP_Ruby23__reduce_551_421.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_552', TMP_Ruby23__reduce_552_422 = function $$_reduce_552(val, _values, result) {\n        var self = this;\n\n        \n        result = [self.builder.$restarg(val['$[]'](0))];\n        return result;\n      }, TMP_Ruby23__reduce_552_422.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_555', TMP_Ruby23__reduce_555_423 = function $$_reduce_555(val, _values, result) {\n        var self = this;\n\n        \n        self.static_env.$declare(val['$[]'](1)['$[]'](0));\n        result = self.builder.$blockarg(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_555_423.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_556', TMP_Ruby23__reduce_556_424 = function $$_reduce_556(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](1)];\n        return result;\n      }, TMP_Ruby23__reduce_556_424.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_557', TMP_Ruby23__reduce_557_425 = function $$_reduce_557(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_557_425.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_559', TMP_Ruby23__reduce_559_426 = function $$_reduce_559(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](1);\n        return result;\n      }, TMP_Ruby23__reduce_559_426.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_560', TMP_Ruby23__reduce_560_427 = function $$_reduce_560(val, _values, result) {\n        var self = this;\n\n        \n        result = [];\n        return result;\n      }, TMP_Ruby23__reduce_560_427.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_562', TMP_Ruby23__reduce_562_428 = function $$_reduce_562(val, _values, result) {\n        var self = this;\n\n        \n        result = [val['$[]'](0)];\n        return result;\n      }, TMP_Ruby23__reduce_562_428.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_563', TMP_Ruby23__reduce_563_429 = function $$_reduce_563(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](0)['$<<'](val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_563_429.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_564', TMP_Ruby23__reduce_564_430 = function $$_reduce_564(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$pair(val['$[]'](0), val['$[]'](1), val['$[]'](2));\n        return result;\n      }, TMP_Ruby23__reduce_564_430.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_565', TMP_Ruby23__reduce_565_431 = function $$_reduce_565(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$pair_keyword(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_565_431.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_566', TMP_Ruby23__reduce_566_432 = function $$_reduce_566(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$pair_quoted(val['$[]'](0), val['$[]'](1), val['$[]'](2), val['$[]'](3));\n        return result;\n      }, TMP_Ruby23__reduce_566_432.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_567', TMP_Ruby23__reduce_567_433 = function $$_reduce_567(val, _values, result) {\n        var self = this;\n\n        \n        result = self.builder.$kwsplat(val['$[]'](0), val['$[]'](1));\n        return result;\n      }, TMP_Ruby23__reduce_567_433.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_580', TMP_Ruby23__reduce_580_434 = function $$_reduce_580(val, _values, result) {\n        var self = this;\n\n        \n        result = [\"dot\", val['$[]'](0)['$[]'](1)];\n        return result;\n      }, TMP_Ruby23__reduce_580_434.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_581', TMP_Ruby23__reduce_581_435 = function $$_reduce_581(val, _values, result) {\n        var self = this;\n\n        \n        result = [\"anddot\", val['$[]'](0)['$[]'](1)];\n        return result;\n      }, TMP_Ruby23__reduce_581_435.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_586', TMP_Ruby23__reduce_586_436 = function $$_reduce_586(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](1);\n        return result;\n      }, TMP_Ruby23__reduce_586_436.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_587', TMP_Ruby23__reduce_587_437 = function $$_reduce_587(val, _values, result) {\n        var self = this;\n\n        \n        result = val['$[]'](1);\n        return result;\n      }, TMP_Ruby23__reduce_587_437.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_591', TMP_Ruby23__reduce_591_438 = function $$_reduce_591(val, _values, result) {\n        var self = this;\n\n        \n        self.$yyerrok();\n        return result;\n      }, TMP_Ruby23__reduce_591_438.$$arity = 3);\n      \n      Opal.defn(self, '$_reduce_595', TMP_Ruby23__reduce_595_439 = function $$_reduce_595(val, _values, result) {\n        var self = this;\n\n        \n        result = nil;\n        return result;\n      }, TMP_Ruby23__reduce_595_439.$$arity = 3);\n      return (Opal.defn(self, '$_reduce_none', TMP_Ruby23__reduce_none_440 = function $$_reduce_none(val, _values, result) {\n        var self = this;\n\n        return val['$[]'](0)\n      }, TMP_Ruby23__reduce_none_440.$$arity = 3), nil) && '_reduce_none';\n    })($nesting[0], Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Parser'), 'Base'), $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/ast/builder\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$new']);\n  \n  self.$require(\"opal/ast/node\");\n  self.$require(\"parser/ruby23\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $AST, self = $AST = $module($base, 'AST');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Builder(){};\n        var self = $Builder = $klass($base, $super, 'Builder', $Builder);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Builder_n_1;\n\n        return (Opal.defn(self, '$n', TMP_Builder_n_1 = function $$n(type, children, location) {\n          var self = this;\n\n          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Opal'), 'AST'), 'Node').$new(type, children, $hash2([\"location\"], {\"location\": location}))\n        }, TMP_Builder_n_1.$$arity = 3), nil) && 'n'\n      })($nesting[0], Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Parser'), 'Builders'), 'Default'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriters/base\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$new', '$current_node', '$loc', '$nil?', '$include?', '$type', '$updated', '$s', '$attr_accessor', '$current_node=', '$-']);\n  \n  self.$require(\"parser\");\n  self.$require(\"opal/ast/node\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Rewriters, self = $Rewriters = $module($base, 'Rewriters');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Base(){};\n        var self = $Base = $klass($base, $super, 'Base', $Base);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Base_s_9, TMP_Base_s_10, TMP_Base_prepend_to_body_11, TMP_Base_append_to_body_12, TMP_Base_process_13;\n\n        \n        (function($base, $super, $parent_nesting) {\n          function $DummyLocation(){};\n          var self = $DummyLocation = $klass($base, $super, 'DummyLocation', $DummyLocation);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DummyLocation_node$eq_1, TMP_DummyLocation_expression_2, TMP_DummyLocation_begin_pos_3, TMP_DummyLocation_end_pos_4, TMP_DummyLocation_source_5, TMP_DummyLocation_line_6, TMP_DummyLocation_column_7, TMP_DummyLocation_last_line_8;\n\n          \n          \n          Opal.defn(self, '$node=', TMP_DummyLocation_node$eq_1 = function($a_rest) {\n            var self = this;\n\n            return nil\n          }, TMP_DummyLocation_node$eq_1.$$arity = -1);\n          \n          Opal.defn(self, '$expression', TMP_DummyLocation_expression_2 = function $$expression() {\n            var self = this;\n\n            return self\n          }, TMP_DummyLocation_expression_2.$$arity = 0);\n          \n          Opal.defn(self, '$begin_pos', TMP_DummyLocation_begin_pos_3 = function $$begin_pos() {\n            var self = this;\n\n            return 0\n          }, TMP_DummyLocation_begin_pos_3.$$arity = 0);\n          \n          Opal.defn(self, '$end_pos', TMP_DummyLocation_end_pos_4 = function $$end_pos() {\n            var self = this;\n\n            return 0\n          }, TMP_DummyLocation_end_pos_4.$$arity = 0);\n          \n          Opal.defn(self, '$source', TMP_DummyLocation_source_5 = function $$source() {\n            var self = this;\n\n            return \"\"\n          }, TMP_DummyLocation_source_5.$$arity = 0);\n          \n          Opal.defn(self, '$line', TMP_DummyLocation_line_6 = function $$line() {\n            var self = this;\n\n            return 0\n          }, TMP_DummyLocation_line_6.$$arity = 0);\n          \n          Opal.defn(self, '$column', TMP_DummyLocation_column_7 = function $$column() {\n            var self = this;\n\n            return 0\n          }, TMP_DummyLocation_column_7.$$arity = 0);\n          return (Opal.defn(self, '$last_line', TMP_DummyLocation_last_line_8 = function $$last_line() {\n            var self = this;\n\n            return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY')\n          }, TMP_DummyLocation_last_line_8.$$arity = 0), nil) && 'last_line';\n        })($nesting[0], null, $nesting);\n        Opal.const_set($nesting[0], 'DUMMY_LOCATION', Opal.const_get_relative($nesting, 'DummyLocation').$new());\n        \n        Opal.defn(self, '$s', TMP_Base_s_9 = function $$s(type, $a_rest) {\n          var self = this, children, loc = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          children = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            children[$arg_idx - 1] = arguments[$arg_idx];\n          }\n          \n          loc = (function() {if ($truthy(self.$current_node())) {\n            return self.$current_node().$loc()\n            } else {\n            return Opal.const_get_relative($nesting, 'DUMMY_LOCATION')\n          }; return nil; })();\n          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Opal'), 'AST'), 'Node').$new(type, children, $hash2([\"location\"], {\"location\": loc}));\n        }, TMP_Base_s_9.$$arity = -2);\n        Opal.defs(self, '$s', TMP_Base_s_10 = function $$s(type, $a_rest) {\n          var self = this, children;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          children = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            children[$arg_idx - 1] = arguments[$arg_idx];\n          }\n          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Opal'), 'AST'), 'Node').$new(type, children, $hash2([\"location\"], {\"location\": Opal.const_get_relative($nesting, 'DUMMY_LOCATION')}))\n        }, TMP_Base_s_10.$$arity = -2);\n        Opal.alias(self, \"on_iter\", \"process_regular_node\");\n        Opal.alias(self, \"on_top\", \"process_regular_node\");\n        Opal.alias(self, \"on_zsuper\", \"process_regular_node\");\n        Opal.alias(self, \"on_jscall\", \"on_send\");\n        Opal.alias(self, \"on_jsattr\", \"process_regular_node\");\n        Opal.alias(self, \"on_jsattrasgn\", \"process_regular_node\");\n        Opal.alias(self, \"on_kwsplat\", \"process_regular_node\");\n        \n        Opal.defn(self, '$prepend_to_body', TMP_Base_prepend_to_body_11 = function $$prepend_to_body(body, node) {\n          var self = this;\n\n          if ($truthy(body['$nil?']())) {\n            return node\n          } else if ($truthy([\"begin\", \"kwbegin\"]['$include?'](body.$type()))) {\n            return body.$updated(nil, [node].concat(Opal.to_a(body)))\n            } else {\n            return self.$s(\"begin\", node, body)\n          }\n        }, TMP_Base_prepend_to_body_11.$$arity = 2);\n        \n        Opal.defn(self, '$append_to_body', TMP_Base_append_to_body_12 = function $$append_to_body(body, node) {\n          var self = this;\n\n          if ($truthy(body['$nil?']())) {\n            return node\n          } else if ($truthy([\"begin\", \"kwbegin\"]['$include?'](body.$type()))) {\n            return body.$updated(nil, [].concat(Opal.to_a(body)).concat([node]))\n            } else {\n            return self.$s(\"begin\", body, node)\n          }\n        }, TMP_Base_append_to_body_12.$$arity = 2);\n        self.$attr_accessor(\"current_node\");\n        return (Opal.defn(self, '$process', TMP_Base_process_13 = function $$process(node) {\n          var self = this, $iter = TMP_Base_process_13.$$p, $yield = $iter || nil, $writer = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_Base_process_13.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          return (function() { try {\n          \n          \n          $writer = [node];\n          $send(self, 'current_node=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          return $send(self, Opal.find_super_dispatcher(self, 'process', TMP_Base_process_13, false), $zuper, $iter);\n          } finally {\n            (($writer = [nil]), $send(self, 'current_node=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])\n          }; })()\n        }, TMP_Base_process_13.$$arity = 1), nil) && 'process';\n      })($nesting[0], Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Parser'), 'AST'), 'Processor'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriters/opal_engine_check\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$children', '$skip_check_present?', '$s', '$skip_check_present_not?', '$updated', '$process_all', '$==']);\n  \n  self.$require(\"opal/rewriters/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Rewriters, self = $Rewriters = $module($base, 'Rewriters');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $OpalEngineCheck(){};\n        var self = $OpalEngineCheck = $klass($base, $super, 'OpalEngineCheck', $OpalEngineCheck);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_OpalEngineCheck_on_if_1, TMP_OpalEngineCheck_skip_check_present$q_2, TMP_OpalEngineCheck_skip_check_present_not$q_3;\n\n        \n        \n        Opal.defn(self, '$on_if', TMP_OpalEngineCheck_on_if_1 = function $$on_if(node) {\n          var $a, self = this, test = nil, true_body = nil, false_body = nil;\n\n          \n          $a = [].concat(Opal.to_a(node.$children())), (test = ($a[0] == null ? nil : $a[0])), (true_body = ($a[1] == null ? nil : $a[1])), (false_body = ($a[2] == null ? nil : $a[2])), $a;\n          if ($truthy(self['$skip_check_present?'](test))) {\n            false_body = self.$s(\"nil\")};\n          if ($truthy(self['$skip_check_present_not?'](test))) {\n            true_body = self.$s(\"nil\")};\n          return node.$updated(nil, self.$process_all([test, true_body, false_body]));\n        }, TMP_OpalEngineCheck_on_if_1.$$arity = 1);\n        \n        Opal.defn(self, '$skip_check_present?', TMP_OpalEngineCheck_skip_check_present$q_2 = function(test) {\n          var $a, self = this;\n\n          return ($truthy($a = test['$=='](Opal.const_get_relative($nesting, 'RUBY_ENGINE_CHECK'))) ? $a : test['$=='](Opal.const_get_relative($nesting, 'RUBY_PLATFORM_CHECK')))\n        }, TMP_OpalEngineCheck_skip_check_present$q_2.$$arity = 1);\n        \n        Opal.defn(self, '$skip_check_present_not?', TMP_OpalEngineCheck_skip_check_present_not$q_3 = function(test) {\n          var $a, self = this;\n\n          return ($truthy($a = test['$=='](Opal.const_get_relative($nesting, 'RUBY_ENGINE_CHECK_NOT'))) ? $a : test['$=='](Opal.const_get_relative($nesting, 'RUBY_PLATFORM_CHECK_NOT')))\n        }, TMP_OpalEngineCheck_skip_check_present_not$q_3.$$arity = 1);\n        Opal.const_set($nesting[0], 'RUBY_ENGINE_CHECK', self.$s(\"send\", self.$s(\"const\", nil, \"RUBY_ENGINE\"), \"==\", self.$s(\"str\", \"opal\")));\n        Opal.const_set($nesting[0], 'RUBY_ENGINE_CHECK_NOT', self.$s(\"send\", self.$s(\"const\", nil, \"RUBY_ENGINE\"), \"!=\", self.$s(\"str\", \"opal\")));\n        Opal.const_set($nesting[0], 'RUBY_PLATFORM_CHECK', self.$s(\"send\", self.$s(\"const\", nil, \"RUBY_PLATFORM\"), \"==\", self.$s(\"str\", \"opal\")));\n        return Opal.const_set($nesting[0], 'RUBY_PLATFORM_CHECK_NOT', self.$s(\"send\", self.$s(\"const\", nil, \"RUBY_PLATFORM\"), \"!=\", self.$s(\"str\", \"opal\")));\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriters/for_rewriter\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$+', '$find', '$map', '$s', '$next_tmp', '$class', '$type', '$===', '$<<', '$prepend_to_body', '$private', '$attr_reader', '$new', '$process', '$to_a', '$result']);\n  \n  self.$require(\"opal/rewriters/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Rewriters, self = $Rewriters = $module($base, 'Rewriters');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $ForRewriter(){};\n        var self = $ForRewriter = $klass($base, $super, 'ForRewriter', $ForRewriter);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ForRewriter_reset_tmp_counter$B_1, TMP_ForRewriter_next_tmp_2, TMP_ForRewriter_on_for_4;\n\n        \n        Opal.defs(self, '$reset_tmp_counter!', TMP_ForRewriter_reset_tmp_counter$B_1 = function() {\n          var self = this;\n\n          return (self.counter = 0)\n        }, TMP_ForRewriter_reset_tmp_counter$B_1.$$arity = 0);\n        Opal.defs(self, '$next_tmp', TMP_ForRewriter_next_tmp_2 = function $$next_tmp() {\n          var $a, self = this;\n          if (self.counter == null) self.counter = nil;\n\n          \n          self.counter = ($truthy($a = self.counter) ? $a : 0);\n          self.counter = $rb_plus(self.counter, 1);\n          return \"\" + \"$for_tmp\" + (self.counter);\n        }, TMP_ForRewriter_next_tmp_2.$$arity = 0);\n        \n        Opal.defn(self, '$on_for', TMP_ForRewriter_on_for_4 = function $$on_for(node) {\n          var $a, TMP_3, self = this, loop_variable = nil, iterating_value = nil, loop_body = nil, iterating_lvars = nil, lvars_declared_in_body = nil, outer_assigns = nil, tmp_loop_variable = nil, get_tmp_loop_variable = nil, loop_variable_assignment = nil, $case = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (loop_variable = ($a[0] == null ? nil : $a[0])), (iterating_value = ($a[1] == null ? nil : $a[1])), (loop_body = ($a[2] == null ? nil : $a[2])), $a;\n          iterating_lvars = Opal.const_get_relative($nesting, 'LocalVariableAssigns').$find(loop_variable);\n          lvars_declared_in_body = Opal.const_get_relative($nesting, 'LocalVariableAssigns').$find(loop_body);\n          outer_assigns = $send($rb_plus(iterating_lvars, lvars_declared_in_body), 'map', [], (TMP_3 = function(lvar_name){var self = TMP_3.$$s || this;\nif (lvar_name == null) lvar_name = nil;\n          return self.$s(\"lvdeclare\", lvar_name)}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3));\n          tmp_loop_variable = self.$class().$next_tmp();\n          get_tmp_loop_variable = self.$s(\"js_tmp\", tmp_loop_variable);\n          loop_variable_assignment = (function() {$case = loop_variable.$type();\n          if (\"mlhs\"['$===']($case)) {return self.$s(\"masgn\", loop_variable, get_tmp_loop_variable)}\n          else {return loop_variable['$<<'](get_tmp_loop_variable)}})();\n          loop_body = self.$prepend_to_body(loop_body, loop_variable_assignment);\n          node = self.$s(\"send\", iterating_value, \"each\", self.$s(\"iter\", self.$s(\"args\", self.$s(\"arg\", tmp_loop_variable)), loop_body));\n          return $send(self, 's', [\"begin\"].concat(Opal.to_a(outer_assigns)).concat(node));\n        }, TMP_ForRewriter_on_for_4.$$arity = 1);\n        self.$private();\n        return (function($base, $super, $parent_nesting) {\n          function $LocalVariableAssigns(){};\n          var self = $LocalVariableAssigns = $klass($base, $super, 'LocalVariableAssigns', $LocalVariableAssigns);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_LocalVariableAssigns_find_5, TMP_LocalVariableAssigns_initialize_6, TMP_LocalVariableAssigns_on_lvasgn_7;\n\n          \n          self.$attr_reader(\"result\");\n          Opal.defs(self, '$find', TMP_LocalVariableAssigns_find_5 = function $$find(node) {\n            var self = this, processor = nil;\n\n            \n            processor = self.$new();\n            processor.$process(node);\n            return processor.$result().$to_a();\n          }, TMP_LocalVariableAssigns_find_5.$$arity = 1);\n          \n          Opal.defn(self, '$initialize', TMP_LocalVariableAssigns_initialize_6 = function $$initialize() {\n            var self = this;\n\n            return (self.result = Opal.const_get_relative($nesting, 'Set').$new())\n          }, TMP_LocalVariableAssigns_initialize_6.$$arity = 0);\n          return (Opal.defn(self, '$on_lvasgn', TMP_LocalVariableAssigns_on_lvasgn_7 = function $$on_lvasgn(node) {\n            var $a, self = this, $iter = TMP_LocalVariableAssigns_on_lvasgn_7.$$p, $yield = $iter || nil, name = nil, _ = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n            if ($iter) TMP_LocalVariableAssigns_on_lvasgn_7.$$p = null;\n            // Prepare super implicit arguments\n            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n              $zuper[$zuper_i] = arguments[$zuper_i];\n            }\n            \n            $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n            self.$result()['$<<'](name);\n            return $send(self, Opal.find_super_dispatcher(self, 'on_lvasgn', TMP_LocalVariableAssigns_on_lvasgn_7, false), $zuper, $iter);\n          }, TMP_LocalVariableAssigns_on_lvasgn_7.$$arity = 1), nil) && 'on_lvasgn';\n        })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriters/explicit_writer_return\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$s', '$=~', '$to_s', '$==', '$process_all', '$updated']);\n  \n  self.$require(\"opal/rewriters/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Rewriters, self = $Rewriters = $module($base, 'Rewriters');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $ExplicitWriterReturn(){};\n        var self = $ExplicitWriterReturn = $klass($base, $super, 'ExplicitWriterReturn', $ExplicitWriterReturn);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ExplicitWriterReturn_initialize_1, TMP_ExplicitWriterReturn_on_send_2, TMP_ExplicitWriterReturn_on_masgn_3;\n\n        def.in_masgn = nil;\n        \n        \n        Opal.defn(self, '$initialize', TMP_ExplicitWriterReturn_initialize_1 = function $$initialize() {\n          var self = this;\n\n          return (self.in_masgn = false)\n        }, TMP_ExplicitWriterReturn_initialize_1.$$arity = 0);\n        Opal.const_set($nesting[0], 'TMP_NAME', \"$writer\");\n        Opal.const_set($nesting[0], 'GET_ARGS_NODE', self.$s(\"lvar\", Opal.const_get_relative($nesting, 'TMP_NAME')));\n        Opal.const_set($nesting[0], 'RETURN_ARGS_NODE', self.$s(\"jsattr\", Opal.const_get_relative($nesting, 'GET_ARGS_NODE'), self.$s(\"send\", self.$s(\"jsattr\", Opal.const_get_relative($nesting, 'GET_ARGS_NODE'), self.$s(\"str\", \"length\")), \"-\", self.$s(\"int\", 1))));\n        \n        Opal.defn(self, '$on_send', TMP_ExplicitWriterReturn_on_send_2 = function $$on_send(node) {\n          var $a, self = this, $iter = TMP_ExplicitWriterReturn_on_send_2.$$p, $yield = $iter || nil, recv = nil, method_name = nil, args = nil, set_args_node = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_ExplicitWriterReturn_on_send_2.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          if ($truthy(self.in_masgn)) {\n            return $send(self, Opal.find_super_dispatcher(self, 'on_send', TMP_ExplicitWriterReturn_on_send_2, false), $zuper, $iter)};\n          $a = [].concat(Opal.to_a(node)), (recv = ($a[0] == null ? nil : $a[0])), (method_name = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;\n          if ($truthy(($truthy($a = method_name.$to_s()['$=~'](new RegExp(\"\" + (Opal.const_get_relative($nesting, 'REGEXP_START')) + \"\\\\w+=\" + (Opal.const_get_relative($nesting, 'REGEXP_END'))))) ? $a : method_name.$to_s()['$=='](\"[]=\")))) {\n            \n            set_args_node = self.$s(\"lvasgn\", Opal.const_get_relative($nesting, 'TMP_NAME'), $send(self, 's', [\"array\"].concat(Opal.to_a(self.$process_all(args)))));\n            return self.$s(\"begin\", set_args_node, node.$updated(nil, [recv, method_name, self.$s(\"splat\", Opal.const_get_relative($nesting, 'GET_ARGS_NODE'))]), Opal.const_get_relative($nesting, 'RETURN_ARGS_NODE'));\n            } else {\n            return $send(self, Opal.find_super_dispatcher(self, 'on_send', TMP_ExplicitWriterReturn_on_send_2, false), $zuper, $iter)\n          };\n        }, TMP_ExplicitWriterReturn_on_send_2.$$arity = 1);\n        return (Opal.defn(self, '$on_masgn', TMP_ExplicitWriterReturn_on_masgn_3 = function $$on_masgn(node) {\n          var self = this, $iter = TMP_ExplicitWriterReturn_on_masgn_3.$$p, $yield = $iter || nil, result = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_ExplicitWriterReturn_on_masgn_3.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          self.in_masgn = true;\n          result = $send(self, Opal.find_super_dispatcher(self, 'on_masgn', TMP_ExplicitWriterReturn_on_masgn_3, false), $zuper, $iter);\n          self.in_masgn = false;\n          return result;\n        }, TMP_ExplicitWriterReturn_on_masgn_3.$$arity = 1), nil) && 'on_masgn';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriters/js_reserved_words\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$=~', '$!', '$valid_name?', '$class', '$to_sym', '$valid_ivar_name?', '$[]', '$to_s', '$updated', '$fix_var_name', '$fix_ivar_name']);\n  \n  self.$require(\"opal/rewriters/base\");\n  self.$require(\"opal/regexp_anchors\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Rewriters, self = $Rewriters = $module($base, 'Rewriters');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $JsReservedWords(){};\n        var self = $JsReservedWords = $klass($base, $super, 'JsReservedWords', $JsReservedWords);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_JsReservedWords_valid_name$q_1, TMP_JsReservedWords_valid_ivar_name$q_2, TMP_JsReservedWords_fix_var_name_3, TMP_JsReservedWords_fix_ivar_name_4, TMP_JsReservedWords_on_lvar_5, TMP_JsReservedWords_on_lvasgn_6, TMP_JsReservedWords_on_ivar_7, TMP_JsReservedWords_on_ivasgn_8, TMP_JsReservedWords_on_restarg_9, TMP_JsReservedWords_on_argument_10;\n\n        \n        Opal.const_set($nesting[0], 'ES51_RESERVED_WORD', new RegExp(\"\" + (Opal.const_get_relative($nesting, 'REGEXP_START')) + \"(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)\" + (Opal.const_get_relative($nesting, 'REGEXP_END'))));\n        Opal.const_set($nesting[0], 'ES3_RESERVED_WORD_EXCLUSIVE', new RegExp(\"\" + (Opal.const_get_relative($nesting, 'REGEXP_START')) + \"(?:int|byte|char|goto|long|final|float|short|double|native|throws|boolean|abstract|volatile|transient|synchronized)\" + (Opal.const_get_relative($nesting, 'REGEXP_END'))));\n        Opal.const_set($nesting[0], 'PROTO_SPECIAL_PROPS', new RegExp(\"\" + (Opal.const_get_relative($nesting, 'REGEXP_START')) + \"(?:constructor|displayName|__proto__|__parent__|__noSuchMethod__|__count__)\" + (Opal.const_get_relative($nesting, 'REGEXP_END'))));\n        Opal.const_set($nesting[0], 'PROTO_SPECIAL_METHODS', new RegExp(\"\" + (Opal.const_get_relative($nesting, 'REGEXP_START')) + \"(?:hasOwnProperty|valueOf)\" + (Opal.const_get_relative($nesting, 'REGEXP_END'))));\n        Opal.const_set($nesting[0], 'IMMUTABLE_PROPS', new RegExp(\"\" + (Opal.const_get_relative($nesting, 'REGEXP_START')) + \"(?:NaN|Infinity|undefined)\" + (Opal.const_get_relative($nesting, 'REGEXP_END'))));\n        Opal.const_set($nesting[0], 'BASIC_IDENTIFIER_RULES', new RegExp(\"\" + (Opal.const_get_relative($nesting, 'REGEXP_START')) + \"[$_a-z][$_a-z\\\\d]*\" + (Opal.const_get_relative($nesting, 'REGEXP_END')), 'i'));\n        Opal.const_set($nesting[0], 'RESERVED_FUNCTION_NAMES', new RegExp(\"\" + (Opal.const_get_relative($nesting, 'REGEXP_START')) + \"(?:Array)\" + (Opal.const_get_relative($nesting, 'REGEXP_END'))));\n        Opal.defs(self, '$valid_name?', TMP_JsReservedWords_valid_name$q_1 = function(name) {\n          var $a, $b, $c, self = this;\n\n          return ($truthy($a = Opal.const_get_relative($nesting, 'BASIC_IDENTIFIER_RULES')['$=~'](name)) ? ($truthy($b = ($truthy($c = Opal.const_get_relative($nesting, 'ES51_RESERVED_WORD')['$=~'](name)) ? $c : Opal.const_get_relative($nesting, 'ES3_RESERVED_WORD_EXCLUSIVE')['$=~'](name))) ? $b : Opal.const_get_relative($nesting, 'IMMUTABLE_PROPS')['$=~'](name))['$!']() : $a)\n        }, TMP_JsReservedWords_valid_name$q_1.$$arity = 1);\n        Opal.defs(self, '$valid_ivar_name?', TMP_JsReservedWords_valid_ivar_name$q_2 = function(name) {\n          var $a, self = this;\n\n          return ($truthy($a = Opal.const_get_relative($nesting, 'PROTO_SPECIAL_PROPS')['$=~'](name)) ? $a : Opal.const_get_relative($nesting, 'PROTO_SPECIAL_METHODS')['$=~'](name))['$!']()\n        }, TMP_JsReservedWords_valid_ivar_name$q_2.$$arity = 1);\n        \n        Opal.defn(self, '$fix_var_name', TMP_JsReservedWords_fix_var_name_3 = function $$fix_var_name(name) {\n          var self = this;\n\n          if ($truthy(self.$class()['$valid_name?'](name))) {\n            return name\n            } else {\n            return ((\"\" + (name)) + \"$\").$to_sym()\n          }\n        }, TMP_JsReservedWords_fix_var_name_3.$$arity = 1);\n        \n        Opal.defn(self, '$fix_ivar_name', TMP_JsReservedWords_fix_ivar_name_4 = function $$fix_ivar_name(name) {\n          var self = this;\n\n          if ($truthy(self.$class()['$valid_ivar_name?'](name.$to_s()['$[]']($range(1, -1, false))))) {\n            return name\n            } else {\n            return ((\"\" + (name)) + \"$\").$to_sym()\n          }\n        }, TMP_JsReservedWords_fix_ivar_name_4.$$arity = 1);\n        \n        Opal.defn(self, '$on_lvar', TMP_JsReservedWords_on_lvar_5 = function $$on_lvar(node) {\n          var $a, self = this, $iter = TMP_JsReservedWords_on_lvar_5.$$p, $yield = $iter || nil, name = nil, _ = nil;\n\n          if ($iter) TMP_JsReservedWords_on_lvar_5.$$p = null;\n          \n          $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n          node = node.$updated(nil, [self.$fix_var_name(name)]);\n          return $send(self, Opal.find_super_dispatcher(self, 'on_lvar', TMP_JsReservedWords_on_lvar_5, false), [node], null);\n        }, TMP_JsReservedWords_on_lvar_5.$$arity = 1);\n        \n        Opal.defn(self, '$on_lvasgn', TMP_JsReservedWords_on_lvasgn_6 = function $$on_lvasgn(node) {\n          var $a, self = this, $iter = TMP_JsReservedWords_on_lvasgn_6.$$p, $yield = $iter || nil, name = nil, value = nil;\n\n          if ($iter) TMP_JsReservedWords_on_lvasgn_6.$$p = null;\n          \n          $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;\n          if ($truthy(value)) {\n            node = node.$updated(nil, [self.$fix_var_name(name), value])\n            } else {\n            node = node.$updated(nil, [self.$fix_var_name(name)])\n          };\n          return $send(self, Opal.find_super_dispatcher(self, 'on_lvasgn', TMP_JsReservedWords_on_lvasgn_6, false), [node], null);\n        }, TMP_JsReservedWords_on_lvasgn_6.$$arity = 1);\n        \n        Opal.defn(self, '$on_ivar', TMP_JsReservedWords_on_ivar_7 = function $$on_ivar(node) {\n          var $a, self = this, $iter = TMP_JsReservedWords_on_ivar_7.$$p, $yield = $iter || nil, name = nil, _ = nil;\n\n          if ($iter) TMP_JsReservedWords_on_ivar_7.$$p = null;\n          \n          $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n          node = node.$updated(nil, [self.$fix_ivar_name(name)]);\n          return $send(self, Opal.find_super_dispatcher(self, 'on_ivar', TMP_JsReservedWords_on_ivar_7, false), [node], null);\n        }, TMP_JsReservedWords_on_ivar_7.$$arity = 1);\n        \n        Opal.defn(self, '$on_ivasgn', TMP_JsReservedWords_on_ivasgn_8 = function $$on_ivasgn(node) {\n          var $a, self = this, $iter = TMP_JsReservedWords_on_ivasgn_8.$$p, $yield = $iter || nil, name = nil, value = nil;\n\n          if ($iter) TMP_JsReservedWords_on_ivasgn_8.$$p = null;\n          \n          $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;\n          if ($truthy(value)) {\n            node = node.$updated(nil, [self.$fix_ivar_name(name), value])\n            } else {\n            node = node.$updated(nil, [self.$fix_ivar_name(name)])\n          };\n          return $send(self, Opal.find_super_dispatcher(self, 'on_ivasgn', TMP_JsReservedWords_on_ivasgn_8, false), [node], null);\n        }, TMP_JsReservedWords_on_ivasgn_8.$$arity = 1);\n        \n        Opal.defn(self, '$on_restarg', TMP_JsReservedWords_on_restarg_9 = function $$on_restarg(node) {\n          var $a, self = this, name = nil, _ = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n          if ($truthy(name)) {\n            node = node.$updated(nil, [self.$fix_var_name(name)], $hash2([\"meta\"], {\"meta\": $hash2([\"arg_name\"], {\"arg_name\": name})}))};\n          return node;\n        }, TMP_JsReservedWords_on_restarg_9.$$arity = 1);\n        return (Opal.defn(self, '$on_argument', TMP_JsReservedWords_on_argument_10 = function $$on_argument(node) {\n          var $a, self = this, $iter = TMP_JsReservedWords_on_argument_10.$$p, $yield = $iter || nil, name = nil, value = nil, fixed_name = nil, new_children = nil;\n\n          if ($iter) TMP_JsReservedWords_on_argument_10.$$p = null;\n          \n          node = $send(self, Opal.find_super_dispatcher(self, 'on_argument', TMP_JsReservedWords_on_argument_10, false), [node], null);\n          $a = [].concat(Opal.to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;\n          fixed_name = self.$fix_var_name(name);\n          new_children = (function() {if ($truthy(value)) {\n            return [fixed_name, value]\n            } else {\n            return [fixed_name]\n          }; return nil; })();\n          return node.$updated(nil, new_children, $hash2([\"meta\"], {\"meta\": $hash2([\"arg_name\"], {\"arg_name\": name})}));\n        }, TMP_JsReservedWords_on_argument_10.$$arity = 1), nil) && 'on_argument';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriters/block_to_iter\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$s', '$updated', '$+', '$children']);\n  \n  self.$require(\"opal/rewriters/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Rewriters, self = $Rewriters = $module($base, 'Rewriters');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $BlockToIter(){};\n        var self = $BlockToIter = $klass($base, $super, 'BlockToIter', $BlockToIter);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BlockToIter_on_block_1;\n\n        return (Opal.defn(self, '$on_block', TMP_BlockToIter_on_block_1 = function $$on_block(node) {\n          var $a, self = this, $iter = TMP_BlockToIter_on_block_1.$$p, $yield = $iter || nil, recvr = nil, args = nil, body = nil, iter_node = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_BlockToIter_on_block_1.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $a = [].concat(Opal.to_a($send(self, Opal.find_super_dispatcher(self, 'on_block', TMP_BlockToIter_on_block_1, false), $zuper, $iter))), (recvr = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), $a;\n          iter_node = self.$s(\"iter\", args, body);\n          return recvr.$updated(nil, $rb_plus(recvr.$children(), [iter_node]));\n        }, TMP_BlockToIter_on_block_1.$$arity = 1), nil) && 'on_block'\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriters/dot_js_syntax\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$==', '$type', '$===', '$!=', '$size', '$raise', '$first', '$to_js_attr_call', '$to_js_attr_assign_call', '$to_native_js_call', '$s']);\n  \n  self.$require(\"opal/rewriters/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Rewriters, self = $Rewriters = $module($base, 'Rewriters');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $DotJsSyntax(){};\n        var self = $DotJsSyntax = $klass($base, $super, 'DotJsSyntax', $DotJsSyntax);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DotJsSyntax_on_send_1, TMP_DotJsSyntax_to_native_js_call_2, TMP_DotJsSyntax_to_js_attr_call_3, TMP_DotJsSyntax_to_js_attr_assign_call_4;\n\n        \n        \n        Opal.defn(self, '$on_send', TMP_DotJsSyntax_on_send_1 = function $$on_send(node) {\n          var $a, self = this, $iter = TMP_DotJsSyntax_on_send_1.$$p, $yield = $iter || nil, recv = nil, meth = nil, args = nil, recv_of_recv = nil, meth_of_recv = nil, _ = nil, $case = nil, property = nil, value = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_DotJsSyntax_on_send_1.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $a = [].concat(Opal.to_a(node)), (recv = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;\n          if ($truthy(($truthy($a = recv) ? recv.$type()['$=='](\"send\") : $a))) {\n            \n            $a = [].concat(Opal.to_a(recv)), (recv_of_recv = ($a[0] == null ? nil : $a[0])), (meth_of_recv = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), $a;\n            if (meth_of_recv['$=='](\"JS\")) {\n              \n              $case = meth;\n              if (\"[]\"['$===']($case)) {\n              if ($truthy(args.$size()['$!='](1))) {\n                self.$raise(Opal.const_get_relative($nesting, 'SyntaxError'), \".JS[:property] syntax supports only one argument\")};\n              property = args.$first();\n              node = self.$to_js_attr_call(recv_of_recv, property);}\n              else if (\"[]=\"['$===']($case)) {\n              if ($truthy(args.$size()['$!='](2))) {\n                self.$raise(Opal.const_get_relative($nesting, 'SyntaxError'), \".JS[:property]= syntax supports only two arguments\")};\n              $a = [].concat(Opal.to_a(args)), (property = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;\n              node = self.$to_js_attr_assign_call(recv_of_recv, property, value);}\n              else {node = self.$to_native_js_call(recv_of_recv, meth, args)};\n              return $send(self, Opal.find_super_dispatcher(self, 'on_send', TMP_DotJsSyntax_on_send_1, false), [node], null);\n              } else {\n              return $send(self, Opal.find_super_dispatcher(self, 'on_send', TMP_DotJsSyntax_on_send_1, false), $zuper, $iter)\n            };\n            } else {\n            return $send(self, Opal.find_super_dispatcher(self, 'on_send', TMP_DotJsSyntax_on_send_1, false), $zuper, $iter)\n          };\n        }, TMP_DotJsSyntax_on_send_1.$$arity = 1);\n        \n        Opal.defn(self, '$to_native_js_call', TMP_DotJsSyntax_to_native_js_call_2 = function $$to_native_js_call(recv, meth, args) {\n          var self = this;\n\n          return $send(self, 's', [\"jscall\", recv, meth].concat(Opal.to_a(args)))\n        }, TMP_DotJsSyntax_to_native_js_call_2.$$arity = 3);\n        \n        Opal.defn(self, '$to_js_attr_call', TMP_DotJsSyntax_to_js_attr_call_3 = function $$to_js_attr_call(recv, property) {\n          var self = this;\n\n          return self.$s(\"jsattr\", recv, property)\n        }, TMP_DotJsSyntax_to_js_attr_call_3.$$arity = 2);\n        return (Opal.defn(self, '$to_js_attr_assign_call', TMP_DotJsSyntax_to_js_attr_assign_call_4 = function $$to_js_attr_assign_call(recv, property, value) {\n          var self = this;\n\n          return self.$s(\"jsattrasgn\", recv, property, value)\n        }, TMP_DotJsSyntax_to_js_attr_assign_call_4.$$arity = 3), nil) && 'to_js_attr_assign_call';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriters/logical_operator_assignment\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$+', '$lambda', '$updated', '$s', '$[]', '$==', '$type', '$new_temp', '$call', '$fetch', '$raise', '$process', '$include?']);\n  \n  self.$require(\"opal/rewriters/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Rewriters, self = $Rewriters = $module($base, 'Rewriters');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $LogicalOperatorAssignment(){};\n        var self = $LogicalOperatorAssignment = $klass($base, $super, 'LogicalOperatorAssignment', $LogicalOperatorAssignment);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_LogicalOperatorAssignment_reset_tmp_counter$B_1, TMP_LogicalOperatorAssignment_new_temp_2, TMP_LogicalOperatorAssignment_3, TMP_LogicalOperatorAssignment_on_or_asgn_8, TMP_LogicalOperatorAssignment_on_and_asgn_10, TMP_LogicalOperatorAssignment_on_defined$q_11;\n\n        \n        Opal.defs(self, '$reset_tmp_counter!', TMP_LogicalOperatorAssignment_reset_tmp_counter$B_1 = function() {\n          var self = this;\n\n          return (Opal.class_variable_set($LogicalOperatorAssignment, '@@counter', 0))\n        }, TMP_LogicalOperatorAssignment_reset_tmp_counter$B_1.$$arity = 0);\n        Opal.defs(self, '$new_temp', TMP_LogicalOperatorAssignment_new_temp_2 = function $$new_temp() {\n          var $a, $b, self = this;\n\n          \n          (Opal.class_variable_set($LogicalOperatorAssignment, '@@counter', ($truthy($a = (($b = $LogicalOperatorAssignment.$$cvars['@@counter']) == null ? nil : $b)) ? $a : 0)));\n          (Opal.class_variable_set($LogicalOperatorAssignment, '@@counter', $rb_plus((($a = $LogicalOperatorAssignment.$$cvars['@@counter']) == null ? nil : $a), 1)));\n          return \"\" + \"$logical_op_recvr_tmp_\" + ((($a = $LogicalOperatorAssignment.$$cvars['@@counter']) == null ? nil : $a));\n        }, TMP_LogicalOperatorAssignment_new_temp_2.$$arity = 0);\n        Opal.const_set($nesting[0], 'GET_SET', $send(self, 'lambda', [], (TMP_LogicalOperatorAssignment_3 = function(get_type, set_type){var self = TMP_LogicalOperatorAssignment_3.$$s || this, TMP_4;\nif (get_type == null) get_type = nil;if (set_type == null) set_type = nil;\n        return $send(self, 'lambda', [], (TMP_4 = function(lhs, rhs, root_type){var self = TMP_4.$$s || this, get_node = nil, condition_node = nil;\nif (lhs == null) lhs = nil;if (rhs == null) rhs = nil;if (root_type == null) root_type = nil;\n          \n            get_node = lhs.$updated(get_type);\n            condition_node = self.$s(root_type, get_node, rhs);\n            return lhs.$updated(set_type, [].concat(Opal.to_a(lhs)).concat([condition_node]));}, TMP_4.$$s = self, TMP_4.$$arity = 3, TMP_4))}, TMP_LogicalOperatorAssignment_3.$$s = self, TMP_LogicalOperatorAssignment_3.$$arity = 2, TMP_LogicalOperatorAssignment_3)));\n        Opal.const_set($nesting[0], 'LocalVariableHandler', Opal.const_get_relative($nesting, 'GET_SET')['$[]'](\"lvar\", \"lvasgn\"));\n        Opal.const_set($nesting[0], 'InstanceVariableHandler', Opal.const_get_relative($nesting, 'GET_SET')['$[]'](\"ivar\", \"ivasgn\"));\n        Opal.const_set($nesting[0], 'ConstantHandler', Opal.const_get_relative($nesting, 'GET_SET')['$[]'](\"const\", \"casgn\"));\n        Opal.const_set($nesting[0], 'GlobalVariableHandler', Opal.const_get_relative($nesting, 'GET_SET')['$[]'](\"gvar\", \"gvasgn\"));\n        Opal.const_set($nesting[0], 'ClassVariableHandler', Opal.const_get_relative($nesting, 'GET_SET')['$[]'](\"cvar\", \"cvasgn\"));\n        (function($base, $super, $parent_nesting) {\n          function $SendHandler(){};\n          var self = $SendHandler = $klass($base, $super, 'SendHandler', $SendHandler);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SendHandler_call_5;\n\n          return Opal.defs(self, '$call', TMP_SendHandler_call_5 = function $$call(lhs, rhs, root_type) {\n            var $a, self = this, recvr = nil, reader_method = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, writer_method = nil, call_reader = nil, call_writer = nil, get_or_set = nil;\n\n            \n            $a = [].concat(Opal.to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (reader_method = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;\n            if ($truthy(($truthy($a = recvr) ? recvr.$type()['$=='](\"send\") : $a))) {\n              \n              recvr_tmp = self.$new_temp();\n              cache_recvr = self.$s(\"lvasgn\", recvr_tmp, recvr);\n              recvr = self.$s(\"js_tmp\", recvr_tmp);};\n            writer_method = \"\" + (reader_method) + \"=\";\n            call_reader = lhs.$updated(\"send\", [recvr, reader_method].concat(Opal.to_a(args)));\n            call_writer = lhs.$updated(\"send\", [recvr, writer_method].concat(Opal.to_a(args)).concat([rhs]));\n            get_or_set = self.$s(root_type, call_reader, call_writer);\n            if ($truthy(cache_recvr)) {\n              return self.$s(\"begin\", cache_recvr, get_or_set)\n              } else {\n              return get_or_set\n            };\n          }, TMP_SendHandler_call_5.$$arity = 3)\n        })($nesting[0], self, $nesting);\n        (function($base, $super, $parent_nesting) {\n          function $ConditionalSendHandler(){};\n          var self = $ConditionalSendHandler = $klass($base, $super, 'ConditionalSendHandler', $ConditionalSendHandler);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ConditionalSendHandler_call_6;\n\n          return Opal.defs(self, '$call', TMP_ConditionalSendHandler_call_6 = function $$call(lhs, rhs, root_type) {\n            var $a, self = this, recvr = nil, meth = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, recvr_is_nil = nil, plain_send = nil, plain_or_asgn = nil;\n\n            \n            root_type = \"\" + (root_type) + \"_asgn\";\n            $a = [].concat(Opal.to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;\n            recvr_tmp = self.$new_temp();\n            cache_recvr = self.$s(\"lvasgn\", recvr_tmp, recvr);\n            recvr = self.$s(\"js_tmp\", recvr_tmp);\n            recvr_is_nil = self.$s(\"send\", recvr, \"nil?\");\n            plain_send = lhs.$updated(\"send\", [recvr, meth].concat(Opal.to_a(args)));\n            plain_or_asgn = self.$s(root_type, plain_send, rhs);\n            return self.$s(\"begin\", cache_recvr, self.$s(\"if\", recvr_is_nil, self.$s(\"nil\"), plain_or_asgn));\n          }, TMP_ConditionalSendHandler_call_6.$$arity = 3)\n        })($nesting[0], self, $nesting);\n        Opal.const_set($nesting[0], 'HANDLERS', $hash2([\"lvasgn\", \"ivasgn\", \"casgn\", \"gvasgn\", \"cvasgn\", \"send\", \"csend\"], {\"lvasgn\": Opal.const_get_relative($nesting, 'LocalVariableHandler'), \"ivasgn\": Opal.const_get_relative($nesting, 'InstanceVariableHandler'), \"casgn\": Opal.const_get_relative($nesting, 'ConstantHandler'), \"gvasgn\": Opal.const_get_relative($nesting, 'GlobalVariableHandler'), \"cvasgn\": Opal.const_get_relative($nesting, 'ClassVariableHandler'), \"send\": Opal.const_get_relative($nesting, 'SendHandler'), \"csend\": Opal.const_get_relative($nesting, 'ConditionalSendHandler')}));\n        \n        Opal.defn(self, '$on_or_asgn', TMP_LogicalOperatorAssignment_on_or_asgn_8 = function $$on_or_asgn(node) {\n          var $a, TMP_7, self = this, lhs = nil, rhs = nil, result = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;\n          result = $send(Opal.const_get_relative($nesting, 'HANDLERS'), 'fetch', [lhs.$type()], (TMP_7 = function(){var self = TMP_7.$$s || this;\n\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7)).$call(lhs, rhs, \"or\");\n          return self.$process(result);\n        }, TMP_LogicalOperatorAssignment_on_or_asgn_8.$$arity = 1);\n        \n        Opal.defn(self, '$on_and_asgn', TMP_LogicalOperatorAssignment_on_and_asgn_10 = function $$on_and_asgn(node) {\n          var $a, TMP_9, self = this, lhs = nil, rhs = nil, result = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;\n          result = $send(Opal.const_get_relative($nesting, 'HANDLERS'), 'fetch', [lhs.$type()], (TMP_9 = function(){var self = TMP_9.$$s || this;\n\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))}, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9)).$call(lhs, rhs, \"and\");\n          return self.$process(result);\n        }, TMP_LogicalOperatorAssignment_on_and_asgn_10.$$arity = 1);\n        Opal.const_set($nesting[0], 'ASSIGNMENT_STRING_NODE', self.$s(\"str\", \"assignment\"));\n        return (Opal.defn(self, '$on_defined?', TMP_LogicalOperatorAssignment_on_defined$q_11 = function(node) {\n          var $a, self = this, $iter = TMP_LogicalOperatorAssignment_on_defined$q_11.$$p, $yield = $iter || nil, inner = nil, _ = nil;\n\n          if ($iter) TMP_LogicalOperatorAssignment_on_defined$q_11.$$p = null;\n          \n          $a = [].concat(Opal.to_a(node)), (inner = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n          if ($truthy([\"or_asgn\", \"and_asgn\"]['$include?'](inner.$type()))) {\n            return Opal.const_get_relative($nesting, 'ASSIGNMENT_STRING_NODE')\n            } else {\n            return $send(self, Opal.find_super_dispatcher(self, 'on_defined?', TMP_LogicalOperatorAssignment_on_defined$q_11, false), [node], null)\n          };\n        }, TMP_LogicalOperatorAssignment_on_defined$q_11.$$arity = 1), nil) && 'on_defined?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriters/binary_operator_assignment\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$+', '$lambda', '$updated', '$s', '$[]', '$==', '$type', '$new_temp', '$call', '$fetch', '$raise', '$process']);\n  \n  self.$require(\"opal/rewriters/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Rewriters, self = $Rewriters = $module($base, 'Rewriters');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $BinaryOperatorAssignment(){};\n        var self = $BinaryOperatorAssignment = $klass($base, $super, 'BinaryOperatorAssignment', $BinaryOperatorAssignment);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BinaryOperatorAssignment_reset_tmp_counter$B_1, TMP_BinaryOperatorAssignment_new_temp_2, TMP_BinaryOperatorAssignment_3, TMP_BinaryOperatorAssignment_on_op_asgn_8, TMP_BinaryOperatorAssignment_on_defined$q_9;\n\n        \n        Opal.defs(self, '$reset_tmp_counter!', TMP_BinaryOperatorAssignment_reset_tmp_counter$B_1 = function() {\n          var self = this;\n\n          return (Opal.class_variable_set($BinaryOperatorAssignment, '@@counter', 0))\n        }, TMP_BinaryOperatorAssignment_reset_tmp_counter$B_1.$$arity = 0);\n        Opal.defs(self, '$new_temp', TMP_BinaryOperatorAssignment_new_temp_2 = function $$new_temp() {\n          var $a, $b, self = this;\n\n          \n          (Opal.class_variable_set($BinaryOperatorAssignment, '@@counter', ($truthy($a = (($b = $BinaryOperatorAssignment.$$cvars['@@counter']) == null ? nil : $b)) ? $a : 0)));\n          (Opal.class_variable_set($BinaryOperatorAssignment, '@@counter', $rb_plus((($a = $BinaryOperatorAssignment.$$cvars['@@counter']) == null ? nil : $a), 1)));\n          return \"\" + \"$binary_op_recvr_tmp_\" + ((($a = $BinaryOperatorAssignment.$$cvars['@@counter']) == null ? nil : $a));\n        }, TMP_BinaryOperatorAssignment_new_temp_2.$$arity = 0);\n        Opal.const_set($nesting[0], 'GET_SET', $send(self, 'lambda', [], (TMP_BinaryOperatorAssignment_3 = function(get_type, set_type){var self = TMP_BinaryOperatorAssignment_3.$$s || this, TMP_4;\nif (get_type == null) get_type = nil;if (set_type == null) set_type = nil;\n        return $send(self, 'lambda', [], (TMP_4 = function(lhs, op, rhs){var self = TMP_4.$$s || this, get_node = nil, set_node = nil;\nif (lhs == null) lhs = nil;if (op == null) op = nil;if (rhs == null) rhs = nil;\n          \n            get_node = lhs.$updated(get_type);\n            set_node = self.$s(\"send\", get_node, op, rhs);\n            return lhs.$updated(set_type, [].concat(Opal.to_a(lhs)).concat([set_node]));}, TMP_4.$$s = self, TMP_4.$$arity = 3, TMP_4))}, TMP_BinaryOperatorAssignment_3.$$s = self, TMP_BinaryOperatorAssignment_3.$$arity = 2, TMP_BinaryOperatorAssignment_3)));\n        Opal.const_set($nesting[0], 'LocalVariableHandler', Opal.const_get_relative($nesting, 'GET_SET')['$[]'](\"lvar\", \"lvasgn\"));\n        Opal.const_set($nesting[0], 'InstanceVariableHandler', Opal.const_get_relative($nesting, 'GET_SET')['$[]'](\"ivar\", \"ivasgn\"));\n        Opal.const_set($nesting[0], 'ConstantHandler', Opal.const_get_relative($nesting, 'GET_SET')['$[]'](\"const\", \"casgn\"));\n        Opal.const_set($nesting[0], 'GlobalVariableHandler', Opal.const_get_relative($nesting, 'GET_SET')['$[]'](\"gvar\", \"gvasgn\"));\n        Opal.const_set($nesting[0], 'ClassVariableHandler', Opal.const_get_relative($nesting, 'GET_SET')['$[]'](\"cvar\", \"cvasgn\"));\n        (function($base, $super, $parent_nesting) {\n          function $SendHandler(){};\n          var self = $SendHandler = $klass($base, $super, 'SendHandler', $SendHandler);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SendHandler_call_5;\n\n          return Opal.defs(self, '$call', TMP_SendHandler_call_5 = function $$call(lhs, op, rhs) {\n            var $a, self = this, recvr = nil, reader_method = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, writer_method = nil, call_reader = nil, call_op = nil, call_writer = nil;\n\n            \n            $a = [].concat(Opal.to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (reader_method = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;\n            if ($truthy(($truthy($a = recvr) ? recvr.$type()['$=='](\"send\") : $a))) {\n              \n              recvr_tmp = self.$new_temp();\n              cache_recvr = self.$s(\"lvasgn\", recvr_tmp, recvr);\n              recvr = self.$s(\"js_tmp\", recvr_tmp);};\n            writer_method = \"\" + (reader_method) + \"=\";\n            call_reader = lhs.$updated(\"send\", [recvr, reader_method].concat(Opal.to_a(args)));\n            call_op = self.$s(\"send\", call_reader, op, rhs);\n            call_writer = lhs.$updated(\"send\", [recvr, writer_method].concat(Opal.to_a(args)).concat([call_op]));\n            if ($truthy(cache_recvr)) {\n              return self.$s(\"begin\", cache_recvr, call_writer)\n              } else {\n              return call_writer\n            };\n          }, TMP_SendHandler_call_5.$$arity = 3)\n        })($nesting[0], self, $nesting);\n        (function($base, $super, $parent_nesting) {\n          function $ConditionalSendHandler(){};\n          var self = $ConditionalSendHandler = $klass($base, $super, 'ConditionalSendHandler', $ConditionalSendHandler);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ConditionalSendHandler_call_6;\n\n          return Opal.defs(self, '$call', TMP_ConditionalSendHandler_call_6 = function $$call(lhs, op, rhs) {\n            var $a, self = this, recvr = nil, meth = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, recvr_is_nil = nil, plain_send = nil, plain_op_asgn = nil;\n\n            \n            $a = [].concat(Opal.to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;\n            recvr_tmp = self.$new_temp();\n            cache_recvr = self.$s(\"lvasgn\", recvr_tmp, recvr);\n            recvr = self.$s(\"js_tmp\", recvr_tmp);\n            recvr_is_nil = self.$s(\"send\", recvr, \"nil?\");\n            plain_send = lhs.$updated(\"send\", [recvr, meth].concat(Opal.to_a(args)));\n            plain_op_asgn = self.$s(\"op_asgn\", plain_send, op, rhs);\n            return self.$s(\"begin\", cache_recvr, self.$s(\"if\", recvr_is_nil, self.$s(\"nil\"), plain_op_asgn));\n          }, TMP_ConditionalSendHandler_call_6.$$arity = 3)\n        })($nesting[0], self, $nesting);\n        Opal.const_set($nesting[0], 'HANDLERS', $hash2([\"lvasgn\", \"ivasgn\", \"casgn\", \"gvasgn\", \"cvasgn\", \"send\", \"csend\"], {\"lvasgn\": Opal.const_get_relative($nesting, 'LocalVariableHandler'), \"ivasgn\": Opal.const_get_relative($nesting, 'InstanceVariableHandler'), \"casgn\": Opal.const_get_relative($nesting, 'ConstantHandler'), \"gvasgn\": Opal.const_get_relative($nesting, 'GlobalVariableHandler'), \"cvasgn\": Opal.const_get_relative($nesting, 'ClassVariableHandler'), \"send\": Opal.const_get_relative($nesting, 'SendHandler'), \"csend\": Opal.const_get_relative($nesting, 'ConditionalSendHandler')}));\n        \n        Opal.defn(self, '$on_op_asgn', TMP_BinaryOperatorAssignment_on_op_asgn_8 = function $$on_op_asgn(node) {\n          var $a, TMP_7, self = this, lhs = nil, op = nil, rhs = nil, result = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (lhs = ($a[0] == null ? nil : $a[0])), (op = ($a[1] == null ? nil : $a[1])), (rhs = ($a[2] == null ? nil : $a[2])), $a;\n          result = $send(Opal.const_get_relative($nesting, 'HANDLERS'), 'fetch', [lhs.$type()], (TMP_7 = function(){var self = TMP_7.$$s || this;\n\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7)).$call(lhs, op, rhs);\n          return self.$process(result);\n        }, TMP_BinaryOperatorAssignment_on_op_asgn_8.$$arity = 1);\n        Opal.const_set($nesting[0], 'ASSIGNMENT_STRING_NODE', self.$s(\"str\", \"assignment\"));\n        return (Opal.defn(self, '$on_defined?', TMP_BinaryOperatorAssignment_on_defined$q_9 = function(node) {\n          var $a, self = this, $iter = TMP_BinaryOperatorAssignment_on_defined$q_9.$$p, $yield = $iter || nil, inner = nil, _ = nil;\n\n          if ($iter) TMP_BinaryOperatorAssignment_on_defined$q_9.$$p = null;\n          \n          $a = [].concat(Opal.to_a(node)), (inner = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n          if (inner.$type()['$=='](\"op_asgn\")) {\n            return Opal.const_get_relative($nesting, 'ASSIGNMENT_STRING_NODE')\n            } else {\n            return $send(self, Opal.find_super_dispatcher(self, 'on_defined?', TMP_BinaryOperatorAssignment_on_defined$q_9, false), [node], null)\n          };\n        }, TMP_BinaryOperatorAssignment_on_defined$q_9.$$arity = 1), nil) && 'on_defined?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriters/hashes/key_duplicates_rewriter\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$new', '$include?', '$type', '$<<', '$==', '$process_regular_node', '$updated', '$inspect', '$warn']);\n  \n  self.$require(\"opal/rewriters/base\");\n  self.$require(\"set\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Rewriters, self = $Rewriters = $module($base, 'Rewriters');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $parent_nesting) {\n        var $Hashes, self = $Hashes = $module($base, 'Hashes');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        (function($base, $super, $parent_nesting) {\n          function $KeyDuplicatesRewriter(){};\n          var self = $KeyDuplicatesRewriter = $klass($base, $super, 'KeyDuplicatesRewriter', $KeyDuplicatesRewriter);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_KeyDuplicatesRewriter_initialize_1, TMP_KeyDuplicatesRewriter_on_hash_2, TMP_KeyDuplicatesRewriter_on_pair_3, TMP_KeyDuplicatesRewriter_on_kwsplat_4;\n\n          def.keys = nil;\n          \n          \n          Opal.defn(self, '$initialize', TMP_KeyDuplicatesRewriter_initialize_1 = function $$initialize() {\n            var self = this;\n\n            return (self.keys = Opal.const_get_relative($nesting, 'UniqKeysSet').$new())\n          }, TMP_KeyDuplicatesRewriter_initialize_1.$$arity = 0);\n          \n          Opal.defn(self, '$on_hash', TMP_KeyDuplicatesRewriter_on_hash_2 = function $$on_hash(node) {\n            var $a, self = this, $iter = TMP_KeyDuplicatesRewriter_on_hash_2.$$p, $yield = $iter || nil, previous_keys = nil;\n\n            if ($iter) TMP_KeyDuplicatesRewriter_on_hash_2.$$p = null;\n            return (function() { try {\n            \n            $a = [self.keys, Opal.const_get_relative($nesting, 'UniqKeysSet').$new()], (previous_keys = $a[0]), (self.keys = $a[1]), $a;\n            return $send(self, Opal.find_super_dispatcher(self, 'on_hash', TMP_KeyDuplicatesRewriter_on_hash_2, false), [node], null);\n            } finally {\n              (self.keys = previous_keys)\n            }; })()\n          }, TMP_KeyDuplicatesRewriter_on_hash_2.$$arity = 1);\n          \n          Opal.defn(self, '$on_pair', TMP_KeyDuplicatesRewriter_on_pair_3 = function $$on_pair(node) {\n            var $a, self = this, $iter = TMP_KeyDuplicatesRewriter_on_pair_3.$$p, $yield = $iter || nil, key = nil, _value = nil;\n\n            if ($iter) TMP_KeyDuplicatesRewriter_on_pair_3.$$p = null;\n            \n            $a = [].concat(Opal.to_a(node)), (key = ($a[0] == null ? nil : $a[0])), (_value = ($a[1] == null ? nil : $a[1])), $a;\n            if ($truthy([\"str\", \"sym\"]['$include?'](key.$type()))) {\n              self.keys['$<<'](key)};\n            return $send(self, Opal.find_super_dispatcher(self, 'on_pair', TMP_KeyDuplicatesRewriter_on_pair_3, false), [node], null);\n          }, TMP_KeyDuplicatesRewriter_on_pair_3.$$arity = 1);\n          \n          Opal.defn(self, '$on_kwsplat', TMP_KeyDuplicatesRewriter_on_kwsplat_4 = function $$on_kwsplat(node) {\n            var $a, self = this, hash = nil, _ = nil;\n\n            \n            $a = [].concat(Opal.to_a(node)), (hash = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n            if (hash.$type()['$=='](\"hash\")) {\n              hash = self.$process_regular_node(hash)};\n            return node.$updated(nil, [hash]);\n          }, TMP_KeyDuplicatesRewriter_on_kwsplat_4.$$arity = 1);\n          return (function($base, $super, $parent_nesting) {\n            function $UniqKeysSet(){};\n            var self = $UniqKeysSet = $klass($base, $super, 'UniqKeysSet', $UniqKeysSet);\n\n            var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_UniqKeysSet_initialize_5, TMP_UniqKeysSet_$lt$lt_6;\n\n            def.set = nil;\n            \n            \n            Opal.defn(self, '$initialize', TMP_UniqKeysSet_initialize_5 = function $$initialize() {\n              var self = this;\n\n              return (self.set = Opal.const_get_relative($nesting, 'Set').$new())\n            }, TMP_UniqKeysSet_initialize_5.$$arity = 0);\n            return (Opal.defn(self, '$<<', TMP_UniqKeysSet_$lt$lt_6 = function(element) {\n              var $a, self = this, key = nil, _ = nil;\n\n              if ($truthy(self.set['$include?'](element))) {\n                \n                $a = [].concat(Opal.to_a(element)), (key = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n                key = (function() {if (element.$type()['$=='](\"str\")) {\n                  return key.$inspect()\n                  } else {\n                  return \"\" + \":\" + (key)\n                }; return nil; })();\n                return Opal.const_get_relative($nesting, 'Kernel').$warn(\"\" + \"warning: key \" + (key) + \" is duplicated and overwritten\");\n                } else {\n                return self.set['$<<'](element)\n              }\n            }, TMP_UniqKeysSet_$lt$lt_6.$$arity = 1), nil) && '<<';\n          })($nesting[0], null, $nesting);\n        })($nesting[0], Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Opal'), 'Rewriters'), 'Base'), $nesting)\n      })($nesting[0], $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriter\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$<<', '$list', '$delete', '$use', '$disabled?', '$class', '$each', '$new', '$process']);\n  \n  self.$require(\"opal/rewriters/opal_engine_check\");\n  self.$require(\"opal/rewriters/for_rewriter\");\n  self.$require(\"opal/rewriters/explicit_writer_return\");\n  self.$require(\"opal/rewriters/js_reserved_words\");\n  self.$require(\"opal/rewriters/block_to_iter\");\n  self.$require(\"opal/rewriters/dot_js_syntax\");\n  self.$require(\"opal/rewriters/logical_operator_assignment\");\n  self.$require(\"opal/rewriters/binary_operator_assignment\");\n  self.$require(\"opal/rewriters/hashes/key_duplicates_rewriter\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Rewriter(){};\n      var self = $Rewriter = $klass($base, $super, 'Rewriter', $Rewriter);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Rewriter_initialize_6, TMP_Rewriter_process_8;\n\n      def.sexp = nil;\n      \n      (function(self, $parent_nesting) {\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_list_1, TMP_use_2, TMP_delete_3, TMP_disable_4, TMP_disabled$q_5;\n\n        \n        \n        Opal.defn(self, '$list', TMP_list_1 = function $$list() {\n          var $a, self = this;\n          if (self.list == null) self.list = nil;\n\n          return (self.list = ($truthy($a = self.list) ? $a : []))\n        }, TMP_list_1.$$arity = 0);\n        \n        Opal.defn(self, '$use', TMP_use_2 = function $$use(rewriter) {\n          var self = this;\n\n          return self.$list()['$<<'](rewriter)\n        }, TMP_use_2.$$arity = 1);\n        \n        Opal.defn(self, '$delete', TMP_delete_3 = function(rewriter) {\n          var self = this;\n\n          return self.$list().$delete(rewriter)\n        }, TMP_delete_3.$$arity = 1);\n        \n        Opal.defn(self, '$disable', TMP_disable_4 = function $$disable() {\n          var self = this, $iter = TMP_disable_4.$$p, $yield = $iter || nil;\n\n          if ($iter) TMP_disable_4.$$p = null;\n          return (function() { try {\n          \n          self.disabled = true;\n          return Opal.yieldX($yield, []);;\n          } finally {\n            (self.disabled = false)\n          }; })()\n        }, TMP_disable_4.$$arity = 0);\n        return (Opal.defn(self, '$disabled?', TMP_disabled$q_5 = function() {\n          var $a, self = this;\n          if (self.disabled == null) self.disabled = nil;\n\n          if ($truthy((($a = self['disabled'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {\n            return self.disabled\n            } else {\n            return nil\n          }\n        }, TMP_disabled$q_5.$$arity = 0), nil) && 'disabled?';\n      })(Opal.get_singleton_class(self), $nesting);\n      self.$use(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriters'), 'OpalEngineCheck'));\n      self.$use(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriters'), 'ForRewriter'));\n      self.$use(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriters'), 'BlockToIter'));\n      self.$use(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriters'), 'DotJsSyntax'));\n      self.$use(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriters'), 'JsReservedWords'));\n      self.$use(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriters'), 'LogicalOperatorAssignment'));\n      self.$use(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriters'), 'BinaryOperatorAssignment'));\n      self.$use(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriters'), 'ExplicitWriterReturn'));\n      self.$use(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Rewriters'), 'Hashes'), 'KeyDuplicatesRewriter'));\n      \n      Opal.defn(self, '$initialize', TMP_Rewriter_initialize_6 = function $$initialize(sexp) {\n        var self = this;\n\n        return (self.sexp = sexp)\n      }, TMP_Rewriter_initialize_6.$$arity = 1);\n      return (Opal.defn(self, '$process', TMP_Rewriter_process_8 = function $$process() {\n        var TMP_7, self = this;\n\n        \n        if ($truthy(self.$class()['$disabled?']())) {\n          return self.sexp};\n        $send(self.$class().$list(), 'each', [], (TMP_7 = function(rewriter_class){var self = TMP_7.$$s || this, rewriter = nil;\n          if (self.sexp == null) self.sexp = nil;\nif (rewriter_class == null) rewriter_class = nil;\n        \n          rewriter = rewriter_class.$new();\n          return (self.sexp = rewriter.$process(self.sexp));}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));\n        return self.sexp;\n      }, TMP_Rewriter_process_8.$$arity = 0), nil) && 'process';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/parser\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$require', '$attr_accessor', '$all_errors_are_fatal=', '$diagnostics', '$-', '$ignore_warnings=', '$==', '$lambda', '$consumer=', '$puts', '$render', '$diagnostics_consumer=', '$new', '$rewrite', '$process']);\n  \n  self.$require(\"opal/ast/builder\");\n  self.$require(\"opal/rewriter\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    (function($base, $parent_nesting) {\n      var $Source, self = $Source = $module($base, 'Source');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Buffer(){};\n        var self = $Buffer = $klass($base, $super, 'Buffer', $Buffer);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Buffer_recognize_encoding_1;\n\n        return Opal.defs(self, '$recognize_encoding', TMP_Buffer_recognize_encoding_1 = function $$recognize_encoding(string) {\n          var $a, self = this, $iter = TMP_Buffer_recognize_encoding_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_Buffer_recognize_encoding_1.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          return ($truthy($a = $send(self, Opal.find_super_dispatcher(self, 'recognize_encoding', TMP_Buffer_recognize_encoding_1, false, $Buffer), $zuper, $iter)) ? $a : Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8'))\n        }, TMP_Buffer_recognize_encoding_1.$$arity = 1)\n      })($nesting[0], Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Parser'), 'Source'), 'Buffer'), $nesting)\n    })($nesting[0], $nesting);\n    (function($base, $super, $parent_nesting) {\n      function $Parser(){};\n      var self = $Parser = $klass($base, $super, 'Parser', $Parser);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Parser_4, TMP_Parser_initialize_5, TMP_Parser_parse_6, TMP_Parser_rewrite_7, $writer = nil;\n\n      \n      (function(self, $parent_nesting) {\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_default_parser_2;\n\n        \n        self.$attr_accessor(\"diagnostics_consumer\");\n        return (Opal.defn(self, '$default_parser', TMP_default_parser_2 = function $$default_parser() {\n          var TMP_3, self = this, $iter = TMP_default_parser_2.$$p, $yield = $iter || nil, parser = nil, $writer = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_default_parser_2.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          parser = $send(self, Opal.find_super_dispatcher(self, 'default_parser', TMP_default_parser_2, false), $zuper, $iter);\n          \n          $writer = [true];\n          $send(parser.$diagnostics(), 'all_errors_are_fatal=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [false];\n          $send(parser.$diagnostics(), 'ignore_warnings=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          if (Opal.const_get_relative($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n            \n            $writer = [$send(self, 'lambda', [], (TMP_3 = function(diag){var self = TMP_3.$$s || this;\nif (diag == null) diag = nil;\n            return nil}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))];\n            $send(parser.$diagnostics(), 'consumer=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n            } else {\n            nil\n          };\n          return parser;\n        }, TMP_default_parser_2.$$arity = 0), nil) && 'default_parser';\n      })(Opal.get_singleton_class(self), $nesting);\n      \n      $writer = [$send(self, 'lambda', [], (TMP_Parser_4 = function(diagnostic){var self = TMP_Parser_4.$$s || this;\n        if ($gvars.stderr == null) $gvars.stderr = nil;\nif (diagnostic == null) diagnostic = nil;\n      return $gvars.stderr.$puts(diagnostic.$render())}, TMP_Parser_4.$$s = self, TMP_Parser_4.$$arity = 1, TMP_Parser_4))];\n      $send(self, 'diagnostics_consumer=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      \n      Opal.defn(self, '$initialize', TMP_Parser_initialize_5 = function $$initialize($a_rest) {\n        var self = this, $iter = TMP_Parser_initialize_5.$$p, $yield = $iter || nil;\n\n        if ($iter) TMP_Parser_initialize_5.$$p = null;\n        return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Parser_initialize_5, false), [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'AST'), 'Builder').$new()], null)\n      }, TMP_Parser_initialize_5.$$arity = -1);\n      \n      Opal.defn(self, '$parse', TMP_Parser_parse_6 = function $$parse(source_buffer) {\n        var self = this, $iter = TMP_Parser_parse_6.$$p, $yield = $iter || nil, parsed = nil, rewriten = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_Parser_parse_6.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        \n        parsed = $send(self, Opal.find_super_dispatcher(self, 'parse', TMP_Parser_parse_6, false), $zuper, $iter);\n        rewriten = self.$rewrite(parsed);\n        return rewriten;\n      }, TMP_Parser_parse_6.$$arity = 1);\n      return (Opal.defn(self, '$rewrite', TMP_Parser_rewrite_7 = function $$rewrite(node) {\n        var self = this;\n\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'Rewriter').$new(node).$process()\n      }, TMP_Parser_rewrite_7.$$arity = 1), nil) && 'rewrite';\n    })($nesting[0], Opal.const_get_qualified(Opal.const_get_qualified('::', 'Parser'), 'Ruby23'), $nesting);\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/fragment\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$attr_reader', '$to_s', '$inspect', '$def?', '$find_parent_def', '$mid', '$line', '$column']);\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Fragment(){};\n      var self = $Fragment = $klass($base, $super, 'Fragment', $Fragment);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Fragment_initialize_1, TMP_Fragment_inspect_2, TMP_Fragment_source_map_name_3, TMP_Fragment_line_4, TMP_Fragment_column_5;\n\n      def.code = def.scope = def.sexp = nil;\n      \n      self.$attr_reader(\"code\");\n      \n      Opal.defn(self, '$initialize', TMP_Fragment_initialize_1 = function $$initialize(code, scope, sexp) {\n        var self = this;\n\n        if (sexp == null) {\n          sexp = nil;\n        }\n        \n        self.code = code.$to_s();\n        self.sexp = sexp;\n        return (self.scope = scope);\n      }, TMP_Fragment_initialize_1.$$arity = -3);\n      \n      Opal.defn(self, '$inspect', TMP_Fragment_inspect_2 = function $$inspect() {\n        var self = this;\n\n        return \"\" + \"f(\" + (self.code.$inspect()) + \")\"\n      }, TMP_Fragment_inspect_2.$$arity = 0);\n      \n      Opal.defn(self, '$source_map_name', TMP_Fragment_source_map_name_3 = function $$source_map_name() {\n        var $a, self = this, def_node = nil;\n\n        \n        if ($truthy(self.scope)) {\n          } else {\n          return nil\n        };\n        def_node = (function() {if ($truthy(self.scope['$def?']())) {\n          return self.scope\n          } else {\n          return self.scope.$find_parent_def()\n        }; return nil; })();\n        return ($truthy($a = def_node) ? def_node.$mid() : $a);\n      }, TMP_Fragment_source_map_name_3.$$arity = 0);\n      \n      Opal.defn(self, '$line', TMP_Fragment_line_4 = function $$line() {\n        var self = this;\n\n        if ($truthy(self.sexp)) {\n          return self.sexp.$line()\n          } else {\n          return nil\n        }\n      }, TMP_Fragment_line_4.$$arity = 0);\n      return (Opal.defn(self, '$column', TMP_Fragment_column_5 = function $$column() {\n        var self = this;\n\n        if ($truthy(self.sexp)) {\n          return self.sexp.$column()\n          } else {\n          return nil\n        }\n      }, TMP_Fragment_column_5.$$arity = 0), nil) && 'column';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/helpers\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$valid_name?', '$inspect', '$=~', '$to_s', '$+', '$indent', '$compiler', '$to_proc', '$parser_indent', '$push', '$current_indent', '$js_truthy_optimize', '$helper', '$fragment', '$expr', '$==', '$type', '$[]', '$children', '$uses_block!', '$scope', '$block_name', '$handlers', '$include?', '$truthy_optimize?', '$new_temp', '$wrap']);\n  \n  self.$require(\"opal/regexp_anchors\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $parent_nesting) {\n        var $Helpers, self = $Helpers = $module($base, 'Helpers');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Helpers_property_1, TMP_Helpers_valid_name$q_2, TMP_Helpers_mid_to_jsid_3, TMP_Helpers_indent_4, TMP_Helpers_current_indent_5, TMP_Helpers_line_6, TMP_Helpers_empty_line_7, TMP_Helpers_js_truthy_8, TMP_Helpers_js_falsy_9, TMP_Helpers_js_truthy_optimize_10, TMP_Helpers_conditional_send_11;\n\n        \n        \n        Opal.defn(self, '$property', TMP_Helpers_property_1 = function $$property(name) {\n          var self = this;\n\n          if ($truthy(self['$valid_name?'](name))) {\n            return \"\" + \".\" + (name)\n            } else {\n            return \"\" + \"[\" + (name.$inspect()) + \"]\"\n          }\n        }, TMP_Helpers_property_1.$$arity = 1);\n        \n        Opal.defn(self, '$valid_name?', TMP_Helpers_valid_name$q_2 = function(name) {\n          var self = this;\n\n          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'Rewriters'), 'JsReservedWords')['$valid_name?'](name)\n        }, TMP_Helpers_valid_name$q_2.$$arity = 1);\n        \n        Opal.defn(self, '$mid_to_jsid', TMP_Helpers_mid_to_jsid_3 = function $$mid_to_jsid(mid) {\n          var self = this;\n\n          if ($truthy(/\\=|\\+|\\-|\\*|\\/|\\!|\\?|<|\\>|\\&|\\||\\^|\\%|\\~|\\[/['$=~'](mid.$to_s()))) {\n            return \"\" + \"['$\" + (mid) + \"']\"\n            } else {\n            return $rb_plus(\".$\", mid)\n          }\n        }, TMP_Helpers_mid_to_jsid_3.$$arity = 1);\n        \n        Opal.defn(self, '$indent', TMP_Helpers_indent_4 = function $$indent() {\n          var self = this, $iter = TMP_Helpers_indent_4.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Helpers_indent_4.$$p = null;\n          return $send(self.$compiler(), 'indent', [], block.$to_proc())\n        }, TMP_Helpers_indent_4.$$arity = 0);\n        \n        Opal.defn(self, '$current_indent', TMP_Helpers_current_indent_5 = function $$current_indent() {\n          var self = this;\n\n          return self.$compiler().$parser_indent()\n        }, TMP_Helpers_current_indent_5.$$arity = 0);\n        \n        Opal.defn(self, '$line', TMP_Helpers_line_6 = function $$line($a_rest) {\n          var self = this, strs;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          strs = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            strs[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          self.$push(\"\" + \"\\n\" + (self.$current_indent()));\n          return $send(self, 'push', Opal.to_a(strs));\n        }, TMP_Helpers_line_6.$$arity = -1);\n        \n        Opal.defn(self, '$empty_line', TMP_Helpers_empty_line_7 = function $$empty_line() {\n          var self = this;\n\n          return self.$push(\"\\n\")\n        }, TMP_Helpers_empty_line_7.$$arity = 0);\n        \n        Opal.defn(self, '$js_truthy', TMP_Helpers_js_truthy_8 = function $$js_truthy(sexp) {\n          var self = this, optimize = nil;\n\n          \n          if ($truthy((optimize = self.$js_truthy_optimize(sexp)))) {\n            return optimize};\n          self.$helper(\"truthy\");\n          return [self.$fragment(\"$truthy(\"), self.$expr(sexp), self.$fragment(\")\")];\n        }, TMP_Helpers_js_truthy_8.$$arity = 1);\n        \n        Opal.defn(self, '$js_falsy', TMP_Helpers_js_falsy_9 = function $$js_falsy(sexp) {\n          var self = this, mid = nil;\n\n          \n          if (sexp.$type()['$=='](\"send\")) {\n            \n            mid = sexp.$children()['$[]'](1);\n            if (mid['$=='](\"block_given?\")) {\n              \n              self.$scope()['$uses_block!']();\n              return \"\" + (self.$scope().$block_name()) + \" === nil\";};};\n          self.$helper(\"falsy\");\n          return [self.$fragment(\"$falsy(\"), self.$expr(sexp), self.$fragment(\")\")];\n        }, TMP_Helpers_js_falsy_9.$$arity = 1);\n        \n        Opal.defn(self, '$js_truthy_optimize', TMP_Helpers_js_truthy_optimize_10 = function $$js_truthy_optimize(sexp) {\n          var $a, $b, self = this, mid = nil, receiver_handler_class = nil, receiver = nil, allow_optimization_on_type = nil;\n\n          if (sexp.$type()['$=='](\"send\")) {\n            \n            mid = sexp.$children()['$[]'](1);\n            receiver_handler_class = ($truthy($a = (receiver = sexp.$children()['$[]'](0))) ? self.$compiler().$handlers()['$[]'](receiver.$type()) : $a);\n            allow_optimization_on_type = ($truthy($a = ($truthy($b = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Compiler'), 'COMPARE')['$include?'](mid.$to_s())) ? receiver_handler_class : $b)) ? receiver_handler_class['$truthy_optimize?']() : $a);\n            if ($truthy(($truthy($a = ($truthy($b = allow_optimization_on_type) ? $b : mid['$=='](\"block_given?\"))) ? $a : mid['$=='](\"==\")))) {\n              return self.$expr(sexp)\n              } else {\n              return nil\n            };\n            } else {\n            return nil\n          }\n        }, TMP_Helpers_js_truthy_optimize_10.$$arity = 1);\n        \n        Opal.defn(self, '$conditional_send', TMP_Helpers_conditional_send_11 = function $$conditional_send(recvr) {\n          var self = this, $iter = TMP_Helpers_conditional_send_11.$$p, $yield = $iter || nil, receiver_temp = nil;\n\n          if ($iter) TMP_Helpers_conditional_send_11.$$p = null;\n          \n          receiver_temp = self.$scope().$new_temp();\n          self.$push(\"\" + (receiver_temp) + \" = \", recvr);\n          self.$push(\"\" + \", (\" + (receiver_temp) + \" === nil || \" + (receiver_temp) + \" == null) ? nil : \");\n          Opal.yield1($yield, receiver_temp);\n          return self.$wrap(\"(\", \")\");\n        }, TMP_Helpers_conditional_send_11.$$arity = 1);\n      })($nesting[0], $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/base\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$include', '$each', '$[]=', '$handlers', '$-', '$each_with_index', '$define_method', '$[]', '$children', '$attr_reader', '$type', '$compile', '$raise', '$is_a?', '$fragment', '$<<', '$reverse', '$unshift', '$push', '$new', '$scope', '$error', '$s', '$==', '$process', '$expr', '$add_scope_local', '$to_sym', '$add_scope_ivar', '$add_scope_gvar', '$add_scope_temp', '$helper', '$with_temp', '$to_proc', '$in_while?', '$instance_variable_get', '$has_rescue_else?', '$in_ensure', '$in_ensure?', '$!', '$class_scope?', '$parent', '$closest_module_node', '$name', '$comments', '$compiler', '$loc']);\n  \n  self.$require(\"opal/nodes/helpers\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Base(){};\n        var self = $Base = $klass($base, $super, 'Base', $Base);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Base_handlers_1, TMP_Base_handle_3, TMP_Base_children_6, TMP_Base_truthy_optimize$q_7, TMP_Base_initialize_8, TMP_Base_children_9, TMP_Base_compile_to_fragments_10, TMP_Base_compile_11, TMP_Base_push_13, TMP_Base_unshift_15, TMP_Base_wrap_16, TMP_Base_fragment_17, TMP_Base_error_18, TMP_Base_scope_19, TMP_Base_s_20, TMP_Base_expr$q_21, TMP_Base_recv$q_22, TMP_Base_stmt$q_23, TMP_Base_process_24, TMP_Base_expr_25, TMP_Base_recv_26, TMP_Base_stmt_27, TMP_Base_expr_or_nil_28, TMP_Base_add_local_29, TMP_Base_add_ivar_30, TMP_Base_add_gvar_31, TMP_Base_add_temp_32, TMP_Base_helper_33, TMP_Base_with_temp_34, TMP_Base_in_while$q_35, TMP_Base_while_loop_36, TMP_Base_has_rescue_else$q_37, TMP_Base_in_ensure_38, TMP_Base_in_ensure$q_39, TMP_Base_closest_module_node_40, TMP_Base_class_variable_owner_41, TMP_Base_comments_42;\n\n        def.sexp = def.fragments = def.compiler = def.level = nil;\n        \n        self.$include(Opal.const_get_relative($nesting, 'Helpers'));\n        Opal.defs(self, '$handlers', TMP_Base_handlers_1 = function $$handlers() {\n          var $a, self = this;\n          if (self.handlers == null) self.handlers = nil;\n\n          return (self.handlers = ($truthy($a = self.handlers) ? $a : $hash2([], {})))\n        }, TMP_Base_handlers_1.$$arity = 0);\n        Opal.defs(self, '$handle', TMP_Base_handle_3 = function $$handle($a_rest) {\n          var TMP_2, self = this, types;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          types = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            types[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return $send(types, 'each', [], (TMP_2 = function(type){var self = TMP_2.$$s || this, $writer = nil;\nif (type == null) type = nil;\n          \n            $writer = [type, self];\n            $send(Opal.const_get_relative($nesting, 'Base').$handlers(), '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))\n        }, TMP_Base_handle_3.$$arity = -1);\n        Opal.defs(self, '$children', TMP_Base_children_6 = function $$children($a_rest) {\n          var TMP_4, self = this, names;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          names = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            names[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return $send(names, 'each_with_index', [], (TMP_4 = function(name, idx){var self = TMP_4.$$s || this, TMP_5;\nif (name == null) name = nil;if (idx == null) idx = nil;\n          return $send(self, 'define_method', [name], (TMP_5 = function(){var self = TMP_5.$$s || this;\n              if (self.sexp == null) self.sexp = nil;\n\n            return self.sexp.$children()['$[]'](idx)}, TMP_5.$$s = self, TMP_5.$$arity = 0, TMP_5))}, TMP_4.$$s = self, TMP_4.$$arity = 2, TMP_4))\n        }, TMP_Base_children_6.$$arity = -1);\n        Opal.defs(self, '$truthy_optimize?', TMP_Base_truthy_optimize$q_7 = function() {\n          var self = this;\n\n          return false\n        }, TMP_Base_truthy_optimize$q_7.$$arity = 0);\n        self.$attr_reader(\"compiler\", \"type\");\n        \n        Opal.defn(self, '$initialize', TMP_Base_initialize_8 = function $$initialize(sexp, level, compiler) {\n          var self = this;\n\n          \n          self.sexp = sexp;\n          self.type = sexp.$type();\n          self.level = level;\n          return (self.compiler = compiler);\n        }, TMP_Base_initialize_8.$$arity = 3);\n        \n        Opal.defn(self, '$children', TMP_Base_children_9 = function $$children() {\n          var self = this;\n\n          return self.sexp.$children()\n        }, TMP_Base_children_9.$$arity = 0);\n        \n        Opal.defn(self, '$compile_to_fragments', TMP_Base_compile_to_fragments_10 = function $$compile_to_fragments() {\n          var $a, self = this;\n\n          \n          if ($truthy((($a = self['fragments'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {\n            return self.fragments};\n          self.fragments = [];\n          self.$compile();\n          return self.fragments;\n        }, TMP_Base_compile_to_fragments_10.$$arity = 0);\n        \n        Opal.defn(self, '$compile', TMP_Base_compile_11 = function $$compile() {\n          var self = this;\n\n          return self.$raise(\"Not Implemented\")\n        }, TMP_Base_compile_11.$$arity = 0);\n        \n        Opal.defn(self, '$push', TMP_Base_push_13 = function $$push($a_rest) {\n          var TMP_12, self = this, strs;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          strs = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            strs[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return $send(strs, 'each', [], (TMP_12 = function(str){var self = TMP_12.$$s || this;\n            if (self.fragments == null) self.fragments = nil;\nif (str == null) str = nil;\n          \n            if ($truthy(str['$is_a?'](Opal.const_get_relative($nesting, 'String')))) {\n              str = self.$fragment(str)};\n            return self.fragments['$<<'](str);}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12))\n        }, TMP_Base_push_13.$$arity = -1);\n        \n        Opal.defn(self, '$unshift', TMP_Base_unshift_15 = function $$unshift($a_rest) {\n          var TMP_14, self = this, strs;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          strs = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            strs[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return $send(strs.$reverse(), 'each', [], (TMP_14 = function(str){var self = TMP_14.$$s || this;\n            if (self.fragments == null) self.fragments = nil;\nif (str == null) str = nil;\n          \n            if ($truthy(str['$is_a?'](Opal.const_get_relative($nesting, 'String')))) {\n              str = self.$fragment(str)};\n            return self.fragments.$unshift(str);}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14))\n        }, TMP_Base_unshift_15.$$arity = -1);\n        \n        Opal.defn(self, '$wrap', TMP_Base_wrap_16 = function $$wrap(pre, post) {\n          var self = this;\n\n          \n          self.$unshift(pre);\n          return self.$push(post);\n        }, TMP_Base_wrap_16.$$arity = 2);\n        \n        Opal.defn(self, '$fragment', TMP_Base_fragment_17 = function $$fragment(str) {\n          var self = this;\n\n          return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'Fragment').$new(str, self.$scope(), self.sexp)\n        }, TMP_Base_fragment_17.$$arity = 1);\n        \n        Opal.defn(self, '$error', TMP_Base_error_18 = function $$error(msg) {\n          var self = this;\n\n          return self.compiler.$error(msg)\n        }, TMP_Base_error_18.$$arity = 1);\n        \n        Opal.defn(self, '$scope', TMP_Base_scope_19 = function $$scope() {\n          var self = this;\n\n          return self.compiler.$scope()\n        }, TMP_Base_scope_19.$$arity = 0);\n        \n        Opal.defn(self, '$s', TMP_Base_s_20 = function $$s($a_rest) {\n          var self = this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return $send(self.compiler, 's', Opal.to_a(args))\n        }, TMP_Base_s_20.$$arity = -1);\n        \n        Opal.defn(self, '$expr?', TMP_Base_expr$q_21 = function() {\n          var self = this;\n\n          return self.level['$=='](\"expr\")\n        }, TMP_Base_expr$q_21.$$arity = 0);\n        \n        Opal.defn(self, '$recv?', TMP_Base_recv$q_22 = function() {\n          var self = this;\n\n          return self.level['$=='](\"recv\")\n        }, TMP_Base_recv$q_22.$$arity = 0);\n        \n        Opal.defn(self, '$stmt?', TMP_Base_stmt$q_23 = function() {\n          var self = this;\n\n          return self.level['$=='](\"stmt\")\n        }, TMP_Base_stmt$q_23.$$arity = 0);\n        \n        Opal.defn(self, '$process', TMP_Base_process_24 = function $$process(sexp, level) {\n          var self = this;\n\n          if (level == null) {\n            level = \"expr\";\n          }\n          return self.compiler.$process(sexp, level)\n        }, TMP_Base_process_24.$$arity = -2);\n        \n        Opal.defn(self, '$expr', TMP_Base_expr_25 = function $$expr(sexp) {\n          var self = this;\n\n          return self.compiler.$process(sexp, \"expr\")\n        }, TMP_Base_expr_25.$$arity = 1);\n        \n        Opal.defn(self, '$recv', TMP_Base_recv_26 = function $$recv(sexp) {\n          var self = this;\n\n          return self.compiler.$process(sexp, \"recv\")\n        }, TMP_Base_recv_26.$$arity = 1);\n        \n        Opal.defn(self, '$stmt', TMP_Base_stmt_27 = function $$stmt(sexp) {\n          var self = this;\n\n          return self.compiler.$process(sexp, \"stmt\")\n        }, TMP_Base_stmt_27.$$arity = 1);\n        \n        Opal.defn(self, '$expr_or_nil', TMP_Base_expr_or_nil_28 = function $$expr_or_nil(sexp) {\n          var self = this;\n\n          if ($truthy(sexp)) {\n            return self.$expr(sexp)\n            } else {\n            return \"nil\"\n          }\n        }, TMP_Base_expr_or_nil_28.$$arity = 1);\n        \n        Opal.defn(self, '$add_local', TMP_Base_add_local_29 = function $$add_local(name) {\n          var self = this;\n\n          return self.$scope().$add_scope_local(name.$to_sym())\n        }, TMP_Base_add_local_29.$$arity = 1);\n        \n        Opal.defn(self, '$add_ivar', TMP_Base_add_ivar_30 = function $$add_ivar(name) {\n          var self = this;\n\n          return self.$scope().$add_scope_ivar(name)\n        }, TMP_Base_add_ivar_30.$$arity = 1);\n        \n        Opal.defn(self, '$add_gvar', TMP_Base_add_gvar_31 = function $$add_gvar(name) {\n          var self = this;\n\n          return self.$scope().$add_scope_gvar(name)\n        }, TMP_Base_add_gvar_31.$$arity = 1);\n        \n        Opal.defn(self, '$add_temp', TMP_Base_add_temp_32 = function $$add_temp(temp) {\n          var self = this;\n\n          return self.$scope().$add_scope_temp(temp)\n        }, TMP_Base_add_temp_32.$$arity = 1);\n        \n        Opal.defn(self, '$helper', TMP_Base_helper_33 = function $$helper(name) {\n          var self = this;\n\n          return self.compiler.$helper(name)\n        }, TMP_Base_helper_33.$$arity = 1);\n        \n        Opal.defn(self, '$with_temp', TMP_Base_with_temp_34 = function $$with_temp() {\n          var self = this, $iter = TMP_Base_with_temp_34.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Base_with_temp_34.$$p = null;\n          return $send(self.compiler, 'with_temp', [], block.$to_proc())\n        }, TMP_Base_with_temp_34.$$arity = 0);\n        \n        Opal.defn(self, '$in_while?', TMP_Base_in_while$q_35 = function() {\n          var self = this;\n\n          return self.compiler['$in_while?']()\n        }, TMP_Base_in_while$q_35.$$arity = 0);\n        \n        Opal.defn(self, '$while_loop', TMP_Base_while_loop_36 = function $$while_loop() {\n          var self = this;\n\n          return self.compiler.$instance_variable_get(\"@while_loop\")\n        }, TMP_Base_while_loop_36.$$arity = 0);\n        \n        Opal.defn(self, '$has_rescue_else?', TMP_Base_has_rescue_else$q_37 = function() {\n          var self = this;\n\n          return self.$scope()['$has_rescue_else?']()\n        }, TMP_Base_has_rescue_else$q_37.$$arity = 0);\n        \n        Opal.defn(self, '$in_ensure', TMP_Base_in_ensure_38 = function $$in_ensure() {\n          var self = this, $iter = TMP_Base_in_ensure_38.$$p, block = $iter || nil;\n\n          if ($iter) TMP_Base_in_ensure_38.$$p = null;\n          return $send(self.$scope(), 'in_ensure', [], block.$to_proc())\n        }, TMP_Base_in_ensure_38.$$arity = 0);\n        \n        Opal.defn(self, '$in_ensure?', TMP_Base_in_ensure$q_39 = function() {\n          var self = this;\n\n          return self.$scope()['$in_ensure?']()\n        }, TMP_Base_in_ensure$q_39.$$arity = 0);\n        \n        Opal.defn(self, '$closest_module_node', TMP_Base_closest_module_node_40 = function $$closest_module_node() {\n          var $a, $b, self = this, current = nil;\n\n          \n          current = self.$scope();\n          while ($truthy(($truthy($b = current) ? current['$class_scope?']()['$!']() : $b))) {\n            current = current.$parent()\n          };\n          return current;\n        }, TMP_Base_closest_module_node_40.$$arity = 0);\n        \n        Opal.defn(self, '$class_variable_owner', TMP_Base_class_variable_owner_41 = function $$class_variable_owner() {\n          var self = this;\n\n          if ($truthy(self.$closest_module_node())) {\n            return \"\" + \"$\" + (self.$closest_module_node().$name())\n            } else {\n            return \"Opal.Object\"\n          }\n        }, TMP_Base_class_variable_owner_41.$$arity = 0);\n        return (Opal.defn(self, '$comments', TMP_Base_comments_42 = function $$comments() {\n          var self = this;\n\n          return self.$compiler().$comments()['$[]'](self.sexp.$loc())\n        }, TMP_Base_comments_42.$$arity = 0), nil) && 'comments';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/literal\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$require', '$handle', '$push', '$to_s', '$type', '$children', '$value', '$recv?', '$wrap', '$join', '$keys', '$gsub', '$even?', '$length', '$+', '$chop', '$[]', '$encoding', '$!=', '$force_encoding', '$inspect', '$to_i', '$to_utf16', '$translate_escape_chars', '$name', '$lambda', '$upcase', '$<=', '$call', '$-', '$>>', '$&', '$attr_accessor', '$extract_flags_and_value', '$select!', '$flags', '$=~', '$warning', '$compiler', '$===', '$compile_dynamic_regexp', '$compile_static_regexp', '$any?', '$expr', '$new', '$map', '$to_proc', '$flags=', '$s', '$value=', '$include?', '$is_a?', '$==', '$updated', '$delete', '$source', '$expression', '$loc', '$regexp', '$each', '$first', '$raise', '$each_with_index', '$compile_inline?', '$helper', '$compile_inline', '$compile_range_initialize', '$start', '$finish', '$numerator', '$denominator', '$real', '$imag']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $ValueNode(){};\n        var self = $ValueNode = $klass($base, $super, 'ValueNode', $ValueNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ValueNode_compile_1, TMP_ValueNode_truthy_optimize$q_2;\n\n        \n        self.$handle(\"true\", \"false\", \"self\", \"nil\");\n        \n        Opal.defn(self, '$compile', TMP_ValueNode_compile_1 = function $$compile() {\n          var self = this;\n\n          return self.$push(self.$type().$to_s())\n        }, TMP_ValueNode_compile_1.$$arity = 0);\n        return Opal.defs(self, '$truthy_optimize?', TMP_ValueNode_truthy_optimize$q_2 = function() {\n          var self = this;\n\n          return true\n        }, TMP_ValueNode_truthy_optimize$q_2.$$arity = 0);\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $NumericNode(){};\n        var self = $NumericNode = $klass($base, $super, 'NumericNode', $NumericNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NumericNode_compile_3, TMP_NumericNode_truthy_optimize$q_4;\n\n        \n        self.$handle(\"int\", \"float\");\n        self.$children(\"value\");\n        \n        Opal.defn(self, '$compile', TMP_NumericNode_compile_3 = function $$compile() {\n          var self = this;\n\n          \n          self.$push(self.$value().$to_s());\n          if ($truthy(self['$recv?']())) {\n            return self.$wrap(\"(\", \")\")\n            } else {\n            return nil\n          };\n        }, TMP_NumericNode_compile_3.$$arity = 0);\n        return Opal.defs(self, '$truthy_optimize?', TMP_NumericNode_truthy_optimize$q_4 = function() {\n          var self = this;\n\n          return true\n        }, TMP_NumericNode_truthy_optimize$q_4.$$arity = 0);\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $StringNode(){};\n        var self = $StringNode = $klass($base, $super, 'StringNode', $StringNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_StringNode_translate_escape_chars_6, TMP_StringNode_compile_8, TMP_StringNode_to_utf16_10;\n\n        \n        self.$handle(\"str\");\n        self.$children(\"value\");\n        Opal.const_set($nesting[0], 'ESCAPE_CHARS', $hash2([\"a\", \"e\"], {\"a\": \"\\\\u0007\", \"e\": \"\\\\u001b\"}));\n        Opal.const_set($nesting[0], 'ESCAPE_REGEX', new RegExp(\"\" + \"(\\\\\\\\+)([\" + (Opal.const_get_relative($nesting, 'ESCAPE_CHARS').$keys().$join(\"\")) + \"])\"));\n        \n        Opal.defn(self, '$translate_escape_chars', TMP_StringNode_translate_escape_chars_6 = function $$translate_escape_chars(inspect_string) {\n          var TMP_5, self = this;\n\n          return $send(inspect_string, 'gsub', [Opal.const_get_relative($nesting, 'ESCAPE_REGEX')], (TMP_5 = function(original){var self = TMP_5.$$s || this, $a;\nif (original == null) original = nil;\n          if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$length()['$even?']())) {\n              return original\n              } else {\n              return $rb_plus((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$chop(), Opal.const_get_relative($nesting, 'ESCAPE_CHARS')['$[]']((($a = $gvars['~']) === nil ? nil : $a['$[]'](2))))\n            }}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5))\n        }, TMP_StringNode_translate_escape_chars_6.$$arity = 1);\n        \n        Opal.defn(self, '$compile', TMP_StringNode_compile_8 = function $$compile() {\n          var TMP_7, $a, self = this, string_value = nil, encoding = nil, should_encode = nil, sanitized_value = nil;\n\n          \n          string_value = self.$value();\n          encoding = string_value.$encoding();\n          should_encode = encoding['$!='](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_8'));\n          if ($truthy(should_encode)) {\n            string_value = string_value.$force_encoding(\"UTF-8\")};\n          sanitized_value = $send(string_value.$inspect(), 'gsub', [/\\\\u\\{([0-9a-f]+)\\}/], (TMP_7 = function(match){var self = TMP_7.$$s || this, $a, code_point = nil;\nif (match == null) match = nil;\n          \n            code_point = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$to_i(16);\n            return self.$to_utf16(code_point);}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));\n          self.$push(self.$translate_escape_chars(sanitized_value));\n          if ($truthy(($truthy($a = should_encode) ? Opal.const_get_relative($nesting, 'RUBY_ENGINE')['$!='](\"opal\") : $a))) {\n            return self.$push(\".$force_encoding(\\\"\", encoding.$name(), \"\\\")\")\n            } else {\n            return nil\n          };\n        }, TMP_StringNode_compile_8.$$arity = 0);\n        return (Opal.defn(self, '$to_utf16', TMP_StringNode_to_utf16_10 = function $$to_utf16(code_point) {\n          var TMP_9, self = this, ten_bits = nil, u = nil, lead_surrogate = nil, tail_surrogate = nil;\n\n          \n          ten_bits = 1023;\n          u = $send(self, 'lambda', [], (TMP_9 = function(code_unit){var self = TMP_9.$$s || this;\nif (code_unit == null) code_unit = nil;\n          return $rb_plus(\"\\\\u\", code_unit.$to_s(16).$upcase())}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9));\n          if ($truthy($rb_le(code_point, 65535))) {\n            return u.$call(code_point)};\n          code_point = $rb_minus(code_point, 65536);\n          lead_surrogate = $rb_plus(55296, code_point['$>>'](10));\n          tail_surrogate = $rb_plus(56320, code_point['$&'](ten_bits));\n          return $rb_plus(u.$call(lead_surrogate), u.$call(tail_surrogate));\n        }, TMP_StringNode_to_utf16_10.$$arity = 1), nil) && 'to_utf16';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $SymbolNode(){};\n        var self = $SymbolNode = $klass($base, $super, 'SymbolNode', $SymbolNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SymbolNode_compile_11;\n\n        \n        self.$handle(\"sym\");\n        self.$children(\"value\");\n        return (Opal.defn(self, '$compile', TMP_SymbolNode_compile_11 = function $$compile() {\n          var self = this;\n\n          return self.$push(self.$value().$to_s().$inspect())\n        }, TMP_SymbolNode_compile_11.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $RegexpNode(){};\n        var self = $RegexpNode = $klass($base, $super, 'RegexpNode', $RegexpNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_RegexpNode_initialize_12, TMP_RegexpNode_compile_14, TMP_RegexpNode_compile_dynamic_regexp_15, TMP_RegexpNode_compile_static_regexp_16, TMP_RegexpNode_extract_flags_and_value_18, TMP_RegexpNode_raw_value_19;\n\n        def.sexp = nil;\n        \n        self.$handle(\"regexp\");\n        self.$attr_accessor(\"value\", \"flags\");\n        Opal.const_set($nesting[0], 'SUPPORTED_FLAGS', /[gimuy]/);\n        \n        Opal.defn(self, '$initialize', TMP_RegexpNode_initialize_12 = function $$initialize($a_rest) {\n          var self = this, $iter = TMP_RegexpNode_initialize_12.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_RegexpNode_initialize_12.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_RegexpNode_initialize_12, false), $zuper, $iter);\n          return self.$extract_flags_and_value();\n        }, TMP_RegexpNode_initialize_12.$$arity = -1);\n        \n        Opal.defn(self, '$compile', TMP_RegexpNode_compile_14 = function $$compile() {\n          var TMP_13, self = this, $case = nil;\n\n          \n          $send(self.$flags(), 'select!', [], (TMP_13 = function(flag){var self = TMP_13.$$s || this;\nif (flag == null) flag = nil;\n          if ($truthy(Opal.const_get_relative($nesting, 'SUPPORTED_FLAGS')['$=~'](flag))) {\n              return true\n              } else {\n              \n              self.$compiler().$warning(\"\" + \"Skipping the '\" + (flag) + \"' Regexp flag as it's not widely supported by JavaScript vendors.\");\n              return false;\n            }}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13));\n          return (function() {$case = self.$value().$type();\n          if (\"dstr\"['$===']($case) || \"begin\"['$===']($case)) {return self.$compile_dynamic_regexp()}\n          else if (\"str\"['$===']($case)) {return self.$compile_static_regexp()}\n          else { return nil }})();\n        }, TMP_RegexpNode_compile_14.$$arity = 0);\n        \n        Opal.defn(self, '$compile_dynamic_regexp', TMP_RegexpNode_compile_dynamic_regexp_15 = function $$compile_dynamic_regexp() {\n          var self = this;\n\n          if ($truthy(self.$flags()['$any?']())) {\n            return self.$push(\"new RegExp(\", self.$expr(self.$value()), \"\" + \", '\" + (self.$flags().$join()) + \"')\")\n            } else {\n            return self.$push(\"new RegExp(\", self.$expr(self.$value()), \")\")\n          }\n        }, TMP_RegexpNode_compile_dynamic_regexp_15.$$arity = 0);\n        \n        Opal.defn(self, '$compile_static_regexp', TMP_RegexpNode_compile_static_regexp_16 = function $$compile_static_regexp() {\n          var self = this, value = nil, $case = nil, message = nil;\n\n          \n          value = self.$value().$children()['$[]'](0);\n          return (function() {$case = value;\n          if (\"\"['$===']($case)) {return self.$push(\"/(?:)/\")}\n          else if (/\\?<\\w+\\>/['$===']($case)) {\n          message = \"\" + \"named captures are not supported in javascript: \" + (value.$inspect());\n          return self.$push(\"\" + \"self.$raise(new SyntaxError('\" + (message) + \"'))\");}\n          else {return self.$push(\"\" + (Opal.const_get_relative($nesting, 'Regexp').$new(value).$inspect()) + (self.$flags().$join()))}})();\n        }, TMP_RegexpNode_compile_static_regexp_16.$$arity = 0);\n        \n        Opal.defn(self, '$extract_flags_and_value', TMP_RegexpNode_extract_flags_and_value_18 = function $$extract_flags_and_value() {\n          var $a, $b, TMP_17, self = this, values = nil, flags_sexp = nil, $writer = nil, $case = nil, parts = nil;\n\n          \n          $a = [].concat(Opal.to_a(self.$children())), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (values = $slice.call($a, 0, $b)), (flags_sexp = ($a[$b] == null ? nil : $a[$b])), $a;\n          \n          $writer = [$send(flags_sexp.$children(), 'map', [], \"to_s\".$to_proc())];\n          $send(self, 'flags=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          $case = values.$length();\n          if ((0)['$===']($case)) {\n          $writer = [self.$s(\"str\", \"\")];\n          $send(self, 'value=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];}\n          else if ((1)['$===']($case)) {\n          $writer = [values['$[]'](0)];\n          $send(self, 'value=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];}\n          else {\n          $writer = [$send(self, 's', [\"dstr\"].concat(Opal.to_a(values)))];\n          $send(self, 'value=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n          if ($truthy(self.$flags()['$include?'](\"x\"))) {\n            \n            parts = $send(self.$value().$children(), 'map', [], (TMP_17 = function(part){var self = TMP_17.$$s || this, $c, trimmed_value = nil;\nif (part == null) part = nil;\n            if ($truthy(($truthy($c = part['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Opal'), 'AST'), 'Node'))) ? part.$type()['$=='](\"str\") : $c))) {\n                \n                trimmed_value = part.$children()['$[]'](0).$gsub(/^\\s*\\#.*/, \"\").$gsub(/\\s/, \"\");\n                return self.$s(\"str\", trimmed_value);\n                } else {\n                return part\n              }}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17));\n            \n            $writer = [self.$value().$updated(nil, parts)];\n            $send(self, 'value=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.$flags().$delete(\"x\");};\n          if (self.$value().$type()['$=='](\"str\")) {\n            \n            $writer = [self.$s(\"str\", self.$value().$children()['$[]'](0).$gsub(\"\\\\A\", \"^\").$gsub(\"\\\\z\", \"$\"))];\n            $send(self, 'value=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n            } else {\n            return nil\n          };\n        }, TMP_RegexpNode_extract_flags_and_value_18.$$arity = 0);\n        return (Opal.defn(self, '$raw_value', TMP_RegexpNode_raw_value_19 = function $$raw_value() {\n          var self = this, $writer = nil;\n\n          \n          $writer = [self.sexp.$loc().$expression().$source()];\n          $send(self, 'value=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        }, TMP_RegexpNode_raw_value_19.$$arity = 0), nil) && 'raw_value';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $MatchCurrentLineNode(){};\n        var self = $MatchCurrentLineNode = $klass($base, $super, 'MatchCurrentLineNode', $MatchCurrentLineNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MatchCurrentLineNode_compile_20;\n\n        \n        self.$handle(\"match_current_line\");\n        self.$children(\"regexp\");\n        return (Opal.defn(self, '$compile', TMP_MatchCurrentLineNode_compile_20 = function $$compile() {\n          var self = this, gvar_sexp = nil, send_node = nil;\n\n          \n          gvar_sexp = self.$s(\"gvar\", \"$_\");\n          send_node = self.$s(\"send\", gvar_sexp, \"=~\", self.$regexp());\n          return self.$push(self.$expr(send_node));\n        }, TMP_MatchCurrentLineNode_compile_20.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $XStringNode(){};\n        var self = $XStringNode = $klass($base, $super, 'XStringNode', $XStringNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_XStringNode_compile_22;\n\n        \n        self.$handle(\"xstr\");\n        return (Opal.defn(self, '$compile', TMP_XStringNode_compile_22 = function $$compile() {\n          var TMP_21, self = this;\n\n          \n          $send(self.$children(), 'each', [], (TMP_21 = function(child){var self = TMP_21.$$s || this, $case = nil, value = nil, str = nil;\nif (child == null) child = nil;\n          return (function() {$case = child.$type();\n            if (\"str\"['$===']($case)) {\n            value = child.$loc().$expression().$source();\n            return self.$push(Opal.const_get_relative($nesting, 'Fragment').$new(value, nil));}\n            else if (\"begin\"['$===']($case)) {return self.$push(self.$expr(child))}\n            else if (\"gvar\"['$===']($case) || \"ivar\"['$===']($case)) {return self.$push(self.$expr(child))}\n            else if (\"js_return\"['$===']($case)) {\n            self.$push(\"return \");\n            str = child.$children().$first();\n            value = str.$loc().$expression().$source();\n            return self.$push(Opal.const_get_relative($nesting, 'Fragment').$new(value, nil));}\n            else {return self.$raise(\"\" + \"Unsupported xstr part: \" + (child.$type()))}})()}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21));\n          if ($truthy(self['$recv?']())) {\n            return self.$wrap(\"(\", \")\")\n            } else {\n            return nil\n          };\n        }, TMP_XStringNode_compile_22.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $DynamicStringNode(){};\n        var self = $DynamicStringNode = $klass($base, $super, 'DynamicStringNode', $DynamicStringNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DynamicStringNode_compile_24;\n\n        \n        self.$handle(\"dstr\");\n        return (Opal.defn(self, '$compile', TMP_DynamicStringNode_compile_24 = function $$compile() {\n          var TMP_23, self = this;\n\n          \n          self.$push(\"\\\"\\\"\");\n          return $send(self.$children(), 'each_with_index', [], (TMP_23 = function(part, idx){var self = TMP_23.$$s || this;\nif (part == null) part = nil;if (idx == null) idx = nil;\n          \n            self.$push(\" + \");\n            if (part.$type()['$=='](\"str\")) {\n              self.$push(part.$children()['$[]'](0).$inspect())\n              } else {\n              self.$push(\"(\", self.$expr(part), \")\")\n            };\n            if ($truthy(self['$recv?']())) {\n              return self.$wrap(\"(\", \")\")\n              } else {\n              return nil\n            };}, TMP_23.$$s = self, TMP_23.$$arity = 2, TMP_23));\n        }, TMP_DynamicStringNode_compile_24.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $DynamicSymbolNode(){};\n        var self = $DynamicSymbolNode = $klass($base, $super, 'DynamicSymbolNode', $DynamicSymbolNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return self.$handle(\"dsym\")\n      })($nesting[0], Opal.const_get_relative($nesting, 'DynamicStringNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $RangeNode(){};\n        var self = $RangeNode = $klass($base, $super, 'RangeNode', $RangeNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_RangeNode_compile_25, TMP_RangeNode_compile_inline$q_26, TMP_RangeNode_compile_inline_27, TMP_RangeNode_compile_range_initialize_28;\n\n        \n        self.$children(\"start\", \"finish\");\n        Opal.const_set($nesting[0], 'SIMPLE_CHILDREN_TYPES', [\"int\", \"float\", \"str\", \"sym\"]);\n        \n        Opal.defn(self, '$compile', TMP_RangeNode_compile_25 = function $$compile() {\n          var self = this;\n\n          if ($truthy(self['$compile_inline?']())) {\n            \n            self.$helper(\"range\");\n            return self.$compile_inline();\n            } else {\n            return self.$compile_range_initialize()\n          }\n        }, TMP_RangeNode_compile_25.$$arity = 0);\n        \n        Opal.defn(self, '$compile_inline?', TMP_RangeNode_compile_inline$q_26 = function() {\n          var $a, $b, self = this;\n\n          return ($truthy($a = (($b = self.$start().$type()['$=='](self.$finish().$type())) ? Opal.const_get_relative($nesting, 'SIMPLE_CHILDREN_TYPES')['$include?'](self.$start().$type()) : self.$start().$type()['$=='](self.$finish().$type()))) ? Opal.const_get_relative($nesting, 'SIMPLE_CHILDREN_TYPES')['$include?'](self.$finish().$type()) : $a)\n        }, TMP_RangeNode_compile_inline$q_26.$$arity = 0);\n        \n        Opal.defn(self, '$compile_inline', TMP_RangeNode_compile_inline_27 = function $$compile_inline() {\n          var self = this;\n\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n        }, TMP_RangeNode_compile_inline_27.$$arity = 0);\n        return (Opal.defn(self, '$compile_range_initialize', TMP_RangeNode_compile_range_initialize_28 = function $$compile_range_initialize() {\n          var self = this;\n\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n        }, TMP_RangeNode_compile_range_initialize_28.$$arity = 0), nil) && 'compile_range_initialize';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $InclusiveRangeNode(){};\n        var self = $InclusiveRangeNode = $klass($base, $super, 'InclusiveRangeNode', $InclusiveRangeNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_InclusiveRangeNode_compile_inline_29, TMP_InclusiveRangeNode_compile_range_initialize_30;\n\n        \n        self.$handle(\"irange\");\n        \n        Opal.defn(self, '$compile_inline', TMP_InclusiveRangeNode_compile_inline_29 = function $$compile_inline() {\n          var self = this;\n\n          return self.$push(\"$range(\", self.$expr(self.$start()), \", \", self.$expr(self.$finish()), \", false)\")\n        }, TMP_InclusiveRangeNode_compile_inline_29.$$arity = 0);\n        return (Opal.defn(self, '$compile_range_initialize', TMP_InclusiveRangeNode_compile_range_initialize_30 = function $$compile_range_initialize() {\n          var self = this;\n\n          return self.$push(\"Opal.Range.$new(\", self.$expr(self.$start()), \", \", self.$expr(self.$finish()), \", false)\")\n        }, TMP_InclusiveRangeNode_compile_range_initialize_30.$$arity = 0), nil) && 'compile_range_initialize';\n      })($nesting[0], Opal.const_get_relative($nesting, 'RangeNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $ExclusiveRangeNode(){};\n        var self = $ExclusiveRangeNode = $klass($base, $super, 'ExclusiveRangeNode', $ExclusiveRangeNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ExclusiveRangeNode_compile_inline_31, TMP_ExclusiveRangeNode_compile_range_initialize_32;\n\n        \n        self.$handle(\"erange\");\n        \n        Opal.defn(self, '$compile_inline', TMP_ExclusiveRangeNode_compile_inline_31 = function $$compile_inline() {\n          var self = this;\n\n          return self.$push(\"$range(\", self.$expr(self.$start()), \", \", self.$expr(self.$finish()), \", true)\")\n        }, TMP_ExclusiveRangeNode_compile_inline_31.$$arity = 0);\n        return (Opal.defn(self, '$compile_range_initialize', TMP_ExclusiveRangeNode_compile_range_initialize_32 = function $$compile_range_initialize() {\n          var self = this;\n\n          return self.$push(\"Opal.Range.$new(\", self.$expr(self.$start()), \",\", self.$expr(self.$finish()), \", true)\")\n        }, TMP_ExclusiveRangeNode_compile_range_initialize_32.$$arity = 0), nil) && 'compile_range_initialize';\n      })($nesting[0], Opal.const_get_relative($nesting, 'RangeNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $RationalNode(){};\n        var self = $RationalNode = $klass($base, $super, 'RationalNode', $RationalNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_RationalNode_compile_33;\n\n        \n        self.$handle(\"rational\");\n        self.$children(\"value\");\n        return (Opal.defn(self, '$compile', TMP_RationalNode_compile_33 = function $$compile() {\n          var self = this;\n\n          return self.$push(\"\" + \"Opal.Rational.$new(\" + (self.$value().$numerator()) + \", \" + (self.$value().$denominator()) + \")\")\n        }, TMP_RationalNode_compile_33.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $ComplexNode(){};\n        var self = $ComplexNode = $klass($base, $super, 'ComplexNode', $ComplexNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ComplexNode_compile_34;\n\n        \n        self.$handle(\"complex\");\n        self.$children(\"value\");\n        return (Opal.defn(self, '$compile', TMP_ComplexNode_compile_34 = function $$compile() {\n          var self = this;\n\n          return self.$push(\"\" + \"Opal.Complex.$new(\" + (self.$value().$real()) + \", \" + (self.$value().$imag()) + \")\")\n        }, TMP_ComplexNode_compile_34.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/variables\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$irb?', '$compiler', '$top?', '$scope', '$using_irb?', '$push', '$to_s', '$var_name', '$with_temp', '$property', '$wrap', '$add_local', '$expr', '$value', '$recv?', '$expr?', '$[]', '$name', '$add_ivar', '$helper', '$add_gvar', '$===', '$handle_global_match', '$handle_post_match', '$handle_pre_match', '$raise', '$index', '$class_variable_owner']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $LocalVariableNode(){};\n        var self = $LocalVariableNode = $klass($base, $super, 'LocalVariableNode', $LocalVariableNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_LocalVariableNode_using_irb$q_1, TMP_LocalVariableNode_compile_3;\n\n        \n        self.$handle(\"lvar\");\n        self.$children(\"var_name\");\n        \n        Opal.defn(self, '$using_irb?', TMP_LocalVariableNode_using_irb$q_1 = function() {\n          var $a, self = this;\n\n          return ($truthy($a = self.$compiler()['$irb?']()) ? self.$scope()['$top?']() : $a)\n        }, TMP_LocalVariableNode_using_irb$q_1.$$arity = 0);\n        return (Opal.defn(self, '$compile', TMP_LocalVariableNode_compile_3 = function $$compile() {\n          var TMP_2, self = this;\n\n          \n          if ($truthy(self['$using_irb?']())) {\n            } else {\n            return self.$push(self.$var_name().$to_s())\n          };\n          return $send(self, 'with_temp', [], (TMP_2 = function(tmp){var self = TMP_2.$$s || this;\nif (tmp == null) tmp = nil;\n          \n            self.$push(self.$property(self.$var_name().$to_s()));\n            return self.$wrap(\"\" + \"((\" + (tmp) + \" = Opal.irb_vars\", \"\" + \") == null ? nil : \" + (tmp) + \")\");}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));\n        }, TMP_LocalVariableNode_compile_3.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $LocalAssignNode(){};\n        var self = $LocalAssignNode = $klass($base, $super, 'LocalAssignNode', $LocalAssignNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_LocalAssignNode_using_irb$q_4, TMP_LocalAssignNode_compile_5;\n\n        \n        self.$handle(\"lvasgn\");\n        self.$children(\"var_name\", \"value\");\n        \n        Opal.defn(self, '$using_irb?', TMP_LocalAssignNode_using_irb$q_4 = function() {\n          var $a, self = this;\n\n          return ($truthy($a = self.$compiler()['$irb?']()) ? self.$scope()['$top?']() : $a)\n        }, TMP_LocalAssignNode_using_irb$q_4.$$arity = 0);\n        return (Opal.defn(self, '$compile', TMP_LocalAssignNode_compile_5 = function $$compile() {\n          var $a, $b, self = this;\n\n          \n          if ($truthy(self['$using_irb?']())) {\n            self.$push(\"\" + \"Opal.irb_vars\" + (self.$property(self.$var_name().$to_s())) + \" = \")\n            } else {\n            \n            self.$add_local(self.$var_name().$to_s());\n            self.$push(\"\" + (self.$var_name()) + \" = \");\n          };\n          self.$push(self.$expr(self.$value()));\n          if ($truthy(($truthy($a = ($truthy($b = self['$recv?']()) ? $b : self['$expr?']())) ? self.$value() : $a))) {\n            return self.$wrap(\"(\", \")\")\n            } else {\n            return nil\n          };\n        }, TMP_LocalAssignNode_compile_5.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $LocalDeclareNode(){};\n        var self = $LocalDeclareNode = $klass($base, $super, 'LocalDeclareNode', $LocalDeclareNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_LocalDeclareNode_compile_6;\n\n        \n        self.$handle(\"lvdeclare\");\n        self.$children(\"var_name\");\n        return (Opal.defn(self, '$compile', TMP_LocalDeclareNode_compile_6 = function $$compile() {\n          var self = this;\n\n          \n          self.$add_local(self.$var_name().$to_s());\n          return nil;\n        }, TMP_LocalDeclareNode_compile_6.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $InstanceVariableNode(){};\n        var self = $InstanceVariableNode = $klass($base, $super, 'InstanceVariableNode', $InstanceVariableNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_InstanceVariableNode_var_name_7, TMP_InstanceVariableNode_compile_8;\n\n        \n        self.$handle(\"ivar\");\n        self.$children(\"name\");\n        \n        Opal.defn(self, '$var_name', TMP_InstanceVariableNode_var_name_7 = function $$var_name() {\n          var self = this;\n\n          return self.$name().$to_s()['$[]']($range(1, -1, false))\n        }, TMP_InstanceVariableNode_var_name_7.$$arity = 0);\n        return (Opal.defn(self, '$compile', TMP_InstanceVariableNode_compile_8 = function $$compile() {\n          var self = this, name = nil;\n\n          \n          name = self.$property(self.$var_name());\n          self.$add_ivar(name);\n          return self.$push(\"\" + \"self\" + (name));\n        }, TMP_InstanceVariableNode_compile_8.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $InstanceAssignNode(){};\n        var self = $InstanceAssignNode = $klass($base, $super, 'InstanceAssignNode', $InstanceAssignNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_InstanceAssignNode_var_name_9, TMP_InstanceAssignNode_compile_10;\n\n        \n        self.$handle(\"ivasgn\");\n        self.$children(\"name\", \"value\");\n        \n        Opal.defn(self, '$var_name', TMP_InstanceAssignNode_var_name_9 = function $$var_name() {\n          var self = this;\n\n          return self.$name().$to_s()['$[]']($range(1, -1, false))\n        }, TMP_InstanceAssignNode_var_name_9.$$arity = 0);\n        return (Opal.defn(self, '$compile', TMP_InstanceAssignNode_compile_10 = function $$compile() {\n          var $a, $b, self = this, name = nil;\n\n          \n          name = self.$property(self.$var_name());\n          self.$push(\"\" + \"self\" + (name) + \" = \");\n          self.$push(self.$expr(self.$value()));\n          if ($truthy(($truthy($a = ($truthy($b = self['$recv?']()) ? $b : self['$expr?']())) ? self.$value() : $a))) {\n            return self.$wrap(\"(\", \")\")\n            } else {\n            return nil\n          };\n        }, TMP_InstanceAssignNode_compile_10.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $GlobalVariableNode(){};\n        var self = $GlobalVariableNode = $klass($base, $super, 'GlobalVariableNode', $GlobalVariableNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_GlobalVariableNode_var_name_11, TMP_GlobalVariableNode_compile_12;\n\n        \n        self.$handle(\"gvar\");\n        self.$children(\"name\");\n        \n        Opal.defn(self, '$var_name', TMP_GlobalVariableNode_var_name_11 = function $$var_name() {\n          var self = this;\n\n          return self.$name().$to_s()['$[]']($range(1, -1, false))\n        }, TMP_GlobalVariableNode_var_name_11.$$arity = 0);\n        return (Opal.defn(self, '$compile', TMP_GlobalVariableNode_compile_12 = function $$compile() {\n          var self = this, name = nil;\n\n          \n          self.$helper(\"gvars\");\n          name = self.$property(self.$var_name());\n          self.$add_gvar(name);\n          return self.$push(\"\" + \"$gvars\" + (name));\n        }, TMP_GlobalVariableNode_compile_12.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $BackRefNode(){};\n        var self = $BackRefNode = $klass($base, $super, 'BackRefNode', $BackRefNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BackRefNode_compile_13, TMP_BackRefNode_handle_global_match_15, TMP_BackRefNode_handle_pre_match_17, TMP_BackRefNode_handle_post_match_19;\n\n        \n        self.$handle(\"back_ref\");\n        \n        Opal.defn(self, '$compile', TMP_BackRefNode_compile_13 = function $$compile() {\n          var self = this, $iter = TMP_BackRefNode_compile_13.$$p, $yield = $iter || nil, $case = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_BackRefNode_compile_13.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          self.$helper(\"gvars\");\n          return (function() {$case = self.$var_name();\n          if (\"&\"['$===']($case)) {return self.$handle_global_match()}\n          else if (\"'\"['$===']($case)) {return self.$handle_post_match()}\n          else if (\"`\"['$===']($case)) {return self.$handle_pre_match()}\n          else if (\"+\"['$===']($case)) {return $send(self, Opal.find_super_dispatcher(self, 'compile', TMP_BackRefNode_compile_13, false), $zuper, $iter)}\n          else {return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))}})();\n        }, TMP_BackRefNode_compile_13.$$arity = 0);\n        \n        Opal.defn(self, '$handle_global_match', TMP_BackRefNode_handle_global_match_15 = function $$handle_global_match() {\n          var TMP_14, self = this;\n\n          return $send(self, 'with_temp', [], (TMP_14 = function(tmp){var self = TMP_14.$$s || this;\nif (tmp == null) tmp = nil;\n          return self.$push(\"\" + \"((\" + (tmp) + \" = $gvars['~']) === nil ? nil : \" + (tmp) + \"['$[]'](0))\")}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14))\n        }, TMP_BackRefNode_handle_global_match_15.$$arity = 0);\n        \n        Opal.defn(self, '$handle_pre_match', TMP_BackRefNode_handle_pre_match_17 = function $$handle_pre_match() {\n          var TMP_16, self = this;\n\n          return $send(self, 'with_temp', [], (TMP_16 = function(tmp){var self = TMP_16.$$s || this;\nif (tmp == null) tmp = nil;\n          return self.$push(\"\" + \"((\" + (tmp) + \" = $gvars['~']) === nil ? nil : \" + (tmp) + \".$pre_match())\")}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16))\n        }, TMP_BackRefNode_handle_pre_match_17.$$arity = 0);\n        return (Opal.defn(self, '$handle_post_match', TMP_BackRefNode_handle_post_match_19 = function $$handle_post_match() {\n          var TMP_18, self = this;\n\n          return $send(self, 'with_temp', [], (TMP_18 = function(tmp){var self = TMP_18.$$s || this;\nif (tmp == null) tmp = nil;\n          return self.$push(\"\" + \"((\" + (tmp) + \" = $gvars['~']) === nil ? nil : \" + (tmp) + \".$post_match())\")}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18))\n        }, TMP_BackRefNode_handle_post_match_19.$$arity = 0), nil) && 'handle_post_match';\n      })($nesting[0], Opal.const_get_relative($nesting, 'GlobalVariableNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $GlobalAssignNode(){};\n        var self = $GlobalAssignNode = $klass($base, $super, 'GlobalAssignNode', $GlobalAssignNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_GlobalAssignNode_var_name_20, TMP_GlobalAssignNode_compile_21;\n\n        \n        self.$handle(\"gvasgn\");\n        self.$children(\"name\", \"value\");\n        \n        Opal.defn(self, '$var_name', TMP_GlobalAssignNode_var_name_20 = function $$var_name() {\n          var self = this;\n\n          return self.$name().$to_s()['$[]']($range(1, -1, false))\n        }, TMP_GlobalAssignNode_var_name_20.$$arity = 0);\n        return (Opal.defn(self, '$compile', TMP_GlobalAssignNode_compile_21 = function $$compile() {\n          var $a, $b, self = this, name = nil;\n\n          \n          self.$helper(\"gvars\");\n          name = self.$property(self.$var_name());\n          self.$push(\"\" + \"$gvars\" + (name) + \" = \");\n          self.$push(self.$expr(self.$value()));\n          if ($truthy(($truthy($a = ($truthy($b = self['$recv?']()) ? $b : self['$expr?']())) ? self.$value() : $a))) {\n            return self.$wrap(\"(\", \")\")\n            } else {\n            return nil\n          };\n        }, TMP_GlobalAssignNode_compile_21.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $NthrefNode(){};\n        var self = $NthrefNode = $klass($base, $super, 'NthrefNode', $NthrefNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NthrefNode_compile_23;\n\n        \n        self.$handle(\"nth_ref\");\n        self.$children(\"index\");\n        return (Opal.defn(self, '$compile', TMP_NthrefNode_compile_23 = function $$compile() {\n          var TMP_22, self = this;\n\n          \n          self.$helper(\"gvars\");\n          return $send(self, 'with_temp', [], (TMP_22 = function(tmp){var self = TMP_22.$$s || this;\nif (tmp == null) tmp = nil;\n          return self.$push(\"\" + \"((\" + (tmp) + \" = $gvars['~']) === nil ? nil : \" + (tmp) + \"['$[]'](\" + (self.$index()) + \"))\")}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22));\n        }, TMP_NthrefNode_compile_23.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $ClassVariableNode(){};\n        var self = $ClassVariableNode = $klass($base, $super, 'ClassVariableNode', $ClassVariableNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ClassVariableNode_compile_25;\n\n        \n        self.$handle(\"cvar\");\n        self.$children(\"name\");\n        return (Opal.defn(self, '$compile', TMP_ClassVariableNode_compile_25 = function $$compile() {\n          var TMP_24, self = this;\n\n          return $send(self, 'with_temp', [], (TMP_24 = function(tmp){var self = TMP_24.$$s || this;\nif (tmp == null) tmp = nil;\n          return self.$push(\"\" + \"((\" + (tmp) + \" = \" + (self.$class_variable_owner()) + \".$$cvars['\" + (self.$name()) + \"']) == null ? nil : \" + (tmp) + \")\")}, TMP_24.$$s = self, TMP_24.$$arity = 1, TMP_24))\n        }, TMP_ClassVariableNode_compile_25.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $ClassVarAssignNode(){};\n        var self = $ClassVarAssignNode = $klass($base, $super, 'ClassVarAssignNode', $ClassVarAssignNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ClassVarAssignNode_compile_26;\n\n        \n        self.$handle(\"cvasgn\");\n        self.$children(\"name\", \"value\");\n        return (Opal.defn(self, '$compile', TMP_ClassVarAssignNode_compile_26 = function $$compile() {\n          var self = this;\n\n          return self.$push(\"\" + \"(Opal.class_variable_set(\" + (self.$class_variable_owner()) + \", '\" + (self.$name()) + \"', \", self.$expr(self.$value()), \"))\")\n        }, TMP_ClassVarAssignNode_compile_26.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/constants\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$magical_data_const?', '$push', '$const_scope', '$recv', '$name', '$eval?', '$compiler', '$nil?', '$==', '$eof_content', '$base', '$expr', '$value']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $ConstNode(){};\n        var self = $ConstNode = $klass($base, $super, 'ConstNode', $ConstNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ConstNode_compile_1, TMP_ConstNode_magical_data_const$q_2;\n\n        \n        self.$handle(\"const\");\n        self.$children(\"const_scope\", \"name\");\n        \n        Opal.defn(self, '$compile', TMP_ConstNode_compile_1 = function $$compile() {\n          var self = this;\n\n          if ($truthy(self['$magical_data_const?']())) {\n            return self.$push(\"$__END__\")\n          } else if ($truthy(self.$const_scope())) {\n            return self.$push(\"Opal.const_get_qualified(\", self.$recv(self.$const_scope()), \"\" + \", '\" + (self.$name()) + \"')\")\n          } else if ($truthy(self.$compiler()['$eval?']())) {\n            return self.$push(\"\" + \"Opal.const_get_relative($nesting, '\" + (self.$name()) + \"')\")\n            } else {\n            return self.$push(\"\" + \"Opal.const_get_relative($nesting, '\" + (self.$name()) + \"')\")\n          }\n        }, TMP_ConstNode_compile_1.$$arity = 0);\n        return (Opal.defn(self, '$magical_data_const?', TMP_ConstNode_magical_data_const$q_2 = function() {\n          var $a, $b, self = this;\n\n          return ($truthy($a = ($truthy($b = self.$const_scope()['$nil?']()) ? self.$name()['$=='](\"DATA\") : $b)) ? self.$compiler().$eof_content() : $a)\n        }, TMP_ConstNode_magical_data_const$q_2.$$arity = 0), nil) && 'magical_data_const?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $CbaseNode(){};\n        var self = $CbaseNode = $klass($base, $super, 'CbaseNode', $CbaseNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_CbaseNode_compile_3;\n\n        \n        self.$handle(\"cbase\");\n        return (Opal.defn(self, '$compile', TMP_CbaseNode_compile_3 = function $$compile() {\n          var self = this;\n\n          return self.$push(\"'::'\")\n        }, TMP_CbaseNode_compile_3.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $ConstAssignNode(){};\n        var self = $ConstAssignNode = $klass($base, $super, 'ConstAssignNode', $ConstAssignNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ConstAssignNode_compile_4;\n\n        \n        self.$handle(\"casgn\");\n        self.$children(\"base\", \"name\", \"value\");\n        return (Opal.defn(self, '$compile', TMP_ConstAssignNode_compile_4 = function $$compile() {\n          var self = this;\n\n          if ($truthy(self.$base())) {\n            return self.$push(\"Opal.const_set(\", self.$expr(self.$base()), \"\" + \", '\" + (self.$name()) + \"', \", self.$expr(self.$value()), \")\")\n            } else {\n            return self.$push(\"\" + \"Opal.const_set($nesting[0], '\" + (self.$name()) + \"', \", self.$expr(self.$value()), \")\")\n          }\n        }, TMP_ConstAssignNode_compile_4.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"pathname\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $module = Opal.module;\n\n  Opal.add_stubs(['$require', '$include', '$quote', '$===', '$to_s', '$path', '$respond_to?', '$to_path', '$is_a?', '$nil?', '$raise', '$class', '$==', '$attr_reader', '$!', '$relative?', '$chop_basename', '$basename', '$=~', '$new', '$source', '$[]', '$rindex', '$sub', '$absolute?', '$expand_path', '$plus', '$unshift', '$length', '$!=', '$empty?', '$first', '$shift', '$+', '$join', '$dirname', '$pop', '$reverse_each', '$directory?', '$extname', '$<=>', '$nonzero?', '$proc', '$casecmp', '$cleanpath', '$inspect', '$include?', '$fill', '$map', '$entries']);\n  \n  self.$require(\"corelib/comparable\");\n  (function($base, $super, $parent_nesting) {\n    function $Pathname(){};\n    var self = $Pathname = $klass($base, $super, 'Pathname', $Pathname);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Pathname_initialize_1, TMP_Pathname_$eq$eq_2, TMP_Pathname_absolute$q_3, TMP_Pathname_relative$q_4, TMP_Pathname_chop_basename_5, TMP_Pathname_root$q_6, TMP_Pathname_parent_7, TMP_Pathname_sub_8, TMP_Pathname_cleanpath_9, TMP_Pathname_to_path_10, TMP_Pathname_hash_11, TMP_Pathname_expand_path_12, TMP_Pathname_$_13, TMP_Pathname_plus_14, TMP_Pathname_join_16, TMP_Pathname_split_17, TMP_Pathname_dirname_18, TMP_Pathname_basename_19, TMP_Pathname_directory$q_20, TMP_Pathname_extname_21, TMP_Pathname_$lt$eq$gt_22, TMP_Pathname_23, TMP_Pathname_24, TMP_Pathname_relative_path_from_25, TMP_Pathname_entries_27;\n\n    def.path = nil;\n    \n    self.$include(Opal.const_get_relative($nesting, 'Comparable'));\n    Opal.const_set($nesting[0], 'SEPARATOR_PAT', new RegExp(Opal.const_get_relative($nesting, 'Regexp').$quote(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'File'), 'SEPARATOR'))));\n    \n    Opal.defn(self, '$initialize', TMP_Pathname_initialize_1 = function $$initialize(path) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Pathname')['$==='](path))) {\n        self.path = path.$path().$to_s()\n      } else if ($truthy(path['$respond_to?'](\"to_path\"))) {\n        self.path = path.$to_path()\n      } else if ($truthy(path['$is_a?'](Opal.const_get_relative($nesting, 'String')))) {\n        self.path = path\n      } else if ($truthy(path['$nil?']())) {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"no implicit conversion of nil into String\")\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), \"\" + \"no implicit conversion of \" + (path.$class()) + \" into String\")\n      };\n      if (self.path['$=='](\"\\u0000\")) {\n        return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'))\n        } else {\n        return nil\n      };\n    }, TMP_Pathname_initialize_1.$$arity = 1);\n    self.$attr_reader(\"path\");\n    \n    Opal.defn(self, '$==', TMP_Pathname_$eq$eq_2 = function(other) {\n      var self = this;\n\n      return other.$path()['$=='](self.path)\n    }, TMP_Pathname_$eq$eq_2.$$arity = 1);\n    \n    Opal.defn(self, '$absolute?', TMP_Pathname_absolute$q_3 = function() {\n      var self = this;\n\n      return self['$relative?']()['$!']()\n    }, TMP_Pathname_absolute$q_3.$$arity = 0);\n    \n    Opal.defn(self, '$relative?', TMP_Pathname_relative$q_4 = function() {\n      var $a, $b, $c, self = this, path = nil, r = nil;\n\n      \n      path = self.path;\n      while ($truthy((r = self.$chop_basename(path)))) {\n        $c = r, $b = Opal.to_ary($c), (path = ($b[0] == null ? nil : $b[0])), $c\n      };\n      return path['$=='](\"\");\n    }, TMP_Pathname_relative$q_4.$$arity = 0);\n    \n    Opal.defn(self, '$chop_basename', TMP_Pathname_chop_basename_5 = function $$chop_basename(path) {\n      var self = this, base = nil;\n\n      \n      base = Opal.const_get_relative($nesting, 'File').$basename(path);\n      if ($truthy(Opal.const_get_relative($nesting, 'Regexp').$new(\"\" + \"^\" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Pathname'), 'SEPARATOR_PAT').$source()) + \"?$\")['$=~'](base))) {\n        return nil\n        } else {\n        return [path['$[]'](0, path.$rindex(base)), base]\n      };\n    }, TMP_Pathname_chop_basename_5.$$arity = 1);\n    \n    Opal.defn(self, '$root?', TMP_Pathname_root$q_6 = function() {\n      var self = this;\n\n      return self.path['$=='](\"/\")\n    }, TMP_Pathname_root$q_6.$$arity = 0);\n    \n    Opal.defn(self, '$parent', TMP_Pathname_parent_7 = function $$parent() {\n      var self = this, new_path = nil;\n\n      \n      new_path = self.path.$sub(/\\/([^\\/]+\\/?$)/, \"\");\n      if (new_path['$=='](\"\")) {\n        new_path = (function() {if ($truthy(self['$absolute?']())) {\n          return \"/\"\n          } else {\n          return \".\"\n        }; return nil; })()};\n      return Opal.const_get_relative($nesting, 'Pathname').$new(new_path);\n    }, TMP_Pathname_parent_7.$$arity = 0);\n    \n    Opal.defn(self, '$sub', TMP_Pathname_sub_8 = function $$sub($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return Opal.const_get_relative($nesting, 'Pathname').$new($send(self.path, 'sub', Opal.to_a(args)))\n    }, TMP_Pathname_sub_8.$$arity = -1);\n    \n    Opal.defn(self, '$cleanpath', TMP_Pathname_cleanpath_9 = function $$cleanpath() {\n      var self = this;\n\n      return Opal.normalize(self.path)\n    }, TMP_Pathname_cleanpath_9.$$arity = 0);\n    \n    Opal.defn(self, '$to_path', TMP_Pathname_to_path_10 = function $$to_path() {\n      var self = this;\n\n      return self.path\n    }, TMP_Pathname_to_path_10.$$arity = 0);\n    \n    Opal.defn(self, '$hash', TMP_Pathname_hash_11 = function $$hash() {\n      var self = this;\n\n      return self.path\n    }, TMP_Pathname_hash_11.$$arity = 0);\n    \n    Opal.defn(self, '$expand_path', TMP_Pathname_expand_path_12 = function $$expand_path() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'File').$expand_path(self.path)\n    }, TMP_Pathname_expand_path_12.$$arity = 0);\n    \n    Opal.defn(self, '$+', TMP_Pathname_$_13 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(Opal.const_get_relative($nesting, 'Pathname')['$==='](other))) {\n        } else {\n        other = Opal.const_get_relative($nesting, 'Pathname').$new(other)\n      };\n      return Opal.const_get_relative($nesting, 'Pathname').$new(self.$plus(self.path, other.$to_s()));\n    }, TMP_Pathname_$_13.$$arity = 1);\n    \n    Opal.defn(self, '$plus', TMP_Pathname_plus_14 = function $$plus(path1, path2) {\n      var $a, $b, $c, self = this, prefix2 = nil, index_list2 = nil, basename_list2 = nil, r2 = nil, basename2 = nil, prefix1 = nil, r1 = nil, basename1 = nil, suffix2 = nil;\n\n      \n      prefix2 = path2;\n      index_list2 = [];\n      basename_list2 = [];\n      while ($truthy((r2 = self.$chop_basename(prefix2)))) {\n        \n        $c = r2, $b = Opal.to_ary($c), (prefix2 = ($b[0] == null ? nil : $b[0])), (basename2 = ($b[1] == null ? nil : $b[1])), $c;\n        index_list2.$unshift(prefix2.$length());\n        basename_list2.$unshift(basename2);\n      };\n      if ($truthy(prefix2['$!='](\"\"))) {\n        return path2};\n      prefix1 = path1;\n      while ($truthy(true)) {\n        \n        while ($truthy(($truthy($c = basename_list2['$empty?']()['$!']()) ? basename_list2.$first()['$=='](\".\") : $c))) {\n          \n          index_list2.$shift();\n          basename_list2.$shift();\n        };\n        if ($truthy((r1 = self.$chop_basename(prefix1)))) {\n          } else {\n          break;\n        };\n        $c = r1, $b = Opal.to_ary($c), (prefix1 = ($b[0] == null ? nil : $b[0])), (basename1 = ($b[1] == null ? nil : $b[1])), $c;\n        if (basename1['$=='](\".\")) {\n          continue;};\n        if ($truthy(($truthy($b = ($truthy($c = basename1['$=='](\"..\")) ? $c : basename_list2['$empty?']())) ? $b : basename_list2.$first()['$!='](\"..\")))) {\n          \n          prefix1 = $rb_plus(prefix1, basename1);\n          break;;};\n        index_list2.$shift();\n        basename_list2.$shift();\n      };\n      r1 = self.$chop_basename(prefix1);\n      if ($truthy(($truthy($a = r1['$!']()) ? new RegExp(Opal.const_get_relative($nesting, 'SEPARATOR_PAT'))['$=~'](Opal.const_get_relative($nesting, 'File').$basename(prefix1)) : $a))) {\n        while ($truthy(($truthy($b = basename_list2['$empty?']()['$!']()) ? basename_list2.$first()['$=='](\"..\") : $b))) {\n          \n          index_list2.$shift();\n          basename_list2.$shift();\n        }};\n      if ($truthy(basename_list2['$empty?']()['$!']())) {\n        \n        suffix2 = path2['$[]'](Opal.Range.$new(index_list2.$first(), -1, false));\n        if ($truthy(r1)) {\n          return Opal.const_get_relative($nesting, 'File').$join(prefix1, suffix2)\n          } else {\n          return $rb_plus(prefix1, suffix2)\n        };\n      } else if ($truthy(r1)) {\n        return prefix1\n        } else {\n        return Opal.const_get_relative($nesting, 'File').$dirname(prefix1)\n      };\n    }, TMP_Pathname_plus_14.$$arity = 2);\n    \n    Opal.defn(self, '$join', TMP_Pathname_join_16 = function $$join($a_rest) {try {\n\n      var TMP_15, self = this, args, result = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if ($truthy(args['$empty?']())) {\n        return self};\n      result = args.$pop();\n      if ($truthy(Opal.const_get_relative($nesting, 'Pathname')['$==='](result))) {\n        } else {\n        result = Opal.const_get_relative($nesting, 'Pathname').$new(result)\n      };\n      if ($truthy(result['$absolute?']())) {\n        return result};\n      $send(args, 'reverse_each', [], (TMP_15 = function(arg){var self = TMP_15.$$s || this;\nif (arg == null) arg = nil;\n      \n        if ($truthy(Opal.const_get_relative($nesting, 'Pathname')['$==='](arg))) {\n          } else {\n          arg = Opal.const_get_relative($nesting, 'Pathname').$new(arg)\n        };\n        result = $rb_plus(arg, result);\n        if ($truthy(result['$absolute?']())) {\n          Opal.ret(result)\n          } else {\n          return nil\n        };}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15));\n      return $rb_plus(self, result);\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Pathname_join_16.$$arity = -1);\n    \n    Opal.defn(self, '$split', TMP_Pathname_split_17 = function $$split() {\n      var self = this;\n\n      return [self.$dirname(), self.$basename()]\n    }, TMP_Pathname_split_17.$$arity = 0);\n    \n    Opal.defn(self, '$dirname', TMP_Pathname_dirname_18 = function $$dirname() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Pathname').$new(Opal.const_get_relative($nesting, 'File').$dirname(self.path))\n    }, TMP_Pathname_dirname_18.$$arity = 0);\n    \n    Opal.defn(self, '$basename', TMP_Pathname_basename_19 = function $$basename() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Pathname').$new(Opal.const_get_relative($nesting, 'File').$basename(self.path))\n    }, TMP_Pathname_basename_19.$$arity = 0);\n    \n    Opal.defn(self, '$directory?', TMP_Pathname_directory$q_20 = function() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'File')['$directory?'](self.path)\n    }, TMP_Pathname_directory$q_20.$$arity = 0);\n    \n    Opal.defn(self, '$extname', TMP_Pathname_extname_21 = function $$extname() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'File').$extname(self.path)\n    }, TMP_Pathname_extname_21.$$arity = 0);\n    \n    Opal.defn(self, '$<=>', TMP_Pathname_$lt$eq$gt_22 = function(other) {\n      var self = this;\n\n      return self.$path()['$<=>'](other.$path())\n    }, TMP_Pathname_$lt$eq$gt_22.$$arity = 1);\n    Opal.alias(self, \"eql?\", \"==\");\n    Opal.alias(self, \"===\", \"==\");\n    Opal.alias(self, \"to_str\", \"to_path\");\n    Opal.alias(self, \"to_s\", \"to_path\");\n    Opal.const_set($nesting[0], 'SAME_PATHS', (function() {if ($truthy(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'File'), 'FNM_SYSCASE')['$nonzero?']())) {\n      return $send(self, 'proc', [], (TMP_Pathname_23 = function(a, b){var self = TMP_Pathname_23.$$s || this;\nif (a == null) a = nil;if (b == null) b = nil;\n      return a.$casecmp(b)['$=='](0)}, TMP_Pathname_23.$$s = self, TMP_Pathname_23.$$arity = 2, TMP_Pathname_23))\n      } else {\n      return $send(self, 'proc', [], (TMP_Pathname_24 = function(a, b){var self = TMP_Pathname_24.$$s || this;\nif (a == null) a = nil;if (b == null) b = nil;\n      return a['$=='](b)}, TMP_Pathname_24.$$s = self, TMP_Pathname_24.$$arity = 2, TMP_Pathname_24))\n    }; return nil; })());\n    \n    Opal.defn(self, '$relative_path_from', TMP_Pathname_relative_path_from_25 = function $$relative_path_from(base_directory) {\n      var $a, $b, $c, self = this, dest_directory = nil, dest_prefix = nil, dest_names = nil, r = nil, basename = nil, base_prefix = nil, base_names = nil, relpath_names = nil;\n\n      \n      dest_directory = self.$cleanpath().$to_s();\n      base_directory = base_directory.$cleanpath().$to_s();\n      dest_prefix = dest_directory;\n      dest_names = [];\n      while ($truthy((r = self.$chop_basename(dest_prefix)))) {\n        \n        $c = r, $b = Opal.to_ary($c), (dest_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;\n        if ($truthy(basename['$!='](\".\"))) {\n          dest_names.$unshift(basename)};\n      };\n      base_prefix = base_directory;\n      base_names = [];\n      while ($truthy((r = self.$chop_basename(base_prefix)))) {\n        \n        $c = r, $b = Opal.to_ary($c), (base_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;\n        if ($truthy(basename['$!='](\".\"))) {\n          base_names.$unshift(basename)};\n      };\n      if ($truthy(Opal.const_get_relative($nesting, 'SAME_PATHS')['$[]'](dest_prefix, base_prefix))) {\n        } else {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"different prefix: \" + (dest_prefix.$inspect()) + \" and \" + (base_directory.$inspect()))\n      };\n      while ($truthy(($truthy($b = ($truthy($c = dest_names['$empty?']()['$!']()) ? base_names['$empty?']()['$!']() : $c)) ? Opal.const_get_relative($nesting, 'SAME_PATHS')['$[]'](dest_names.$first(), base_names.$first()) : $b))) {\n        \n        dest_names.$shift();\n        base_names.$shift();\n      };\n      if ($truthy(base_names['$include?'](\"..\"))) {\n        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), \"\" + \"base_directory has ..: \" + (base_directory.$inspect()))};\n      base_names.$fill(\"..\");\n      relpath_names = $rb_plus(base_names, dest_names);\n      if ($truthy(relpath_names['$empty?']())) {\n        return Opal.const_get_relative($nesting, 'Pathname').$new(\".\")\n        } else {\n        return Opal.const_get_relative($nesting, 'Pathname').$new($send(Opal.const_get_relative($nesting, 'File'), 'join', Opal.to_a(relpath_names)))\n      };\n    }, TMP_Pathname_relative_path_from_25.$$arity = 1);\n    return (Opal.defn(self, '$entries', TMP_Pathname_entries_27 = function $$entries() {\n      var TMP_26, self = this;\n\n      return $send(Opal.const_get_relative($nesting, 'Dir').$entries(self.path), 'map', [], (TMP_26 = function(f){var self = TMP_26.$$s || this;\nif (f == null) f = nil;\n      return self.$class().$new(f)}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26))\n    }, TMP_Pathname_entries_27.$$arity = 0), nil) && 'entries';\n  })($nesting[0], null, $nesting);\n  return (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_Pathname_28;\n\n    \n    Opal.defn(self, '$Pathname', TMP_Kernel_Pathname_28 = function $$Pathname(path) {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'Pathname').$new(path)\n    }, TMP_Kernel_Pathname_28.$$arity = 1)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/runtime_helpers\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$new', '$children', '$==', '$s', '$include?', '$to_sym', '$<<', '$define_method', '$to_proc', '$meth', '$__send__', '$raise', '$helper', '$[]', '$arglist', '$js_truthy', '$js_falsy']);\n  \n  self.$require(\"set\");\n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $RuntimeHelpers(){};\n        var self = $RuntimeHelpers = $klass($base, $super, 'RuntimeHelpers', $RuntimeHelpers);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_RuntimeHelpers_s_1, TMP_RuntimeHelpers_compatible$q_2, TMP_RuntimeHelpers_helper_3, TMP_RuntimeHelpers_compile_4, TMP_RuntimeHelpers_5, TMP_RuntimeHelpers_6;\n\n        \n        Opal.const_set($nesting[0], 'HELPERS', Opal.const_get_relative($nesting, 'Set').$new());\n        self.$children(\"recvr\", \"meth\", \"arglist\");\n        Opal.defs(self, '$s', TMP_RuntimeHelpers_s_1 = function $$s(type, $a_rest) {\n          var self = this, children;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          children = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            children[$arg_idx - 1] = arguments[$arg_idx];\n          }\n          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Opal'), 'AST'), 'Node').$new(type, children)\n        }, TMP_RuntimeHelpers_s_1.$$arity = -2);\n        Opal.defs(self, '$compatible?', TMP_RuntimeHelpers_compatible$q_2 = function(recvr, meth, arglist) {\n          var $a, self = this;\n\n          return (($a = recvr['$=='](self.$s(\"const\", nil, \"Opal\"))) ? Opal.const_get_relative($nesting, 'HELPERS')['$include?'](meth.$to_sym()) : recvr['$=='](self.$s(\"const\", nil, \"Opal\")))\n        }, TMP_RuntimeHelpers_compatible$q_2.$$arity = 3);\n        Opal.defs(self, '$helper', TMP_RuntimeHelpers_helper_3 = function $$helper(name) {\n          var self = this, $iter = TMP_RuntimeHelpers_helper_3.$$p, block = $iter || nil;\n\n          if ($iter) TMP_RuntimeHelpers_helper_3.$$p = null;\n          \n          Opal.const_get_relative($nesting, 'HELPERS')['$<<'](name);\n          return $send(self, 'define_method', [\"\" + \"compile_\" + (name)], block.$to_proc());\n        }, TMP_RuntimeHelpers_helper_3.$$arity = 1);\n        \n        Opal.defn(self, '$compile', TMP_RuntimeHelpers_compile_4 = function $$compile() {\n          var self = this;\n\n          if ($truthy(Opal.const_get_relative($nesting, 'HELPERS')['$include?'](self.$meth().$to_sym()))) {\n            return self.$__send__(\"\" + \"compile_\" + (self.$meth()))\n            } else {\n            return self.$raise(\"\" + \"Helper not supported: \" + (self.$meth()))\n          }\n        }, TMP_RuntimeHelpers_compile_4.$$arity = 0);\n        $send(self, 'helper', [\"truthy?\"], (TMP_RuntimeHelpers_5 = function(){var self = TMP_RuntimeHelpers_5.$$s || this, sexp = nil;\n\n        \n          if ($truthy((sexp = self.$arglist().$children()['$[]'](0)))) {\n            } else {\n            self.$raise(\"truthy? requires an object\")\n          };\n          return self.$js_truthy(sexp);}, TMP_RuntimeHelpers_5.$$s = self, TMP_RuntimeHelpers_5.$$arity = 0, TMP_RuntimeHelpers_5));\n        return $send(self, 'helper', [\"falsy?\"], (TMP_RuntimeHelpers_6 = function(){var self = TMP_RuntimeHelpers_6.$$s || this, sexp = nil;\n\n        \n          if ($truthy((sexp = self.$arglist().$children()['$[]'](0)))) {\n            } else {\n            self.$raise(\"falsy? requires an object\")\n          };\n          return self.$js_falsy(sexp);}, TMP_RuntimeHelpers_6.$$s = self, TMP_RuntimeHelpers_6.$$arity = 0, TMP_RuntimeHelpers_6));\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/rewriters/break_finder\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"opal/rewriter\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Rewriters, self = $Rewriters = $module($base, 'Rewriters');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $BreakFinder(){};\n        var self = $BreakFinder = $klass($base, $super, 'BreakFinder', $BreakFinder);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BreakFinder_initialize_1, TMP_BreakFinder_found_break$q_2, TMP_BreakFinder_on_break_3, TMP_BreakFinder_stop_lookup_4;\n\n        def.found_break = nil;\n        \n        \n        Opal.defn(self, '$initialize', TMP_BreakFinder_initialize_1 = function $$initialize() {\n          var self = this;\n\n          return (self.found_break = false)\n        }, TMP_BreakFinder_initialize_1.$$arity = 0);\n        \n        Opal.defn(self, '$found_break?', TMP_BreakFinder_found_break$q_2 = function() {\n          var self = this;\n\n          return self.found_break\n        }, TMP_BreakFinder_found_break$q_2.$$arity = 0);\n        \n        Opal.defn(self, '$on_break', TMP_BreakFinder_on_break_3 = function $$on_break(node) {\n          var self = this;\n\n          \n          self.found_break = true;\n          return node;\n        }, TMP_BreakFinder_on_break_3.$$arity = 1);\n        \n        Opal.defn(self, '$stop_lookup', TMP_BreakFinder_stop_lookup_4 = function $$stop_lookup(node) {\n          var self = this;\n\n          return nil\n        }, TMP_BreakFinder_stop_lookup_4.$$arity = 1);\n        Opal.alias(self, \"on_for\", \"stop_lookup\");\n        Opal.alias(self, \"on_while\", \"stop_lookup\");\n        Opal.alias(self, \"on_while_post\", \"stop_lookup\");\n        Opal.alias(self, \"on_until\", \"stop_lookup\");\n        Opal.alias(self, \"on_until_post\", \"stop_lookup\");\n        return Opal.alias(self, \"on_block\", \"stop_lookup\");\n      })($nesting[0], Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'Rewriters'), 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/call\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy, $range = Opal.range;\n\n  Opal.add_stubs(['$require', '$handle', '$attr_reader', '$[]=', '$-', '$define_method', '$to_proc', '$include?', '$type', '$s', '$handle_special', '$record_method?', '$<<', '$method_calls', '$compiler', '$to_sym', '$meth', '$using_irb?', '$compile_irb_var', '$default_compile', '$private', '$iter', '$new', '$process', '$found_break?', '$splat?', '$invoke_using_send?', '$compile_using_send', '$compile_simple_call_chain', '$compile_break_catcher', '$helper', '$push', '$compile_receiver', '$compile_method_name', '$compile_arguments', '$compile_block_pass', '$recv', '$receiver_sexp', '$expr', '$arglist', '$empty?', '$children', '$iter_has_break?', '$unshift', '$line', '$method_jsid', '$any?', '$==', '$recvr', '$mid_to_jsid', '$to_s', '$with_temp', '$intern', '$irb?', '$top?', '$scope', '$nil?', '$updated', '$method', '$arity', '$[]', '$compatible?', '$compile', '$sexp_with_arglist', '$call', '$each', '$add_special', '$inline_operators?', '$operator_helpers', '$fragment', '$resolve', '$requires', '$file', '$dirname', '$cleanpath', '$join', '$Pathname', '$inspect', '$class_scope?', '$required_trees', '$force_encoding', '$encoding', '$+', '$handle_block_given_call', '$def?', '$mid', '$arity_check?', '$push_nesting?', '$first', '$size', '$last', '$handle_part', '$map', '$===', '$expand_path', '$split', '$dynamic_require_severity', '$error', '$warning', '$inject', '$pop']);\n  \n  self.$require(\"set\");\n  self.$require(\"pathname\");\n  self.$require(\"opal/nodes/base\");\n  self.$require(\"opal/nodes/runtime_helpers\");\n  self.$require(\"opal/rewriters/break_finder\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $CallNode(){};\n        var self = $CallNode = $klass($base, $super, 'CallNode', $CallNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_CallNode_add_special_1, TMP_CallNode_initialize_2, TMP_CallNode_compile_4, TMP_CallNode_iter_has_break$q_5, TMP_CallNode_invoke_using_send$q_6, TMP_CallNode_default_compile_7, TMP_CallNode_compile_using_send_8, TMP_CallNode_compile_receiver_9, TMP_CallNode_compile_method_name_10, TMP_CallNode_compile_arguments_11, TMP_CallNode_compile_block_pass_12, TMP_CallNode_compile_break_catcher_13, TMP_CallNode_compile_simple_call_chain_14, TMP_CallNode_splat$q_16, TMP_CallNode_receiver_sexp_17, TMP_CallNode_method_jsid_18, TMP_CallNode_record_method$q_19, TMP_CallNode_compile_irb_var_21, TMP_CallNode_using_irb$q_22, TMP_CallNode_sexp_with_arglist_23, TMP_CallNode_handle_special_24, TMP_CallNode_25, TMP_CallNode_27, TMP_CallNode_28, TMP_CallNode_29, TMP_CallNode_30, TMP_CallNode_31, TMP_CallNode_32, TMP_CallNode_33, TMP_CallNode_34, TMP_CallNode_35, TMP_CallNode_36, TMP_CallNode_37, TMP_CallNode_push_nesting$q_38;\n\n        def.sexp = def.compiler = def.level = nil;\n        \n        self.$handle(\"send\");\n        self.$attr_reader(\"recvr\", \"meth\", \"arglist\", \"iter\");\n        Opal.const_set($nesting[0], 'SPECIALS', $hash2([], {}));\n        Opal.const_set($nesting[0], 'OPERATORS', $hash2([\"+\", \"-\", \"*\", \"/\", \"<\", \"<=\", \">\", \">=\"], {\"+\": \"plus\", \"-\": \"minus\", \"*\": \"times\", \"/\": \"divide\", \"<\": \"lt\", \"<=\": \"le\", \">\": \"gt\", \">=\": \"ge\"}));\n        Opal.defs(self, '$add_special', TMP_CallNode_add_special_1 = function $$add_special(name, options) {\n          var self = this, $iter = TMP_CallNode_add_special_1.$$p, handler = $iter || nil, $writer = nil;\n\n          if (options == null) {\n            options = $hash2([], {});\n          }\n          if ($iter) TMP_CallNode_add_special_1.$$p = null;\n          \n          \n          $writer = [name, options];\n          $send(Opal.const_get_relative($nesting, 'SPECIALS'), '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          return $send(self, 'define_method', [\"\" + \"handle_\" + (name)], handler.$to_proc());\n        }, TMP_CallNode_add_special_1.$$arity = -2);\n        \n        Opal.defn(self, '$initialize', TMP_CallNode_initialize_2 = function $$initialize($a_rest) {\n          var $b, $c, self = this, $iter = TMP_CallNode_initialize_2.$$p, $yield = $iter || nil, args = nil, rest = nil, last_arg = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_CallNode_initialize_2.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_CallNode_initialize_2, false), $zuper, $iter);\n          $b = [].concat(Opal.to_a(self.sexp)), (self.recvr = ($b[0] == null ? nil : $b[0])), (self.meth = ($b[1] == null ? nil : $b[1])), (args = $slice.call($b, 2)), $b;\n          $b = [].concat(Opal.to_a(args)), $c = $b.length - 1, $c = ($c < 0) ? 0 : $c, (rest = $slice.call($b, 0, $c)), (last_arg = ($b[$c] == null ? nil : $b[$c])), $b;\n          if ($truthy(($truthy($b = last_arg) ? [\"iter\", \"block_pass\"]['$include?'](last_arg.$type()) : $b))) {\n            \n            self.iter = last_arg;\n            args = rest;\n            } else {\n            self.iter = nil\n          };\n          return (self.arglist = $send(self, 's', [\"arglist\"].concat(Opal.to_a(args))));\n        }, TMP_CallNode_initialize_2.$$arity = -1);\n        \n        Opal.defn(self, '$compile', TMP_CallNode_compile_4 = function $$compile() {try {\n\n          var TMP_3, self = this;\n\n          return $send(self, 'handle_special', [], (TMP_3 = function(){var self = TMP_3.$$s || this;\n\n          \n            if ($truthy(self['$record_method?']())) {\n              self.$compiler().$method_calls()['$<<'](self.$meth().$to_sym())};\n            if ($truthy(self['$using_irb?']())) {\n              Opal.ret(self.$compile_irb_var())};\n            return self.$default_compile();}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3))\n          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n        }, TMP_CallNode_compile_4.$$arity = 0);\n        self.$private();\n        \n        Opal.defn(self, '$iter_has_break?', TMP_CallNode_iter_has_break$q_5 = function() {\n          var self = this, finder = nil;\n\n          \n          if ($truthy(self.$iter())) {\n            } else {\n            return false\n          };\n          finder = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'Rewriters'), 'BreakFinder').$new();\n          finder.$process(self.$iter());\n          return finder['$found_break?']();\n        }, TMP_CallNode_iter_has_break$q_5.$$arity = 0);\n        \n        Opal.defn(self, '$invoke_using_send?', TMP_CallNode_invoke_using_send$q_6 = function() {\n          var $a, self = this;\n\n          return ($truthy($a = self.$iter()) ? $a : self['$splat?']())\n        }, TMP_CallNode_invoke_using_send$q_6.$$arity = 0);\n        \n        Opal.defn(self, '$default_compile', TMP_CallNode_default_compile_7 = function $$default_compile() {\n          var self = this;\n\n          \n          if ($truthy(self['$invoke_using_send?']())) {\n            self.$compile_using_send()\n            } else {\n            self.$compile_simple_call_chain()\n          };\n          return self.$compile_break_catcher();\n        }, TMP_CallNode_default_compile_7.$$arity = 0);\n        \n        Opal.defn(self, '$compile_using_send', TMP_CallNode_compile_using_send_8 = function $$compile_using_send() {\n          var self = this;\n\n          \n          self.$helper(\"send\");\n          self.$push(\"$send(\");\n          self.$compile_receiver();\n          self.$compile_method_name();\n          self.$compile_arguments();\n          self.$compile_block_pass();\n          return self.$push(\")\");\n        }, TMP_CallNode_compile_using_send_8.$$arity = 0);\n        \n        Opal.defn(self, '$compile_receiver', TMP_CallNode_compile_receiver_9 = function $$compile_receiver() {\n          var self = this;\n\n          return self.$push(self.$recv(self.$receiver_sexp()))\n        }, TMP_CallNode_compile_receiver_9.$$arity = 0);\n        \n        Opal.defn(self, '$compile_method_name', TMP_CallNode_compile_method_name_10 = function $$compile_method_name() {\n          var self = this;\n\n          return self.$push(\"\" + \", '\" + (self.$meth()) + \"'\")\n        }, TMP_CallNode_compile_method_name_10.$$arity = 0);\n        \n        Opal.defn(self, '$compile_arguments', TMP_CallNode_compile_arguments_11 = function $$compile_arguments() {\n          var self = this;\n\n          \n          self.$push(\", \");\n          if ($truthy(self['$splat?']())) {\n            return self.$push(self.$expr(self.$arglist()))\n          } else if ($truthy(self.$arglist().$children()['$empty?']())) {\n            return self.$push(\"[]\")\n            } else {\n            return self.$push(\"[\", self.$expr(self.$arglist()), \"]\")\n          };\n        }, TMP_CallNode_compile_arguments_11.$$arity = 0);\n        \n        Opal.defn(self, '$compile_block_pass', TMP_CallNode_compile_block_pass_12 = function $$compile_block_pass() {\n          var self = this;\n\n          if ($truthy(self.$iter())) {\n            return self.$push(\", \", self.$expr(self.$iter()))\n            } else {\n            return nil\n          }\n        }, TMP_CallNode_compile_block_pass_12.$$arity = 0);\n        \n        Opal.defn(self, '$compile_break_catcher', TMP_CallNode_compile_break_catcher_13 = function $$compile_break_catcher() {\n          var self = this;\n\n          if ($truthy(self['$iter_has_break?']())) {\n            \n            self.$unshift(\"return \");\n            self.$unshift(\"(function(){var $brk = Opal.new_brk(); try {\");\n            return self.$line(\"} catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()\");\n            } else {\n            return nil\n          }\n        }, TMP_CallNode_compile_break_catcher_13.$$arity = 0);\n        \n        Opal.defn(self, '$compile_simple_call_chain', TMP_CallNode_compile_simple_call_chain_14 = function $$compile_simple_call_chain() {\n          var self = this;\n\n          return self.$push(self.$recv(self.$receiver_sexp()), self.$method_jsid(), \"(\", self.$expr(self.$arglist()), \")\")\n        }, TMP_CallNode_compile_simple_call_chain_14.$$arity = 0);\n        \n        Opal.defn(self, '$splat?', TMP_CallNode_splat$q_16 = function() {\n          var TMP_15, self = this;\n\n          return $send(self.$arglist().$children(), 'any?', [], (TMP_15 = function(a){var self = TMP_15.$$s || this;\nif (a == null) a = nil;\n          return a.$type()['$=='](\"splat\")}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15))\n        }, TMP_CallNode_splat$q_16.$$arity = 0);\n        \n        Opal.defn(self, '$receiver_sexp', TMP_CallNode_receiver_sexp_17 = function $$receiver_sexp() {\n          var $a, self = this;\n\n          return ($truthy($a = self.$recvr()) ? $a : self.$s(\"self\"))\n        }, TMP_CallNode_receiver_sexp_17.$$arity = 0);\n        \n        Opal.defn(self, '$method_jsid', TMP_CallNode_method_jsid_18 = function $$method_jsid() {\n          var self = this;\n\n          return self.$mid_to_jsid(self.$meth().$to_s())\n        }, TMP_CallNode_method_jsid_18.$$arity = 0);\n        \n        Opal.defn(self, '$record_method?', TMP_CallNode_record_method$q_19 = function() {\n          var self = this;\n\n          return true\n        }, TMP_CallNode_record_method$q_19.$$arity = 0);\n        \n        Opal.defn(self, '$compile_irb_var', TMP_CallNode_compile_irb_var_21 = function $$compile_irb_var() {\n          var TMP_20, self = this;\n\n          return $send(self, 'with_temp', [], (TMP_20 = function(tmp){var self = TMP_20.$$s || this, lvar = nil, call = nil;\nif (tmp == null) tmp = nil;\n          \n            lvar = self.$meth();\n            call = self.$s(\"send\", self.$s(\"self\"), self.$meth().$intern(), self.$s(\"arglist\"));\n            return self.$push(\"\" + \"((\" + (tmp) + \" = Opal.irb_vars.\" + (lvar) + \") == null ? \", self.$expr(call), \"\" + \" : \" + (tmp) + \")\");}, TMP_20.$$s = self, TMP_20.$$arity = 1, TMP_20))\n        }, TMP_CallNode_compile_irb_var_21.$$arity = 0);\n        \n        Opal.defn(self, '$using_irb?', TMP_CallNode_using_irb$q_22 = function() {\n          var $a, $b, $c, $d, self = this;\n\n          return ($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = self.compiler['$irb?']()) ? self.$scope()['$top?']() : $d)) ? self.$arglist()['$=='](self.$s(\"arglist\")) : $c)) ? self.$recvr()['$nil?']() : $b)) ? self.$iter()['$nil?']() : $a)\n        }, TMP_CallNode_using_irb$q_22.$$arity = 0);\n        \n        Opal.defn(self, '$sexp_with_arglist', TMP_CallNode_sexp_with_arglist_23 = function $$sexp_with_arglist() {\n          var self = this;\n\n          return self.sexp.$updated(nil, [self.$recvr(), self.$meth(), self.$arglist()])\n        }, TMP_CallNode_sexp_with_arglist_23.$$arity = 0);\n        \n        Opal.defn(self, '$handle_special', TMP_CallNode_handle_special_24 = function $$handle_special() {\n          var self = this, $iter = TMP_CallNode_handle_special_24.$$p, compile_default = $iter || nil, method = nil;\n\n          if ($iter) TMP_CallNode_handle_special_24.$$p = null;\n          if ($truthy(Opal.const_get_relative($nesting, 'SPECIALS')['$include?'](self.$meth()))) {\n            \n            method = self.$method(\"\" + \"handle_\" + (self.$meth()));\n            if (method.$arity()['$=='](1)) {\n              return method['$[]'](compile_default)\n              } else {\n              return method['$[]']()\n            };\n          } else if ($truthy(Opal.const_get_relative($nesting, 'RuntimeHelpers')['$compatible?'](self.$recvr(), self.$meth(), self.$arglist()))) {\n            return self.$push(Opal.const_get_relative($nesting, 'RuntimeHelpers').$new(self.$sexp_with_arglist(), self.level, self.compiler).$compile())\n            } else {\n            return compile_default.$call()\n          }\n        }, TMP_CallNode_handle_special_24.$$arity = 0);\n        $send(Opal.const_get_relative($nesting, 'OPERATORS'), 'each', [], (TMP_CallNode_25 = function(operator, name){var self = TMP_CallNode_25.$$s || this, TMP_26;\nif (operator == null) operator = nil;if (name == null) name = nil;\n        return $send(self, 'add_special', [operator.$to_sym()], (TMP_26 = function(compile_default){var self = TMP_26.$$s || this, $a, lhs = nil, rhs = nil;\nif (compile_default == null) compile_default = nil;\n          if ($truthy(self.$compiler()['$inline_operators?']())) {\n              \n              if ($truthy(self['$record_method?']())) {\n                self.$compiler().$method_calls()['$<<'](operator.$to_sym())};\n              self.$compiler().$operator_helpers()['$<<'](operator.$to_sym());\n              $a = [self.$expr(self.$recvr()), self.$expr(self.$arglist())], (lhs = $a[0]), (rhs = $a[1]), $a;\n              self.$push(self.$fragment(\"\" + \"$rb_\" + (name) + \"(\"));\n              self.$push(lhs);\n              self.$push(self.$fragment(\", \"));\n              self.$push(rhs);\n              return self.$push(self.$fragment(\")\"));\n              } else {\n              return compile_default.$call()\n            }}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26))}, TMP_CallNode_25.$$s = self, TMP_CallNode_25.$$arity = 2, TMP_CallNode_25));\n        $send(self, 'add_special', [\"require\"], (TMP_CallNode_27 = function(compile_default){var self = TMP_CallNode_27.$$s || this, str = nil;\nif (compile_default == null) compile_default = nil;\n        \n          str = Opal.const_get_relative($nesting, 'DependencyResolver').$new(self.$compiler(), self.$arglist().$children()['$[]'](0)).$resolve();\n          if ($truthy(str['$nil?']())) {\n            } else {\n            self.$compiler().$requires()['$<<'](str)\n          };\n          return compile_default.$call();}, TMP_CallNode_27.$$s = self, TMP_CallNode_27.$$arity = 1, TMP_CallNode_27));\n        $send(self, 'add_special', [\"require_relative\"], (TMP_CallNode_28 = function(_compile_default){var self = TMP_CallNode_28.$$s || this, arg = nil, file = nil, dir = nil;\nif (_compile_default == null) _compile_default = nil;\n        \n          arg = self.$arglist().$children()['$[]'](0);\n          file = self.$compiler().$file();\n          if (arg.$type()['$=='](\"str\")) {\n            \n            dir = Opal.const_get_relative($nesting, 'File').$dirname(file);\n            self.$compiler().$requires()['$<<'](self.$Pathname(dir).$join(arg.$children()['$[]'](0)).$cleanpath().$to_s());};\n          self.$push(self.$fragment(\"\" + \"self.$require(\" + (file.$inspect()) + \"+ '/../' + \"));\n          self.$push(self.$process(self.$arglist()));\n          return self.$push(self.$fragment(\")\"));}, TMP_CallNode_28.$$s = self, TMP_CallNode_28.$$arity = 1, TMP_CallNode_28));\n        $send(self, 'add_special', [\"autoload\"], (TMP_CallNode_29 = function(compile_default){var self = TMP_CallNode_29.$$s || this, str = nil;\nif (compile_default == null) compile_default = nil;\n        if ($truthy(self.$scope()['$class_scope?']())) {\n            \n            str = Opal.const_get_relative($nesting, 'DependencyResolver').$new(self.$compiler(), self.$arglist().$children()['$[]'](1)).$resolve();\n            if ($truthy(str['$nil?']())) {\n              } else {\n              self.$compiler().$requires()['$<<'](str)\n            };\n            return compile_default.$call();\n            } else {\n            return nil\n          }}, TMP_CallNode_29.$$s = self, TMP_CallNode_29.$$arity = 1, TMP_CallNode_29));\n        $send(self, 'add_special', [\"require_tree\"], (TMP_CallNode_30 = function(compile_default){var self = TMP_CallNode_30.$$s || this, $a, first_arg = nil, rest = nil, relative_path = nil, dir = nil, full_path = nil;\nif (compile_default == null) compile_default = nil;\n        \n          $a = [].concat(Opal.to_a(self.$arglist().$children())), (first_arg = ($a[0] == null ? nil : $a[0])), (rest = $slice.call($a, 1)), $a;\n          if (first_arg.$type()['$=='](\"str\")) {\n            \n            relative_path = first_arg.$children()['$[]'](0);\n            self.$compiler().$required_trees()['$<<'](relative_path);\n            dir = Opal.const_get_relative($nesting, 'File').$dirname(self.$compiler().$file());\n            full_path = self.$Pathname(dir).$join(relative_path).$cleanpath().$to_s();\n            full_path.$force_encoding(relative_path.$encoding());\n            first_arg = first_arg.$updated(nil, [full_path]);};\n          self.arglist = self.$arglist().$updated(nil, $rb_plus([first_arg], rest));\n          return compile_default.$call();}, TMP_CallNode_30.$$s = self, TMP_CallNode_30.$$arity = 1, TMP_CallNode_30));\n        $send(self, 'add_special', [\"block_given?\"], (TMP_CallNode_31 = function(compile_default){var self = TMP_CallNode_31.$$s || this;\n          if (self.sexp == null) self.sexp = nil;\nif (compile_default == null) compile_default = nil;\n        return self.$push(self.$compiler().$handle_block_given_call(self.sexp))}, TMP_CallNode_31.$$s = self, TMP_CallNode_31.$$arity = 1, TMP_CallNode_31));\n        $send(self, 'add_special', [\"__callee__\"], (TMP_CallNode_32 = function(compile_default){var self = TMP_CallNode_32.$$s || this;\nif (compile_default == null) compile_default = nil;\n        if ($truthy(self.$scope()['$def?']())) {\n            return self.$push(self.$fragment(self.$scope().$mid().$to_s().$inspect()))\n            } else {\n            return self.$push(self.$fragment(\"nil\"))\n          }}, TMP_CallNode_32.$$s = self, TMP_CallNode_32.$$arity = 1, TMP_CallNode_32));\n        $send(self, 'add_special', [\"__method__\"], (TMP_CallNode_33 = function(compile_default){var self = TMP_CallNode_33.$$s || this;\nif (compile_default == null) compile_default = nil;\n        if ($truthy(self.$scope()['$def?']())) {\n            return self.$push(self.$fragment(self.$scope().$mid().$to_s().$inspect()))\n            } else {\n            return self.$push(self.$fragment(\"nil\"))\n          }}, TMP_CallNode_33.$$s = self, TMP_CallNode_33.$$arity = 1, TMP_CallNode_33));\n        $send(self, 'add_special', [\"debugger\"], (TMP_CallNode_34 = function(compile_default){var self = TMP_CallNode_34.$$s || this;\nif (compile_default == null) compile_default = nil;\n        return self.$push(self.$fragment(\"debugger\"))}, TMP_CallNode_34.$$s = self, TMP_CallNode_34.$$arity = 1, TMP_CallNode_34));\n        $send(self, 'add_special', [\"__OPAL_COMPILER_CONFIG__\"], (TMP_CallNode_35 = function(compile_default){var self = TMP_CallNode_35.$$s || this;\nif (compile_default == null) compile_default = nil;\n        return self.$push(self.$fragment(\"\" + \"Opal.hash({ arity_check: \" + (self.$compiler()['$arity_check?']()) + \" })\"))}, TMP_CallNode_35.$$s = self, TMP_CallNode_35.$$arity = 1, TMP_CallNode_35));\n        $send(self, 'add_special', [\"nesting\"], (TMP_CallNode_36 = function(compile_default){var self = TMP_CallNode_36.$$s || this, push_nesting = nil;\nif (compile_default == null) compile_default = nil;\n        \n          push_nesting = self['$push_nesting?'](self.$children());\n          if ($truthy(push_nesting)) {\n            self.$push(\"(Opal.Module.$$nesting = $nesting, \")};\n          compile_default.$call();\n          if ($truthy(push_nesting)) {\n            return self.$push(\")\")\n            } else {\n            return nil\n          };}, TMP_CallNode_36.$$s = self, TMP_CallNode_36.$$arity = 1, TMP_CallNode_36));\n        $send(self, 'add_special', [\"constants\"], (TMP_CallNode_37 = function(compile_default){var self = TMP_CallNode_37.$$s || this, push_nesting = nil;\nif (compile_default == null) compile_default = nil;\n        \n          push_nesting = self['$push_nesting?'](self.$children());\n          if ($truthy(push_nesting)) {\n            self.$push(\"(Opal.Module.$$nesting = $nesting, \")};\n          compile_default.$call();\n          if ($truthy(push_nesting)) {\n            return self.$push(\")\")\n            } else {\n            return nil\n          };}, TMP_CallNode_37.$$s = self, TMP_CallNode_37.$$arity = 1, TMP_CallNode_37));\n        \n        Opal.defn(self, '$push_nesting?', TMP_CallNode_push_nesting$q_38 = function(recv) {\n          var $a, $b, $c, self = this;\n\n          \n          recv = self.$children().$first();\n          return (($a = self.$children().$size()['$=='](2)) ? ($truthy($b = recv['$nil?']()) ? $b : (($c = recv.$type()['$=='](\"const\")) ? recv.$children().$last()['$=='](\"Module\") : recv.$type()['$=='](\"const\"))) : self.$children().$size()['$=='](2));\n        }, TMP_CallNode_push_nesting$q_38.$$arity = 1);\n        return (function($base, $super, $parent_nesting) {\n          function $DependencyResolver(){};\n          var self = $DependencyResolver = $klass($base, $super, 'DependencyResolver', $DependencyResolver);\n\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DependencyResolver_initialize_39, TMP_DependencyResolver_resolve_40, TMP_DependencyResolver_handle_part_42, TMP_DependencyResolver_expand_path_44;\n\n          def.sexp = def.compiler = nil;\n          \n          \n          Opal.defn(self, '$initialize', TMP_DependencyResolver_initialize_39 = function $$initialize(compiler, sexp) {\n            var self = this;\n\n            \n            self.compiler = compiler;\n            return (self.sexp = sexp);\n          }, TMP_DependencyResolver_initialize_39.$$arity = 2);\n          \n          Opal.defn(self, '$resolve', TMP_DependencyResolver_resolve_40 = function $$resolve() {\n            var self = this;\n\n            return self.$handle_part(self.sexp)\n          }, TMP_DependencyResolver_resolve_40.$$arity = 0);\n          \n          Opal.defn(self, '$handle_part', TMP_DependencyResolver_handle_part_42 = function $$handle_part(sexp) {\n            var $a, $b, TMP_41, self = this, type = nil, recv = nil, meth = nil, args = nil, parts = nil, msg = nil, $case = nil;\n\n            \n            type = sexp.$type();\n            if (type['$=='](\"str\")) {\n              return sexp.$children()['$[]'](0)\n            } else if (type['$=='](\"send\")) {\n              \n              $b = sexp.$children(), $a = Opal.to_ary($b), (recv = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $b;\n              parts = $send(args, 'map', [], (TMP_41 = function(s){var self = TMP_41.$$s || this;\nif (s == null) s = nil;\n              return self.$handle_part(s)}, TMP_41.$$s = self, TMP_41.$$arity = 1, TMP_41));\n              if ($truthy(($truthy($a = ($truthy($b = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Opal'), 'AST'), 'Node')['$==='](recv)) ? recv.$type()['$=='](\"const\") : $b)) ? recv.$children().$last()['$=='](\"File\") : $a))) {\n                if (meth['$=='](\"expand_path\")) {\n                  return $send(self, 'expand_path', Opal.to_a(parts))\n                } else if (meth['$=='](\"join\")) {\n                  return self.$expand_path(parts.$join(\"/\"))\n                } else if (meth['$=='](\"dirname\")) {\n                  return self.$expand_path(parts['$[]'](0).$split(\"/\")['$[]']($range(0, -1, true)).$join(\"/\"))}};};\n            msg = \"Cannot handle dynamic require\";\n            return (function() {$case = self.compiler.$dynamic_require_severity();\n            if (\"error\"['$===']($case)) {return self.compiler.$error(msg, self.sexp.$line())}\n            else if (\"warning\"['$===']($case)) {return self.compiler.$warning(msg, self.sexp.$line())}\n            else { return nil }})();\n          }, TMP_DependencyResolver_handle_part_42.$$arity = 1);\n          return (Opal.defn(self, '$expand_path', TMP_DependencyResolver_expand_path_44 = function $$expand_path(path, base) {\n            var TMP_43, self = this;\n\n            if (base == null) {\n              base = \"\";\n            }\n            return $send((((\"\" + (base)) + \"/\") + (path)).$split(\"/\"), 'inject', [[]], (TMP_43 = function(p, part){var self = TMP_43.$$s || this;\nif (p == null) p = nil;if (part == null) part = nil;\n            \n              if (part['$=='](\"\")) {\n              } else if (part['$=='](\"..\")) {\n                p.$pop()\n                } else {\n                p['$<<'](part)\n              };\n              return p;}, TMP_43.$$s = self, TMP_43.$$arity = 2, TMP_43)).$join(\"/\")\n          }, TMP_DependencyResolver_expand_path_44.$$arity = -2), nil) && 'expand_path';\n        })($nesting[0], null, $nesting);\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/csend\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$handle', '$helper', '$conditional_send', '$recv', '$receiver_sexp', '$push', '$compile_method_name', '$compile_arguments', '$compile_block_pass']);\n  \n  self.$require(\"opal/nodes/call\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $CSendNode(){};\n        var self = $CSendNode = $klass($base, $super, 'CSendNode', $CSendNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_CSendNode_default_compile_2;\n\n        \n        self.$handle(\"csend\");\n        return (Opal.defn(self, '$default_compile', TMP_CSendNode_default_compile_2 = function $$default_compile() {\n          var TMP_1, self = this;\n\n          \n          self.$helper(\"send\");\n          return $send(self, 'conditional_send', [self.$recv(self.$receiver_sexp())], (TMP_1 = function(receiver_temp){var self = TMP_1.$$s || this;\nif (receiver_temp == null) receiver_temp = nil;\n          \n            self.$push(\"$send(\", receiver_temp);\n            self.$compile_method_name();\n            self.$compile_arguments();\n            self.$compile_block_pass();\n            return self.$push(\")\");}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));\n        }, TMP_CSendNode_default_compile_2.$$arity = 0), nil) && 'default_compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'CallNode'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/call_special\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$push', '$recv', '$recvr', '$expr', '$property', '$value', '$<<', '$default_compile', '$meth', '$receiver_sexp', '$method_jsid', '$compile_arguments', '$iter', '$s', '$lhs', '$rhs', '$process']);\n  \n  self.$require(\"opal/nodes/base\");\n  self.$require(\"opal/nodes/call\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $JsAttrNode(){};\n        var self = $JsAttrNode = $klass($base, $super, 'JsAttrNode', $JsAttrNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_JsAttrNode_compile_1;\n\n        \n        self.$handle(\"jsattr\");\n        self.$children(\"recvr\", \"property\");\n        return (Opal.defn(self, '$compile', TMP_JsAttrNode_compile_1 = function $$compile() {\n          var self = this;\n\n          return self.$push(self.$recv(self.$recvr()), \"[\", self.$expr(self.$property()), \"]\")\n        }, TMP_JsAttrNode_compile_1.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $JsAttrAsgnNode(){};\n        var self = $JsAttrAsgnNode = $klass($base, $super, 'JsAttrAsgnNode', $JsAttrAsgnNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_JsAttrAsgnNode_compile_2;\n\n        \n        self.$handle(\"jsattrasgn\");\n        self.$children(\"recvr\", \"property\", \"value\");\n        return (Opal.defn(self, '$compile', TMP_JsAttrAsgnNode_compile_2 = function $$compile() {\n          var self = this;\n\n          return self.$push(self.$recv(self.$recvr()), \"[\", self.$expr(self.$property()), \"] = \", self.$expr(self.$value()))\n        }, TMP_JsAttrAsgnNode_compile_2.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $JsCallNode(){};\n        var self = $JsCallNode = $klass($base, $super, 'JsCallNode', $JsCallNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_JsCallNode_initialize_3, TMP_JsCallNode_compile_4, TMP_JsCallNode_method_jsid_5, TMP_JsCallNode_compile_using_send_6;\n\n        def.iter = def.arglist = nil;\n        \n        self.$handle(\"jscall\");\n        \n        Opal.defn(self, '$initialize', TMP_JsCallNode_initialize_3 = function $$initialize($a_rest) {\n          var self = this, $iter = TMP_JsCallNode_initialize_3.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_JsCallNode_initialize_3.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_JsCallNode_initialize_3, false), $zuper, $iter);\n          if ($truthy(self.iter)) {\n            self.arglist = self.arglist['$<<'](self.iter)};\n          return (self.iter = nil);\n        }, TMP_JsCallNode_initialize_3.$$arity = -1);\n        \n        Opal.defn(self, '$compile', TMP_JsCallNode_compile_4 = function $$compile() {\n          var self = this;\n\n          return self.$default_compile()\n        }, TMP_JsCallNode_compile_4.$$arity = 0);\n        \n        Opal.defn(self, '$method_jsid', TMP_JsCallNode_method_jsid_5 = function $$method_jsid() {\n          var self = this;\n\n          return \"\" + \".\" + (self.$meth())\n        }, TMP_JsCallNode_method_jsid_5.$$arity = 0);\n        return (Opal.defn(self, '$compile_using_send', TMP_JsCallNode_compile_using_send_6 = function $$compile_using_send() {\n          var self = this;\n\n          \n          self.$push(self.$recv(self.$receiver_sexp()), self.$method_jsid(), \".apply(null\");\n          self.$compile_arguments();\n          if ($truthy(self.$iter())) {\n            self.$push(\".concat(\", self.$expr(self.$iter()), \")\")};\n          return self.$push(\")\");\n        }, TMP_JsCallNode_compile_using_send_6.$$arity = 0), nil) && 'compile_using_send';\n      })($nesting[0], Opal.const_get_relative($nesting, 'CallNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $Match3Node(){};\n        var self = $Match3Node = $klass($base, $super, 'Match3Node', $Match3Node);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Match3Node_compile_7;\n\n        def.level = nil;\n        \n        self.$handle(\"match_with_lvasgn\");\n        self.$children(\"lhs\", \"rhs\");\n        return (Opal.defn(self, '$compile', TMP_Match3Node_compile_7 = function $$compile() {\n          var self = this, sexp = nil;\n\n          \n          sexp = self.$s(\"send\", self.$lhs(), \"=~\", self.$rhs());\n          return self.$push(self.$process(sexp, self.level));\n        }, TMP_Match3Node_compile_7.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/scope\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$attr_accessor', '$attr_reader', '$indent', '$scope', '$compiler', '$scope=', '$-', '$call', '$==', '$!', '$class?', '$dup', '$push', '$map', '$ivars', '$gvars', '$parser_indent', '$empty?', '$join', '$+', '$proto', '$%', '$fragment', '$def_in_class?', '$add_proto_ivar', '$include?', '$<<', '$has_local?', '$has_temp?', '$pop', '$next_temp', '$succ', '$uses_block!', '$identify!', '$compact', '$parent', '$name', '$scope_name', '$mid', '$unique_temp', '$add_scope_temp', '$def?', '$type', '$rescue_else_sexp']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $ScopeNode(){};\n        var self = $ScopeNode = $klass($base, $super, 'ScopeNode', $ScopeNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ScopeNode_initialize_1, TMP_ScopeNode_in_scope_2, TMP_ScopeNode_class_scope$q_4, TMP_ScopeNode_class$q_5, TMP_ScopeNode_module$q_6, TMP_ScopeNode_sclass$q_7, TMP_ScopeNode_top$q_8, TMP_ScopeNode_iter$q_9, TMP_ScopeNode_def$q_10, TMP_ScopeNode_def_in_class$q_11, TMP_ScopeNode_proto_12, TMP_ScopeNode_to_vars_17, TMP_ScopeNode_add_scope_ivar_18, TMP_ScopeNode_add_scope_gvar_19, TMP_ScopeNode_add_proto_ivar_20, TMP_ScopeNode_add_arg_21, TMP_ScopeNode_add_scope_local_22, TMP_ScopeNode_has_local$q_23, TMP_ScopeNode_add_scope_temp_24, TMP_ScopeNode_has_temp$q_25, TMP_ScopeNode_new_temp_26, TMP_ScopeNode_next_temp_27, TMP_ScopeNode_queue_temp_28, TMP_ScopeNode_push_while_29, TMP_ScopeNode_pop_while_30, TMP_ScopeNode_in_while$q_31, TMP_ScopeNode_uses_block$B_32, TMP_ScopeNode_identify$B_33, TMP_ScopeNode_identity_34, TMP_ScopeNode_find_parent_def_35, TMP_ScopeNode_get_super_chain_36, TMP_ScopeNode_uses_block$q_37, TMP_ScopeNode_has_rescue_else$q_38, TMP_ScopeNode_in_ensure_39, TMP_ScopeNode_in_ensure$q_40;\n\n        def.type = def.defs = def.parent = def.temps = def.locals = def.compiler = def.proto_ivars = def.ivars = def.gvars = def.args = def.queue = def.unique = def.while_stack = def.identity = def.uses_block = def.in_ensure = nil;\n        \n        self.$attr_accessor(\"parent\");\n        self.$attr_accessor(\"name\");\n        self.$attr_accessor(\"block_name\");\n        self.$attr_reader(\"scope_name\");\n        self.$attr_reader(\"locals\");\n        self.$attr_reader(\"ivars\");\n        self.$attr_reader(\"gvars\");\n        self.$attr_accessor(\"mid\");\n        self.$attr_accessor(\"defs\");\n        self.$attr_reader(\"methods\");\n        self.$attr_accessor(\"uses_super\");\n        self.$attr_accessor(\"uses_zuper\");\n        self.$attr_accessor(\"catch_return\", \"has_break\");\n        self.$attr_accessor(\"rescue_else_sexp\");\n        \n        Opal.defn(self, '$initialize', TMP_ScopeNode_initialize_1 = function $$initialize($a_rest) {\n          var self = this, $iter = TMP_ScopeNode_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_ScopeNode_initialize_1.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_ScopeNode_initialize_1, false), $zuper, $iter);\n          self.locals = [];\n          self.temps = [];\n          self.args = [];\n          self.ivars = [];\n          self.gvars = [];\n          self.parent = nil;\n          self.queue = [];\n          self.unique = \"a\";\n          self.while_stack = [];\n          self.identity = nil;\n          self.defs = nil;\n          self.methods = [];\n          self.uses_block = false;\n          self.in_ensure = false;\n          return (self.proto_ivars = []);\n        }, TMP_ScopeNode_initialize_1.$$arity = -1);\n        \n        Opal.defn(self, '$in_scope', TMP_ScopeNode_in_scope_2 = function $$in_scope() {\n          var TMP_3, self = this, $iter = TMP_ScopeNode_in_scope_2.$$p, block = $iter || nil;\n\n          if ($iter) TMP_ScopeNode_in_scope_2.$$p = null;\n          return $send(self, 'indent', [], (TMP_3 = function(){var self = TMP_3.$$s || this, $writer = nil;\n            if (self.parent == null) self.parent = nil;\n\n          \n            self.parent = self.$compiler().$scope();\n            \n            $writer = [self];\n            $send(self.$compiler(), 'scope=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            block.$call(self);\n            \n            $writer = [self.parent];\n            $send(self.$compiler(), 'scope=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];;}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3))\n        }, TMP_ScopeNode_in_scope_2.$$arity = 0);\n        \n        Opal.defn(self, '$class_scope?', TMP_ScopeNode_class_scope$q_4 = function() {\n          var $a, self = this;\n\n          return ($truthy($a = self.type['$=='](\"class\")) ? $a : self.type['$=='](\"module\"))\n        }, TMP_ScopeNode_class_scope$q_4.$$arity = 0);\n        \n        Opal.defn(self, '$class?', TMP_ScopeNode_class$q_5 = function() {\n          var self = this;\n\n          return self.type['$=='](\"class\")\n        }, TMP_ScopeNode_class$q_5.$$arity = 0);\n        \n        Opal.defn(self, '$module?', TMP_ScopeNode_module$q_6 = function() {\n          var self = this;\n\n          return self.type['$=='](\"module\")\n        }, TMP_ScopeNode_module$q_6.$$arity = 0);\n        \n        Opal.defn(self, '$sclass?', TMP_ScopeNode_sclass$q_7 = function() {\n          var self = this;\n\n          return self.type['$=='](\"sclass\")\n        }, TMP_ScopeNode_sclass$q_7.$$arity = 0);\n        \n        Opal.defn(self, '$top?', TMP_ScopeNode_top$q_8 = function() {\n          var self = this;\n\n          return self.type['$=='](\"top\")\n        }, TMP_ScopeNode_top$q_8.$$arity = 0);\n        \n        Opal.defn(self, '$iter?', TMP_ScopeNode_iter$q_9 = function() {\n          var self = this;\n\n          return self.type['$=='](\"iter\")\n        }, TMP_ScopeNode_iter$q_9.$$arity = 0);\n        \n        Opal.defn(self, '$def?', TMP_ScopeNode_def$q_10 = function() {\n          var $a, self = this;\n\n          return ($truthy($a = self.type['$=='](\"def\")) ? $a : self.type['$=='](\"defs\"))\n        }, TMP_ScopeNode_def$q_10.$$arity = 0);\n        \n        Opal.defn(self, '$def_in_class?', TMP_ScopeNode_def_in_class$q_11 = function() {\n          var $a, $b, $c, self = this;\n\n          return ($truthy($a = ($truthy($b = ($truthy($c = self.defs['$!']()) ? self.type['$=='](\"def\") : $c)) ? self.parent : $b)) ? self.parent['$class?']() : $a)\n        }, TMP_ScopeNode_def_in_class$q_11.$$arity = 0);\n        \n        Opal.defn(self, '$proto', TMP_ScopeNode_proto_12 = function $$proto() {\n          var self = this;\n\n          return \"def\"\n        }, TMP_ScopeNode_proto_12.$$arity = 0);\n        \n        Opal.defn(self, '$to_vars', TMP_ScopeNode_to_vars_17 = function $$to_vars() {\n          var TMP_13, TMP_14, TMP_15, $a, TMP_16, self = this, vars = nil, iv = nil, gv = nil, indent = nil, str = nil, pvars = nil, result = nil;\n\n          \n          vars = self.temps.$dup();\n          $send(vars, 'push', Opal.to_a($send(self.locals, 'map', [], (TMP_13 = function(l){var self = TMP_13.$$s || this;\nif (l == null) l = nil;\n          return \"\" + (l) + \" = nil\"}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13))));\n          iv = $send(self.$ivars(), 'map', [], (TMP_14 = function(ivar){var self = TMP_14.$$s || this;\nif (ivar == null) ivar = nil;\n          return \"\" + \"if (self\" + (ivar) + \" == null) self\" + (ivar) + \" = nil;\\n\"}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14));\n          gv = $send(self.$gvars(), 'map', [], (TMP_15 = function(gvar){var self = TMP_15.$$s || this;\nif (gvar == null) gvar = nil;\n          return \"\" + \"if ($gvars\" + (gvar) + \" == null) $gvars\" + (gvar) + \" = nil;\\n\"}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15));\n          indent = self.compiler.$parser_indent();\n          str = (function() {if ($truthy(vars['$empty?']())) {\n            return \"\"\n            } else {\n            return \"\" + \"var \" + (vars.$join(\", \")) + \";\\n\"\n          }; return nil; })();\n          if ($truthy(self.$ivars()['$empty?']())) {\n            } else {\n            str = $rb_plus(str, \"\" + (indent) + (iv.$join(indent)))\n          };\n          if ($truthy(self.$gvars()['$empty?']())) {\n            } else {\n            str = $rb_plus(str, \"\" + (indent) + (gv.$join(indent)))\n          };\n          if ($truthy(($truthy($a = self['$class?']()) ? self.proto_ivars['$empty?']()['$!']() : $a))) {\n            \n            pvars = $send(self.proto_ivars, 'map', [], (TMP_16 = function(i){var self = TMP_16.$$s || this;\nif (i == null) i = nil;\n            return \"\" + (self.$proto()) + (i)}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16)).$join(\" = \");\n            result = \"%s\\n%s%s = nil;\"['$%']([str, indent, pvars]);\n            } else {\n            result = str\n          };\n          return self.$fragment(result);\n        }, TMP_ScopeNode_to_vars_17.$$arity = 0);\n        \n        Opal.defn(self, '$add_scope_ivar', TMP_ScopeNode_add_scope_ivar_18 = function $$add_scope_ivar(ivar) {\n          var self = this;\n\n          if ($truthy(self['$def_in_class?']())) {\n            return self.parent.$add_proto_ivar(ivar)\n          } else if ($truthy(self.ivars['$include?'](ivar))) {\n            return nil\n            } else {\n            return self.ivars['$<<'](ivar)\n          }\n        }, TMP_ScopeNode_add_scope_ivar_18.$$arity = 1);\n        \n        Opal.defn(self, '$add_scope_gvar', TMP_ScopeNode_add_scope_gvar_19 = function $$add_scope_gvar(gvar) {\n          var self = this;\n\n          if ($truthy(self.gvars['$include?'](gvar))) {\n            return nil\n            } else {\n            return self.gvars['$<<'](gvar)\n          }\n        }, TMP_ScopeNode_add_scope_gvar_19.$$arity = 1);\n        \n        Opal.defn(self, '$add_proto_ivar', TMP_ScopeNode_add_proto_ivar_20 = function $$add_proto_ivar(ivar) {\n          var self = this;\n\n          if ($truthy(self.proto_ivars['$include?'](ivar))) {\n            return nil\n            } else {\n            return self.proto_ivars['$<<'](ivar)\n          }\n        }, TMP_ScopeNode_add_proto_ivar_20.$$arity = 1);\n        \n        Opal.defn(self, '$add_arg', TMP_ScopeNode_add_arg_21 = function $$add_arg(arg) {\n          var self = this;\n\n          \n          if ($truthy(self.args['$include?'](arg))) {\n            } else {\n            self.args['$<<'](arg)\n          };\n          return arg;\n        }, TMP_ScopeNode_add_arg_21.$$arity = 1);\n        \n        Opal.defn(self, '$add_scope_local', TMP_ScopeNode_add_scope_local_22 = function $$add_scope_local(local) {\n          var self = this;\n\n          \n          if ($truthy(self['$has_local?'](local))) {\n            return nil};\n          return self.locals['$<<'](local);\n        }, TMP_ScopeNode_add_scope_local_22.$$arity = 1);\n        \n        Opal.defn(self, '$has_local?', TMP_ScopeNode_has_local$q_23 = function(local) {\n          var $a, $b, self = this;\n\n          \n          if ($truthy(($truthy($a = ($truthy($b = self.locals['$include?'](local)) ? $b : self.args['$include?'](local))) ? $a : self.temps['$include?'](local)))) {\n            return true};\n          if ($truthy(($truthy($a = self.parent) ? self.type['$=='](\"iter\") : $a))) {\n            return self.parent['$has_local?'](local)};\n          return false;\n        }, TMP_ScopeNode_has_local$q_23.$$arity = 1);\n        \n        Opal.defn(self, '$add_scope_temp', TMP_ScopeNode_add_scope_temp_24 = function $$add_scope_temp(tmp) {\n          var self = this;\n\n          \n          if ($truthy(self['$has_temp?'](tmp))) {\n            return nil};\n          return self.temps.$push(tmp);\n        }, TMP_ScopeNode_add_scope_temp_24.$$arity = 1);\n        \n        Opal.defn(self, '$has_temp?', TMP_ScopeNode_has_temp$q_25 = function(tmp) {\n          var self = this;\n\n          return self.temps['$include?'](tmp)\n        }, TMP_ScopeNode_has_temp$q_25.$$arity = 1);\n        \n        Opal.defn(self, '$new_temp', TMP_ScopeNode_new_temp_26 = function $$new_temp() {\n          var self = this, tmp = nil;\n\n          \n          if ($truthy(self.queue['$empty?']())) {\n            } else {\n            return self.queue.$pop()\n          };\n          tmp = self.$next_temp();\n          self.temps['$<<'](tmp);\n          return tmp;\n        }, TMP_ScopeNode_new_temp_26.$$arity = 0);\n        \n        Opal.defn(self, '$next_temp', TMP_ScopeNode_next_temp_27 = function $$next_temp() {\n          var $a, self = this, tmp = nil;\n\n          \n          while ($truthy(true)) {\n            \n            tmp = \"\" + \"$\" + (self.unique);\n            self.unique = self.unique.$succ();\n            if ($truthy(self['$has_local?'](tmp))) {\n              } else {\n              break;\n            };\n          };\n          return tmp;\n        }, TMP_ScopeNode_next_temp_27.$$arity = 0);\n        \n        Opal.defn(self, '$queue_temp', TMP_ScopeNode_queue_temp_28 = function $$queue_temp(name) {\n          var self = this;\n\n          return self.queue['$<<'](name)\n        }, TMP_ScopeNode_queue_temp_28.$$arity = 1);\n        \n        Opal.defn(self, '$push_while', TMP_ScopeNode_push_while_29 = function $$push_while() {\n          var self = this, info = nil;\n\n          \n          info = $hash2([], {});\n          self.while_stack.$push(info);\n          return info;\n        }, TMP_ScopeNode_push_while_29.$$arity = 0);\n        \n        Opal.defn(self, '$pop_while', TMP_ScopeNode_pop_while_30 = function $$pop_while() {\n          var self = this;\n\n          return self.while_stack.$pop()\n        }, TMP_ScopeNode_pop_while_30.$$arity = 0);\n        \n        Opal.defn(self, '$in_while?', TMP_ScopeNode_in_while$q_31 = function() {\n          var self = this;\n\n          return self.while_stack['$empty?']()['$!']()\n        }, TMP_ScopeNode_in_while$q_31.$$arity = 0);\n        \n        Opal.defn(self, '$uses_block!', TMP_ScopeNode_uses_block$B_32 = function() {\n          var $a, self = this;\n\n          if ($truthy((($a = self.type['$=='](\"iter\")) ? self.parent : self.type['$=='](\"iter\")))) {\n            return self.parent['$uses_block!']()\n            } else {\n            \n            self.uses_block = true;\n            return self['$identify!']();\n          }\n        }, TMP_ScopeNode_uses_block$B_32.$$arity = 0);\n        \n        Opal.defn(self, '$identify!', TMP_ScopeNode_identify$B_33 = function(name) {\n          var $a, $b, $c, self = this;\n\n          if (name == null) {\n            name = nil;\n          }\n          \n          if ($truthy(self.identity)) {\n            return self.identity};\n          name = ($truthy($a = name) ? $a : [($truthy($b = self.$parent()) ? ($truthy($c = self.$parent().$name()) ? $c : self.$parent().$scope_name()) : $b), self.$mid()].$compact().$join(\"_\"));\n          self.identity = self.compiler.$unique_temp(name);\n          if ($truthy(self.parent)) {\n            self.parent.$add_scope_temp(self.identity)};\n          return self.identity;\n        }, TMP_ScopeNode_identify$B_33.$$arity = -1);\n        \n        Opal.defn(self, '$identity', TMP_ScopeNode_identity_34 = function $$identity() {\n          var self = this;\n\n          return self.identity\n        }, TMP_ScopeNode_identity_34.$$arity = 0);\n        \n        Opal.defn(self, '$find_parent_def', TMP_ScopeNode_find_parent_def_35 = function $$find_parent_def() {\n          var $a, self = this, scope = nil;\n\n          \n          scope = self;\n          while ($truthy((scope = scope.$parent()))) {\n            if ($truthy(scope['$def?']())) {\n              return scope}\n          };\n          return nil;\n        }, TMP_ScopeNode_find_parent_def_35.$$arity = 0);\n        \n        Opal.defn(self, '$get_super_chain', TMP_ScopeNode_get_super_chain_36 = function $$get_super_chain() {\n          var $a, self = this, chain = nil, scope = nil, defn = nil, mid = nil;\n\n          \n          $a = [[], self, \"null\", \"null\"], (chain = $a[0]), (scope = $a[1]), (defn = $a[2]), (mid = $a[3]), $a;\n          while ($truthy(scope)) {\n            if (scope.$type()['$=='](\"iter\")) {\n              \n              chain['$<<'](scope['$identify!']());\n              if ($truthy(scope.$parent())) {\n                scope = scope.$parent()};\n            } else if ($truthy([\"def\", \"defs\"]['$include?'](scope.$type()))) {\n              \n              defn = scope['$identify!']();\n              mid = \"\" + \"'\" + (scope.$mid()) + \"'\";\n              break;;\n              } else {\n              break;\n            }\n          };\n          return [chain, defn, mid];\n        }, TMP_ScopeNode_get_super_chain_36.$$arity = 0);\n        \n        Opal.defn(self, '$uses_block?', TMP_ScopeNode_uses_block$q_37 = function() {\n          var self = this;\n\n          return self.uses_block\n        }, TMP_ScopeNode_uses_block$q_37.$$arity = 0);\n        \n        Opal.defn(self, '$has_rescue_else?', TMP_ScopeNode_has_rescue_else$q_38 = function() {\n          var self = this;\n\n          return self.$rescue_else_sexp()['$!']()['$!']()\n        }, TMP_ScopeNode_has_rescue_else$q_38.$$arity = 0);\n        \n        Opal.defn(self, '$in_ensure', TMP_ScopeNode_in_ensure_39 = function $$in_ensure() {\n          var self = this, $iter = TMP_ScopeNode_in_ensure_39.$$p, $yield = $iter || nil, result = nil;\n\n          if ($iter) TMP_ScopeNode_in_ensure_39.$$p = null;\n          \n          if (($yield !== nil)) {\n            } else {\n            return nil\n          };\n          self.in_ensure = true;\n          result = Opal.yieldX($yield, []);\n          self.in_ensure = false;\n          return result;\n        }, TMP_ScopeNode_in_ensure_39.$$arity = 0);\n        return (Opal.defn(self, '$in_ensure?', TMP_ScopeNode_in_ensure$q_40 = function() {\n          var self = this;\n\n          return self.in_ensure['$!']()['$!']()\n        }, TMP_ScopeNode_in_ensure$q_40.$$arity = 0), nil) && 'in_ensure?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/module\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$name_and_base', '$helper', '$push', '$line', '$in_scope', '$name=', '$scope', '$-', '$add_temp', '$proto', '$stmt', '$body', '$s', '$empty_line', '$to_vars', '$cid', '$nil?', '$expr']);\n  \n  self.$require(\"opal/nodes/scope\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $ModuleNode(){};\n        var self = $ModuleNode = $klass($base, $super, 'ModuleNode', $ModuleNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ModuleNode_compile_2, TMP_ModuleNode_name_and_base_3;\n\n        \n        self.$handle(\"module\");\n        self.$children(\"cid\", \"body\");\n        \n        Opal.defn(self, '$compile', TMP_ModuleNode_compile_2 = function $$compile() {\n          var $a, $b, TMP_1, self = this, name = nil, base = nil;\n\n          \n          $b = self.$name_and_base(), $a = Opal.to_ary($b), (name = ($a[0] == null ? nil : $a[0])), (base = ($a[1] == null ? nil : $a[1])), $b;\n          self.$helper(\"module\");\n          self.$push(\"(function($base, $parent_nesting) {\");\n          self.$line(\"\" + \"  var $\" + (name) + \", self = $\" + (name) + \" = $module($base, '\" + (name) + \"');\");\n          $send(self, 'in_scope', [], (TMP_1 = function(){var self = TMP_1.$$s || this, $c, $writer = nil, body_code = nil;\n\n          \n            \n            $writer = [name];\n            $send(self.$scope(), 'name=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.$add_temp(\"\" + (self.$scope().$proto()) + \" = self.$$proto\");\n            self.$add_temp(\"$nesting = [self].concat($parent_nesting)\");\n            body_code = self.$stmt(($truthy($c = self.$body()) ? $c : self.$s(\"nil\")));\n            self.$empty_line();\n            self.$line(self.$scope().$to_vars());\n            return self.$line(body_code);}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1));\n          return self.$line(\"})(\", base, \", $nesting)\");\n        }, TMP_ModuleNode_compile_2.$$arity = 0);\n        return (Opal.defn(self, '$name_and_base', TMP_ModuleNode_name_and_base_3 = function $$name_and_base() {\n          var $a, $b, self = this, base = nil, name = nil;\n\n          \n          $b = self.$cid().$children(), $a = Opal.to_ary($b), (base = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), $b;\n          if ($truthy(base['$nil?']())) {\n            return [name, \"$nesting[0]\"]\n            } else {\n            return [name, self.$expr(base)]\n          };\n        }, TMP_ModuleNode_name_and_base_3.$$arity = 0), nil) && 'name_and_base';\n      })($nesting[0], Opal.const_get_relative($nesting, 'ScopeNode'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/class\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$name_and_base', '$helper', '$push', '$line', '$in_scope', '$name=', '$scope', '$-', '$add_temp', '$proto', '$body_code', '$empty_line', '$to_vars', '$super_code', '$sup', '$expr', '$stmt', '$returns', '$compiler', '$body', '$s']);\n  \n  self.$require(\"opal/nodes/module\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $ClassNode(){};\n        var self = $ClassNode = $klass($base, $super, 'ClassNode', $ClassNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ClassNode_compile_2, TMP_ClassNode_super_code_3, TMP_ClassNode_body_code_4;\n\n        \n        self.$handle(\"class\");\n        self.$children(\"cid\", \"sup\", \"body\");\n        \n        Opal.defn(self, '$compile', TMP_ClassNode_compile_2 = function $$compile() {\n          var $a, $b, TMP_1, self = this, name = nil, base = nil;\n\n          \n          $b = self.$name_and_base(), $a = Opal.to_ary($b), (name = ($a[0] == null ? nil : $a[0])), (base = ($a[1] == null ? nil : $a[1])), $b;\n          self.$helper(\"klass\");\n          self.$push(\"(function($base, $super, $parent_nesting) {\");\n          self.$line(\"\" + \"  function $\" + (name) + \"(){};\");\n          self.$line(\"\" + \"  var self = $\" + (name) + \" = $klass($base, $super, '\" + (name) + \"', $\" + (name) + \");\");\n          $send(self, 'in_scope', [], (TMP_1 = function(){var self = TMP_1.$$s || this, $writer = nil, body_code = nil;\n\n          \n            \n            $writer = [name];\n            $send(self.$scope(), 'name=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.$add_temp(\"\" + (self.$scope().$proto()) + \" = self.$$proto\");\n            self.$add_temp(\"$nesting = [self].concat($parent_nesting)\");\n            body_code = self.$body_code();\n            self.$empty_line();\n            self.$line(self.$scope().$to_vars());\n            return self.$line(body_code);}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1));\n          return self.$line(\"})(\", base, \", \", self.$super_code(), \", $nesting)\");\n        }, TMP_ClassNode_compile_2.$$arity = 0);\n        \n        Opal.defn(self, '$super_code', TMP_ClassNode_super_code_3 = function $$super_code() {\n          var self = this;\n\n          if ($truthy(self.$sup())) {\n            return self.$expr(self.$sup())\n            } else {\n            return \"null\"\n          }\n        }, TMP_ClassNode_super_code_3.$$arity = 0);\n        return (Opal.defn(self, '$body_code', TMP_ClassNode_body_code_4 = function $$body_code() {\n          var $a, self = this;\n\n          return self.$stmt(self.$compiler().$returns(($truthy($a = self.$body()) ? $a : self.$s(\"nil\"))))\n        }, TMP_ClassNode_body_code_4.$$arity = 0), nil) && 'body_code';\n      })($nesting[0], Opal.const_get_relative($nesting, 'ModuleNode'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/singleton_class\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$push', '$in_scope', '$add_temp', '$stmt', '$returns', '$compiler', '$body', '$line', '$to_vars', '$scope', '$recv', '$object']);\n  \n  self.$require(\"opal/nodes/scope\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $SingletonClassNode(){};\n        var self = $SingletonClassNode = $klass($base, $super, 'SingletonClassNode', $SingletonClassNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SingletonClassNode_compile_2;\n\n        \n        self.$handle(\"sclass\");\n        self.$children(\"object\", \"body\");\n        return (Opal.defn(self, '$compile', TMP_SingletonClassNode_compile_2 = function $$compile() {\n          var TMP_1, self = this;\n\n          \n          self.$push(\"(function(self, $parent_nesting) {\");\n          $send(self, 'in_scope', [], (TMP_1 = function(){var self = TMP_1.$$s || this, body_stmt = nil;\n\n          \n            self.$add_temp(\"def = self.$$proto\");\n            self.$add_temp(\"$nesting = [self].concat($parent_nesting)\");\n            body_stmt = self.$stmt(self.$compiler().$returns(self.$body()));\n            self.$line(self.$scope().$to_vars());\n            return self.$line(body_stmt);}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1));\n          return self.$line(\"})(Opal.get_singleton_class(\", self.$recv(self.$object()), \"), $nesting)\");\n        }, TMP_SingletonClassNode_compile_2.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'ScopeNode'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/inline_args\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$push', '$join', '$arg_names', '$inject', '$children', '$type', '$===', '$<<', '$add_arg', '$next_temp', '$scope', '$[]=', '$mlhs_mapping', '$-', '$!', '$[]', '$meta', '$!=', '$+', '$raise', '$inspect']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $InlineArgs(){};\n        var self = $InlineArgs = $klass($base, $super, 'InlineArgs', $InlineArgs);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_InlineArgs_compile_1, TMP_InlineArgs_arg_names_3, TMP_InlineArgs_add_arg_4;\n\n        \n        self.$handle(\"inline_args\");\n        \n        Opal.defn(self, '$compile', TMP_InlineArgs_compile_1 = function $$compile() {\n          var self = this;\n\n          return self.$push(self.$arg_names().$join(\", \"))\n        }, TMP_InlineArgs_compile_1.$$arity = 0);\n        \n        Opal.defn(self, '$arg_names', TMP_InlineArgs_arg_names_3 = function $$arg_names() {\n          var TMP_2, self = this, done_kwargs = nil;\n\n          \n          done_kwargs = false;\n          return $send(self.$children(), 'inject', [[]], (TMP_2 = function(result, arg){var self = TMP_2.$$s || this, $a, $case = nil, tmp = nil, $writer = nil, arg_name = nil, _ = nil, tmp_arg_name = nil;\nif (result == null) result = nil;if (arg == null) arg = nil;\n          \n            $case = arg.$type();\n            if (\"kwarg\"['$===']($case) || \"kwoptarg\"['$===']($case) || \"kwrestarg\"['$===']($case)) {\n            if ($truthy(done_kwargs)) {\n              } else {\n              \n              done_kwargs = true;\n              result['$<<'](\"$kwargs\");\n            };\n            self.$add_arg(arg);}\n            else if (\"mlhs\"['$===']($case)) {\n            tmp = self.$scope().$next_temp();\n            result['$<<'](tmp);\n            \n            $writer = [arg, tmp];\n            $send(self.$scope().$mlhs_mapping(), '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;}\n            else if (\"arg\"['$===']($case) || \"optarg\"['$===']($case)) {\n            $a = [].concat(Opal.to_a(arg)), (arg_name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n            if ($truthy(($truthy($a = arg.$meta()['$[]'](\"inline\")['$!']()) ? arg_name['$[]'](0)['$!='](\"$\") : $a))) {\n              arg_name = \"\" + \"$\" + (arg_name)};\n            result['$<<'](arg_name);\n            self.$add_arg(arg);}\n            else if (\"restarg\"['$===']($case)) {\n            tmp_arg_name = $rb_plus(self.$scope().$next_temp(), \"_rest\");\n            result['$<<'](tmp_arg_name);\n            self.$add_arg(arg);}\n            else {self.$raise(\"\" + \"Unknown argument type \" + (arg.$inspect()))};\n            return result;}, TMP_2.$$s = self, TMP_2.$$arity = 2, TMP_2));\n        }, TMP_InlineArgs_arg_names_3.$$arity = 0);\n        return (Opal.defn(self, '$add_arg', TMP_InlineArgs_add_arg_4 = function $$add_arg(arg) {\n          var $a, self = this, arg_name = nil, _ = nil;\n\n          \n          $a = [].concat(Opal.to_a(arg)), (arg_name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n          if ($truthy(arg_name)) {\n            return self.$scope().$add_arg(arg_name)\n            } else {\n            return nil\n          };\n        }, TMP_InlineArgs_add_arg_4.$$arity = 1), nil) && 'add_arg';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/args/normarg\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$[]', '$meta', '$add_temp', '$name', '$line', '$working_arguments', '$scope', '$in_mlhs?']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $NormargNode(){};\n        var self = $NormargNode = $klass($base, $super, 'NormargNode', $NormargNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NormargNode_compile_1;\n\n        def.sexp = nil;\n        \n        self.$handle(\"arg\");\n        self.$children(\"name\");\n        return (Opal.defn(self, '$compile', TMP_NormargNode_compile_1 = function $$compile() {\n          var self = this;\n\n          \n          if ($truthy(self.sexp.$meta()['$[]'](\"post\"))) {\n            \n            self.$add_temp(self.$name());\n            self.$line(\"\" + (self.$name()) + \" = \" + (self.$scope().$working_arguments()) + \".splice(0,1)[0];\");};\n          if ($truthy(self.$scope()['$in_mlhs?']())) {\n            \n            self.$line(\"\" + \"if (\" + (self.$name()) + \" == null) {\");\n            self.$line(\"\" + \"  \" + (self.$name()) + \" = nil;\");\n            return self.$line(\"}\");\n            } else {\n            return nil\n          };\n        }, TMP_NormargNode_compile_1.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/args/optarg\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$==', '$[]', '$default_value', '$line', '$name', '$expr', '$push']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $OptargNode(){};\n        var self = $OptargNode = $klass($base, $super, 'OptargNode', $OptargNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_OptargNode_compile_1;\n\n        \n        self.$handle(\"optarg\");\n        self.$children(\"name\", \"default_value\");\n        return (Opal.defn(self, '$compile', TMP_OptargNode_compile_1 = function $$compile() {\n          var self = this;\n\n          \n          if (self.$default_value().$children()['$[]'](1)['$=='](\"undefined\")) {\n            return nil};\n          self.$line(\"\" + \"if (\" + (self.$name()) + \" == null) {\");\n          self.$line(\"\" + \"  \" + (self.$name()) + \" = \", self.$expr(self.$default_value()));\n          self.$push(\";\");\n          return self.$line(\"}\");\n        }, TMP_OptargNode_compile_1.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/args/mlhsarg\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$s', '$children', '$[]', '$meta', '$mlhs_name', '$[]=', '$-', '$with_inline_args', '$scope', '$push', '$process', '$mlhs_mapping', '$line', '$in_mlhs', '$each', '$type', '$===', '$<<', '$join', '$to_s', '$take_while', '$!=']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $MlhsArgNode(){};\n        var self = $MlhsArgNode = $klass($base, $super, 'MlhsArgNode', $MlhsArgNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MlhsArgNode_compile_4, TMP_MlhsArgNode_mlhs_name_6, TMP_MlhsArgNode_inline_args_8;\n\n        def.sexp = def.mlhs_name = def.inline_args = nil;\n        \n        self.$handle(\"mlhs\");\n        \n        Opal.defn(self, '$compile', TMP_MlhsArgNode_compile_4 = function $$compile() {\n          var TMP_1, TMP_2, self = this, args_sexp = nil, mlhs_sexp = nil, $writer = nil, var_name = nil;\n\n          \n          args_sexp = $send(self, 's', [\"post_args\"].concat(Opal.to_a(self.$children())));\n          if ($truthy(self.sexp.$meta()['$[]'](\"post\"))) {\n            \n            mlhs_sexp = self.$s(\"arg\", self.$mlhs_name());\n            \n            $writer = [\"post\", true];\n            $send(mlhs_sexp.$meta(), '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            $send(self.$scope(), 'with_inline_args', [[]], (TMP_1 = function(){var self = TMP_1.$$s || this;\n\n            return self.$push(self.$process(mlhs_sexp))}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1));\n            var_name = (($writer = [\"js_source\", self.$mlhs_name()]), $send(args_sexp.$meta(), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]);\n            } else {\n            var_name = (($writer = [\"js_source\", self.$scope().$mlhs_mapping()['$[]'](self.sexp)]), $send(args_sexp.$meta(), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])\n          };\n          self.$line(\"\" + \"if (\" + (var_name) + \" == null) {\");\n          self.$line(\"\" + \"  \" + (var_name) + \" = nil;\");\n          self.$line(\"}\");\n          self.$line(\"\" + (var_name) + \" = Opal.to_ary(\" + (var_name) + \");\");\n          return $send(self.$scope(), 'with_inline_args', [[]], (TMP_2 = function(){var self = TMP_2.$$s || this, TMP_3;\n\n          return $send(self.$scope(), 'in_mlhs', [], (TMP_3 = function(){var self = TMP_3.$$s || this;\n\n            return self.$push(self.$process(args_sexp))}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3))}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2));\n        }, TMP_MlhsArgNode_compile_4.$$arity = 0);\n        \n        Opal.defn(self, '$mlhs_name', TMP_MlhsArgNode_mlhs_name_6 = function $$mlhs_name() {\n          var $a, TMP_5, self = this, result = nil;\n\n          return (self.mlhs_name = ($truthy($a = self.mlhs_name) ? $a : (function() {if ($truthy(self.sexp.$meta()['$[]'](\"post\"))) {\n            \n            result = [\"$mlhs_of\"];\n            $send(self.$children(), 'each', [], (TMP_5 = function(child){var self = TMP_5.$$s || this, $case = nil;\nif (child == null) child = nil;\n            return (function() {$case = child.$type();\n              if (\"arg\"['$===']($case)) {return result['$<<'](child.$children()['$[]'](0))}\n              else if (\"mlhs\"['$===']($case)) {return result['$<<'](\"mlhs\")}\n              else { return nil }})()}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));\n            return result.$join(\"_\");\n            } else {\n            return self.sexp.$children()['$[]'](0).$to_s()\n          }; return nil; })()))\n        }, TMP_MlhsArgNode_mlhs_name_6.$$arity = 0);\n        return (Opal.defn(self, '$inline_args', TMP_MlhsArgNode_inline_args_8 = function $$inline_args() {\n          var $a, TMP_7, self = this;\n\n          return (self.inline_args = ($truthy($a = self.inline_args) ? $a : $send(self.$children(), 'take_while', [], (TMP_7 = function(arg){var self = TMP_7.$$s || this, $b;\nif (arg == null) arg = nil;\n          return ($truthy($b = arg.$type()['$!='](\"restarg\")) ? arg.$type()['$!='](\"optarg\") : $b)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7))))\n        }, TMP_MlhsArgNode_inline_args_8.$$arity = 0), nil) && 'inline_args';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/args/restarg\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$name', '$add_temp', '$[]', '$meta', '$line', '$working_arguments', '$scope']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $RestargNode(){};\n        var self = $RestargNode = $klass($base, $super, 'RestargNode', $RestargNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_RestargNode_compile_1;\n\n        def.sexp = nil;\n        \n        self.$handle(\"restarg\");\n        self.$children(\"name\");\n        return (Opal.defn(self, '$compile', TMP_RestargNode_compile_1 = function $$compile() {\n          var self = this, offset = nil;\n\n          \n          if ($truthy(self.$name())) {\n            } else {\n            return nil\n          };\n          self.$add_temp(self.$name());\n          if ($truthy(self.sexp.$meta()['$[]'](\"post\"))) {\n            return self.$line(\"\" + (self.$name()) + \" = \" + (self.$scope().$working_arguments()) + \";\")\n            } else {\n            \n            offset = self.sexp.$meta()['$[]'](\"offset\");\n            self.$line(\"\" + \"var $args_len = arguments.length, $rest_len = $args_len - \" + (offset) + \";\");\n            self.$line(\"if ($rest_len < 0) { $rest_len = 0; }\");\n            self.$line(\"\" + (self.$name()) + \" = new Array($rest_len);\");\n            self.$line(\"\" + \"for (var $arg_idx = \" + (offset) + \"; $arg_idx < $args_len; $arg_idx++) {\");\n            self.$line(\"\" + \"  \" + (self.$name()) + \"[$arg_idx - \" + (offset) + \"] = arguments[$arg_idx];\");\n            return self.$line(\"}\");\n          };\n        }, TMP_RestargNode_compile_1.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/args/initialize_kwargs\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$kwargs_initialized', '$scope', '$helper', '$line', '$kwargs_initialized=', '$-']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $InitializeKwargsNode(){};\n        var self = $InitializeKwargsNode = $klass($base, $super, 'InitializeKwargsNode', $InitializeKwargsNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_InitializeKwargsNode_initialize_kw_args_if_needed_1;\n\n        return (Opal.defn(self, '$initialize_kw_args_if_needed', TMP_InitializeKwargsNode_initialize_kw_args_if_needed_1 = function $$initialize_kw_args_if_needed() {\n          var self = this, $writer = nil;\n\n          \n          if ($truthy(self.$scope().$kwargs_initialized())) {\n            return nil};\n          self.$helper(\"hash2\");\n          self.$line(\"if ($kwargs == null || !$kwargs.$$is_hash) {\");\n          self.$line(\"  if ($kwargs == null) {\");\n          self.$line(\"    $kwargs = $hash2([], {});\");\n          self.$line(\"  } else {\");\n          self.$line(\"    throw Opal.ArgumentError.$new('expected kwargs');\");\n          self.$line(\"  }\");\n          self.$line(\"}\");\n          \n          $writer = [true];\n          $send(self.$scope(), 'kwargs_initialized=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];;\n        }, TMP_InitializeKwargsNode_initialize_kw_args_if_needed_1.$$arity = 0), nil) && 'initialize_kw_args_if_needed'\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/args/kwarg\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$[]', '$meta', '$initialize_kw_args_if_needed', '$add_temp', '$lvar_name', '$line', '$inspect', '$to_s', '$<<', '$used_kwargs', '$scope']);\n  \n  self.$require(\"opal/nodes/args/initialize_kwargs\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $KwargNode(){};\n        var self = $KwargNode = $klass($base, $super, 'KwargNode', $KwargNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_KwargNode_compile_1;\n\n        def.sexp = nil;\n        \n        self.$handle(\"kwarg\");\n        self.$children(\"lvar_name\");\n        return (Opal.defn(self, '$compile', TMP_KwargNode_compile_1 = function $$compile() {\n          var self = this, key_name = nil;\n\n          \n          key_name = self.sexp.$meta()['$[]'](\"arg_name\");\n          self.$initialize_kw_args_if_needed();\n          self.$add_temp(self.$lvar_name());\n          self.$line(\"\" + \"if (!Opal.hasOwnProperty.call($kwargs.$$smap, '\" + (key_name) + \"')) {\");\n          self.$line(\"\" + \"  throw Opal.ArgumentError.$new('missing keyword: \" + (key_name) + \"');\");\n          self.$line(\"}\");\n          self.$line(\"\" + (self.$lvar_name()) + \" = $kwargs.$$smap[\" + (key_name.$to_s().$inspect()) + \"];\");\n          return self.$scope().$used_kwargs()['$<<'](key_name);\n        }, TMP_KwargNode_compile_1.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'InitializeKwargsNode'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/args/kwoptarg\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$[]', '$meta', '$initialize_kw_args_if_needed', '$add_temp', '$lvar_name', '$line', '$inspect', '$to_s', '$<<', '$used_kwargs', '$scope', '$==', '$default_value', '$expr']);\n  \n  self.$require(\"opal/nodes/args/initialize_kwargs\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $KwoptArgNode(){};\n        var self = $KwoptArgNode = $klass($base, $super, 'KwoptArgNode', $KwoptArgNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_KwoptArgNode_compile_1;\n\n        def.sexp = nil;\n        \n        self.$handle(\"kwoptarg\");\n        self.$children(\"lvar_name\", \"default_value\");\n        return (Opal.defn(self, '$compile', TMP_KwoptArgNode_compile_1 = function $$compile() {\n          var self = this, key_name = nil;\n\n          \n          key_name = self.sexp.$meta()['$[]'](\"arg_name\");\n          self.$initialize_kw_args_if_needed();\n          self.$add_temp(self.$lvar_name());\n          self.$line(\"\" + (self.$lvar_name()) + \" = $kwargs.$$smap[\" + (key_name.$to_s().$inspect()) + \"];\");\n          self.$scope().$used_kwargs()['$<<'](key_name);\n          if (self.$default_value().$children()['$[]'](1)['$=='](\"undefined\")) {\n            return nil};\n          self.$line(\"\" + \"if (\" + (self.$lvar_name()) + \" == null) {\");\n          self.$line(\"\" + \"  \" + (self.$lvar_name()) + \" = \", self.$expr(self.$default_value()));\n          return self.$line(\"}\");\n        }, TMP_KwoptArgNode_compile_1.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'InitializeKwargsNode'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/args/kwrestarg\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$initialize_kw_args_if_needed', '$used_kwargs', '$name', '$add_temp', '$line', '$map', '$scope', '$join']);\n  \n  self.$require(\"opal/nodes/args/initialize_kwargs\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $KwrestArgNode(){};\n        var self = $KwrestArgNode = $klass($base, $super, 'KwrestArgNode', $KwrestArgNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_KwrestArgNode_compile_1, TMP_KwrestArgNode_used_kwargs_3;\n\n        \n        self.$handle(\"kwrestarg\");\n        self.$children(\"name\");\n        \n        Opal.defn(self, '$compile', TMP_KwrestArgNode_compile_1 = function $$compile() {\n          var self = this, extract_code = nil;\n\n          \n          self.$initialize_kw_args_if_needed();\n          extract_code = \"\" + \"Opal.kwrestargs($kwargs, \" + (self.$used_kwargs()) + \");\";\n          if ($truthy(self.$name())) {\n            \n            self.$add_temp(self.$name());\n            return self.$line(\"\" + (self.$name()) + \" = \" + (extract_code));\n            } else {\n            return nil\n          };\n        }, TMP_KwrestArgNode_compile_1.$$arity = 0);\n        return (Opal.defn(self, '$used_kwargs', TMP_KwrestArgNode_used_kwargs_3 = function $$used_kwargs() {\n          var TMP_2, self = this, args = nil;\n\n          \n          args = $send(self.$scope().$used_kwargs(), 'map', [], (TMP_2 = function(arg_name){var self = TMP_2.$$s || this;\nif (arg_name == null) arg_name = nil;\n          return \"\" + \"'\" + (arg_name) + \"': true\"}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));\n          return \"\" + \"{\" + (args.$join(\",\")) + \"}\";\n        }, TMP_KwrestArgNode_used_kwargs_3.$$arity = 0), nil) && 'used_kwargs';\n      })($nesting[0], Opal.const_get_relative($nesting, 'InitializeKwargsNode'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/args/post_kwargs\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$handle', '$empty?', '$children', '$initialize_kw_args', '$each', '$push', '$process', '$line', '$working_arguments', '$scope']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $PostKwargsNode(){};\n        var self = $PostKwargsNode = $klass($base, $super, 'PostKwargsNode', $PostKwargsNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_PostKwargsNode_compile_2, TMP_PostKwargsNode_initialize_kw_args_3;\n\n        \n        self.$handle(\"post_kwargs\");\n        \n        Opal.defn(self, '$compile', TMP_PostKwargsNode_compile_2 = function $$compile() {\n          var TMP_1, self = this;\n\n          \n          if ($truthy(self.$children()['$empty?']())) {\n            return nil};\n          self.$initialize_kw_args();\n          return $send(self.$children(), 'each', [], (TMP_1 = function(arg){var self = TMP_1.$$s || this;\nif (arg == null) arg = nil;\n          return self.$push(self.$process(arg))}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));\n        }, TMP_PostKwargsNode_compile_2.$$arity = 0);\n        return (Opal.defn(self, '$initialize_kw_args', TMP_PostKwargsNode_initialize_kw_args_3 = function $$initialize_kw_args() {\n          var self = this;\n\n          return self.$line(\"\" + \"$kwargs = Opal.extract_kwargs(\" + (self.$scope().$working_arguments()) + \");\")\n        }, TMP_PostKwargsNode_initialize_kw_args_3.$$arity = 0), nil) && 'initialize_kw_args';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/args/post_args\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$attr_reader', '$each', '$children', '$[]=', '$meta', '$-', '$type', '$===', '$<<', '$empty?', '$working_arguments', '$scope', '$[]', '$working_arguments=', '$add_temp', '$line', '$size', '$inline_args', '$extract_arguments', '$push', '$process', '$kwargs_sexp', '$required_left_args', '$compile_required_arg', '$optargs', '$compile_optarg', '$compile_restarg', '$required_right_args', '$indent', '$restarg', '$extract_restarg', '$extract_blank_restarg', '$s', '$kwargs']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $PostArgsNode(){};\n        var self = $PostArgsNode = $klass($base, $super, 'PostArgsNode', $PostArgsNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_PostArgsNode_initialize_1, TMP_PostArgsNode_extract_arguments_3, TMP_PostArgsNode_compile_7, TMP_PostArgsNode_compile_optarg_9, TMP_PostArgsNode_compile_required_arg_10, TMP_PostArgsNode_compile_restarg_13, TMP_PostArgsNode_extract_restarg_14, TMP_PostArgsNode_extract_blank_restarg_15, TMP_PostArgsNode_kwargs_sexp_16;\n\n        def.sexp = nil;\n        \n        self.$handle(\"post_args\");\n        self.$attr_reader(\"kwargs\");\n        self.$attr_reader(\"required_left_args\");\n        self.$attr_reader(\"optargs\");\n        self.$attr_reader(\"restarg\");\n        self.$attr_reader(\"required_right_args\");\n        \n        Opal.defn(self, '$initialize', TMP_PostArgsNode_initialize_1 = function $$initialize($a_rest) {\n          var self = this, $iter = TMP_PostArgsNode_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_PostArgsNode_initialize_1.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_PostArgsNode_initialize_1, false), $zuper, $iter);\n          self.kwargs = [];\n          self.required_left_args = [];\n          self.optargs = [];\n          self.restarg = nil;\n          return (self.required_right_args = []);\n        }, TMP_PostArgsNode_initialize_1.$$arity = -1);\n        \n        Opal.defn(self, '$extract_arguments', TMP_PostArgsNode_extract_arguments_3 = function $$extract_arguments() {\n          var TMP_2, self = this, found_opt_or_rest = nil;\n\n          \n          found_opt_or_rest = false;\n          return $send(self.$children(), 'each', [], (TMP_2 = function(arg){var self = TMP_2.$$s || this, $writer = nil, $case = nil;\n            if (self.kwargs == null) self.kwargs = nil;\n            if (self.optargs == null) self.optargs = nil;\n            if (self.required_right_args == null) self.required_right_args = nil;\n            if (self.required_left_args == null) self.required_left_args = nil;\nif (arg == null) arg = nil;\n          \n            \n            $writer = [\"post\", true];\n            $send(arg.$meta(), '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            return (function() {$case = arg.$type();\n            if (\"kwarg\"['$===']($case) || \"kwoptarg\"['$===']($case) || \"kwrestarg\"['$===']($case)) {return self.kwargs['$<<'](arg)}\n            else if (\"restarg\"['$===']($case)) {\n            self.restarg = arg;\n            return (found_opt_or_rest = true);}\n            else if (\"optarg\"['$===']($case)) {\n            self.optargs['$<<'](arg);\n            return (found_opt_or_rest = true);}\n            else if (\"arg\"['$===']($case) || \"mlhs\"['$===']($case)) {if ($truthy(found_opt_or_rest)) {\n              return self.required_right_args['$<<'](arg)\n              } else {\n              return self.required_left_args['$<<'](arg)\n            }}\n            else { return nil }})();}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));\n        }, TMP_PostArgsNode_extract_arguments_3.$$arity = 0);\n        \n        Opal.defn(self, '$compile', TMP_PostArgsNode_compile_7 = function $$compile() {\n          var TMP_4, TMP_5, TMP_6, self = this, old_working_arguments = nil, js_source = nil, $writer = nil;\n\n          \n          if ($truthy(self.$children()['$empty?']())) {\n            return nil};\n          old_working_arguments = self.$scope().$working_arguments();\n          if ($truthy(self.sexp.$meta()['$[]'](\"js_source\"))) {\n            \n            js_source = self.sexp.$meta()['$[]'](\"js_source\");\n            \n            $writer = [\"\" + (js_source) + \"_args\"];\n            $send(self.$scope(), 'working_arguments=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            } else {\n            \n            js_source = \"arguments\";\n            \n            $writer = [\"$post_args\"];\n            $send(self.$scope(), 'working_arguments=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n          };\n          self.$add_temp(\"\" + (self.$scope().$working_arguments()));\n          self.$line(\"\" + (self.$scope().$working_arguments()) + \" = Opal.slice.call(\" + (js_source) + \", \" + (self.$scope().$inline_args().$size()) + \", \" + (js_source) + \".length);\");\n          self.$extract_arguments();\n          self.$push(self.$process(self.$kwargs_sexp()));\n          $send(self.$required_left_args(), 'each', [], (TMP_4 = function(arg){var self = TMP_4.$$s || this;\nif (arg == null) arg = nil;\n          return self.$compile_required_arg(arg)}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));\n          $send(self.$optargs(), 'each', [], (TMP_5 = function(optarg){var self = TMP_5.$$s || this;\nif (optarg == null) optarg = nil;\n          return self.$compile_optarg(optarg)}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));\n          self.$compile_restarg();\n          $send(self.$required_right_args(), 'each', [], (TMP_6 = function(arg){var self = TMP_6.$$s || this;\nif (arg == null) arg = nil;\n          return self.$compile_required_arg(arg)}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));\n          \n          $writer = [old_working_arguments];\n          $send(self.$scope(), 'working_arguments=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];;\n        }, TMP_PostArgsNode_compile_7.$$arity = 0);\n        \n        Opal.defn(self, '$compile_optarg', TMP_PostArgsNode_compile_optarg_9 = function $$compile_optarg(optarg) {\n          var $a, TMP_8, self = this, var_name = nil, _ = nil;\n\n          \n          $a = [].concat(Opal.to_a(optarg)), (var_name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n          self.$add_temp(var_name);\n          self.$line(\"\" + \"if (\" + (self.$required_right_args().$size()) + \" < \" + (self.$scope().$working_arguments()) + \".length) {\");\n          $send(self, 'indent', [], (TMP_8 = function(){var self = TMP_8.$$s || this;\n\n          return self.$line(\"\" + (var_name) + \" = \" + (self.$scope().$working_arguments()) + \".splice(0,1)[0];\")}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8));\n          self.$line(\"}\");\n          return self.$push(self.$process(optarg));\n        }, TMP_PostArgsNode_compile_optarg_9.$$arity = 1);\n        \n        Opal.defn(self, '$compile_required_arg', TMP_PostArgsNode_compile_required_arg_10 = function $$compile_required_arg(arg) {\n          var self = this;\n\n          return self.$push(self.$process(arg))\n        }, TMP_PostArgsNode_compile_required_arg_10.$$arity = 1);\n        \n        Opal.defn(self, '$compile_restarg', TMP_PostArgsNode_compile_restarg_13 = function $$compile_restarg() {\n          var TMP_11, TMP_12, self = this;\n\n          \n          if ($truthy(self.$restarg())) {\n            } else {\n            return nil\n          };\n          self.$line(\"\" + \"if (\" + (self.$required_right_args().$size()) + \" < \" + (self.$scope().$working_arguments()) + \".length) {\");\n          $send(self, 'indent', [], (TMP_11 = function(){var self = TMP_11.$$s || this;\n\n          return self.$extract_restarg()}, TMP_11.$$s = self, TMP_11.$$arity = 0, TMP_11));\n          self.$line(\"} else {\");\n          $send(self, 'indent', [], (TMP_12 = function(){var self = TMP_12.$$s || this;\n\n          return self.$extract_blank_restarg()}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12));\n          return self.$line(\"}\");\n        }, TMP_PostArgsNode_compile_restarg_13.$$arity = 0);\n        \n        Opal.defn(self, '$extract_restarg', TMP_PostArgsNode_extract_restarg_14 = function $$extract_restarg() {\n          var $a, self = this, extract_code = nil, var_name = nil, _ = nil;\n\n          \n          extract_code = \"\" + (self.$scope().$working_arguments()) + \".splice(0, \" + (self.$scope().$working_arguments()) + \".length - \" + (self.$required_right_args().$size()) + \");\";\n          $a = [].concat(Opal.to_a(self.$restarg())), (var_name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n          if ($truthy(var_name)) {\n            \n            self.$add_temp(var_name);\n            return self.$line(\"\" + (var_name) + \" = \" + (extract_code));\n            } else {\n            return self.$line(extract_code)\n          };\n        }, TMP_PostArgsNode_extract_restarg_14.$$arity = 0);\n        \n        Opal.defn(self, '$extract_blank_restarg', TMP_PostArgsNode_extract_blank_restarg_15 = function $$extract_blank_restarg() {\n          var $a, self = this, var_name = nil, _ = nil;\n\n          \n          $a = [].concat(Opal.to_a(self.$restarg())), (var_name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n          if ($truthy(var_name)) {\n            \n            self.$add_temp(var_name);\n            return self.$line(\"\" + (var_name) + \" = [];\");\n            } else {\n            return nil\n          };\n        }, TMP_PostArgsNode_extract_blank_restarg_15.$$arity = 0);\n        return (Opal.defn(self, '$kwargs_sexp', TMP_PostArgsNode_kwargs_sexp_16 = function $$kwargs_sexp() {\n          var self = this;\n\n          return $send(self, 's', [\"post_kwargs\"].concat(Opal.to_a(self.$kwargs())))\n        }, TMP_PostArgsNode_kwargs_sexp_16.$$arity = 0), nil) && 'kwargs_sexp';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/node_with_args\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$attr_accessor', '$attr_writer', '$attr_reader', '$children', '$args', '$each_with_index', '$type', '$===', '$<<', '$any?', '$[]', '$length', '$!=', '$map!', '$inline_args', '$updated', '$optimize_args!', '$select', '$==', '$find', '$include?', '$s', '$post_args', '$each', '$push', '$process', '$post_args_sexp', '$uses_block?', '$scope', '$identity', '$block_name', '$add_temp', '$line', '$inline_args=', '$-', '$first', '$pop', '$[]=', '$meta', '$keyword_args', '$all?', '$rest_arg', '$opt_args', '$has_only_optional_kwargs?', '$negative_arity', '$positive_arity', '$size', '$has_required_kwargs?', '$+', '$-@', '$map', '$build_parameter', '$block_arg', '$join', '$!', '$empty?', '$<', '$>']);\n  \n  self.$require(\"opal/nodes/scope\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $NodeWithArgs(){};\n        var self = $NodeWithArgs = $klass($base, $super, 'NodeWithArgs', $NodeWithArgs);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NodeWithArgs_initialize_1, TMP_NodeWithArgs_split_args_5, TMP_NodeWithArgs_opt_args_7, TMP_NodeWithArgs_rest_arg_9, TMP_NodeWithArgs_keyword_args_11, TMP_NodeWithArgs_inline_args_sexp_12, TMP_NodeWithArgs_post_args_sexp_13, TMP_NodeWithArgs_compile_inline_args_15, TMP_NodeWithArgs_compile_post_args_16, TMP_NodeWithArgs_compile_block_arg_17, TMP_NodeWithArgs_with_inline_args_18, TMP_NodeWithArgs_in_mlhs_19, TMP_NodeWithArgs_in_mlhs$q_20, TMP_NodeWithArgs_optimize_args$B_21, TMP_NodeWithArgs_has_only_optional_kwargs$q_23, TMP_NodeWithArgs_has_required_kwargs$q_25, TMP_NodeWithArgs_arity_26, TMP_NodeWithArgs_negative_arity_28, TMP_NodeWithArgs_positive_arity_29, TMP_NodeWithArgs_build_parameter_30, TMP_NodeWithArgs_parameters_code_32, TMP_NodeWithArgs_arity_checks_33;\n\n        def.opt_args = def.rest_arg = def.keyword_args = def.in_mlhs = def.arity_checks = nil;\n        \n        self.$attr_accessor(\"mlhs_args\");\n        self.$attr_accessor(\"used_kwargs\");\n        self.$attr_accessor(\"mlhs_mapping\");\n        self.$attr_accessor(\"working_arguments\");\n        self.$attr_writer(\"inline_args\");\n        self.$attr_accessor(\"kwargs_initialized\");\n        self.$attr_reader(\"inline_args\", \"post_args\");\n        \n        Opal.defn(self, '$initialize', TMP_NodeWithArgs_initialize_1 = function $$initialize($a_rest) {\n          var self = this, $iter = TMP_NodeWithArgs_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_NodeWithArgs_initialize_1.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_NodeWithArgs_initialize_1, false), $zuper, $iter);\n          self.mlhs_args = $hash2([], {});\n          self.used_kwargs = [];\n          self.mlhs_mapping = $hash2([], {});\n          self.working_arguments = nil;\n          self.in_mlhs = false;\n          self.kwargs_initialized = false;\n          self.inline_args = [];\n          self.post_args = [];\n          return (self.post_args_started = false);\n        }, TMP_NodeWithArgs_initialize_1.$$arity = -1);\n        \n        Opal.defn(self, '$split_args', TMP_NodeWithArgs_split_args_5 = function $$split_args() {\n          var TMP_2, TMP_4, self = this, args = nil;\n\n          \n          args = self.$args().$children();\n          $send(args, 'each_with_index', [], (TMP_2 = function(arg, idx){var self = TMP_2.$$s || this, TMP_3, $case = nil;\n            if (self.post_args_started == null) self.post_args_started = nil;\n            if (self.post_args == null) self.post_args = nil;\n            if (self.inline_args == null) self.inline_args = nil;\nif (arg == null) arg = nil;if (idx == null) idx = nil;\n          return (function() {$case = arg.$type();\n            if (\"arg\"['$===']($case) || \"mlhs\"['$===']($case) || \"kwarg\"['$===']($case) || \"kwoptarg\"['$===']($case) || \"kwrestarg\"['$===']($case)) {if ($truthy(self.post_args_started)) {\n              return self.post_args['$<<'](arg)\n              } else {\n              return self.inline_args['$<<'](arg)\n            }}\n            else if (\"restarg\"['$===']($case)) {\n            self.post_args_started = true;\n            return self.post_args['$<<'](arg);}\n            else if (\"optarg\"['$===']($case)) {\n            if ($truthy($send(args['$[]'](idx, args.$length()), 'any?', [], (TMP_3 = function(next_arg){var self = TMP_3.$$s || this, $a;\nif (next_arg == null) next_arg = nil;\n            return ($truthy($a = next_arg.$type()['$!='](\"optarg\")) ? next_arg.$type()['$!='](\"restarg\") : $a)}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3)))) {\n              self.post_args_started = true};\n            if ($truthy(self.post_args_started)) {\n              return self.post_args['$<<'](arg)\n              } else {\n              return self.inline_args['$<<'](arg)\n            };}\n            else { return nil }})()}, TMP_2.$$s = self, TMP_2.$$arity = 2, TMP_2));\n          $send(self.$inline_args(), 'map!', [], (TMP_4 = function(inline_arg){var self = TMP_4.$$s || this;\nif (inline_arg == null) inline_arg = nil;\n          return inline_arg.$updated(nil, nil, $hash2([\"meta\"], {\"meta\": $hash2([\"inline\"], {\"inline\": true})}))}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));\n          return self['$optimize_args!']();\n        }, TMP_NodeWithArgs_split_args_5.$$arity = 0);\n        \n        Opal.defn(self, '$opt_args', TMP_NodeWithArgs_opt_args_7 = function $$opt_args() {\n          var $a, TMP_6, self = this;\n\n          return (self.opt_args = ($truthy($a = self.opt_args) ? $a : $send(self.$args().$children(), 'select', [], (TMP_6 = function(arg){var self = TMP_6.$$s || this;\nif (arg == null) arg = nil;\n          return arg.$type()['$=='](\"optarg\")}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6))))\n        }, TMP_NodeWithArgs_opt_args_7.$$arity = 0);\n        \n        Opal.defn(self, '$rest_arg', TMP_NodeWithArgs_rest_arg_9 = function $$rest_arg() {\n          var $a, TMP_8, self = this;\n\n          return (self.rest_arg = ($truthy($a = self.rest_arg) ? $a : $send(self.$args().$children(), 'find', [], (TMP_8 = function(arg){var self = TMP_8.$$s || this;\nif (arg == null) arg = nil;\n          return arg.$type()['$=='](\"restarg\")}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8))))\n        }, TMP_NodeWithArgs_rest_arg_9.$$arity = 0);\n        \n        Opal.defn(self, '$keyword_args', TMP_NodeWithArgs_keyword_args_11 = function $$keyword_args() {\n          var $a, TMP_10, self = this;\n\n          return (self.keyword_args = ($truthy($a = self.keyword_args) ? $a : $send(self.$args().$children(), 'select', [], (TMP_10 = function(arg){var self = TMP_10.$$s || this;\nif (arg == null) arg = nil;\n          return [\"kwarg\", \"kwoptarg\", \"kwrestarg\"]['$include?'](arg.$type())}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10))))\n        }, TMP_NodeWithArgs_keyword_args_11.$$arity = 0);\n        \n        Opal.defn(self, '$inline_args_sexp', TMP_NodeWithArgs_inline_args_sexp_12 = function $$inline_args_sexp() {\n          var self = this;\n\n          return $send(self, 's', [\"inline_args\"].concat(Opal.to_a(self.$args().$children())))\n        }, TMP_NodeWithArgs_inline_args_sexp_12.$$arity = 0);\n        \n        Opal.defn(self, '$post_args_sexp', TMP_NodeWithArgs_post_args_sexp_13 = function $$post_args_sexp() {\n          var self = this;\n\n          return $send(self, 's', [\"post_args\"].concat(Opal.to_a(self.$post_args())))\n        }, TMP_NodeWithArgs_post_args_sexp_13.$$arity = 0);\n        \n        Opal.defn(self, '$compile_inline_args', TMP_NodeWithArgs_compile_inline_args_15 = function $$compile_inline_args() {\n          var TMP_14, self = this;\n\n          return $send(self.$inline_args(), 'each', [], (TMP_14 = function(inline_arg){var self = TMP_14.$$s || this;\nif (inline_arg == null) inline_arg = nil;\n          return self.$push(self.$process(inline_arg))}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14))\n        }, TMP_NodeWithArgs_compile_inline_args_15.$$arity = 0);\n        \n        Opal.defn(self, '$compile_post_args', TMP_NodeWithArgs_compile_post_args_16 = function $$compile_post_args() {\n          var self = this;\n\n          return self.$push(self.$process(self.$post_args_sexp()))\n        }, TMP_NodeWithArgs_compile_post_args_16.$$arity = 0);\n        \n        Opal.defn(self, '$compile_block_arg', TMP_NodeWithArgs_compile_block_arg_17 = function $$compile_block_arg() {\n          var self = this, scope_name = nil, yielder = nil;\n\n          if ($truthy(self.$scope()['$uses_block?']())) {\n            \n            scope_name = self.$scope().$identity();\n            yielder = self.$scope().$block_name();\n            self.$add_temp(\"\" + \"$iter = \" + (scope_name) + \".$$p\");\n            self.$add_temp(\"\" + (yielder) + \" = $iter || nil\");\n            return self.$line(\"\" + \"if ($iter) \" + (scope_name) + \".$$p = null;\");\n            } else {\n            return nil\n          }\n        }, TMP_NodeWithArgs_compile_block_arg_17.$$arity = 0);\n        \n        Opal.defn(self, '$with_inline_args', TMP_NodeWithArgs_with_inline_args_18 = function $$with_inline_args(args) {\n          var self = this, $iter = TMP_NodeWithArgs_with_inline_args_18.$$p, $yield = $iter || nil, old_inline_args = nil, $writer = nil;\n\n          if ($iter) TMP_NodeWithArgs_with_inline_args_18.$$p = null;\n          \n          old_inline_args = self.$inline_args();\n          \n          $writer = [args];\n          $send(self, 'inline_args=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          Opal.yieldX($yield, []);\n          \n          $writer = [old_inline_args];\n          $send(self, 'inline_args=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];;\n        }, TMP_NodeWithArgs_with_inline_args_18.$$arity = 1);\n        \n        Opal.defn(self, '$in_mlhs', TMP_NodeWithArgs_in_mlhs_19 = function $$in_mlhs() {\n          var self = this, $iter = TMP_NodeWithArgs_in_mlhs_19.$$p, $yield = $iter || nil, old_mlhs = nil;\n\n          if ($iter) TMP_NodeWithArgs_in_mlhs_19.$$p = null;\n          \n          old_mlhs = self.in_mlhs;\n          self.in_mlhs = true;\n          Opal.yieldX($yield, []);\n          return (self.in_mlhs = old_mlhs);\n        }, TMP_NodeWithArgs_in_mlhs_19.$$arity = 0);\n        \n        Opal.defn(self, '$in_mlhs?', TMP_NodeWithArgs_in_mlhs$q_20 = function() {\n          var self = this;\n\n          return self.in_mlhs\n        }, TMP_NodeWithArgs_in_mlhs$q_20.$$arity = 0);\n        \n        Opal.defn(self, '$optimize_args!', TMP_NodeWithArgs_optimize_args$B_21 = function() {\n          var $a, self = this, rest_arg = nil, $writer = nil;\n\n          if ($truthy((($a = self.$post_args().$length()['$=='](1)) ? self.$post_args().$first().$type()['$=='](\"restarg\") : self.$post_args().$length()['$=='](1)))) {\n            \n            rest_arg = self.$post_args().$pop();\n            \n            $writer = [\"offset\", self.$inline_args().$length()];\n            $send(rest_arg.$meta(), '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            return self.$inline_args()['$<<'](rest_arg);\n            } else {\n            return nil\n          }\n        }, TMP_NodeWithArgs_optimize_args$B_21.$$arity = 0);\n        \n        Opal.defn(self, '$has_only_optional_kwargs?', TMP_NodeWithArgs_has_only_optional_kwargs$q_23 = function() {\n          var $a, TMP_22, self = this;\n\n          return ($truthy($a = self.$keyword_args()['$any?']()) ? $send(self.$keyword_args(), 'all?', [], (TMP_22 = function(arg){var self = TMP_22.$$s || this;\nif (arg == null) arg = nil;\n          return [\"kwoptarg\", \"kwrestarg\"]['$include?'](arg.$type())}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22)) : $a)\n        }, TMP_NodeWithArgs_has_only_optional_kwargs$q_23.$$arity = 0);\n        \n        Opal.defn(self, '$has_required_kwargs?', TMP_NodeWithArgs_has_required_kwargs$q_25 = function() {\n          var TMP_24, self = this;\n\n          return $send(self.$keyword_args(), 'any?', [], (TMP_24 = function(arg){var self = TMP_24.$$s || this;\nif (arg == null) arg = nil;\n          return arg.$type()['$=='](\"kwarg\")}, TMP_24.$$s = self, TMP_24.$$arity = 1, TMP_24))\n        }, TMP_NodeWithArgs_has_required_kwargs$q_25.$$arity = 0);\n        \n        Opal.defn(self, '$arity', TMP_NodeWithArgs_arity_26 = function $$arity() {\n          var $a, $b, self = this;\n\n          if ($truthy(($truthy($a = ($truthy($b = self.$rest_arg()) ? $b : self.$opt_args()['$any?']())) ? $a : self['$has_only_optional_kwargs?']()))) {\n            return self.$negative_arity()\n            } else {\n            return self.$positive_arity()\n          }\n        }, TMP_NodeWithArgs_arity_26.$$arity = 0);\n        \n        Opal.defn(self, '$negative_arity', TMP_NodeWithArgs_negative_arity_28 = function $$negative_arity() {\n          var TMP_27, self = this, required_plain_args = nil, result = nil;\n\n          \n          required_plain_args = $send(self.$args().$children(), 'select', [], (TMP_27 = function(arg){var self = TMP_27.$$s || this;\nif (arg == null) arg = nil;\n          return [\"arg\", \"mlhs\"]['$include?'](arg.$type())}, TMP_27.$$s = self, TMP_27.$$arity = 1, TMP_27));\n          result = required_plain_args.$size();\n          if ($truthy(self['$has_required_kwargs?']())) {\n            result = $rb_plus(result, 1)};\n          result = $rb_minus(result['$-@'](), 1);\n          return result;\n        }, TMP_NodeWithArgs_negative_arity_28.$$arity = 0);\n        \n        Opal.defn(self, '$positive_arity', TMP_NodeWithArgs_positive_arity_29 = function $$positive_arity() {\n          var self = this, result = nil;\n\n          \n          result = self.$args().$children().$size();\n          result = $rb_minus(result, self.$keyword_args().$size());\n          if ($truthy(self.$keyword_args()['$any?']())) {\n            result = $rb_plus(result, 1)};\n          return result;\n        }, TMP_NodeWithArgs_positive_arity_29.$$arity = 0);\n        \n        Opal.defn(self, '$build_parameter', TMP_NodeWithArgs_build_parameter_30 = function $$build_parameter(parameter_type, parameter_name) {\n          var self = this;\n\n          if ($truthy(parameter_name)) {\n            return \"\" + \"['\" + (parameter_type) + \"', '\" + (parameter_name) + \"']\"\n            } else {\n            return \"\" + \"['\" + (parameter_type) + \"']\"\n          }\n        }, TMP_NodeWithArgs_build_parameter_30.$$arity = 2);\n        Opal.const_set($nesting[0], 'SEXP_TO_PARAMETERS', $hash2([\"arg\", \"mlhs\", \"optarg\", \"restarg\", \"kwarg\", \"kwoptarg\", \"kwrestarg\"], {\"arg\": \"req\", \"mlhs\": \"req\", \"optarg\": \"opt\", \"restarg\": \"rest\", \"kwarg\": \"keyreq\", \"kwoptarg\": \"key\", \"kwrestarg\": \"keyrest\"}));\n        \n        Opal.defn(self, '$parameters_code', TMP_NodeWithArgs_parameters_code_32 = function $$parameters_code() {\n          var TMP_31, self = this, stringified_parameters = nil;\n\n          \n          stringified_parameters = $send(self.$args().$children(), 'map', [], (TMP_31 = function(arg){var self = TMP_31.$$s || this, value = nil;\nif (arg == null) arg = nil;\n          \n            value = (function() {if (arg.$type()['$=='](\"mlhs\")) {\n              return nil\n              } else {\n              return arg.$children()['$[]'](0)\n            }; return nil; })();\n            return self.$build_parameter(Opal.const_get_relative($nesting, 'SEXP_TO_PARAMETERS')['$[]'](arg.$type()), value);}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31));\n          if ($truthy(self.$block_arg())) {\n            stringified_parameters['$<<'](\"\" + \"['block', '\" + (self.$block_arg()) + \"']\")};\n          return \"\" + \"[\" + (stringified_parameters.$join(\", \")) + \"]\";\n        }, TMP_NodeWithArgs_parameters_code_32.$$arity = 0);\n        return (Opal.defn(self, '$arity_checks', TMP_NodeWithArgs_arity_checks_33 = function $$arity_checks() {\n          var $a, $b, $c, self = this, arity = nil, min_arity = nil, max_arity = nil;\n\n          \n          if ($truthy((($a = self['arity_checks'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {\n            return self.arity_checks};\n          arity = self.$args().$children().$size();\n          arity = $rb_minus(arity, self.$opt_args().$size());\n          if ($truthy(self.$rest_arg())) {\n            arity = $rb_minus(arity, 1)};\n          arity = $rb_minus(arity, self.$keyword_args().$size());\n          if ($truthy(($truthy($b = ($truthy($c = self.$opt_args()['$empty?']()['$!']()) ? $c : self.$keyword_args()['$empty?']()['$!']())) ? $b : self.$rest_arg()))) {\n            arity = $rb_minus(arity['$-@'](), 1)};\n          self.arity_checks = [];\n          if ($truthy($rb_lt(arity, 0))) {\n            \n            min_arity = $rb_plus(arity, 1)['$-@']();\n            max_arity = self.$args().$children().$size();\n            if ($truthy($rb_gt(min_arity, 0))) {\n              self.arity_checks['$<<'](\"\" + \"$arity < \" + (min_arity))};\n            if ($truthy(($truthy($b = max_arity) ? self.$rest_arg()['$!']() : $b))) {\n              self.arity_checks['$<<'](\"\" + \"$arity > \" + (max_arity))};\n            } else {\n            self.arity_checks['$<<'](\"\" + \"$arity !== \" + (arity))\n          };\n          return self.arity_checks;\n        }, TMP_NodeWithArgs_arity_checks_33.$$arity = 0), nil) && 'arity_checks';\n      })($nesting[0], Opal.const_get_relative($nesting, 'ScopeNode'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/iter\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$attr_accessor', '$extract_block_arg', '$extract_shadow_args', '$extract_underscore_args', '$split_args', '$in_scope', '$process', '$inline_args_sexp', '$identify!', '$scope', '$add_temp', '$compile_block_arg', '$compile_shadow_args', '$compile_inline_args', '$compile_post_args', '$compile_norm_args', '$arity_check?', '$compiler', '$compile_arity_check', '$stmt', '$returned_body', '$to_vars', '$line', '$unshift', '$push', '$contains_break?', '$arity', '$parameters_code', '$has_top_level_mlhs_arg?', '$has_trailing_comma_in_args?', '$select', '$args', '$==', '$type', '$each', '$norm_args', '$block_arg', '$block_name=', '$-', '$[]', '$updated', '$s', '$body', '$shadow_args', '$<<', '$locals', '$add_arg', '$each_with_index', '$first', '$returns', '$keys', '$mlhs_mapping', '$any?', '$loc', '$expression', '$source', '$match', '$>', '$size', '$arity_checks', '$!', '$top?', '$def?', '$class_scope?', '$parent', '$mid', '$class?', '$name', '$module?', '$identity', '$join', '$new', '$found_break?']);\n  \n  self.$require(\"opal/nodes/node_with_args\");\n  self.$require(\"opal/rewriters/break_finder\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $IterNode(){};\n        var self = $IterNode = $klass($base, $super, 'IterNode', $IterNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_IterNode_compile_2, TMP_IterNode_norm_args_4, TMP_IterNode_compile_norm_args_6, TMP_IterNode_compile_block_arg_7, TMP_IterNode_extract_block_arg_8, TMP_IterNode_compile_shadow_args_10, TMP_IterNode_extract_shadow_args_12, TMP_IterNode_extract_underscore_args_14, TMP_IterNode_returned_body_15, TMP_IterNode_mlhs_args_16, TMP_IterNode_has_top_level_mlhs_arg$q_18, TMP_IterNode_has_trailing_comma_in_args$q_19, TMP_IterNode_compile_arity_check_20, TMP_IterNode_contains_break$q_21;\n\n        def.norm_args = def.sexp = nil;\n        \n        self.$handle(\"iter\");\n        self.$children(\"args\", \"body\");\n        self.$attr_accessor(\"block_arg\", \"shadow_args\");\n        \n        Opal.defn(self, '$compile', TMP_IterNode_compile_2 = function $$compile() {\n          var TMP_1, self = this, inline_params = nil, to_vars = nil, identity = nil, body_code = nil;\n\n          \n          inline_params = nil;\n          self.$extract_block_arg();\n          self.$extract_shadow_args();\n          self.$extract_underscore_args();\n          self.$split_args();\n          to_vars = (identity = (body_code = nil));\n          $send(self, 'in_scope', [], (TMP_1 = function(){var self = TMP_1.$$s || this;\n\n          \n            inline_params = self.$process(self.$inline_args_sexp());\n            identity = self.$scope()['$identify!']();\n            self.$add_temp(\"\" + \"self = \" + (identity) + \".$$s || this\");\n            self.$compile_block_arg();\n            self.$compile_shadow_args();\n            self.$compile_inline_args();\n            self.$compile_post_args();\n            self.$compile_norm_args();\n            if ($truthy(self.$compiler()['$arity_check?']())) {\n              self.$compile_arity_check()};\n            body_code = self.$stmt(self.$returned_body());\n            return (to_vars = self.$scope().$to_vars());}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1));\n          self.$line(body_code);\n          self.$unshift(to_vars);\n          self.$unshift(\"\" + \"(\" + (identity) + \" = function(\", inline_params, \"){\");\n          self.$push(\"\" + \"}, \" + (identity) + \".$$s = self,\");\n          if ($truthy(self['$contains_break?']())) {\n            self.$push(\"\" + \" \" + (identity) + \".$$brk = $brk,\")};\n          self.$push(\"\" + \" \" + (identity) + \".$$arity = \" + (self.$arity()) + \",\");\n          if ($truthy(self.$compiler()['$arity_check?']())) {\n            self.$push(\"\" + \" \" + (identity) + \".$$parameters = \" + (self.$parameters_code()) + \",\")};\n          if ($truthy(self['$has_top_level_mlhs_arg?']())) {\n            self.$push(\"\" + \" \" + (identity) + \".$$has_top_level_mlhs_arg = true,\")};\n          if ($truthy(self['$has_trailing_comma_in_args?']())) {\n            self.$push(\"\" + \" \" + (identity) + \".$$has_trailing_comma_in_args = true,\")};\n          return self.$push(\"\" + \" \" + (identity) + \")\");\n        }, TMP_IterNode_compile_2.$$arity = 0);\n        \n        Opal.defn(self, '$norm_args', TMP_IterNode_norm_args_4 = function $$norm_args() {\n          var $a, TMP_3, self = this;\n\n          return (self.norm_args = ($truthy($a = self.norm_args) ? $a : $send(self.$args().$children(), 'select', [], (TMP_3 = function(arg){var self = TMP_3.$$s || this;\nif (arg == null) arg = nil;\n          return arg.$type()['$=='](\"arg\")}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))))\n        }, TMP_IterNode_norm_args_4.$$arity = 0);\n        \n        Opal.defn(self, '$compile_norm_args', TMP_IterNode_compile_norm_args_6 = function $$compile_norm_args() {\n          var TMP_5, self = this;\n\n          return $send(self.$norm_args(), 'each', [], (TMP_5 = function(arg){var self = TMP_5.$$s || this, $a, arg_name = nil, _ = nil;\nif (arg == null) arg = nil;\n          \n            $a = [].concat(Opal.to_a(arg)), (arg_name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n            return self.$push(\"\" + \"if (\" + (arg_name) + \" == null) \" + (arg_name) + \" = nil;\");}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5))\n        }, TMP_IterNode_compile_norm_args_6.$$arity = 0);\n        \n        Opal.defn(self, '$compile_block_arg', TMP_IterNode_compile_block_arg_7 = function $$compile_block_arg() {\n          var self = this, $writer = nil, scope_name = nil;\n\n          if ($truthy(self.$block_arg())) {\n            \n            \n            $writer = [self.$block_arg()];\n            $send(self.$scope(), 'block_name=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.$scope().$add_temp(self.$block_arg());\n            scope_name = self.$scope()['$identify!']();\n            self.$line(\"\" + (self.$block_arg()) + \" = \" + (scope_name) + \".$$p || nil;\");\n            return self.$line(\"\" + \"if (\" + (self.$block_arg()) + \") \" + (scope_name) + \".$$p = null;\");\n            } else {\n            return nil\n          }\n        }, TMP_IterNode_compile_block_arg_7.$$arity = 0);\n        \n        Opal.defn(self, '$extract_block_arg', TMP_IterNode_extract_block_arg_8 = function $$extract_block_arg() {\n          var $a, $b, $c, self = this, regular_args = nil, last_arg = nil;\n\n          \n          $b = self.$args().$children(), $a = Opal.to_ary($b), $c = $a.length - 1, $c = ($c < 0) ? 0 : $c, (regular_args = $slice.call($a, 0, $c)), (last_arg = ($a[$c] == null ? nil : $a[$c])), $b;\n          if ($truthy(($truthy($a = last_arg) ? last_arg.$type()['$=='](\"blockarg\") : $a))) {\n            \n            self.block_arg = last_arg.$children()['$[]'](0);\n            return (self.sexp = self.sexp.$updated(nil, [$send(self, 's', [\"args\"].concat(Opal.to_a(regular_args))), self.$body()]));\n            } else {\n            return nil\n          };\n        }, TMP_IterNode_extract_block_arg_8.$$arity = 0);\n        \n        Opal.defn(self, '$compile_shadow_args', TMP_IterNode_compile_shadow_args_10 = function $$compile_shadow_args() {\n          var TMP_9, self = this;\n\n          return $send(self.$shadow_args(), 'each', [], (TMP_9 = function(shadow_arg){var self = TMP_9.$$s || this, arg_name = nil;\nif (shadow_arg == null) shadow_arg = nil;\n          \n            arg_name = shadow_arg.$children()['$[]'](0);\n            self.$scope().$locals()['$<<'](arg_name);\n            return self.$scope().$add_arg(arg_name);}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9))\n        }, TMP_IterNode_compile_shadow_args_10.$$arity = 0);\n        \n        Opal.defn(self, '$extract_shadow_args', TMP_IterNode_extract_shadow_args_12 = function $$extract_shadow_args() {\n          var TMP_11, self = this, valid_args = nil;\n\n          \n          self.shadow_args = [];\n          valid_args = [];\n          if ($truthy(self.$args())) {\n            } else {\n            return nil\n          };\n          $send(self.$args().$children(), 'each_with_index', [], (TMP_11 = function(arg, idx){var self = TMP_11.$$s || this;\n            if (self.shadow_args == null) self.shadow_args = nil;\nif (arg == null) arg = nil;if (idx == null) idx = nil;\n          if (arg.$type()['$=='](\"shadowarg\")) {\n              return self.shadow_args['$<<'](arg)\n              } else {\n              return valid_args['$<<'](arg)\n            }}, TMP_11.$$s = self, TMP_11.$$arity = 2, TMP_11));\n          return (self.sexp = self.sexp.$updated(nil, [self.$args().$updated(nil, valid_args), self.$body()]));\n        }, TMP_IterNode_extract_shadow_args_12.$$arity = 0);\n        \n        Opal.defn(self, '$extract_underscore_args', TMP_IterNode_extract_underscore_args_14 = function $$extract_underscore_args() {\n          var TMP_13, self = this, valid_args = nil, caught_blank_argument = nil;\n\n          \n          valid_args = [];\n          caught_blank_argument = false;\n          $send(self.$args().$children(), 'each', [], (TMP_13 = function(arg){var self = TMP_13.$$s || this, arg_name = nil;\nif (arg == null) arg = nil;\n          \n            arg_name = arg.$children().$first();\n            if (arg_name['$=='](\"_\")) {\n              if ($truthy(caught_blank_argument)) {\n                return nil\n                } else {\n                \n                caught_blank_argument = true;\n                return valid_args['$<<'](arg);\n              }\n              } else {\n              return valid_args['$<<'](arg)\n            };}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13));\n          return (self.sexp = self.sexp.$updated(nil, [self.$args().$updated(nil, valid_args), self.$body()]));\n        }, TMP_IterNode_extract_underscore_args_14.$$arity = 0);\n        \n        Opal.defn(self, '$returned_body', TMP_IterNode_returned_body_15 = function $$returned_body() {\n          var $a, self = this;\n\n          return self.$compiler().$returns(($truthy($a = self.$body()) ? $a : self.$s(\"nil\")))\n        }, TMP_IterNode_returned_body_15.$$arity = 0);\n        \n        Opal.defn(self, '$mlhs_args', TMP_IterNode_mlhs_args_16 = function $$mlhs_args() {\n          var self = this;\n\n          return self.$scope().$mlhs_mapping().$keys()\n        }, TMP_IterNode_mlhs_args_16.$$arity = 0);\n        \n        Opal.defn(self, '$has_top_level_mlhs_arg?', TMP_IterNode_has_top_level_mlhs_arg$q_18 = function() {\n          var TMP_17, self = this;\n\n          return $send(self.$args().$children(), 'any?', [], (TMP_17 = function(arg){var self = TMP_17.$$s || this;\nif (arg == null) arg = nil;\n          return arg.$type()['$=='](\"mlhs\")}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17))\n        }, TMP_IterNode_has_top_level_mlhs_arg$q_18.$$arity = 0);\n        \n        Opal.defn(self, '$has_trailing_comma_in_args?', TMP_IterNode_has_trailing_comma_in_args$q_19 = function() {\n          var $a, self = this, args_source = nil;\n\n          if ($truthy(($truthy($a = self.$args().$loc()) ? self.$args().$loc().$expression() : $a))) {\n            \n            args_source = self.$args().$loc().$expression().$source();\n            return args_source.$match(/,\\s*\\|/);\n            } else {\n            return nil\n          }\n        }, TMP_IterNode_has_trailing_comma_in_args$q_19.$$arity = 0);\n        \n        Opal.defn(self, '$compile_arity_check', TMP_IterNode_compile_arity_check_20 = function $$compile_arity_check() {\n          var $a, $b, $c, self = this, parent_scope = nil, context = nil, identity = nil;\n\n          if ($truthy($rb_gt(self.$arity_checks().$size(), 0))) {\n            \n            parent_scope = self.$scope();\n            while ($truthy(($truthy($b = ($truthy($c = parent_scope['$top?']()) ? $c : parent_scope['$def?']())) ? $b : parent_scope['$class_scope?']())['$!']())) {\n              parent_scope = parent_scope.$parent()\n            };\n            context = (function() {if ($truthy(parent_scope['$top?']())) {\n              return \"'<main>'\"\n            } else if ($truthy(parent_scope['$def?']())) {\n              return \"\" + \"'\" + (parent_scope.$mid()) + \"'\"\n            } else if ($truthy(parent_scope['$class?']())) {\n              return \"\" + \"'<class:\" + (parent_scope.$name()) + \">'\"\n            } else if ($truthy(parent_scope['$module?']())) {\n              return \"\" + \"'<module:\" + (parent_scope.$name()) + \">'\"\n              } else {\n              return nil\n            }; return nil; })();\n            identity = self.$scope().$identity();\n            self.$line(\"\" + \"if (\" + (identity) + \".$$is_lambda || \" + (identity) + \".$$define_meth) {\");\n            self.$line(\"  var $arity = arguments.length;\");\n            self.$line(\"\" + \"  if (\" + (self.$arity_checks().$join(\" || \")) + \") { Opal.block_ac($arity, \" + (self.$arity()) + \", \" + (context) + \"); }\");\n            return self.$line(\"}\");\n            } else {\n            return nil\n          }\n        }, TMP_IterNode_compile_arity_check_20.$$arity = 0);\n        return (Opal.defn(self, '$contains_break?', TMP_IterNode_contains_break$q_21 = function() {\n          var self = this, finder = nil;\n\n          \n          finder = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'Rewriters'), 'BreakFinder').$new();\n          finder.$process(self.sexp);\n          return finder['$found_break?']();\n        }, TMP_IterNode_contains_break$q_21.$$arity = 0), nil) && 'contains_break?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'NodeWithArgs'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/def\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$attr_accessor', '$args', '$==', '$type', '$[]', '$updated', '$mid', '$s', '$stmts', '$extract_block_arg', '$split_args', '$block_arg', '$in_scope', '$mid=', '$scope', '$-', '$defs=', '$uses_block!', '$add_arg', '$block_name=', '$process', '$inline_args_sexp', '$stmt', '$returns', '$compiler', '$add_temp', '$compile_inline_args', '$compile_post_args', '$identify!', '$identity', '$compile_block_arg', '$arity_check?', '$compile_arity_check', '$uses_zuper', '$add_local', '$line', '$unshift', '$current_indent', '$to_vars', '$catch_return', '$push', '$valid_name?', '$arity', '$parameters_code', '$parse_comments?', '$comments_code', '$enable_source_location?', '$source_location', '$wrap_with_definition', '$iter?', '$module?', '$class?', '$sclass?', '$eval?', '$top?', '$def?', '$raise', '$expr?', '$wrap', '$>', '$size', '$arity_checks', '$inspect', '$to_s', '$join', '$name', '$source_buffer', '$expression', '$loc', '$+', '$map', '$comments', '$text']);\n  \n  self.$require(\"opal/nodes/node_with_args\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $DefNode(){};\n        var self = $DefNode = $klass($base, $super, 'DefNode', $DefNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DefNode_extract_block_arg_1, TMP_DefNode_compile_3, TMP_DefNode_wrap_with_definition_4, TMP_DefNode_compile_arity_check_5, TMP_DefNode_source_location_6, TMP_DefNode_comments_code_8;\n\n        def.sexp = nil;\n        \n        self.$handle(\"def\");\n        self.$children(\"mid\", \"args\", \"stmts\");\n        self.$attr_accessor(\"block_arg\");\n        \n        Opal.defn(self, '$extract_block_arg', TMP_DefNode_extract_block_arg_1 = function $$extract_block_arg() {\n          var $a, $b, $c, self = this, regular_args = nil, last_arg = nil;\n\n          \n          $b = self.$args().$children(), $a = Opal.to_ary($b), $c = $a.length - 1, $c = ($c < 0) ? 0 : $c, (regular_args = $slice.call($a, 0, $c)), (last_arg = ($a[$c] == null ? nil : $a[$c])), $b;\n          if ($truthy(($truthy($a = last_arg) ? last_arg.$type()['$=='](\"blockarg\") : $a))) {\n            \n            self.block_arg = last_arg.$children()['$[]'](0);\n            return (self.sexp = self.sexp.$updated(nil, [self.$mid(), $send(self, 's', [\"args\"].concat(Opal.to_a(regular_args))), self.$stmts()]));\n            } else {\n            return nil\n          };\n        }, TMP_DefNode_extract_block_arg_1.$$arity = 0);\n        \n        Opal.defn(self, '$compile', TMP_DefNode_compile_3 = function $$compile() {\n          var TMP_2, self = this, inline_params = nil, scope_name = nil, block_name = nil, function_name = nil;\n\n          \n          self.$extract_block_arg();\n          self.$split_args();\n          inline_params = nil;\n          scope_name = nil;\n          if ($truthy(self.$block_arg())) {\n            block_name = self.$block_arg()};\n          $send(self, 'in_scope', [], (TMP_2 = function(){var self = TMP_2.$$s || this, $a, $writer = nil, stmt_code = nil;\n            if (self.sexp == null) self.sexp = nil;\n\n          \n            \n            $writer = [self.$mid()];\n            $send(self.$scope(), 'mid=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            if (self.sexp.$type()['$=='](\"defs\")) {\n              \n              $writer = [true];\n              $send(self.$scope(), 'defs=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n            if ($truthy(block_name)) {\n              \n              self.$scope()['$uses_block!']();\n              self.$scope().$add_arg(block_name);};\n            \n            $writer = [($truthy($a = block_name) ? $a : \"$yield\")];\n            $send(self.$scope(), 'block_name=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            inline_params = self.$process(self.$inline_args_sexp());\n            stmt_code = self.$stmt(self.$compiler().$returns(self.$stmts()));\n            self.$add_temp(\"self = this\");\n            self.$compile_inline_args();\n            self.$compile_post_args();\n            self.$scope()['$identify!']();\n            scope_name = self.$scope().$identity();\n            self.$compile_block_arg();\n            if ($truthy(self.$compiler()['$arity_check?']())) {\n              self.$compile_arity_check()};\n            if ($truthy(self.$scope().$uses_zuper())) {\n              \n              self.$add_local(\"$zuper\");\n              self.$add_local(\"$zuper_i\");\n              self.$add_local(\"$zuper_ii\");\n              self.$line(\"// Prepare super implicit arguments\");\n              self.$line(\"for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\");\n              self.$line(\"  $zuper[$zuper_i] = arguments[$zuper_i];\");\n              self.$line(\"}\");};\n            self.$unshift(\"\" + \"\\n\" + (self.$current_indent()), self.$scope().$to_vars());\n            self.$line(stmt_code);\n            if ($truthy(self.$scope().$catch_return())) {\n              \n              self.$unshift(\"try {\\n\");\n              self.$line(\"} catch ($returner) { if ($returner === Opal.returner) { return $returner.$v }\");\n              return self.$push(\" throw $returner; }\");\n              } else {\n              return nil\n            };}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2));\n          function_name = (function() {if ($truthy(self['$valid_name?'](self.$mid()))) {\n            return \"\" + \" $$\" + (self.$mid())\n            } else {\n            return \"\"\n          }; return nil; })();\n          self.$unshift(\") {\");\n          self.$unshift(inline_params);\n          self.$unshift(\"\" + \"function\" + (function_name) + \"(\");\n          if ($truthy(scope_name)) {\n            self.$unshift(\"\" + (scope_name) + \" = \")};\n          self.$line(\"}\");\n          self.$push(\"\" + \", \" + (scope_name) + \".$$arity = \" + (self.$arity()));\n          if ($truthy(self.$compiler()['$arity_check?']())) {\n            self.$push(\"\" + \", \" + (scope_name) + \".$$parameters = \" + (self.$parameters_code()))};\n          if ($truthy(self.$compiler()['$parse_comments?']())) {\n            self.$push(\"\" + \", \" + (scope_name) + \".$$comments = \" + (self.$comments_code()))};\n          if ($truthy(self.$compiler()['$enable_source_location?']())) {\n            self.$push(\"\" + \", \" + (scope_name) + \".$$source_location = \" + (self.$source_location()))};\n          return self.$wrap_with_definition();\n        }, TMP_DefNode_compile_3.$$arity = 0);\n        \n        Opal.defn(self, '$wrap_with_definition', TMP_DefNode_wrap_with_definition_4 = function $$wrap_with_definition() {\n          var $a, self = this;\n\n          \n          if ($truthy(self.$scope()['$iter?']())) {\n            self.$unshift(\"\" + \"Opal.def(self, '$\" + (self.$mid()) + \"', \")\n          } else if ($truthy(($truthy($a = self.$scope()['$module?']()) ? $a : self.$scope()['$class?']()))) {\n            self.$unshift(\"\" + \"Opal.defn(self, '$\" + (self.$mid()) + \"', \")\n          } else if ($truthy(self.$scope()['$sclass?']())) {\n            self.$unshift(\"\" + \"Opal.defn(self, '$\" + (self.$mid()) + \"', \")\n          } else if ($truthy(self.$compiler()['$eval?']())) {\n            self.$unshift(\"\" + \"Opal.def(self, '$\" + (self.$mid()) + \"', \")\n          } else if ($truthy(self.$scope()['$top?']())) {\n            self.$unshift(\"\" + \"Opal.defn(Opal.Object, '$\" + (self.$mid()) + \"', \")\n          } else if ($truthy(self.$scope()['$def?']())) {\n            self.$unshift(\"\" + \"Opal.def(self, '$\" + (self.$mid()) + \"', \")\n            } else {\n            self.$raise(\"Unsupported use of `def`; please file a bug at https://github.com/opal/opal/issues/new reporting this message.\")\n          };\n          self.$push(\")\");\n          if ($truthy(self['$expr?']())) {\n            return self.$wrap(\"(\", \"\" + \", nil) && '\" + (self.$mid()) + \"'\")\n            } else {\n            return self.$unshift(\"\" + \"\\n\" + (self.$current_indent()))\n          };\n        }, TMP_DefNode_wrap_with_definition_4.$$arity = 0);\n        \n        Opal.defn(self, '$compile_arity_check', TMP_DefNode_compile_arity_check_5 = function $$compile_arity_check() {\n          var self = this, meth = nil;\n\n          if ($truthy($rb_gt(self.$arity_checks().$size(), 0))) {\n            \n            meth = self.$scope().$mid().$to_s().$inspect();\n            self.$line(\"var $arity = arguments.length;\");\n            return self.$push(\"\" + \" if (\" + (self.$arity_checks().$join(\" || \")) + \") { Opal.ac($arity, \" + (self.$arity()) + \", this, \" + (meth) + \"); }\");\n            } else {\n            return nil\n          }\n        }, TMP_DefNode_compile_arity_check_5.$$arity = 0);\n        \n        Opal.defn(self, '$source_location', TMP_DefNode_source_location_6 = function $$source_location() {\n          var self = this, file = nil, line = nil;\n\n          \n          file = self.sexp.$loc().$expression().$source_buffer().$name();\n          line = self.sexp.$loc().$line();\n          return \"\" + \"['\" + (file) + \".rb', \" + (line) + \"]\";\n        }, TMP_DefNode_source_location_6.$$arity = 0);\n        return (Opal.defn(self, '$comments_code', TMP_DefNode_comments_code_8 = function $$comments_code() {\n          var TMP_7, self = this;\n\n          return $rb_plus($rb_plus(\"[\", $send(self.$comments(), 'map', [], (TMP_7 = function(comment){var self = TMP_7.$$s || this;\nif (comment == null) comment = nil;\n          return comment.$text().$inspect()}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7)).$join(\", \")), \"]\")\n        }, TMP_DefNode_comments_code_8.$$arity = 0), nil) && 'comments_code';\n      })($nesting[0], Opal.const_get_relative($nesting, 'NodeWithArgs'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/defs\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$args', '$==', '$type', '$[]', '$updated', '$recvr', '$mid', '$s', '$stmts', '$unshift', '$expr', '$push']);\n  \n  self.$require(\"opal/nodes/def\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $DefsNode(){};\n        var self = $DefsNode = $klass($base, $super, 'DefsNode', $DefsNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DefsNode_extract_block_arg_1, TMP_DefsNode_wrap_with_definition_2;\n\n        def.sexp = nil;\n        \n        self.$handle(\"defs\");\n        self.$children(\"recvr\", \"mid\", \"args\", \"stmts\");\n        \n        Opal.defn(self, '$extract_block_arg', TMP_DefsNode_extract_block_arg_1 = function $$extract_block_arg() {\n          var $a, $b, $c, self = this, regular_args = nil, last_arg = nil;\n\n          \n          $b = self.$args().$children(), $a = Opal.to_ary($b), $c = $a.length - 1, $c = ($c < 0) ? 0 : $c, (regular_args = $slice.call($a, 0, $c)), (last_arg = ($a[$c] == null ? nil : $a[$c])), $b;\n          if ($truthy(($truthy($a = last_arg) ? last_arg.$type()['$=='](\"blockarg\") : $a))) {\n            \n            self.block_arg = last_arg.$children()['$[]'](0);\n            return (self.sexp = self.sexp.$updated(nil, [self.$recvr(), self.$mid(), $send(self, 's', [\"args\"].concat(Opal.to_a(regular_args))), self.$stmts()]));\n            } else {\n            return nil\n          };\n        }, TMP_DefsNode_extract_block_arg_1.$$arity = 0);\n        return (Opal.defn(self, '$wrap_with_definition', TMP_DefsNode_wrap_with_definition_2 = function $$wrap_with_definition() {\n          var self = this;\n\n          \n          self.$unshift(\"Opal.defs(\", self.$expr(self.$recvr()), \"\" + \", '$\" + (self.$mid()) + \"', \");\n          return self.$push(\")\");\n        }, TMP_DefsNode_wrap_with_definition_2.$$arity = 0), nil) && 'wrap_with_definition';\n      })($nesting[0], Opal.const_get_relative($nesting, 'DefNode'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/if\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$truthy', '$falsy', '$push', '$js_truthy', '$test', '$indent', '$line', '$stmt', '$==', '$type', '$needs_wrapper?', '$wrap', '$returns', '$compiler', '$true_body', '$s', '$false_body', '$expr?', '$recv?']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $IfNode(){};\n        var self = $IfNode = $klass($base, $super, 'IfNode', $IfNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_IfNode_compile_3, TMP_IfNode_truthy_4, TMP_IfNode_falsy_5, TMP_IfNode_needs_wrapper$q_6;\n\n        \n        self.$handle(\"if\");\n        self.$children(\"test\", \"true_body\", \"false_body\");\n        \n        Opal.defn(self, '$compile', TMP_IfNode_compile_3 = function $$compile() {\n          var $a, TMP_1, TMP_2, self = this, truthy = nil, falsy = nil;\n\n          \n          $a = [self.$truthy(), self.$falsy()], (truthy = $a[0]), (falsy = $a[1]), $a;\n          self.$push(\"if (\", self.$js_truthy(self.$test()), \") {\");\n          if ($truthy(truthy)) {\n            $send(self, 'indent', [], (TMP_1 = function(){var self = TMP_1.$$s || this;\n\n            return self.$line(self.$stmt(truthy))}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1))};\n          if ($truthy(falsy)) {\n            if (falsy.$type()['$=='](\"if\")) {\n              self.$line(\"} else \", self.$stmt(falsy))\n              } else {\n              \n              $send(self, 'indent', [], (TMP_2 = function(){var self = TMP_2.$$s || this;\n\n              \n                self.$line(\"} else {\");\n                return self.$line(self.$stmt(falsy));}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2));\n              self.$line(\"}\");\n            }\n            } else {\n            self.$push(\"}\")\n          };\n          if ($truthy(self['$needs_wrapper?']())) {\n            return self.$wrap(\"(function() {\", \"; return nil; })()\")\n            } else {\n            return nil\n          };\n        }, TMP_IfNode_compile_3.$$arity = 0);\n        \n        Opal.defn(self, '$truthy', TMP_IfNode_truthy_4 = function $$truthy() {\n          var $a, self = this;\n\n          if ($truthy(self['$needs_wrapper?']())) {\n            return self.$compiler().$returns(($truthy($a = self.$true_body()) ? $a : self.$s(\"nil\")))\n            } else {\n            return self.$true_body()\n          }\n        }, TMP_IfNode_truthy_4.$$arity = 0);\n        \n        Opal.defn(self, '$falsy', TMP_IfNode_falsy_5 = function $$falsy() {\n          var $a, self = this;\n\n          if ($truthy(self['$needs_wrapper?']())) {\n            return self.$compiler().$returns(($truthy($a = self.$false_body()) ? $a : self.$s(\"nil\")))\n            } else {\n            return self.$false_body()\n          }\n        }, TMP_IfNode_falsy_5.$$arity = 0);\n        return (Opal.defn(self, '$needs_wrapper?', TMP_IfNode_needs_wrapper$q_6 = function() {\n          var $a, self = this;\n\n          return ($truthy($a = self['$expr?']()) ? $a : self['$recv?']())\n        }, TMP_IfNode_needs_wrapper$q_6.$$arity = 0), nil) && 'needs_wrapper?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $IFlipFlop(){};\n        var self = $IFlipFlop = $klass($base, $super, 'IFlipFlop', $IFlipFlop);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_IFlipFlop_compile_7;\n\n        \n        self.$handle(\"iflipflop\");\n        return (Opal.defn(self, '$compile', TMP_IFlipFlop_compile_7 = function $$compile() {\n          var self = this;\n\n          return self.$push(\"true\")\n        }, TMP_IFlipFlop_compile_7.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $EFlipFlop(){};\n        var self = $EFlipFlop = $klass($base, $super, 'EFlipFlop', $EFlipFlop);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_EFlipFlop_compile_8;\n\n        \n        self.$handle(\"eflipflop\");\n        return (Opal.defn(self, '$compile', TMP_EFlipFlop_compile_8 = function $$compile() {\n          var self = this;\n\n          return self.$push(\"true\")\n        }, TMP_EFlipFlop_compile_8.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/logic\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$handle', '$in_while?', '$push', '$expr_or_nil', '$value', '$wrap', '$size', '$children', '$===', '$s', '$first', '$compile_while', '$iter?', '$scope', '$compile_iter', '$error', '$[]', '$while_loop', '$stmt?', '$line', '$break_val', '$nil?', '$expr', '$[]=', '$-', '$identity', '$==', '$empty_splat?', '$recv', '$type', '$rhs', '$compile_if', '$compile_ternary', '$raise', '$helper', '$with_temp', '$lhs', '$indent', '$js_truthy_optimize', '$>', '$find_parent_def', '$expr?', '$def?', '$return_in_iter?', '$return_expr_in_def?', '$scope_to_catch_return', '$catch_return=', '$return_val', '$to_s']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $NextNode(){};\n        var self = $NextNode = $klass($base, $super, 'NextNode', $NextNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NextNode_compile_1, TMP_NextNode_value_2;\n\n        \n        self.$handle(\"next\");\n        \n        Opal.defn(self, '$compile', TMP_NextNode_compile_1 = function $$compile() {\n          var self = this;\n\n          if ($truthy(self['$in_while?']())) {\n            return self.$push(\"continue;\")\n            } else {\n            \n            self.$push(self.$expr_or_nil(self.$value()));\n            return self.$wrap(\"return \", \";\");\n          }\n        }, TMP_NextNode_compile_1.$$arity = 0);\n        return (Opal.defn(self, '$value', TMP_NextNode_value_2 = function $$value() {\n          var self = this, $case = nil;\n\n          return (function() {$case = self.$children().$size();\n          if ((0)['$===']($case)) {return self.$s(\"nil\")}\n          else if ((1)['$===']($case)) {return self.$children().$first()}\n          else {return $send(self, 's', [\"array\"].concat(Opal.to_a(self.$children())))}})()\n        }, TMP_NextNode_value_2.$$arity = 0), nil) && 'value';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $BreakNode(){};\n        var self = $BreakNode = $klass($base, $super, 'BreakNode', $BreakNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BreakNode_compile_3, TMP_BreakNode_compile_while_4, TMP_BreakNode_compile_iter_5, TMP_BreakNode_break_val_6;\n\n        \n        self.$handle(\"break\");\n        self.$children(\"value\");\n        \n        Opal.defn(self, '$compile', TMP_BreakNode_compile_3 = function $$compile() {\n          var self = this;\n\n          if ($truthy(self['$in_while?']())) {\n            return self.$compile_while()\n          } else if ($truthy(self.$scope()['$iter?']())) {\n            return self.$compile_iter()\n            } else {\n            return self.$error(\"void value expression: cannot use break outside of iter/while\")\n          }\n        }, TMP_BreakNode_compile_3.$$arity = 0);\n        \n        Opal.defn(self, '$compile_while', TMP_BreakNode_compile_while_4 = function $$compile_while() {\n          var self = this;\n\n          if ($truthy(self.$while_loop()['$[]'](\"closure\"))) {\n            return self.$push(\"return \", self.$expr_or_nil(self.$value()))\n            } else {\n            return self.$push(\"break;\")\n          }\n        }, TMP_BreakNode_compile_while_4.$$arity = 0);\n        \n        Opal.defn(self, '$compile_iter', TMP_BreakNode_compile_iter_5 = function $$compile_iter() {\n          var self = this;\n\n          \n          if ($truthy(self['$stmt?']())) {\n            } else {\n            self.$error(\"break must be used as a statement\")\n          };\n          return self.$line(\"Opal.brk(\", self.$break_val(), \", $brk)\");\n        }, TMP_BreakNode_compile_iter_5.$$arity = 0);\n        return (Opal.defn(self, '$break_val', TMP_BreakNode_break_val_6 = function $$break_val() {\n          var self = this;\n\n          if ($truthy(self.$value()['$nil?']())) {\n            return self.$expr(self.$s(\"nil\"))\n            } else {\n            return self.$expr(self.$value())\n          }\n        }, TMP_BreakNode_break_val_6.$$arity = 0), nil) && 'break_val';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $RedoNode(){};\n        var self = $RedoNode = $klass($base, $super, 'RedoNode', $RedoNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_RedoNode_compile_7, TMP_RedoNode_compile_while_8, TMP_RedoNode_compile_iter_9;\n\n        \n        self.$handle(\"redo\");\n        \n        Opal.defn(self, '$compile', TMP_RedoNode_compile_7 = function $$compile() {\n          var self = this;\n\n          if ($truthy(self['$in_while?']())) {\n            return self.$compile_while()\n          } else if ($truthy(self.$scope()['$iter?']())) {\n            return self.$compile_iter()\n            } else {\n            return self.$push(\"REDO()\")\n          }\n        }, TMP_RedoNode_compile_7.$$arity = 0);\n        \n        Opal.defn(self, '$compile_while', TMP_RedoNode_compile_while_8 = function $$compile_while() {\n          var self = this, $writer = nil;\n\n          \n          \n          $writer = [\"use_redo\", true];\n          $send(self.$while_loop(), '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          return self.$push(\"\" + (self.$while_loop()['$[]'](\"redo_var\")) + \" = true\");\n        }, TMP_RedoNode_compile_while_8.$$arity = 0);\n        return (Opal.defn(self, '$compile_iter', TMP_RedoNode_compile_iter_9 = function $$compile_iter() {\n          var self = this;\n\n          return self.$push(\"\" + \"return \" + (self.$scope().$identity()) + \".apply(null, $slice.call(arguments))\")\n        }, TMP_RedoNode_compile_iter_9.$$arity = 0), nil) && 'compile_iter';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $SplatNode(){};\n        var self = $SplatNode = $klass($base, $super, 'SplatNode', $SplatNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SplatNode_empty_splat$q_10, TMP_SplatNode_compile_11;\n\n        \n        self.$handle(\"splat\");\n        self.$children(\"value\");\n        \n        Opal.defn(self, '$empty_splat?', TMP_SplatNode_empty_splat$q_10 = function() {\n          var self = this;\n\n          return self.$value()['$=='](self.$s(\"array\"))\n        }, TMP_SplatNode_empty_splat$q_10.$$arity = 0);\n        return (Opal.defn(self, '$compile', TMP_SplatNode_compile_11 = function $$compile() {\n          var self = this;\n\n          if ($truthy(self['$empty_splat?']())) {\n            return self.$push(\"[]\")\n            } else {\n            return self.$push(\"Opal.to_a(\", self.$recv(self.$value()), \")\")\n          }\n        }, TMP_SplatNode_compile_11.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $BinaryOp(){};\n        var self = $BinaryOp = $klass($base, $super, 'BinaryOp', $BinaryOp);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BinaryOp_compile_12, TMP_BinaryOp_compile_ternary_13, TMP_BinaryOp_compile_if_14;\n\n        \n        \n        Opal.defn(self, '$compile', TMP_BinaryOp_compile_12 = function $$compile() {\n          var self = this;\n\n          if (self.$rhs().$type()['$=='](\"break\")) {\n            return self.$compile_if()\n            } else {\n            return self.$compile_ternary()\n          }\n        }, TMP_BinaryOp_compile_12.$$arity = 0);\n        \n        Opal.defn(self, '$compile_ternary', TMP_BinaryOp_compile_ternary_13 = function $$compile_ternary() {\n          var self = this;\n\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n        }, TMP_BinaryOp_compile_ternary_13.$$arity = 0);\n        return (Opal.defn(self, '$compile_if', TMP_BinaryOp_compile_if_14 = function $$compile_if() {\n          var self = this;\n\n          return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))\n        }, TMP_BinaryOp_compile_if_14.$$arity = 0), nil) && 'compile_if';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $OrNode(){};\n        var self = $OrNode = $klass($base, $super, 'OrNode', $OrNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_OrNode_compile_ternary_16, TMP_OrNode_compile_if_20;\n\n        \n        self.$handle(\"or\");\n        self.$children(\"lhs\", \"rhs\");\n        \n        Opal.defn(self, '$compile_ternary', TMP_OrNode_compile_ternary_16 = function $$compile_ternary() {\n          var TMP_15, self = this;\n\n          \n          self.$helper(\"truthy\");\n          return $send(self, 'with_temp', [], (TMP_15 = function(tmp){var self = TMP_15.$$s || this;\nif (tmp == null) tmp = nil;\n          return self.$push(\"\" + \"($truthy(\" + (tmp) + \" = \", self.$expr(self.$lhs()), \"\" + \") ? \" + (tmp) + \" : \", self.$expr(self.$rhs()), \")\")}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15));\n        }, TMP_OrNode_compile_ternary_16.$$arity = 0);\n        return (Opal.defn(self, '$compile_if', TMP_OrNode_compile_if_20 = function $$compile_if() {\n          var TMP_17, self = this;\n\n          \n          self.$helper(\"truthy\");\n          return $send(self, 'with_temp', [], (TMP_17 = function(tmp){var self = TMP_17.$$s || this, TMP_18, TMP_19;\nif (tmp == null) tmp = nil;\n          \n            self.$push(\"\" + \"if ($truthy(\" + (tmp) + \" = \", self.$expr(self.$lhs()), \")) {\");\n            $send(self, 'indent', [], (TMP_18 = function(){var self = TMP_18.$$s || this;\n\n            return self.$line(tmp)}, TMP_18.$$s = self, TMP_18.$$arity = 0, TMP_18));\n            self.$line(\"} else {\");\n            $send(self, 'indent', [], (TMP_19 = function(){var self = TMP_19.$$s || this;\n\n            return self.$line(self.$expr(self.$rhs()))}, TMP_19.$$s = self, TMP_19.$$arity = 0, TMP_19));\n            return self.$line(\"}\");}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17));\n        }, TMP_OrNode_compile_if_20.$$arity = 0), nil) && 'compile_if';\n      })($nesting[0], Opal.const_get_relative($nesting, 'BinaryOp'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $AndNode(){};\n        var self = $AndNode = $klass($base, $super, 'AndNode', $AndNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_AndNode_compile_ternary_22, TMP_AndNode_compile_if_25;\n\n        \n        self.$handle(\"and\");\n        self.$children(\"lhs\", \"rhs\");\n        \n        Opal.defn(self, '$compile_ternary', TMP_AndNode_compile_ternary_22 = function $$compile_ternary() {\n          var TMP_21, self = this, truthy_opt = nil;\n\n          \n          truthy_opt = nil;\n          return $send(self, 'with_temp', [], (TMP_21 = function(tmp){var self = TMP_21.$$s || this;\nif (tmp == null) tmp = nil;\n          if ($truthy((truthy_opt = self.$js_truthy_optimize(self.$lhs())))) {\n              \n              self.$push(\"\" + \"((\" + (tmp) + \" = \", truthy_opt);\n              self.$push(\") ? \");\n              self.$push(self.$expr(self.$rhs()));\n              return self.$push(\" : \", self.$expr(self.$lhs()), \")\");\n              } else {\n              \n              self.$helper(\"truthy\");\n              return self.$push(\"\" + \"($truthy(\" + (tmp) + \" = \", self.$expr(self.$lhs()), \") ? \", self.$expr(self.$rhs()), \"\" + \" : \" + (tmp) + \")\");\n            }}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21));\n        }, TMP_AndNode_compile_ternary_22.$$arity = 0);\n        return (Opal.defn(self, '$compile_if', TMP_AndNode_compile_if_25 = function $$compile_if() {\n          var $a, TMP_23, TMP_24, self = this, condition = nil;\n\n          \n          self.$helper(\"truthy\");\n          condition = ($truthy($a = self.$js_truthy_optimize(self.$lhs())) ? $a : self.$expr(self.$lhs()));\n          self.$line(\"if ($truthy(\", condition, \")) {\");\n          $send(self, 'indent', [], (TMP_23 = function(){var self = TMP_23.$$s || this;\n\n          return self.$line(self.$expr(self.$rhs()))}, TMP_23.$$s = self, TMP_23.$$arity = 0, TMP_23));\n          self.$line(\"} else {\");\n          $send(self, 'indent', [], (TMP_24 = function(){var self = TMP_24.$$s || this;\n\n          return self.$line(self.$expr(self.$lhs()))}, TMP_24.$$s = self, TMP_24.$$arity = 0, TMP_24));\n          return self.$line(\"}\");\n        }, TMP_AndNode_compile_if_25.$$arity = 0), nil) && 'compile_if';\n      })($nesting[0], Opal.const_get_relative($nesting, 'BinaryOp'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $ReturnNode(){};\n        var self = $ReturnNode = $klass($base, $super, 'ReturnNode', $ReturnNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ReturnNode_return_val_26, TMP_ReturnNode_return_in_iter$q_27, TMP_ReturnNode_return_expr_in_def$q_28, TMP_ReturnNode_scope_to_catch_return_29, TMP_ReturnNode_compile_30;\n\n        \n        self.$handle(\"return\");\n        self.$children(\"value\");\n        \n        Opal.defn(self, '$return_val', TMP_ReturnNode_return_val_26 = function $$return_val() {\n          var self = this;\n\n          if ($truthy(self.$value()['$nil?']())) {\n            return self.$expr(self.$s(\"nil\"))\n          } else if ($truthy($rb_gt(self.$children().$size(), 1))) {\n            return self.$expr($send(self, 's', [\"array\"].concat(Opal.to_a(self.$children()))))\n            } else {\n            return self.$expr(self.$value())\n          }\n        }, TMP_ReturnNode_return_val_26.$$arity = 0);\n        \n        Opal.defn(self, '$return_in_iter?', TMP_ReturnNode_return_in_iter$q_27 = function() {\n          var $a, self = this, parent_def = nil;\n\n          if ($truthy(($truthy($a = self.$scope()['$iter?']()) ? (parent_def = self.$scope().$find_parent_def()) : $a))) {\n            return parent_def\n            } else {\n            return nil\n          }\n        }, TMP_ReturnNode_return_in_iter$q_27.$$arity = 0);\n        \n        Opal.defn(self, '$return_expr_in_def?', TMP_ReturnNode_return_expr_in_def$q_28 = function() {\n          var $a, self = this;\n\n          if ($truthy(($truthy($a = self['$expr?']()) ? self.$scope()['$def?']() : $a))) {\n            return self.$scope()\n            } else {\n            return nil\n          }\n        }, TMP_ReturnNode_return_expr_in_def$q_28.$$arity = 0);\n        \n        Opal.defn(self, '$scope_to_catch_return', TMP_ReturnNode_scope_to_catch_return_29 = function $$scope_to_catch_return() {\n          var $a, self = this;\n\n          return ($truthy($a = self['$return_in_iter?']()) ? $a : self['$return_expr_in_def?']())\n        }, TMP_ReturnNode_scope_to_catch_return_29.$$arity = 0);\n        return (Opal.defn(self, '$compile', TMP_ReturnNode_compile_30 = function $$compile() {\n          var self = this, def_scope = nil, $writer = nil;\n\n          if ($truthy((def_scope = self.$scope_to_catch_return()))) {\n            \n            \n            $writer = [true];\n            $send(def_scope, 'catch_return=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            return self.$push(\"Opal.ret(\", self.$return_val(), \")\");\n          } else if ($truthy(self['$stmt?']())) {\n            return self.$push(\"return \", self.$return_val())\n            } else {\n            return self.$raise(Opal.const_get_relative($nesting, 'SyntaxError'), \"void value expression: cannot return as an expression\")\n          }\n        }, TMP_ReturnNode_compile_30.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $JSReturnNode(){};\n        var self = $JSReturnNode = $klass($base, $super, 'JSReturnNode', $JSReturnNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_JSReturnNode_compile_31;\n\n        \n        self.$handle(\"js_return\");\n        self.$children(\"value\");\n        return (Opal.defn(self, '$compile', TMP_JSReturnNode_compile_31 = function $$compile() {\n          var self = this;\n\n          \n          self.$push(\"return \");\n          return self.$push(self.$expr(self.$value()));\n        }, TMP_JSReturnNode_compile_31.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $JSTempNode(){};\n        var self = $JSTempNode = $klass($base, $super, 'JSTempNode', $JSTempNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_JSTempNode_compile_32;\n\n        \n        self.$handle(\"js_tmp\");\n        self.$children(\"value\");\n        return (Opal.defn(self, '$compile', TMP_JSTempNode_compile_32 = function $$compile() {\n          var self = this;\n\n          return self.$push(self.$value().$to_s())\n        }, TMP_JSTempNode_compile_32.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $BlockPassNode(){};\n        var self = $BlockPassNode = $klass($base, $super, 'BlockPassNode', $BlockPassNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BlockPassNode_compile_33;\n\n        \n        self.$handle(\"block_pass\");\n        self.$children(\"value\");\n        return (Opal.defn(self, '$compile', TMP_BlockPassNode_compile_33 = function $$compile() {\n          var self = this;\n\n          return self.$push(self.$expr(self.$s(\"send\", self.$value(), \"to_proc\", self.$s(\"arglist\"))))\n        }, TMP_BlockPassNode_compile_33.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/definitions\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$each', '$line', '$expr', '$push', '$new_name', '$old_name', '$empty?', '$stmt?', '$compile_children', '$simple_children?', '$compile_inline_children', '$>', '$size', '$wrap', '$==', '$returned_children', '$+', '$returns', '$compiler', '$s', '$process', '$none?', '$include?', '$type', '$each_with_index', '$reject', '$map', '$to_proc']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $UndefNode(){};\n        var self = $UndefNode = $klass($base, $super, 'UndefNode', $UndefNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_UndefNode_compile_2;\n\n        \n        self.$handle(\"undef\");\n        self.$children(\"value\");\n        return (Opal.defn(self, '$compile', TMP_UndefNode_compile_2 = function $$compile() {\n          var TMP_1, self = this;\n\n          return $send(self.$children(), 'each', [], (TMP_1 = function(child){var self = TMP_1.$$s || this;\nif (child == null) child = nil;\n          return self.$line(\"Opal.udef(self, '$' + \", self.$expr(child), \");\")}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1))\n        }, TMP_UndefNode_compile_2.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $AliasNode(){};\n        var self = $AliasNode = $klass($base, $super, 'AliasNode', $AliasNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_AliasNode_compile_3;\n\n        \n        self.$handle(\"alias\");\n        self.$children(\"new_name\", \"old_name\");\n        return (Opal.defn(self, '$compile', TMP_AliasNode_compile_3 = function $$compile() {\n          var self = this;\n\n          return self.$push(\"Opal.alias(self, \", self.$expr(self.$new_name()), \", \", self.$expr(self.$old_name()), \")\")\n        }, TMP_AliasNode_compile_3.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $BeginNode(){};\n        var self = $BeginNode = $klass($base, $super, 'BeginNode', $BeginNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BeginNode_compile_4, TMP_BeginNode_returned_children_5, TMP_BeginNode_compile_children_7, TMP_BeginNode_simple_children$q_9, TMP_BeginNode_compile_inline_children_12;\n\n        def.level = def.returned_children = nil;\n        \n        self.$handle(\"begin\");\n        \n        Opal.defn(self, '$compile', TMP_BeginNode_compile_4 = function $$compile() {\n          var self = this;\n\n          \n          if ($truthy(self.$children()['$empty?']())) {\n            return self.$push(\"nil\")};\n          if ($truthy(self['$stmt?']())) {\n            return self.$compile_children(self.$children(), self.level)\n          } else if ($truthy(self['$simple_children?']())) {\n            \n            self.$compile_inline_children(self.$children(), self.level);\n            if ($truthy($rb_gt(self.$children().$size(), 1))) {\n              return self.$wrap(\"(\", \")\")\n              } else {\n              return nil\n            };\n          } else if (self.$children().$size()['$=='](1)) {\n            return self.$compile_inline_children(self.$returned_children(), self.level)\n            } else {\n            \n            self.$compile_children(self.$returned_children(), self.level);\n            return self.$wrap(\"(function() {\", \"})()\");\n          };\n        }, TMP_BeginNode_compile_4.$$arity = 0);\n        \n        Opal.defn(self, '$returned_children', TMP_BeginNode_returned_children_5 = function $$returned_children() {\n          var $a, $b, $c, self = this, rest = nil, last_child = nil;\n\n          return (self.returned_children = ($truthy($a = self.returned_children) ? $a : ($b = [].concat(Opal.to_a(self.$children())), $c = $b.length - 1, $c = ($c < 0) ? 0 : $c, (rest = $slice.call($b, 0, $c)), (last_child = ($b[$c] == null ? nil : $b[$c])), $b, (function() {if ($truthy(last_child)) {\n            return $rb_plus(rest, [self.$compiler().$returns(last_child)])\n            } else {\n            return [self.$s(\"nil\")]\n          }; return nil; })())))\n        }, TMP_BeginNode_returned_children_5.$$arity = 0);\n        \n        Opal.defn(self, '$compile_children', TMP_BeginNode_compile_children_7 = function $$compile_children(children, level) {\n          var TMP_6, self = this;\n\n          return $send(children, 'each', [], (TMP_6 = function(child){var self = TMP_6.$$s || this;\nif (child == null) child = nil;\n          return self.$line(self.$process(child, level), \";\")}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6))\n        }, TMP_BeginNode_compile_children_7.$$arity = 2);\n        Opal.const_set($nesting[0], 'COMPLEX_CHILDREN', [\"while\", \"while_post\", \"until\", \"until_post\", \"js_return\"]);\n        \n        Opal.defn(self, '$simple_children?', TMP_BeginNode_simple_children$q_9 = function() {\n          var TMP_8, self = this;\n\n          return $send(self.$children(), 'none?', [], (TMP_8 = function(child){var self = TMP_8.$$s || this;\nif (child == null) child = nil;\n          return Opal.const_get_relative($nesting, 'COMPLEX_CHILDREN')['$include?'](child.$type())}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8))\n        }, TMP_BeginNode_simple_children$q_9.$$arity = 0);\n        return (Opal.defn(self, '$compile_inline_children', TMP_BeginNode_compile_inline_children_12 = function $$compile_inline_children(children, level) {\n          var TMP_10, TMP_11, self = this;\n\n          return $send($send($send(children, 'map', [], (TMP_10 = function(child){var self = TMP_10.$$s || this;\nif (child == null) child = nil;\n          return self.$process(child, level)}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10)), 'reject', [], \"empty?\".$to_proc()), 'each_with_index', [], (TMP_11 = function(child, idx){var self = TMP_11.$$s || this;\nif (child == null) child = nil;if (idx == null) idx = nil;\n          \n            if (idx['$=='](0)) {\n              } else {\n              self.$push(\", \")\n            };\n            return self.$push(child);}, TMP_11.$$s = self, TMP_11.$$arity = 2, TMP_11))\n        }, TMP_BeginNode_compile_inline_children_12.$$arity = 2), nil) && 'compile_inline_children';\n      })($nesting[0], Opal.const_get_relative($nesting, 'ScopeNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $KwBeginNode(){};\n        var self = $KwBeginNode = $klass($base, $super, 'KwBeginNode', $KwBeginNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return self.$handle(\"kwbegin\")\n      })($nesting[0], Opal.const_get_relative($nesting, 'BeginNode'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/yield\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$find_yielding_scope', '$uses_block!', '$block_name', '$yields_single_arg?', '$push', '$expr', '$first', '$wrap', '$s', '$uses_splat?', '$scope', '$def?', '$parent', '$!', '$==', '$size', '$any?', '$type', '$handle', '$compile_call', '$children']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $BaseYieldNode(){};\n        var self = $BaseYieldNode = $klass($base, $super, 'BaseYieldNode', $BaseYieldNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BaseYieldNode_compile_call_1, TMP_BaseYieldNode_find_yielding_scope_2, TMP_BaseYieldNode_yields_single_arg$q_3, TMP_BaseYieldNode_uses_splat$q_5;\n\n        \n        \n        Opal.defn(self, '$compile_call', TMP_BaseYieldNode_compile_call_1 = function $$compile_call(children, level) {\n          var $a, self = this, yielding_scope = nil, block_name = nil;\n\n          \n          yielding_scope = self.$find_yielding_scope();\n          yielding_scope['$uses_block!']();\n          block_name = ($truthy($a = yielding_scope.$block_name()) ? $a : \"$yield\");\n          if ($truthy(self['$yields_single_arg?'](children))) {\n            \n            self.$push(self.$expr(children.$first()));\n            return self.$wrap(\"\" + \"Opal.yield1(\" + (block_name) + \", \", \")\");\n            } else {\n            \n            self.$push(self.$expr($send(self, 's', [\"arglist\"].concat(Opal.to_a(children)))));\n            if ($truthy(self['$uses_splat?'](children))) {\n              return self.$wrap(\"\" + \"Opal.yieldX(\" + (block_name) + \", \", \")\")\n              } else {\n              return self.$wrap(\"\" + \"Opal.yieldX(\" + (block_name) + \", [\", \"])\")\n            };\n          };\n        }, TMP_BaseYieldNode_compile_call_1.$$arity = 2);\n        \n        Opal.defn(self, '$find_yielding_scope', TMP_BaseYieldNode_find_yielding_scope_2 = function $$find_yielding_scope() {\n          var $a, $b, self = this, working = nil;\n\n          \n          working = self.$scope();\n          while ($truthy(working)) {\n            \n            if ($truthy(($truthy($b = working.$block_name()) ? $b : working['$def?']()))) {\n              break;};\n            working = working.$parent();\n          };\n          return working;\n        }, TMP_BaseYieldNode_find_yielding_scope_2.$$arity = 0);\n        \n        Opal.defn(self, '$yields_single_arg?', TMP_BaseYieldNode_yields_single_arg$q_3 = function(children) {\n          var $a, self = this;\n\n          return ($truthy($a = self['$uses_splat?'](children)['$!']()) ? children.$size()['$=='](1) : $a)\n        }, TMP_BaseYieldNode_yields_single_arg$q_3.$$arity = 1);\n        return (Opal.defn(self, '$uses_splat?', TMP_BaseYieldNode_uses_splat$q_5 = function(children) {\n          var TMP_4, self = this;\n\n          return $send(children, 'any?', [], (TMP_4 = function(child){var self = TMP_4.$$s || this;\nif (child == null) child = nil;\n          return child.$type()['$=='](\"splat\")}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4))\n        }, TMP_BaseYieldNode_uses_splat$q_5.$$arity = 1), nil) && 'uses_splat?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $YieldNode(){};\n        var self = $YieldNode = $klass($base, $super, 'YieldNode', $YieldNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_YieldNode_compile_6;\n\n        def.level = nil;\n        \n        self.$handle(\"yield\");\n        return (Opal.defn(self, '$compile', TMP_YieldNode_compile_6 = function $$compile() {\n          var self = this;\n\n          return self.$compile_call(self.$children(), self.level)\n        }, TMP_YieldNode_compile_6.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'BaseYieldNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $ReturnableYieldNode(){};\n        var self = $ReturnableYieldNode = $klass($base, $super, 'ReturnableYieldNode', $ReturnableYieldNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ReturnableYieldNode_compile_7;\n\n        def.level = nil;\n        \n        self.$handle(\"returnable_yield\");\n        return (Opal.defn(self, '$compile', TMP_ReturnableYieldNode_compile_7 = function $$compile() {\n          var self = this;\n\n          \n          self.$compile_call(self.$children(), self.level);\n          return self.$wrap(\"return \", \";\");\n        }, TMP_ReturnableYieldNode_compile_7.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'BaseYieldNode'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/rescue\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $range = Opal.range;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$push', '$in_ensure', '$line', '$stmt', '$body_sexp', '$indent', '$has_rescue_else?', '$unshift', '$rescue_else_code', '$process', '$compiler', '$ensr_sexp', '$wrap_in_closure?', '$wrap', '$returns', '$begn', '$ensr', '$s', '$recv?', '$expr?', '$rescue_else_sexp', '$scope', '$stmt?', '$detect', '$[]', '$!=', '$type', '$rescue_else_sexp=', '$-', '$handle_rescue_else_manually?', '$body_code', '$each_with_index', '$==', '$nil?', '$body', '$!', '$in_ensure?', '$expr', '$klasses', '$lvar', '$rescue_body', '$klasses_sexp']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $EnsureNode(){};\n        var self = $EnsureNode = $klass($base, $super, 'EnsureNode', $EnsureNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_EnsureNode_compile_5, TMP_EnsureNode_body_sexp_6, TMP_EnsureNode_ensr_sexp_7, TMP_EnsureNode_wrap_in_closure$q_8, TMP_EnsureNode_rescue_else_code_9;\n\n        \n        self.$handle(\"ensure\");\n        self.$children(\"begn\", \"ensr\");\n        \n        Opal.defn(self, '$compile', TMP_EnsureNode_compile_5 = function $$compile() {\n          var TMP_1, TMP_2, self = this;\n\n          \n          self.$push(\"try {\");\n          $send(self, 'in_ensure', [], (TMP_1 = function(){var self = TMP_1.$$s || this;\n\n          return self.$line(self.$stmt(self.$body_sexp()))}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1));\n          self.$line(\"} finally {\");\n          $send(self, 'indent', [], (TMP_2 = function(){var self = TMP_2.$$s || this, TMP_3;\n            if (self.level == null) self.level = nil;\n\n          if ($truthy(self['$has_rescue_else?']())) {\n              \n              self.$unshift(\"var $no_errors = true; \");\n              self.$line(\"var $rescue_else_result;\");\n              self.$line(\"if ($no_errors) { \");\n              $send(self, 'indent', [], (TMP_3 = function(){var self = TMP_3.$$s || this, TMP_4;\n\n              \n                self.$line(\"$rescue_else_result = (function() {\");\n                $send(self, 'indent', [], (TMP_4 = function(){var self = TMP_4.$$s || this;\n\n                return self.$line(self.$stmt(self.$rescue_else_code()))}, TMP_4.$$s = self, TMP_4.$$arity = 0, TMP_4));\n                return self.$line(\"})();\");}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3));\n              self.$line(\"}\");\n              self.$line(self.$compiler().$process(self.$ensr_sexp(), self.level));\n              return self.$line(\"if ($no_errors) { return $rescue_else_result; }\");\n              } else {\n              return self.$line(self.$compiler().$process(self.$ensr_sexp(), self.level))\n            }}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2));\n          self.$line(\"}\");\n          if ($truthy(self['$wrap_in_closure?']())) {\n            return self.$wrap(\"(function() { \", \"; })()\")\n            } else {\n            return nil\n          };\n        }, TMP_EnsureNode_compile_5.$$arity = 0);\n        \n        Opal.defn(self, '$body_sexp', TMP_EnsureNode_body_sexp_6 = function $$body_sexp() {\n          var self = this;\n\n          if ($truthy(self['$wrap_in_closure?']())) {\n            return self.$compiler().$returns(self.$begn())\n            } else {\n            return self.$begn()\n          }\n        }, TMP_EnsureNode_body_sexp_6.$$arity = 0);\n        \n        Opal.defn(self, '$ensr_sexp', TMP_EnsureNode_ensr_sexp_7 = function $$ensr_sexp() {\n          var $a, self = this;\n\n          return ($truthy($a = self.$ensr()) ? $a : self.$s(\"nil\"))\n        }, TMP_EnsureNode_ensr_sexp_7.$$arity = 0);\n        \n        Opal.defn(self, '$wrap_in_closure?', TMP_EnsureNode_wrap_in_closure$q_8 = function() {\n          var $a, $b, self = this;\n\n          return ($truthy($a = ($truthy($b = self['$recv?']()) ? $b : self['$expr?']())) ? $a : self['$has_rescue_else?']())\n        }, TMP_EnsureNode_wrap_in_closure$q_8.$$arity = 0);\n        return (Opal.defn(self, '$rescue_else_code', TMP_EnsureNode_rescue_else_code_9 = function $$rescue_else_code() {\n          var self = this, rescue_else_code = nil;\n\n          \n          rescue_else_code = self.$scope().$rescue_else_sexp();\n          if ($truthy(self['$stmt?']())) {\n            } else {\n            rescue_else_code = self.$compiler().$returns(rescue_else_code)\n          };\n          return rescue_else_code;\n        }, TMP_EnsureNode_rescue_else_code_9.$$arity = 0), nil) && 'rescue_else_code';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $RescueNode(){};\n        var self = $RescueNode = $klass($base, $super, 'RescueNode', $RescueNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_RescueNode_compile_16, TMP_RescueNode_body_code_17, TMP_RescueNode_rescue_else_code_18, TMP_RescueNode_handle_rescue_else_manually$q_19;\n\n        \n        self.$handle(\"rescue\");\n        self.$children(\"body\");\n        \n        Opal.defn(self, '$compile', TMP_RescueNode_compile_16 = function $$compile() {\n          var TMP_10, TMP_11, TMP_12, TMP_14, $a, self = this, $writer = nil, has_rescue_handlers = nil;\n\n          \n          \n          $writer = [$send(self.$children()['$[]']($range(1, -1, false)), 'detect', [], (TMP_10 = function(sexp){var self = TMP_10.$$s || this, $a;\nif (sexp == null) sexp = nil;\n          return ($truthy($a = sexp) ? sexp.$type()['$!='](\"resbody\") : $a)}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10))];\n          $send(self.$scope(), 'rescue_else_sexp=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          has_rescue_handlers = false;\n          if ($truthy(self['$handle_rescue_else_manually?']())) {\n            self.$line(\"var $no_errors = true;\")};\n          self.$push(\"try {\");\n          $send(self, 'indent', [], (TMP_11 = function(){var self = TMP_11.$$s || this;\n\n          return self.$line(self.$stmt(self.$body_code()))}, TMP_11.$$s = self, TMP_11.$$arity = 0, TMP_11));\n          self.$line(\"} catch ($err) {\");\n          $send(self, 'indent', [], (TMP_12 = function(){var self = TMP_12.$$s || this, TMP_13;\n\n          \n            if ($truthy(self['$has_rescue_else?']())) {\n              self.$line(\"$no_errors = false;\")};\n            $send(self.$children()['$[]']($range(1, -1, false)), 'each_with_index', [], (TMP_13 = function(child, idx){var self = TMP_13.$$s || this, $a;\n              if (self.level == null) self.level = nil;\nif (child == null) child = nil;if (idx == null) idx = nil;\n            if ($truthy(($truthy($a = child) ? child.$type()['$=='](\"resbody\") : $a))) {\n                \n                has_rescue_handlers = true;\n                if (idx['$=='](0)) {\n                  } else {\n                  self.$push(\" else \")\n                };\n                return self.$line(self.$process(child, self.level));\n                } else {\n                return nil\n              }}, TMP_13.$$s = self, TMP_13.$$arity = 2, TMP_13));\n            return self.$push(\" else { throw $err; }\");}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12));\n          self.$line(\"}\");\n          if ($truthy(self['$handle_rescue_else_manually?']())) {\n            \n            self.$push(\"finally {\");\n            $send(self, 'indent', [], (TMP_14 = function(){var self = TMP_14.$$s || this, TMP_15;\n\n            \n              self.$line(\"if ($no_errors) { \");\n              $send(self, 'indent', [], (TMP_15 = function(){var self = TMP_15.$$s || this;\n\n              return self.$line(self.$stmt(self.$rescue_else_code()))}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15));\n              return self.$line(\"}\");}, TMP_14.$$s = self, TMP_14.$$arity = 0, TMP_14));\n            self.$push(\"}\");};\n          if ($truthy(($truthy($a = self['$expr?']()) ? $a : self['$recv?']()))) {\n            return self.$wrap(\"(function() { \", \"})()\")\n            } else {\n            return nil\n          };\n        }, TMP_RescueNode_compile_16.$$arity = 0);\n        \n        Opal.defn(self, '$body_code', TMP_RescueNode_body_code_17 = function $$body_code() {\n          var $a, self = this, body_code = nil;\n\n          \n          body_code = (function() {if ($truthy(($truthy($a = self.$body()['$nil?']()) ? $a : self.$body().$type()['$=='](\"resbody\")))) {\n            return self.$s(\"nil\")\n            } else {\n            return self.$body()\n          }; return nil; })();\n          if ($truthy(self['$stmt?']())) {\n            } else {\n            body_code = self.$compiler().$returns(body_code)\n          };\n          return body_code;\n        }, TMP_RescueNode_body_code_17.$$arity = 0);\n        \n        Opal.defn(self, '$rescue_else_code', TMP_RescueNode_rescue_else_code_18 = function $$rescue_else_code() {\n          var self = this, rescue_else_code = nil;\n\n          \n          rescue_else_code = self.$scope().$rescue_else_sexp();\n          if ($truthy(self['$stmt?']())) {\n            } else {\n            rescue_else_code = self.$compiler().$returns(rescue_else_code)\n          };\n          return rescue_else_code;\n        }, TMP_RescueNode_rescue_else_code_18.$$arity = 0);\n        return (Opal.defn(self, '$handle_rescue_else_manually?', TMP_RescueNode_handle_rescue_else_manually$q_19 = function() {\n          var $a, self = this;\n\n          return ($truthy($a = self.$scope()['$in_ensure?']()['$!']()) ? self.$scope()['$has_rescue_else?']() : $a)\n        }, TMP_RescueNode_handle_rescue_else_manually$q_19.$$arity = 0), nil) && 'handle_rescue_else_manually?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $ResBodyNode(){};\n        var self = $ResBodyNode = $klass($base, $super, 'ResBodyNode', $ResBodyNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ResBodyNode_compile_22, TMP_ResBodyNode_klasses_23, TMP_ResBodyNode_rescue_body_24;\n\n        \n        self.$handle(\"resbody\");\n        self.$children(\"klasses_sexp\", \"lvar\", \"body\");\n        \n        Opal.defn(self, '$compile', TMP_ResBodyNode_compile_22 = function $$compile() {\n          var TMP_20, self = this;\n\n          \n          self.$push(\"if (Opal.rescue($err, \", self.$expr(self.$klasses()), \")) {\");\n          $send(self, 'indent', [], (TMP_20 = function(){var self = TMP_20.$$s || this, TMP_21;\n\n          \n            if ($truthy(self.$lvar())) {\n              self.$push(self.$expr(self.$lvar()), \"$err;\")};\n            self.$line(\"try {\");\n            $send(self, 'indent', [], (TMP_21 = function(){var self = TMP_21.$$s || this;\n\n            return self.$line(self.$stmt(self.$rescue_body()))}, TMP_21.$$s = self, TMP_21.$$arity = 0, TMP_21));\n            return self.$line(\"} finally { Opal.pop_exception() }\");}, TMP_20.$$s = self, TMP_20.$$arity = 0, TMP_20));\n          return self.$line(\"}\");\n        }, TMP_ResBodyNode_compile_22.$$arity = 0);\n        \n        Opal.defn(self, '$klasses', TMP_ResBodyNode_klasses_23 = function $$klasses() {\n          var $a, self = this;\n\n          return ($truthy($a = self.$klasses_sexp()) ? $a : self.$s(\"array\", self.$s(\"const\", nil, \"StandardError\")))\n        }, TMP_ResBodyNode_klasses_23.$$arity = 0);\n        return (Opal.defn(self, '$rescue_body', TMP_ResBodyNode_rescue_body_24 = function $$rescue_body() {\n          var $a, self = this, body_code = nil;\n\n          \n          body_code = ($truthy($a = self.$body()) ? $a : self.$s(\"nil\"));\n          if ($truthy(self['$stmt?']())) {\n            } else {\n            body_code = self.$compiler().$returns(body_code)\n          };\n          return body_code;\n        }, TMP_ResBodyNode_rescue_body_24.$$arity = 0), nil) && 'rescue_body';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $RetryNode(){};\n        var self = $RetryNode = $klass($base, $super, 'RetryNode', $RetryNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_RetryNode_compile_25;\n\n        \n        self.$handle(\"retry\");\n        return (Opal.defn(self, '$compile', TMP_RetryNode_compile_25 = function $$compile() {\n          var self = this;\n\n          return self.$push(self.$stmt(self.$s(\"send\", nil, \"retry\")))\n        }, TMP_RetryNode_compile_25.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/case\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $range = Opal.range;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$in_case', '$compiler', '$compile_code', '$needs_closure?', '$wrap', '$condition', '$[]=', '$case_stmt', '$-', '$add_local', '$push', '$expr', '$each_with_index', '$case_parts', '$line', '$type', '$===', '$returns', '$==', '$stmt', '$!', '$stmt?', '$[]', '$when_checks', '$js_truthy', '$s', '$process', '$body_code', '$last']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $CaseNode(){};\n        var self = $CaseNode = $klass($base, $super, 'CaseNode', $CaseNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_CaseNode_compile_2, TMP_CaseNode_compile_code_4, TMP_CaseNode_needs_closure$q_5, TMP_CaseNode_case_parts_6, TMP_CaseNode_case_stmt_7;\n\n        \n        self.$handle(\"case\");\n        self.$children(\"condition\");\n        \n        Opal.defn(self, '$compile', TMP_CaseNode_compile_2 = function $$compile() {\n          var TMP_1, self = this;\n\n          return $send(self.$compiler(), 'in_case', [], (TMP_1 = function(){var self = TMP_1.$$s || this;\n\n          \n            self.$compile_code();\n            if ($truthy(self['$needs_closure?']())) {\n              return self.$wrap(\"(function() {\", \"})()\")\n              } else {\n              return nil\n            };}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1))\n        }, TMP_CaseNode_compile_2.$$arity = 0);\n        \n        Opal.defn(self, '$compile_code', TMP_CaseNode_compile_code_4 = function $$compile_code() {\n          var TMP_3, $a, self = this, handled_else = nil, $writer = nil;\n\n          \n          handled_else = false;\n          if ($truthy(self.$condition())) {\n            \n            \n            $writer = [\"cond\", true];\n            $send(self.$case_stmt(), '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            self.$add_local(\"$case\");\n            self.$push(\"$case = \", self.$expr(self.$condition()), \";\");};\n          $send(self.$case_parts(), 'each_with_index', [], (TMP_3 = function(wen, idx){var self = TMP_3.$$s || this, $case = nil;\nif (wen == null) wen = nil;if (idx == null) idx = nil;\n          if ($truthy(wen)) {\n              \n              self.$line();\n              return (function() {$case = wen.$type();\n              if (\"when\"['$===']($case)) {\n              if ($truthy(self['$needs_closure?']())) {\n                wen = self.$compiler().$returns(wen)};\n              if (idx['$=='](0)) {\n                } else {\n                self.$push(\"else \")\n              };\n              return self.$push(self.$stmt(wen));}\n              else {\n              handled_else = true;\n              if ($truthy(self['$needs_closure?']())) {\n                wen = self.$compiler().$returns(wen)};\n              return self.$push(\"else {\", self.$stmt(wen), \"}\");}})();\n              } else {\n              return nil\n            }}, TMP_3.$$s = self, TMP_3.$$arity = 2, TMP_3));\n          if ($truthy(($truthy($a = self['$needs_closure?']()) ? handled_else['$!']() : $a))) {\n            \n            self.$line();\n            return self.$push(\"else { return nil }\");\n            } else {\n            return nil\n          };\n        }, TMP_CaseNode_compile_code_4.$$arity = 0);\n        \n        Opal.defn(self, '$needs_closure?', TMP_CaseNode_needs_closure$q_5 = function() {\n          var self = this;\n\n          return self['$stmt?']()['$!']()\n        }, TMP_CaseNode_needs_closure$q_5.$$arity = 0);\n        \n        Opal.defn(self, '$case_parts', TMP_CaseNode_case_parts_6 = function $$case_parts() {\n          var self = this;\n\n          return self.$children()['$[]']($range(1, -1, false))\n        }, TMP_CaseNode_case_parts_6.$$arity = 0);\n        return (Opal.defn(self, '$case_stmt', TMP_CaseNode_case_stmt_7 = function $$case_stmt() {\n          var self = this;\n\n          return self.$compiler().$case_stmt()\n        }, TMP_CaseNode_case_stmt_7.$$arity = 0), nil) && 'case_stmt';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $WhenNode(){};\n        var self = $WhenNode = $klass($base, $super, 'WhenNode', $WhenNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_WhenNode_compile_9, TMP_WhenNode_when_checks_10, TMP_WhenNode_case_stmt_11, TMP_WhenNode_body_code_12;\n\n        def.level = nil;\n        \n        self.$handle(\"when\");\n        self.$children(\"whens\", \"body\");\n        \n        Opal.defn(self, '$compile', TMP_WhenNode_compile_9 = function $$compile() {\n          var TMP_8, self = this;\n\n          \n          self.$push(\"if (\");\n          $send(self.$when_checks(), 'each_with_index', [], (TMP_8 = function(check, idx){var self = TMP_8.$$s || this, call = nil;\nif (check == null) check = nil;if (idx == null) idx = nil;\n          \n            if (idx['$=='](0)) {\n              } else {\n              self.$push(\" || \")\n            };\n            if (check.$type()['$=='](\"splat\")) {\n              \n              self.$push(\"(function($splt) { for (var i = 0, ii = $splt.length; i < ii; i++) {\");\n              if ($truthy(self.$case_stmt()['$[]'](\"cond\"))) {\n                self.$push(\"if ($splt[i]['$===']($case)) { return true; }\")\n                } else {\n                self.$push(\"if (\", self.$js_truthy(check), \")) { return true; }\")\n              };\n              return self.$push(\"} return false; })(\", self.$expr(check.$children()['$[]'](0)), \")\");\n            } else if ($truthy(self.$case_stmt()['$[]'](\"cond\"))) {\n              \n              call = self.$s(\"send\", check, \"===\", self.$s(\"arglist\", self.$s(\"js_tmp\", \"$case\")));\n              return self.$push(self.$expr(call));\n              } else {\n              return self.$push(self.$js_truthy(check))\n            };}, TMP_8.$$s = self, TMP_8.$$arity = 2, TMP_8));\n          return self.$push(\") {\", self.$process(self.$body_code(), self.level), \"}\");\n        }, TMP_WhenNode_compile_9.$$arity = 0);\n        \n        Opal.defn(self, '$when_checks', TMP_WhenNode_when_checks_10 = function $$when_checks() {\n          var self = this;\n\n          return self.$children()['$[]']($range(0, -2, false))\n        }, TMP_WhenNode_when_checks_10.$$arity = 0);\n        \n        Opal.defn(self, '$case_stmt', TMP_WhenNode_case_stmt_11 = function $$case_stmt() {\n          var self = this;\n\n          return self.$compiler().$case_stmt()\n        }, TMP_WhenNode_case_stmt_11.$$arity = 0);\n        return (Opal.defn(self, '$body_code', TMP_WhenNode_body_code_12 = function $$body_code() {\n          var $a, self = this;\n\n          return ($truthy($a = self.$children().$last()) ? $a : self.$s(\"nil\"))\n        }, TMP_WhenNode_body_code_12.$$arity = 0), nil) && 'body_code';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/super\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$include?', '$type', '$s', '$helper', '$push', '$compile_receiver', '$compile_method', '$compile_arguments', '$compile_block_pass', '$private', '$def?', '$scope', '$find_parent_def', '$==', '$raise_exception?', '$implicit_args?', '$to_s', '$mid', '$def_scope', '$identify!', '$defs', '$name', '$parent', '$method_id', '$def_scope_identity', '$defined_check_param', '$get_super_chain', '$join', '$map', '$implicit_arguments_param', '$super_method_invocation', '$iter?', '$super_block_invocation', '$raise', '$handle', '$method_missing?', '$compiler', '$wrap', '$uses_block!', '$compile_using_send', '$iter', '$uses_zuper=', '$-', '$formal_block_parameter', '$!', '$[]', '$<<', '$empty?', '$children', '$arglist', '$expr', '$===', '$extract_block_arg', '$block_arg']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $BaseSuperNode(){};\n        var self = $BaseSuperNode = $klass($base, $super, 'BaseSuperNode', $BaseSuperNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BaseSuperNode_initialize_1, TMP_BaseSuperNode_compile_using_send_2, TMP_BaseSuperNode_def_scope_3, TMP_BaseSuperNode_raise_exception$q_4, TMP_BaseSuperNode_defined_check_param_5, TMP_BaseSuperNode_implicit_args$q_6, TMP_BaseSuperNode_implicit_arguments_param_7, TMP_BaseSuperNode_method_id_8, TMP_BaseSuperNode_def_scope_identity_9, TMP_BaseSuperNode_super_method_invocation_10, TMP_BaseSuperNode_super_block_invocation_12, TMP_BaseSuperNode_compile_method_13;\n\n        def.sexp = def.def_scope = nil;\n        \n        \n        Opal.defn(self, '$initialize', TMP_BaseSuperNode_initialize_1 = function $$initialize($a_rest) {\n          var $b, $c, self = this, $iter = TMP_BaseSuperNode_initialize_1.$$p, $yield = $iter || nil, args = nil, rest = nil, last_child = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_BaseSuperNode_initialize_1.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_BaseSuperNode_initialize_1, false), $zuper, $iter);\n          args = [].concat(Opal.to_a(self.sexp));\n          $b = [].concat(Opal.to_a(args)), $c = $b.length - 1, $c = ($c < 0) ? 0 : $c, (rest = $slice.call($b, 0, $c)), (last_child = ($b[$c] == null ? nil : $b[$c])), $b;\n          if ($truthy(($truthy($b = last_child) ? [\"iter\", \"block_pass\"]['$include?'](last_child.$type()) : $b))) {\n            \n            self.iter = last_child;\n            args = rest;\n            } else {\n            self.iter = self.$s(\"js_tmp\", \"null\")\n          };\n          self.arglist = $send(self, 's', [\"arglist\"].concat(Opal.to_a(args)));\n          return (self.recvr = self.$s(\"self\"));\n        }, TMP_BaseSuperNode_initialize_1.$$arity = -1);\n        \n        Opal.defn(self, '$compile_using_send', TMP_BaseSuperNode_compile_using_send_2 = function $$compile_using_send() {\n          var self = this;\n\n          \n          self.$helper(\"send\");\n          self.$push(\"$send(\");\n          self.$compile_receiver();\n          self.$compile_method();\n          self.$compile_arguments();\n          self.$compile_block_pass();\n          return self.$push(\")\");\n        }, TMP_BaseSuperNode_compile_using_send_2.$$arity = 0);\n        self.$private();\n        \n        Opal.defn(self, '$def_scope', TMP_BaseSuperNode_def_scope_3 = function $$def_scope() {\n          var $a, self = this;\n\n          return (self.def_scope = ($truthy($a = self.def_scope) ? $a : (function() {if ($truthy(self.$scope()['$def?']())) {\n            return self.$scope()\n            } else {\n            return self.$scope().$find_parent_def()\n          }; return nil; })()))\n        }, TMP_BaseSuperNode_def_scope_3.$$arity = 0);\n        \n        Opal.defn(self, '$raise_exception?', TMP_BaseSuperNode_raise_exception$q_4 = function() {\n          var self = this;\n\n          return self.sexp.$type()['$=='](\"defined_super\")\n        }, TMP_BaseSuperNode_raise_exception$q_4.$$arity = 0);\n        \n        Opal.defn(self, '$defined_check_param', TMP_BaseSuperNode_defined_check_param_5 = function $$defined_check_param() {\n          var self = this;\n\n          if ($truthy(self['$raise_exception?']())) {\n            return \"true\"\n            } else {\n            return \"false\"\n          }\n        }, TMP_BaseSuperNode_defined_check_param_5.$$arity = 0);\n        \n        Opal.defn(self, '$implicit_args?', TMP_BaseSuperNode_implicit_args$q_6 = function() {\n          var self = this;\n\n          return self.sexp.$type()['$=='](\"zsuper\")\n        }, TMP_BaseSuperNode_implicit_args$q_6.$$arity = 0);\n        \n        Opal.defn(self, '$implicit_arguments_param', TMP_BaseSuperNode_implicit_arguments_param_7 = function $$implicit_arguments_param() {\n          var self = this;\n\n          if ($truthy(self['$implicit_args?']())) {\n            return \"true\"\n            } else {\n            return \"false\"\n          }\n        }, TMP_BaseSuperNode_implicit_arguments_param_7.$$arity = 0);\n        \n        Opal.defn(self, '$method_id', TMP_BaseSuperNode_method_id_8 = function $$method_id() {\n          var self = this;\n\n          return self.$def_scope().$mid().$to_s()\n        }, TMP_BaseSuperNode_method_id_8.$$arity = 0);\n        \n        Opal.defn(self, '$def_scope_identity', TMP_BaseSuperNode_def_scope_identity_9 = function $$def_scope_identity() {\n          var self = this;\n\n          return self.$def_scope()['$identify!'](self.$def_scope().$mid())\n        }, TMP_BaseSuperNode_def_scope_identity_9.$$arity = 0);\n        \n        Opal.defn(self, '$super_method_invocation', TMP_BaseSuperNode_super_method_invocation_10 = function $$super_method_invocation() {\n          var self = this, class_name = nil;\n\n          if ($truthy(self.$def_scope().$defs())) {\n            \n            class_name = (function() {if ($truthy(self.$def_scope().$parent().$name())) {\n              return \"\" + \"$\" + (self.$def_scope().$parent().$name())\n              } else {\n              return \"self.$$class.$$proto\"\n            }; return nil; })();\n            return \"\" + \"Opal.find_super_dispatcher(self, '\" + (self.$method_id()) + \"', \" + (self.$def_scope_identity()) + \", \" + (self.$defined_check_param()) + \", \" + (class_name) + \")\";\n            } else {\n            return \"\" + \"Opal.find_super_dispatcher(self, '\" + (self.$method_id()) + \"', \" + (self.$def_scope_identity()) + \", \" + (self.$defined_check_param()) + \")\"\n          }\n        }, TMP_BaseSuperNode_super_method_invocation_10.$$arity = 0);\n        \n        Opal.defn(self, '$super_block_invocation', TMP_BaseSuperNode_super_block_invocation_12 = function $$super_block_invocation() {\n          var $a, $b, TMP_11, self = this, chain = nil, cur_defn = nil, mid = nil, trys = nil;\n\n          \n          $b = self.$scope().$get_super_chain(), $a = Opal.to_ary($b), (chain = ($a[0] == null ? nil : $a[0])), (cur_defn = ($a[1] == null ? nil : $a[1])), (mid = ($a[2] == null ? nil : $a[2])), $b;\n          trys = $send(chain, 'map', [], (TMP_11 = function(c){var self = TMP_11.$$s || this;\nif (c == null) c = nil;\n          return \"\" + (c) + \".$$def\"}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11)).$join(\" || \");\n          return \"\" + \"Opal.find_iter_super_dispatcher(self, \" + (mid) + \", (\" + (trys) + \" || \" + (cur_defn) + \"), \" + (self.$defined_check_param()) + \", \" + (self.$implicit_arguments_param()) + \")\";\n        }, TMP_BaseSuperNode_super_block_invocation_12.$$arity = 0);\n        return (Opal.defn(self, '$compile_method', TMP_BaseSuperNode_compile_method_13 = function $$compile_method() {\n          var self = this;\n\n          \n          self.$push(\", \");\n          if ($truthy(self.$scope()['$def?']())) {\n            return self.$push(self.$super_method_invocation())\n          } else if ($truthy(self.$scope()['$iter?']())) {\n            return self.$push(self.$super_block_invocation())\n            } else {\n            return self.$raise(\"super must be called from method body or block\")\n          };\n        }, TMP_BaseSuperNode_compile_method_13.$$arity = 0), nil) && 'compile_method';\n      })($nesting[0], Opal.const_get_relative($nesting, 'CallNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $DefinedSuperNode(){};\n        var self = $DefinedSuperNode = $klass($base, $super, 'DefinedSuperNode', $DefinedSuperNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DefinedSuperNode_compile_14;\n\n        \n        self.$handle(\"defined_super\");\n        return (Opal.defn(self, '$compile', TMP_DefinedSuperNode_compile_14 = function $$compile() {\n          var self = this;\n\n          \n          self.$compile_receiver();\n          self.$compile_method();\n          if ($truthy(self.$compiler()['$method_missing?']())) {\n            return self.$wrap(\"(!(\", \".$$stub) ? \\\"super\\\" : nil)\")\n            } else {\n            return self.$wrap(\"((\", \") != null ? \\\"super\\\" : nil)\")\n          };\n        }, TMP_DefinedSuperNode_compile_14.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'BaseSuperNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $SuperNode(){};\n        var self = $SuperNode = $klass($base, $super, 'SuperNode', $SuperNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SuperNode_initialize_15, TMP_SuperNode_compile_16;\n\n        \n        self.$handle(\"super\");\n        \n        Opal.defn(self, '$initialize', TMP_SuperNode_initialize_15 = function $$initialize($a_rest) {\n          var self = this, $iter = TMP_SuperNode_initialize_15.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_SuperNode_initialize_15.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_SuperNode_initialize_15, false), $zuper, $iter);\n          if ($truthy(self.$scope()['$def?']())) {\n            return self.$scope()['$uses_block!']()\n            } else {\n            return nil\n          };\n        }, TMP_SuperNode_initialize_15.$$arity = -1);\n        return (Opal.defn(self, '$compile', TMP_SuperNode_compile_16 = function $$compile() {\n          var self = this;\n\n          return self.$compile_using_send()\n        }, TMP_SuperNode_compile_16.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'BaseSuperNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $ZsuperNode(){};\n        var self = $ZsuperNode = $klass($base, $super, 'ZsuperNode', $ZsuperNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ZsuperNode_initialize_17, TMP_ZsuperNode_compile_18, TMP_ZsuperNode_compile_arguments_19, TMP_ZsuperNode_formal_block_parameter_20;\n\n        \n        self.$handle(\"zsuper\");\n        \n        Opal.defn(self, '$initialize', TMP_ZsuperNode_initialize_17 = function $$initialize($a_rest) {\n          var self = this, $iter = TMP_ZsuperNode_initialize_17.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_ZsuperNode_initialize_17.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_ZsuperNode_initialize_17, false), $zuper, $iter);\n          if (self.$iter().$type()['$=='](\"iter\")) {\n            return nil\n            } else {\n            \n            self.$scope()['$uses_block!']();\n            return (self.iter = self.$s(\"js_tmp\", \"$iter\"));\n          };\n        }, TMP_ZsuperNode_initialize_17.$$arity = -1);\n        \n        Opal.defn(self, '$compile', TMP_ZsuperNode_compile_18 = function $$compile() {\n          var $a, self = this, $writer = nil, implicit_args = nil, block_arg = nil, block_pass = nil;\n\n          \n          if ($truthy(self.$def_scope())) {\n            \n            \n            $writer = [true];\n            $send(self.$def_scope(), 'uses_zuper=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            implicit_args = [self.$s(\"js_tmp\", \"$zuper\")];\n            if ($truthy(($truthy($a = (block_arg = self.$formal_block_parameter())) ? self.$iter()['$!']() : $a))) {\n              \n              block_pass = self.$s(\"block_pass\", self.$s(\"lvar\", block_arg['$[]'](1)));\n              implicit_args['$<<'](block_pass);};\n            self.arglist = $send(self, 's', [\"arglist\"].concat(Opal.to_a(implicit_args)));};\n          return self.$compile_using_send();\n        }, TMP_ZsuperNode_compile_18.$$arity = 0);\n        \n        Opal.defn(self, '$compile_arguments', TMP_ZsuperNode_compile_arguments_19 = function $$compile_arguments() {\n          var self = this;\n\n          \n          self.$push(\", \");\n          if ($truthy(self.$arglist().$children()['$empty?']())) {\n            return self.$push(\"[]\")\n            } else {\n            return self.$push(self.$expr(self.$arglist()))\n          };\n        }, TMP_ZsuperNode_compile_arguments_19.$$arity = 0);\n        return (Opal.defn(self, '$formal_block_parameter', TMP_ZsuperNode_formal_block_parameter_20 = function $$formal_block_parameter() {\n          var self = this, $case = nil;\n\n          return (function() {$case = self.$def_scope();\n          if (Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'Nodes'), 'IterNode')['$===']($case)) {return self.$def_scope().$extract_block_arg()}\n          else if (Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'Nodes'), 'DefNode')['$===']($case)) {return self.$def_scope().$block_arg()}\n          else {return self.$raise(\"\" + \"Don't know what to do with super in the scope \" + (self.$def_scope()))}})()\n        }, TMP_ZsuperNode_formal_block_parameter_20.$$arity = 0), nil) && 'formal_block_parameter';\n      })($nesting[0], Opal.const_get_relative($nesting, 'SuperNode'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/top\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$push', '$version_comment', '$opening', '$in_scope', '$stmt', '$stmts', '$is_a?', '$eval?', '$compiler', '$add_temp', '$add_used_helpers', '$add_used_operators', '$line', '$to_vars', '$scope', '$compile_method_stubs', '$compile_irb_vars', '$compile_end_construct', '$closing', '$requirable?', '$to_s', '$cleanpath', '$Pathname', '$file', '$inspect', '$returns', '$body', '$irb?', '$to_a', '$helpers', '$each', '$operator_helpers', '$[]', '$method_missing?', '$method_calls', '$join', '$map', '$empty?', '$eof_content']);\n  \n  self.$require(\"pathname\");\n  self.$require(\"opal/version\");\n  self.$require(\"opal/nodes/scope\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $TopNode(){};\n        var self = $TopNode = $klass($base, $super, 'TopNode', $TopNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_TopNode_compile_2, TMP_TopNode_opening_3, TMP_TopNode_closing_4, TMP_TopNode_stmts_5, TMP_TopNode_compile_irb_vars_6, TMP_TopNode_add_used_helpers_8, TMP_TopNode_add_used_operators_10, TMP_TopNode_compile_method_stubs_12, TMP_TopNode_compile_end_construct_13, TMP_TopNode_version_comment_14;\n\n        \n        self.$handle(\"top\");\n        self.$children(\"body\");\n        \n        Opal.defn(self, '$compile', TMP_TopNode_compile_2 = function $$compile() {\n          var TMP_1, self = this;\n\n          \n          self.$push(self.$version_comment());\n          self.$opening();\n          $send(self, 'in_scope', [], (TMP_1 = function(){var self = TMP_1.$$s || this, body_code = nil;\n\n          \n            body_code = self.$stmt(self.$stmts());\n            if ($truthy(body_code['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {\n              } else {\n              body_code = [body_code]\n            };\n            if ($truthy(self.$compiler()['$eval?']())) {\n              self.$add_temp(\"$nesting = self.$$is_a_module ? [self] : [self.$$class]\")\n              } else {\n              \n              self.$add_temp(\"self = Opal.top\");\n              self.$add_temp(\"$nesting = []\");\n            };\n            self.$add_temp(\"nil = Opal.nil\");\n            self.$add_used_helpers();\n            self.$add_used_operators();\n            self.$line(self.$scope().$to_vars());\n            self.$compile_method_stubs();\n            self.$compile_irb_vars();\n            self.$compile_end_construct();\n            return self.$line(body_code);}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1));\n          return self.$closing();\n        }, TMP_TopNode_compile_2.$$arity = 0);\n        \n        Opal.defn(self, '$opening', TMP_TopNode_opening_3 = function $$opening() {\n          var self = this, path = nil;\n\n          if ($truthy(self.$compiler()['$requirable?']())) {\n            \n            path = self.$Pathname(self.$compiler().$file()).$cleanpath().$to_s();\n            return self.$line(\"\" + \"Opal.modules[\" + (path.$inspect()) + \"] = function(Opal) {\");\n          } else if ($truthy(self.$compiler()['$eval?']())) {\n            return self.$line(\"(function(Opal, self) {\")\n            } else {\n            return self.$line(\"(function(Opal) {\")\n          }\n        }, TMP_TopNode_opening_3.$$arity = 0);\n        \n        Opal.defn(self, '$closing', TMP_TopNode_closing_4 = function $$closing() {\n          var self = this;\n\n          if ($truthy(self.$compiler()['$requirable?']())) {\n            return self.$line(\"};\\n\")\n          } else if ($truthy(self.$compiler()['$eval?']())) {\n            return self.$line(\"})(Opal, self)\")\n            } else {\n            return self.$line(\"})(Opal);\\n\")\n          }\n        }, TMP_TopNode_closing_4.$$arity = 0);\n        \n        Opal.defn(self, '$stmts', TMP_TopNode_stmts_5 = function $$stmts() {\n          var self = this;\n\n          return self.$compiler().$returns(self.$body())\n        }, TMP_TopNode_stmts_5.$$arity = 0);\n        \n        Opal.defn(self, '$compile_irb_vars', TMP_TopNode_compile_irb_vars_6 = function $$compile_irb_vars() {\n          var self = this;\n\n          if ($truthy(self.$compiler()['$irb?']())) {\n            return self.$line(\"if (!Opal.irb_vars) { Opal.irb_vars = {}; }\")\n            } else {\n            return nil\n          }\n        }, TMP_TopNode_compile_irb_vars_6.$$arity = 0);\n        \n        Opal.defn(self, '$add_used_helpers', TMP_TopNode_add_used_helpers_8 = function $$add_used_helpers() {\n          var TMP_7, self = this, helpers = nil;\n\n          \n          helpers = self.$compiler().$helpers().$to_a();\n          return $send(helpers.$to_a(), 'each', [], (TMP_7 = function(h){var self = TMP_7.$$s || this;\nif (h == null) h = nil;\n          return self.$add_temp(\"\" + \"$\" + (h) + \" = Opal.\" + (h))}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));\n        }, TMP_TopNode_add_used_helpers_8.$$arity = 0);\n        \n        Opal.defn(self, '$add_used_operators', TMP_TopNode_add_used_operators_10 = function $$add_used_operators() {\n          var TMP_9, self = this, operators = nil;\n\n          \n          operators = self.$compiler().$operator_helpers().$to_a();\n          return $send(operators, 'each', [], (TMP_9 = function(op){var self = TMP_9.$$s || this, name = nil;\nif (op == null) op = nil;\n          \n            name = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Nodes'), 'CallNode'), 'OPERATORS')['$[]'](op);\n            self.$line(\"\" + \"function $rb_\" + (name) + \"(lhs, rhs) {\");\n            self.$line(\"\" + \"  return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs \" + (op) + \" rhs : lhs['$\" + (op) + \"'](rhs);\");\n            return self.$line(\"}\");}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9));\n        }, TMP_TopNode_add_used_operators_10.$$arity = 0);\n        \n        Opal.defn(self, '$compile_method_stubs', TMP_TopNode_compile_method_stubs_12 = function $$compile_method_stubs() {\n          var TMP_11, self = this, calls = nil, stubs = nil;\n\n          if ($truthy(self.$compiler()['$method_missing?']())) {\n            \n            calls = self.$compiler().$method_calls();\n            stubs = $send(calls.$to_a(), 'map', [], (TMP_11 = function(k){var self = TMP_11.$$s || this;\nif (k == null) k = nil;\n            return \"\" + \"'$\" + (k) + \"'\"}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11)).$join(\", \");\n            if ($truthy(stubs['$empty?']())) {\n              return nil\n              } else {\n              return self.$line(\"\" + \"Opal.add_stubs([\" + (stubs) + \"]);\")\n            };\n            } else {\n            return nil\n          }\n        }, TMP_TopNode_compile_method_stubs_12.$$arity = 0);\n        \n        Opal.defn(self, '$compile_end_construct', TMP_TopNode_compile_end_construct_13 = function $$compile_end_construct() {\n          var self = this, content = nil;\n\n          if ($truthy((content = self.$compiler().$eof_content()))) {\n            \n            self.$line(\"var $__END__ = Opal.Object.$new();\");\n            return self.$line(\"\" + \"$__END__.$read = function() { return \" + (content.$inspect()) + \"; };\");\n            } else {\n            return nil\n          }\n        }, TMP_TopNode_compile_end_construct_13.$$arity = 0);\n        return (Opal.defn(self, '$version_comment', TMP_TopNode_version_comment_14 = function $$version_comment() {\n          var self = this;\n\n          return \"\" + \"/* Generated by Opal \" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'VERSION')) + \" */\"\n        }, TMP_TopNode_version_comment_14.$$arity = 0), nil) && 'version_comment';\n      })($nesting[0], Opal.const_get_relative($nesting, 'ScopeNode'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/while\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$with_temp', '$js_truthy', '$test', '$in_while', '$compiler', '$wrap_in_closure?', '$[]=', '$while_loop', '$-', '$stmt', '$body', '$uses_redo?', '$push', '$while_open', '$while_close', '$line', '$wrap', '$[]', '$expr?', '$recv?']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $WhileNode(){};\n        var self = $WhileNode = $klass($base, $super, 'WhileNode', $WhileNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_WhileNode_compile_3, TMP_WhileNode_while_open_4, TMP_WhileNode_while_close_5, TMP_WhileNode_uses_redo$q_6, TMP_WhileNode_wrap_in_closure$q_7;\n\n        \n        self.$handle(\"while\");\n        self.$children(\"test\", \"body\");\n        \n        Opal.defn(self, '$compile', TMP_WhileNode_compile_3 = function $$compile() {\n          var TMP_1, self = this;\n\n          \n          $send(self, 'with_temp', [], (TMP_1 = function(redo_var){var self = TMP_1.$$s || this, TMP_2, test_code = nil;\nif (redo_var == null) redo_var = nil;\n          \n            test_code = self.$js_truthy(self.$test());\n            $send(self.$compiler(), 'in_while', [], (TMP_2 = function(){var self = TMP_2.$$s || this, $writer = nil, body_code = nil;\n\n            \n              if ($truthy(self['$wrap_in_closure?']())) {\n                \n                $writer = [\"closure\", true];\n                $send(self.$while_loop(), '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];};\n              \n              $writer = [\"redo_var\", redo_var];\n              $send(self.$while_loop(), '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              body_code = self.$stmt(self.$body());\n              if ($truthy(self['$uses_redo?']())) {\n                \n                self.$push(\"\" + (redo_var) + \" = false; \" + (self.$while_open()) + (redo_var) + \" || \");\n                self.$push(test_code);\n                self.$push(self.$while_close());\n                } else {\n                self.$push(self.$while_open(), test_code, self.$while_close())\n              };\n              if ($truthy(self['$uses_redo?']())) {\n                self.$push(\"\" + (redo_var) + \" = false;\")};\n              return self.$line(body_code);}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2));\n            return self.$line(\"}\");}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));\n          if ($truthy(self['$wrap_in_closure?']())) {\n            return self.$wrap(\"(function() {\", \"; return nil; })()\")\n            } else {\n            return nil\n          };\n        }, TMP_WhileNode_compile_3.$$arity = 0);\n        \n        Opal.defn(self, '$while_open', TMP_WhileNode_while_open_4 = function $$while_open() {\n          var self = this;\n\n          return \"while (\"\n        }, TMP_WhileNode_while_open_4.$$arity = 0);\n        \n        Opal.defn(self, '$while_close', TMP_WhileNode_while_close_5 = function $$while_close() {\n          var self = this;\n\n          return \") {\"\n        }, TMP_WhileNode_while_close_5.$$arity = 0);\n        \n        Opal.defn(self, '$uses_redo?', TMP_WhileNode_uses_redo$q_6 = function() {\n          var self = this;\n\n          return self.$while_loop()['$[]'](\"use_redo\")\n        }, TMP_WhileNode_uses_redo$q_6.$$arity = 0);\n        return (Opal.defn(self, '$wrap_in_closure?', TMP_WhileNode_wrap_in_closure$q_7 = function() {\n          var $a, self = this;\n\n          return ($truthy($a = self['$expr?']()) ? $a : self['$recv?']())\n        }, TMP_WhileNode_wrap_in_closure$q_7.$$arity = 0), nil) && 'wrap_in_closure?';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $WhilePostNode(){};\n        var self = $WhilePostNode = $klass($base, $super, 'WhilePostNode', $WhilePostNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return self.$handle(\"while_post\")\n      })($nesting[0], Opal.const_get_relative($nesting, 'WhileNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $UntilNode(){};\n        var self = $UntilNode = $klass($base, $super, 'UntilNode', $UntilNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_UntilNode_while_open_8, TMP_UntilNode_while_close_9;\n\n        \n        self.$handle(\"until\");\n        \n        Opal.defn(self, '$while_open', TMP_UntilNode_while_open_8 = function $$while_open() {\n          var self = this;\n\n          return \"while (!(\"\n        }, TMP_UntilNode_while_open_8.$$arity = 0);\n        return (Opal.defn(self, '$while_close', TMP_UntilNode_while_close_9 = function $$while_close() {\n          var self = this;\n\n          return \")) {\"\n        }, TMP_UntilNode_while_close_9.$$arity = 0), nil) && 'while_close';\n      })($nesting[0], Opal.const_get_relative($nesting, 'WhileNode'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $UntilPostNode(){};\n        var self = $UntilPostNode = $klass($base, $super, 'UntilPostNode', $UntilPostNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return self.$handle(\"until_post\")\n      })($nesting[0], Opal.const_get_relative($nesting, 'UntilNode'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/hash\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$handle', '$attr_accessor', '$each', '$children', '$type', '$===', '$<<', '$[]', '$all?', '$keys', '$include?', '$has_kwsplat', '$compile_merge', '$simple_keys?', '$compile_hash2', '$compile_hash', '$helper', '$==', '$empty?', '$expr', '$s', '$each_with_index', '$push', '$wrap', '$times', '$size', '$inspect', '$to_s', '$values', '$[]=', '$-', '$join', '$value']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $HashNode(){};\n        var self = $HashNode = $klass($base, $super, 'HashNode', $HashNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_HashNode_initialize_1, TMP_HashNode_simple_keys$q_4, TMP_HashNode_compile_5, TMP_HashNode_compile_merge_8, TMP_HashNode_compile_hash_10, TMP_HashNode_compile_hash2_13;\n\n        \n        self.$handle(\"hash\");\n        self.$attr_accessor(\"has_kwsplat\", \"keys\", \"values\");\n        \n        Opal.defn(self, '$initialize', TMP_HashNode_initialize_1 = function $$initialize($a_rest) {\n          var TMP_2, self = this, $iter = TMP_HashNode_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          if ($iter) TMP_HashNode_initialize_1.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_HashNode_initialize_1, false), $zuper, $iter);\n          self.has_kwsplat = false;\n          self.keys = [];\n          self.values = [];\n          return $send(self.$children(), 'each', [], (TMP_2 = function(child){var self = TMP_2.$$s || this, $case = nil;\n            if (self.keys == null) self.keys = nil;\n            if (self.values == null) self.values = nil;\nif (child == null) child = nil;\n          return (function() {$case = child.$type();\n            if (\"kwsplat\"['$===']($case)) {return (self.has_kwsplat = true)}\n            else if (\"pair\"['$===']($case)) {\n            self.keys['$<<'](child.$children()['$[]'](0));\n            return self.values['$<<'](child.$children()['$[]'](1));}\n            else { return nil }})()}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));\n        }, TMP_HashNode_initialize_1.$$arity = -1);\n        \n        Opal.defn(self, '$simple_keys?', TMP_HashNode_simple_keys$q_4 = function() {\n          var TMP_3, self = this;\n\n          return $send(self.$keys(), 'all?', [], (TMP_3 = function(key){var self = TMP_3.$$s || this;\nif (key == null) key = nil;\n          return [\"sym\", \"str\"]['$include?'](key.$type())}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))\n        }, TMP_HashNode_simple_keys$q_4.$$arity = 0);\n        \n        Opal.defn(self, '$compile', TMP_HashNode_compile_5 = function $$compile() {\n          var self = this;\n\n          if ($truthy(self.$has_kwsplat())) {\n            return self.$compile_merge()\n          } else if ($truthy(self['$simple_keys?']())) {\n            return self.$compile_hash2()\n            } else {\n            return self.$compile_hash()\n          }\n        }, TMP_HashNode_compile_5.$$arity = 0);\n        \n        Opal.defn(self, '$compile_merge', TMP_HashNode_compile_merge_8 = function $$compile_merge() {\n          var $a, TMP_6, TMP_7, self = this, result = nil, seq = nil;\n\n          \n          self.$helper(\"hash\");\n          $a = [[], []], (result = $a[0]), (seq = $a[1]), $a;\n          $send(self.$children(), 'each', [], (TMP_6 = function(child){var self = TMP_6.$$s || this;\nif (child == null) child = nil;\n          if (child.$type()['$=='](\"kwsplat\")) {\n              \n              if ($truthy(seq['$empty?']())) {\n                } else {\n                result['$<<'](self.$expr($send(self, 's', [\"hash\"].concat(Opal.to_a(seq)))))\n              };\n              result['$<<'](self.$expr(child));\n              return (seq = []);\n              } else {\n              return seq['$<<'](child)\n            }}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));\n          if ($truthy(seq['$empty?']())) {\n            } else {\n            result['$<<'](self.$expr($send(self, 's', [\"hash\"].concat(Opal.to_a(seq)))))\n          };\n          return $send(result, 'each_with_index', [], (TMP_7 = function(fragment, idx){var self = TMP_7.$$s || this;\nif (fragment == null) fragment = nil;if (idx == null) idx = nil;\n          if (idx['$=='](0)) {\n              return self.$push(fragment)\n              } else {\n              return self.$push(\".$merge(\", fragment, \")\")\n            }}, TMP_7.$$s = self, TMP_7.$$arity = 2, TMP_7));\n        }, TMP_HashNode_compile_merge_8.$$arity = 0);\n        \n        Opal.defn(self, '$compile_hash', TMP_HashNode_compile_hash_10 = function $$compile_hash() {\n          var TMP_9, self = this;\n\n          \n          self.$helper(\"hash\");\n          $send(self.$children(), 'each_with_index', [], (TMP_9 = function(pair, idx){var self = TMP_9.$$s || this, $a, $b, key = nil, value = nil;\nif (pair == null) pair = nil;if (idx == null) idx = nil;\n          \n            $b = pair.$children(), $a = Opal.to_ary($b), (key = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $b;\n            if (idx['$=='](0)) {\n              } else {\n              self.$push(\", \")\n            };\n            return self.$push(self.$expr(key), \", \", self.$expr(value));}, TMP_9.$$s = self, TMP_9.$$arity = 2, TMP_9));\n          return self.$wrap(\"$hash(\", \")\");\n        }, TMP_HashNode_compile_hash_10.$$arity = 0);\n        return (Opal.defn(self, '$compile_hash2', TMP_HashNode_compile_hash2_13 = function $$compile_hash2() {\n          var $a, TMP_11, TMP_12, self = this, hash_obj = nil, hash_keys = nil;\n\n          \n          $a = [$hash2([], {}), []], (hash_obj = $a[0]), (hash_keys = $a[1]), $a;\n          self.$helper(\"hash2\");\n          $send(self.$keys().$size(), 'times', [], (TMP_11 = function(idx){var self = TMP_11.$$s || this, key = nil, $writer = nil;\nif (idx == null) idx = nil;\n          \n            key = self.$keys()['$[]'](idx).$children()['$[]'](0).$to_s().$inspect();\n            if ($truthy(hash_obj['$include?'](key))) {\n              } else {\n              hash_keys['$<<'](key)\n            };\n            \n            $writer = [key, self.$expr(self.$values()['$[]'](idx))];\n            $send(hash_obj, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];;}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11));\n          $send(hash_keys, 'each_with_index', [], (TMP_12 = function(key, idx){var self = TMP_12.$$s || this;\nif (key == null) key = nil;if (idx == null) idx = nil;\n          \n            if (idx['$=='](0)) {\n              } else {\n              self.$push(\", \")\n            };\n            self.$push(\"\" + (key) + \": \");\n            return self.$push(hash_obj['$[]'](key));}, TMP_12.$$s = self, TMP_12.$$arity = 2, TMP_12));\n          return self.$wrap(\"\" + \"$hash2([\" + (hash_keys.$join(\", \")) + \"], {\", \"})\");\n        }, TMP_HashNode_compile_hash2_13.$$arity = 0), nil) && 'compile_hash2';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $KwSplatNode(){};\n        var self = $KwSplatNode = $klass($base, $super, 'KwSplatNode', $KwSplatNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_KwSplatNode_compile_14;\n\n        \n        self.$handle(\"kwsplat\");\n        self.$children(\"value\");\n        return (Opal.defn(self, '$compile', TMP_KwSplatNode_compile_14 = function $$compile() {\n          var self = this;\n\n          return self.$push(\"Opal.to_hash(\", self.$expr(self.$value()), \")\")\n        }, TMP_KwSplatNode_compile_14.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/array\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$handle', '$empty?', '$children', '$push', '$each', '$==', '$type', '$expr', '$<<', '$fragment']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $ArrayNode(){};\n        var self = $ArrayNode = $klass($base, $super, 'ArrayNode', $ArrayNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ArrayNode_compile_2;\n\n        \n        self.$handle(\"array\");\n        return (Opal.defn(self, '$compile', TMP_ArrayNode_compile_2 = function $$compile() {\n          var $a, TMP_1, self = this, code = nil, work = nil, join = nil;\n\n          \n          if ($truthy(self.$children()['$empty?']())) {\n            return self.$push(\"[]\")};\n          $a = [[], []], (code = $a[0]), (work = $a[1]), $a;\n          $send(self.$children(), 'each', [], (TMP_1 = function(child){var self = TMP_1.$$s || this, splat = nil, part = nil;\nif (child == null) child = nil;\n          \n            splat = child.$type()['$=='](\"splat\");\n            part = self.$expr(child);\n            if ($truthy(splat)) {\n              \n              if ($truthy(work['$empty?']())) {\n                if ($truthy(code['$empty?']())) {\n                  code['$<<'](self.$fragment(\"[].concat(\"))['$<<'](part)['$<<'](self.$fragment(\")\"))\n                  } else {\n                  code['$<<'](self.$fragment(\".concat(\"))['$<<'](part)['$<<'](self.$fragment(\")\"))\n                }\n                } else {\n                \n                if ($truthy(code['$empty?']())) {\n                  code['$<<'](self.$fragment(\"[\"))['$<<'](work)['$<<'](self.$fragment(\"]\"))\n                  } else {\n                  code['$<<'](self.$fragment(\".concat([\"))['$<<'](work)['$<<'](self.$fragment(\"])\"))\n                };\n                code['$<<'](self.$fragment(\".concat(\"))['$<<'](part)['$<<'](self.$fragment(\")\"));\n              };\n              return (work = []);\n              } else {\n              \n              if ($truthy(work['$empty?']())) {\n                } else {\n                work['$<<'](self.$fragment(\", \"))\n              };\n              return work['$<<'](part);\n            };}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));\n          if ($truthy(work['$empty?']())) {\n            } else {\n            \n            join = [self.$fragment(\"[\"), work, self.$fragment(\"]\")];\n            if ($truthy(code['$empty?']())) {\n              code = join\n              } else {\n              code.$push([self.$fragment(\".concat(\"), join, self.$fragment(\")\")])\n            };\n          };\n          return self.$push(code);\n        }, TMP_ArrayNode_compile_2.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/defined\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$type', '$value', '$===', '$push', '$inspect', '$to_s', '$==', '$size', '$[]', '$compile_defined_send', '$wrap', '$compile_defined_ivar', '$compile_defined_super', '$compile_defined_yield', '$compile_defined_xstr', '$compile_defined_const', '$compile_defined_cvar', '$compile_defined_gvar', '$compile_defined_back_ref', '$compile_defined_nth_ref', '$compile_defined_array', '$respond_to?', '$__send__', '$new_temp', '$scope', '$expr', '$wrap_with_try_catch', '$mid_to_jsid', '$compile_defined', '$compile_send_recv_doesnt_raise', '$each', '$s', '$uses_block!', '$block_name', '$find_parent_def', '$nil?', '$class_variable_owner', '$helper', '$include?', '$each_with_index']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $DefinedNode(){};\n        var self = $DefinedNode = $klass($base, $super, 'DefinedNode', $DefinedNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DefinedNode_compile_1, TMP_DefinedNode_compile_defined_2, TMP_DefinedNode_wrap_with_try_catch_3, TMP_DefinedNode_compile_send_recv_doesnt_raise_4, TMP_DefinedNode_compile_defined_send_6, TMP_DefinedNode_compile_defined_ivar_7, TMP_DefinedNode_compile_defined_super_8, TMP_DefinedNode_compile_defined_yield_9, TMP_DefinedNode_compile_defined_xstr_10, TMP_DefinedNode_compile_defined_const_11, TMP_DefinedNode_compile_defined_cvar_12, TMP_DefinedNode_compile_defined_gvar_13, TMP_DefinedNode_compile_defined_back_ref_14, TMP_DefinedNode_compile_defined_nth_ref_15, TMP_DefinedNode_compile_defined_array_17;\n\n        \n        self.$handle(\"defined?\");\n        self.$children(\"value\");\n        \n        Opal.defn(self, '$compile', TMP_DefinedNode_compile_1 = function $$compile() {\n          var $a, self = this, $case = nil;\n\n          return (function() {$case = self.$value().$type();\n          if (\"self\"['$===']($case) || \"nil\"['$===']($case) || \"false\"['$===']($case) || \"true\"['$===']($case)) {return self.$push(self.$value().$type().$to_s().$inspect())}\n          else if (\"lvasgn\"['$===']($case) || \"ivasgn\"['$===']($case) || \"gvasgn\"['$===']($case) || \"cvasgn\"['$===']($case) || \"casgn\"['$===']($case) || \"op_asgn\"['$===']($case) || \"or_asgn\"['$===']($case) || \"and_asgn\"['$===']($case)) {return self.$push(\"'assignment'\")}\n          else if (\"lvar\"['$===']($case)) {return self.$push(\"'local-variable'\")}\n          else if (\"begin\"['$===']($case)) {if ($truthy((($a = self.$value().$children().$size()['$=='](1)) ? self.$value().$children()['$[]'](0).$type()['$=='](\"masgn\") : self.$value().$children().$size()['$=='](1)))) {\n            return self.$push(\"'assignment'\")\n            } else {\n            return self.$push(\"'expression'\")\n          }}\n          else if (\"send\"['$===']($case)) {\n          self.$compile_defined_send(self.$value());\n          return self.$wrap(\"(\", \" ? 'method' : nil)\");}\n          else if (\"ivar\"['$===']($case)) {\n          self.$compile_defined_ivar(self.$value());\n          return self.$wrap(\"(\", \" ? 'instance-variable' : nil)\");}\n          else if (\"zsuper\"['$===']($case) || \"super\"['$===']($case)) {return self.$compile_defined_super(self.$value())}\n          else if (\"yield\"['$===']($case)) {\n          self.$compile_defined_yield(self.$value());\n          return self.$wrap(\"(\", \" ? 'yield' : nil)\");}\n          else if (\"xstr\"['$===']($case)) {return self.$compile_defined_xstr(self.$value())}\n          else if (\"const\"['$===']($case)) {\n          self.$compile_defined_const(self.$value());\n          return self.$wrap(\"(\", \" ? 'constant' : nil)\");}\n          else if (\"cvar\"['$===']($case)) {\n          self.$compile_defined_cvar(self.$value());\n          return self.$wrap(\"(\", \" ? 'class variable' : nil)\");}\n          else if (\"gvar\"['$===']($case)) {\n          self.$compile_defined_gvar(self.$value());\n          return self.$wrap(\"(\", \" ? 'global-variable' : nil)\");}\n          else if (\"back_ref\"['$===']($case)) {\n          self.$compile_defined_back_ref(self.$value());\n          return self.$wrap(\"(\", \" ? 'global-variable' : nil)\");}\n          else if (\"nth_ref\"['$===']($case)) {\n          self.$compile_defined_nth_ref(self.$value());\n          return self.$wrap(\"(\", \" ? 'global-variable' : nil)\");}\n          else if (\"array\"['$===']($case)) {\n          self.$compile_defined_array(self.$value());\n          return self.$wrap(\"(\", \" ? 'expression' : nil)\");}\n          else {return self.$push(\"'expression'\")}})()\n        }, TMP_DefinedNode_compile_1.$$arity = 0);\n        \n        Opal.defn(self, '$compile_defined', TMP_DefinedNode_compile_defined_2 = function $$compile_defined(node) {\n          var self = this, type = nil, node_tmp = nil;\n\n          \n          type = node.$type();\n          if ($truthy(self['$respond_to?'](\"\" + \"compile_defined_\" + (type)))) {\n            return self.$__send__(\"\" + \"compile_defined_\" + (type), node)\n            } else {\n            \n            node_tmp = self.$scope().$new_temp();\n            self.$push(\"\" + \"(\" + (node_tmp) + \" = \", self.$expr(node), \")\");\n            return node_tmp;\n          };\n        }, TMP_DefinedNode_compile_defined_2.$$arity = 1);\n        \n        Opal.defn(self, '$wrap_with_try_catch', TMP_DefinedNode_wrap_with_try_catch_3 = function $$wrap_with_try_catch(code) {\n          var self = this, returning_tmp = nil;\n\n          \n          returning_tmp = self.$scope().$new_temp();\n          self.$push(\"\" + \"(\" + (returning_tmp) + \" = (function() { try {\");\n          self.$push(\"\" + \"  return \" + (code) + \";\");\n          self.$push(\"} catch ($err) {\");\n          self.$push(\"  if (Opal.rescue($err, [Opal.Exception])) {\");\n          self.$push(\"    try {\");\n          self.$push(\"      return false;\");\n          self.$push(\"    } finally { Opal.pop_exception() }\");\n          self.$push(\"  } else { throw $err; }\");\n          self.$push(\"}})())\");\n          return returning_tmp;\n        }, TMP_DefinedNode_wrap_with_try_catch_3.$$arity = 1);\n        \n        Opal.defn(self, '$compile_send_recv_doesnt_raise', TMP_DefinedNode_compile_send_recv_doesnt_raise_4 = function $$compile_send_recv_doesnt_raise(recv_code) {\n          var self = this;\n\n          return self.$wrap_with_try_catch(recv_code)\n        }, TMP_DefinedNode_compile_send_recv_doesnt_raise_4.$$arity = 1);\n        \n        Opal.defn(self, '$compile_defined_send', TMP_DefinedNode_compile_defined_send_6 = function $$compile_defined_send(node) {\n          var $a, TMP_5, self = this, recv = nil, method_name = nil, args = nil, mid = nil, recv_code = nil, recv_tmp = nil, recv_value_tmp = nil, meth_tmp = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (recv = ($a[0] == null ? nil : $a[0])), (method_name = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $a;\n          mid = self.$mid_to_jsid(method_name.$to_s());\n          if ($truthy(recv)) {\n            \n            recv_code = self.$compile_defined(recv);\n            self.$push(\" && \");\n            if (recv.$type()['$=='](\"send\")) {\n              \n              recv_code = self.$compile_send_recv_doesnt_raise(recv_code);\n              self.$push(\" && \");};\n            recv_tmp = self.$scope().$new_temp();\n            self.$push(\"\" + \"(\" + (recv_tmp) + \" = \", recv_code, \"\" + \", \" + (recv_tmp) + \") && \");\n            } else {\n            recv_tmp = \"self\"\n          };\n          recv_value_tmp = self.$scope().$new_temp();\n          self.$push(\"\" + \"(\" + (recv_value_tmp) + \" = \" + (recv_tmp) + \") && \");\n          meth_tmp = self.$scope().$new_temp();\n          self.$push(\"\" + \"(((\" + (meth_tmp) + \" = \" + (recv_value_tmp) + (mid) + \") && !\" + (meth_tmp) + \".$$stub)\");\n          self.$push(\"\" + \" || \" + (recv_value_tmp) + \"['$respond_to_missing?']('\" + (method_name) + \"'))\");\n          $send(args, 'each', [], (TMP_5 = function(arg){var self = TMP_5.$$s || this, $case = nil;\nif (arg == null) arg = nil;\n          return (function() {$case = arg.$type();\n            if (\"block_pass\"['$===']($case)) {return nil}\n            else {\n            self.$push(\" && \");\n            return self.$compile_defined(arg);}})()}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));\n          self.$wrap(\"(\", \")\");\n          return \"\" + (meth_tmp) + \"()\";\n        }, TMP_DefinedNode_compile_defined_send_6.$$arity = 1);\n        \n        Opal.defn(self, '$compile_defined_ivar', TMP_DefinedNode_compile_defined_ivar_7 = function $$compile_defined_ivar(node) {\n          var self = this, name = nil, tmp = nil;\n\n          \n          name = node.$children()['$[]'](0).$to_s()['$[]']($range(1, -1, false));\n          tmp = self.$scope().$new_temp();\n          self.$push(\"\" + \"(\" + (tmp) + \" = self['\" + (name) + \"'], \" + (tmp) + \" != null && \" + (tmp) + \" !== nil)\");\n          return tmp;\n        }, TMP_DefinedNode_compile_defined_ivar_7.$$arity = 1);\n        \n        Opal.defn(self, '$compile_defined_super', TMP_DefinedNode_compile_defined_super_8 = function $$compile_defined_super(node) {\n          var self = this;\n\n          return self.$push(self.$expr(self.$s(\"defined_super\")))\n        }, TMP_DefinedNode_compile_defined_super_8.$$arity = 1);\n        \n        Opal.defn(self, '$compile_defined_yield', TMP_DefinedNode_compile_defined_yield_9 = function $$compile_defined_yield(node) {\n          var $a, $b, self = this, block_name = nil, parent = nil;\n\n          \n          self.$scope()['$uses_block!']();\n          block_name = ($truthy($a = self.$scope().$block_name()) ? $a : (parent = ($truthy($b = self.$scope().$find_parent_def()) ? parent.$block_name() : $b)));\n          self.$push(\"\" + \"(\" + (block_name) + \" != null && \" + (block_name) + \" !== nil)\");\n          return block_name;\n        }, TMP_DefinedNode_compile_defined_yield_9.$$arity = 1);\n        \n        Opal.defn(self, '$compile_defined_xstr', TMP_DefinedNode_compile_defined_xstr_10 = function $$compile_defined_xstr(node) {\n          var self = this;\n\n          return self.$push(\"(typeof(\", self.$expr(node), \") !== \\\"undefined\\\")\")\n        }, TMP_DefinedNode_compile_defined_xstr_10.$$arity = 1);\n        \n        Opal.defn(self, '$compile_defined_const', TMP_DefinedNode_compile_defined_const_11 = function $$compile_defined_const(node) {\n          var $a, self = this, const_scope = nil, const_name = nil, const_tmp = nil, const_scope_tmp = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (const_scope = ($a[0] == null ? nil : $a[0])), (const_name = ($a[1] == null ? nil : $a[1])), $a;\n          const_tmp = self.$scope().$new_temp();\n          if ($truthy(const_scope['$nil?']())) {\n            self.$push(\"\" + \"(\" + (const_tmp) + \" = Opal.const_get_relative($nesting, '\" + (const_name) + \"', 'skip_raise'))\")\n          } else if (const_scope['$=='](self.$s(\"cbase\"))) {\n            self.$push(\"\" + \"(\" + (const_tmp) + \" = Opal.const_get_qualified('::', '\" + (const_name) + \"', 'skip_raise'))\")\n            } else {\n            \n            const_scope_tmp = self.$compile_defined(const_scope);\n            self.$push(\"\" + \" && (\" + (const_tmp) + \" = Opal.const_get_qualified(\" + (const_scope_tmp) + \", '\" + (const_name) + \"', 'skip_raise'))\");\n          };\n          return const_tmp;\n        }, TMP_DefinedNode_compile_defined_const_11.$$arity = 1);\n        \n        Opal.defn(self, '$compile_defined_cvar', TMP_DefinedNode_compile_defined_cvar_12 = function $$compile_defined_cvar(node) {\n          var $a, self = this, cvar_name = nil, _ = nil, cvar_tmp = nil;\n\n          \n          $a = [].concat(Opal.to_a(node)), (cvar_name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;\n          cvar_tmp = self.$scope().$new_temp();\n          self.$push(\"\" + \"(\" + (cvar_tmp) + \" = \" + (self.$class_variable_owner()) + \".$$cvars['\" + (cvar_name) + \"'], \" + (cvar_tmp) + \" != null)\");\n          return cvar_tmp;\n        }, TMP_DefinedNode_compile_defined_cvar_12.$$arity = 1);\n        \n        Opal.defn(self, '$compile_defined_gvar', TMP_DefinedNode_compile_defined_gvar_13 = function $$compile_defined_gvar(node) {\n          var self = this, name = nil, gvar_temp = nil;\n\n          \n          self.$helper(\"gvars\");\n          name = node.$children()['$[]'](0).$to_s()['$[]']($range(1, -1, false));\n          gvar_temp = self.$scope().$new_temp();\n          if ($truthy([\"~\", \"!\"]['$include?'](name))) {\n            self.$push(\"\" + \"(\" + (gvar_temp) + \" = \", self.$expr(node), \" || true)\")\n            } else {\n            self.$push(\"\" + \"(\" + (gvar_temp) + \" = $gvars[\" + (name.$inspect()) + \"], \" + (gvar_temp) + \" != null)\")\n          };\n          return gvar_temp;\n        }, TMP_DefinedNode_compile_defined_gvar_13.$$arity = 1);\n        \n        Opal.defn(self, '$compile_defined_back_ref', TMP_DefinedNode_compile_defined_back_ref_14 = function $$compile_defined_back_ref(node) {\n          var self = this, back_ref_temp = nil;\n\n          \n          self.$helper(\"gvars\");\n          back_ref_temp = self.$scope().$new_temp();\n          self.$push(\"\" + \"(\" + (back_ref_temp) + \" = $gvars['~'], \" + (back_ref_temp) + \" != null && \" + (back_ref_temp) + \" !== nil)\");\n          return back_ref_temp;\n        }, TMP_DefinedNode_compile_defined_back_ref_14.$$arity = 1);\n        \n        Opal.defn(self, '$compile_defined_nth_ref', TMP_DefinedNode_compile_defined_nth_ref_15 = function $$compile_defined_nth_ref(node) {\n          var self = this, nth_ref_tmp = nil;\n\n          \n          self.$helper(\"gvars\");\n          nth_ref_tmp = self.$scope().$new_temp();\n          self.$push(\"\" + \"(\" + (nth_ref_tmp) + \" = $gvars['~'], \" + (nth_ref_tmp) + \" != null && \" + (nth_ref_tmp) + \" != nil)\");\n          return nth_ref_tmp;\n        }, TMP_DefinedNode_compile_defined_nth_ref_15.$$arity = 1);\n        return (Opal.defn(self, '$compile_defined_array', TMP_DefinedNode_compile_defined_array_17 = function $$compile_defined_array(node) {\n          var TMP_16, self = this;\n\n          return $send(node.$children(), 'each_with_index', [], (TMP_16 = function(child, idx){var self = TMP_16.$$s || this;\nif (child == null) child = nil;if (idx == null) idx = nil;\n          \n            if (idx['$=='](0)) {\n              } else {\n              self.$push(\" && \")\n            };\n            return self.$compile_defined(child);}, TMP_16.$$s = self, TMP_16.$$arity = 2, TMP_16))\n        }, TMP_DefinedNode_compile_defined_array_17.$$arity = 1), nil) && 'compile_defined_array';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/masgn\"] = function(Opal) {\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$handle', '$children', '$new_temp', '$scope', '$==', '$type', '$rhs', '$push', '$expr', '$any?', '$size', '$compile_masgn', '$lhs', '$queue_temp', '$take_while', '$!=', '$drop', '$each_with_index', '$compile_assignment', '$empty?', '$shift', '$[]', '$<<', '$dup', '$s', '$!', '$>=', '$updated', '$include?', '$+', '$last', '$raise']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $MassAssignNode(){};\n        var self = $MassAssignNode = $klass($base, $super, 'MassAssignNode', $MassAssignNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MassAssignNode_compile_2, TMP_MassAssignNode_compile_masgn_6, TMP_MassAssignNode_compile_assignment_7;\n\n        \n        Opal.const_set($nesting[0], 'SIMPLE_ASSIGNMENT', [\"lvasgn\", \"ivasgn\", \"lvar\", \"gvasgn\", \"cdecl\", \"casgn\"]);\n        self.$handle(\"masgn\");\n        self.$children(\"lhs\", \"rhs\");\n        \n        Opal.defn(self, '$compile', TMP_MassAssignNode_compile_2 = function $$compile() {\n          var TMP_1, self = this, array = nil, rhs_len = nil, retval = nil;\n\n          \n          array = self.$scope().$new_temp();\n          if (self.$rhs().$type()['$=='](\"array\")) {\n            \n            self.$push(\"\" + (array) + \" = \", self.$expr(self.$rhs()));\n            rhs_len = (function() {if ($truthy($send(self.$rhs().$children(), 'any?', [], (TMP_1 = function(c){var self = TMP_1.$$s || this;\nif (c == null) c = nil;\n            return c.$type()['$=='](\"splat\")}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1)))) {\n              return nil\n              } else {\n              return self.$rhs().$children().$size()\n            }; return nil; })();\n            self.$compile_masgn(self.$lhs().$children(), array, rhs_len);\n            self.$push(\"\" + \", \" + (array));\n          } else if (self.$rhs().$type()['$=='](\"begin\")) {\n            \n            retval = self.$scope().$new_temp();\n            self.$push(\"\" + (retval) + \" = \", self.$expr(self.$rhs()));\n            self.$push(\"\" + \", \" + (array) + \" = Opal.to_ary(\" + (retval) + \")\");\n            self.$compile_masgn(self.$lhs().$children(), array);\n            self.$push(\"\" + \", \" + (retval));\n            self.$scope().$queue_temp(retval);\n            } else {\n            \n            retval = self.$scope().$new_temp();\n            self.$push(\"\" + (retval) + \" = \", self.$expr(self.$rhs()));\n            self.$push(\"\" + \", \" + (array) + \" = Opal.to_ary(\" + (retval) + \")\");\n            self.$compile_masgn(self.$lhs().$children(), array);\n            self.$push(\"\" + \", \" + (retval));\n            self.$scope().$queue_temp(retval);\n          };\n          return self.$scope().$queue_temp(array);\n        }, TMP_MassAssignNode_compile_2.$$arity = 0);\n        \n        Opal.defn(self, '$compile_masgn', TMP_MassAssignNode_compile_masgn_6 = function $$compile_masgn(lhs_items, array, len) {\n          var TMP_3, TMP_4, TMP_5, self = this, pre_splat = nil, post_splat = nil, splat = nil, part = nil, tmp = nil;\n\n          if (len == null) {\n            len = nil;\n          }\n          \n          pre_splat = $send(lhs_items, 'take_while', [], (TMP_3 = function(child){var self = TMP_3.$$s || this;\nif (child == null) child = nil;\n          return child.$type()['$!='](\"splat\")}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3));\n          post_splat = lhs_items.$drop(pre_splat.$size());\n          $send(pre_splat, 'each_with_index', [], (TMP_4 = function(child, idx){var self = TMP_4.$$s || this;\nif (child == null) child = nil;if (idx == null) idx = nil;\n          return self.$compile_assignment(child, array, idx, len)}, TMP_4.$$s = self, TMP_4.$$arity = 2, TMP_4));\n          if ($truthy(post_splat['$empty?']())) {\n            return nil\n            } else {\n            \n            splat = post_splat.$shift();\n            if ($truthy(post_splat['$empty?']())) {\n              if ($truthy((part = splat.$children()['$[]'](0)))) {\n                \n                part = part.$dup()['$<<'](self.$s(\"js_tmp\", \"\" + \"$slice.call(\" + (array) + \", \" + (pre_splat.$size()) + \")\"));\n                self.$push(\", \");\n                return self.$push(self.$expr(part));\n                } else {\n                return nil\n              }\n              } else {\n              \n              tmp = self.$scope().$new_temp();\n              self.$push(\"\" + \", \" + (tmp) + \" = \" + (array) + \".length - \" + (post_splat.$size()));\n              self.$push(\"\" + \", \" + (tmp) + \" = (\" + (tmp) + \" < \" + (pre_splat.$size()) + \") ? \" + (pre_splat.$size()) + \" : \" + (tmp));\n              if ($truthy((part = splat.$children()['$[]'](0)))) {\n                \n                part = part.$dup()['$<<'](self.$s(\"js_tmp\", \"\" + \"$slice.call(\" + (array) + \", \" + (pre_splat.$size()) + \", \" + (tmp) + \")\"));\n                self.$push(\", \");\n                self.$push(self.$expr(part));};\n              $send(post_splat, 'each_with_index', [], (TMP_5 = function(child, idx){var self = TMP_5.$$s || this;\nif (child == null) child = nil;if (idx == null) idx = nil;\n              if (idx['$=='](0)) {\n                  return self.$compile_assignment(child, array, tmp)\n                  } else {\n                  return self.$compile_assignment(child, array, \"\" + (tmp) + \" + \" + (idx))\n                }}, TMP_5.$$s = self, TMP_5.$$arity = 2, TMP_5));\n              return self.$scope().$queue_temp(tmp);\n            };\n          };\n        }, TMP_MassAssignNode_compile_masgn_6.$$arity = -3);\n        return (Opal.defn(self, '$compile_assignment', TMP_MassAssignNode_compile_assignment_7 = function $$compile_assignment(child, array, idx, len) {\n          var $a, self = this, assign = nil, part = nil, tmp = nil;\n\n          if (len == null) {\n            len = nil;\n          }\n          \n          if ($truthy(($truthy($a = len['$!']()) ? $a : $rb_ge(idx, len)))) {\n            assign = self.$s(\"js_tmp\", \"\" + \"(\" + (array) + \"[\" + (idx) + \"] == null ? nil : \" + (array) + \"[\" + (idx) + \"])\")\n            } else {\n            assign = self.$s(\"js_tmp\", \"\" + (array) + \"[\" + (idx) + \"]\")\n          };\n          part = child.$updated();\n          if ($truthy(Opal.const_get_relative($nesting, 'SIMPLE_ASSIGNMENT')['$include?'](child.$type()))) {\n            part = part.$updated(nil, $rb_plus(part.$children(), [assign]))\n          } else if (child.$type()['$=='](\"send\")) {\n            part = part.$updated(nil, $rb_plus(part.$children(), [assign]))\n          } else if (child.$type()['$=='](\"attrasgn\")) {\n            part.$last()['$<<'](assign)\n          } else if (child.$type()['$=='](\"mlhs\")) {\n            \n            tmp = self.$scope().$new_temp();\n            self.$push(\"\" + \", (\" + (tmp) + \" = Opal.to_ary(\" + (assign.$children()['$[]'](0)) + \")\");\n            self.$compile_masgn(child.$children(), tmp);\n            self.$push(\")\");\n            self.$scope().$queue_temp(tmp);\n            return nil;\n            } else {\n            self.$raise(\"\" + \"Bad child node in masgn LHS: \" + (child) + \". LHS: \" + (self.$lhs()))\n          };\n          self.$push(\", \");\n          return self.$push(self.$expr(part));\n        }, TMP_MassAssignNode_compile_assignment_7.$$arity = -4), nil) && 'compile_assignment';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes/arglist\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$handle', '$each', '$children', '$==', '$type', '$expr', '$empty?', '$<<', '$fragment', '$push']);\n  \n  self.$require(\"opal/nodes/base\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Nodes, self = $Nodes = $module($base, 'Nodes');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $ArglistNode(){};\n        var self = $ArglistNode = $klass($base, $super, 'ArglistNode', $ArglistNode);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ArglistNode_compile_2;\n\n        \n        self.$handle(\"arglist\");\n        return (Opal.defn(self, '$compile', TMP_ArglistNode_compile_2 = function $$compile() {\n          var $a, TMP_1, self = this, code = nil, work = nil, join = nil;\n\n          \n          $a = [[], []], (code = $a[0]), (work = $a[1]), $a;\n          $send(self.$children(), 'each', [], (TMP_1 = function(current){var self = TMP_1.$$s || this, splat = nil, arg = nil;\nif (current == null) current = nil;\n          \n            splat = current.$type()['$=='](\"splat\");\n            arg = self.$expr(current);\n            if ($truthy(splat)) {\n              \n              if ($truthy(work['$empty?']())) {\n                if ($truthy(code['$empty?']())) {\n                  code['$<<'](arg)\n                  } else {\n                  code['$<<'](self.$fragment(\".concat(\"))['$<<'](arg)['$<<'](self.$fragment(\")\"))\n                }\n                } else {\n                \n                if ($truthy(code['$empty?']())) {\n                  code['$<<'](self.$fragment(\"[\"))['$<<'](work)['$<<'](self.$fragment(\"]\"))\n                  } else {\n                  code['$<<'](self.$fragment(\".concat([\"))['$<<'](work)['$<<'](self.$fragment(\"])\"))\n                };\n                code['$<<'](self.$fragment(\".concat(\"))['$<<'](arg)['$<<'](self.$fragment(\")\"));\n              };\n              return (work = []);\n              } else {\n              \n              if ($truthy(work['$empty?']())) {\n                } else {\n                work['$<<'](self.$fragment(\", \"))\n              };\n              return work['$<<'](arg);\n            };}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));\n          if ($truthy(work['$empty?']())) {\n            } else {\n            \n            join = work;\n            if ($truthy(code['$empty?']())) {\n              code = join\n              } else {\n              code['$<<'](self.$fragment(\".concat(\"))['$<<'](join)['$<<'](self.$fragment(\")\"))\n            };\n          };\n          return $send(self, 'push', Opal.to_a(code));\n        }, TMP_ArglistNode_compile_2.$$arity = 0), nil) && 'compile';\n      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/nodes\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"opal/nodes/base\");\n  self.$require(\"opal/nodes/literal\");\n  self.$require(\"opal/nodes/variables\");\n  self.$require(\"opal/nodes/constants\");\n  self.$require(\"opal/nodes/call\");\n  self.$require(\"opal/nodes/csend\");\n  self.$require(\"opal/nodes/call_special\");\n  self.$require(\"opal/nodes/module\");\n  self.$require(\"opal/nodes/class\");\n  self.$require(\"opal/nodes/singleton_class\");\n  self.$require(\"opal/nodes/inline_args\");\n  self.$require(\"opal/nodes/args/normarg\");\n  self.$require(\"opal/nodes/args/optarg\");\n  self.$require(\"opal/nodes/args/mlhsarg\");\n  self.$require(\"opal/nodes/args/restarg\");\n  self.$require(\"opal/nodes/args/kwarg\");\n  self.$require(\"opal/nodes/args/kwoptarg\");\n  self.$require(\"opal/nodes/args/kwrestarg\");\n  self.$require(\"opal/nodes/args/post_kwargs\");\n  self.$require(\"opal/nodes/args/post_args\");\n  self.$require(\"opal/nodes/iter\");\n  self.$require(\"opal/nodes/def\");\n  self.$require(\"opal/nodes/defs\");\n  self.$require(\"opal/nodes/if\");\n  self.$require(\"opal/nodes/logic\");\n  self.$require(\"opal/nodes/definitions\");\n  self.$require(\"opal/nodes/yield\");\n  self.$require(\"opal/nodes/rescue\");\n  self.$require(\"opal/nodes/case\");\n  self.$require(\"opal/nodes/super\");\n  self.$require(\"opal/nodes/top\");\n  self.$require(\"opal/nodes/while\");\n  self.$require(\"opal/nodes/hash\");\n  self.$require(\"opal/nodes/array\");\n  self.$require(\"opal/nodes/defined\");\n  self.$require(\"opal/nodes/masgn\");\n  return self.$require(\"opal/nodes/arglist\");\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/eof_content\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;\n\n  Opal.add_stubs(['$empty?', '$[]', '$last_token_position', '$drop_while', '$lines', '$==', '$join', '$private', '$last', '$end_pos']);\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $EofContent(){};\n      var self = $EofContent = $klass($base, $super, 'EofContent', $EofContent);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_EofContent_initialize_1, TMP_EofContent_eof_3, TMP_EofContent_last_token_position_4;\n\n      def.tokens = def.source = nil;\n      \n      Opal.const_set($nesting[0], 'DATA_SEPARATOR', \"__END__\\n\");\n      \n      Opal.defn(self, '$initialize', TMP_EofContent_initialize_1 = function $$initialize(tokens, source) {\n        var self = this;\n\n        \n        self.tokens = tokens;\n        return (self.source = source);\n      }, TMP_EofContent_initialize_1.$$arity = 2);\n      \n      Opal.defn(self, '$eof', TMP_EofContent_eof_3 = function $$eof() {\n        var TMP_2, $a, self = this, eof_content = nil;\n\n        \n        if ($truthy(self.tokens['$empty?']())) {\n          return nil};\n        eof_content = self.source['$[]'](Opal.Range.$new(self.$last_token_position(), -1, false));\n        if ($truthy(eof_content)) {\n          } else {\n          return nil\n        };\n        eof_content = $send(eof_content.$lines(), 'drop_while', [], (TMP_2 = function(line){var self = TMP_2.$$s || this;\nif (line == null) line = nil;\n        return line['$=='](\"\\n\")}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));\n        if (eof_content['$[]'](0)['$=='](\"__END__\\n\")) {\n          \n          eof_content = ($truthy($a = eof_content['$[]']($range(1, -1, false))) ? $a : []);\n          return eof_content.$join();\n        } else if (eof_content['$==']([\"__END__\"])) {\n          return \"\"\n          } else {\n          return nil\n        };\n      }, TMP_EofContent_eof_3.$$arity = 0);\n      self.$private();\n      return (Opal.defn(self, '$last_token_position', TMP_EofContent_last_token_position_4 = function $$last_token_position() {\n        var $a, $b, self = this, _ = nil, last_token_info = nil, last_token_range = nil;\n\n        \n        $b = self.tokens.$last(), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (last_token_info = ($a[1] == null ? nil : $a[1])), $b;\n        $b = last_token_info, $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (last_token_range = ($a[1] == null ? nil : $a[1])), $b;\n        return last_token_range.$end_pos();\n      }, TMP_EofContent_last_token_position_4.$$arity = 0), nil) && 'last_token_position';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/compiler\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$compile', '$new', '$[]', '$define_method', '$fetch', '$!', '$include?', '$raise', '$+', '$inspect', '$compiler_option', '$attr_reader', '$attr_accessor', '$parse', '$flatten', '$process', '$join', '$map', '$to_proc', '$file', '$source=', '$-', '$default_parser', '$tokenize', '$message', '$backtrace', '$s', '$associate_locations', '$eof', '$warn', '$to_s', '$empty?', '$gsub', '$<<', '$helpers', '$new_temp', '$queue_temp', '$push_while', '$indent', '$pop_while', '$in_while?', '$==', '$fragment', '$scope', '$handlers', '$type', '$compile_to_fragments', '$error', '$returns', '$===', '$updated', '$any?', '$children', '$select', '$end_with?', '$loc', '$uses_block!', '$block_name', '$find_parent_def']);\n  \n  self.$require(\"set\");\n  self.$require(\"opal/parser\");\n  self.$require(\"opal/fragment\");\n  self.$require(\"opal/nodes\");\n  self.$require(\"opal/eof_content\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Opal_compile_1;\n\n    \n    Opal.defs(self, '$compile', TMP_Opal_compile_1 = function $$compile(source, options) {\n      var self = this;\n\n      if (options == null) {\n        options = $hash2([], {});\n      }\n      return Opal.const_get_relative($nesting, 'Compiler').$new(source, options).$compile()\n    }, TMP_Opal_compile_1.$$arity = -2);\n    (function($base, $super, $parent_nesting) {\n      function $Compiler(){};\n      var self = $Compiler = $klass($base, $super, 'Compiler', $Compiler);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Compiler_compiler_option_4, TMP_Compiler_initialize_5, TMP_Compiler_compile_6, TMP_Compiler_parse_7, TMP_Compiler_source_map_8, TMP_Compiler_helpers_9, TMP_Compiler_operator_helpers_10, TMP_Compiler_method_calls_11, TMP_Compiler_error_12, TMP_Compiler_warning_13, TMP_Compiler_parser_indent_14, TMP_Compiler_s_15, TMP_Compiler_fragment_16, TMP_Compiler_unique_temp_17, TMP_Compiler_helper_18, TMP_Compiler_indent_19, TMP_Compiler_with_temp_20, TMP_Compiler_in_while_21, TMP_Compiler_in_ensure_23, TMP_Compiler_in_ensure$q_24, TMP_Compiler_in_case_25, TMP_Compiler_in_while$q_26, TMP_Compiler_process_27, TMP_Compiler_handlers_28, TMP_Compiler_requires_29, TMP_Compiler_required_trees_30, TMP_Compiler_returns_35, TMP_Compiler_handle_block_given_call_36;\n\n      def.sexp = def.fragments = def.source = def.buffer = def.parser = def.helpers = def.operator_helpers = def.method_calls = def.indent = def.unique = def.scope = def.in_ensure = def.case_stmt = def.handlers = def.requires = def.required_trees = nil;\n      \n      Opal.const_set($nesting[0], 'INDENT', \"  \");\n      Opal.const_set($nesting[0], 'COMPARE', [\"<\", \">\", \"<=\", \">=\"]);\n      Opal.defs(self, '$compiler_option', TMP_Compiler_compiler_option_4 = function $$compiler_option(name, default_value, options) {\n        var $a, TMP_2, self = this, mid = nil, valid_values = nil;\n\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        \n        mid = options['$[]'](\"as\");\n        valid_values = options['$[]'](\"valid_values\");\n        return $send(self, 'define_method', [($truthy($a = mid) ? $a : name)], (TMP_2 = function(){var self = TMP_2.$$s || this, TMP_3, $b, value = nil;\n          if (self.options == null) self.options = nil;\n\n        \n          value = $send(self.options, 'fetch', [name], (TMP_3 = function(){var self = TMP_3.$$s || this;\n\n          return default_value}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3));\n          if ($truthy(($truthy($b = valid_values) ? valid_values['$include?'](value)['$!']() : $b))) {\n            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), $rb_plus(\"\" + \"invalid value \" + (value.$inspect()) + \" for option \" + (name.$inspect()) + \" \", \"\" + \"(valid values: \" + (valid_values.$inspect()) + \")\"))};\n          return value;}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2));\n      }, TMP_Compiler_compiler_option_4.$$arity = -3);\n      self.$compiler_option(\"file\", \"(file)\");\n      self.$compiler_option(\"method_missing\", true, $hash2([\"as\"], {\"as\": \"method_missing?\"}));\n      self.$compiler_option(\"arity_check\", false, $hash2([\"as\"], {\"as\": \"arity_check?\"}));\n      self.$compiler_option(\"freezing\", true, $hash2([\"as\"], {\"as\": \"freezing?\"}));\n      self.$compiler_option(\"tainting\", true, $hash2([\"as\"], {\"as\": \"tainting?\"}));\n      self.$compiler_option(\"irb\", false, $hash2([\"as\"], {\"as\": \"irb?\"}));\n      self.$compiler_option(\"dynamic_require_severity\", \"ignore\", $hash2([\"valid_values\"], {\"valid_values\": [\"error\", \"warning\", \"ignore\"]}));\n      self.$compiler_option(\"requirable\", false, $hash2([\"as\"], {\"as\": \"requirable?\"}));\n      self.$compiler_option(\"inline_operators\", true, $hash2([\"as\"], {\"as\": \"inline_operators?\"}));\n      self.$compiler_option(\"eval\", false, $hash2([\"as\"], {\"as\": \"eval?\"}));\n      self.$compiler_option(\"enable_source_location\", false, $hash2([\"as\"], {\"as\": \"enable_source_location?\"}));\n      self.$compiler_option(\"parse_comments\", false, $hash2([\"as\"], {\"as\": \"parse_comments?\"}));\n      self.$attr_reader(\"result\");\n      self.$attr_reader(\"fragments\");\n      self.$attr_accessor(\"scope\");\n      self.$attr_reader(\"case_stmt\");\n      self.$attr_reader(\"eof_content\");\n      self.$attr_reader(\"comments\");\n      \n      Opal.defn(self, '$initialize', TMP_Compiler_initialize_5 = function $$initialize(source, options) {\n        var self = this;\n\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        \n        self.source = source;\n        self.indent = \"\";\n        self.unique = 0;\n        self.options = options;\n        self.comments = Opal.const_get_relative($nesting, 'Hash').$new([]);\n        return (self.case_stmt = nil);\n      }, TMP_Compiler_initialize_5.$$arity = -2);\n      \n      Opal.defn(self, '$compile', TMP_Compiler_compile_6 = function $$compile() {\n        var self = this;\n\n        \n        self.$parse();\n        self.fragments = self.$process(self.sexp).$flatten();\n        return (self.result = $send(self.fragments, 'map', [], \"code\".$to_proc()).$join(\"\"));\n      }, TMP_Compiler_compile_6.$$arity = 0);\n      \n      Opal.defn(self, '$parse', TMP_Compiler_parse_7 = function $$parse() {\n        var $a, $b, self = this, $writer = nil, sexp = nil, comments = nil, tokens = nil, error = nil;\n\n        \n        self.buffer = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Opal'), 'Source'), 'Buffer').$new(self.$file(), 1);\n        \n        $writer = [self.source];\n        $send(self.buffer, 'source=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        self.parser = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'Parser').$default_parser();\n        \n        try {\n          $b = self.parser.$tokenize(self.buffer), $a = Opal.to_ary($b), (sexp = ($a[0] == null ? nil : $a[0])), (comments = ($a[1] == null ? nil : $a[1])), (tokens = ($a[2] == null ? nil : $a[2])), $b\n        } catch ($err) {\n          if (Opal.rescue($err, [Opal.const_get_qualified(Opal.const_get_qualified('::', 'Parser'), 'SyntaxError')])) {error = $err;\n            try {\n              self.$raise(Opal.const_get_qualified('::', 'SyntaxError'), error.$message(), error.$backtrace())\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        };;\n        self.sexp = self.$s(\"top\", ($truthy($a = sexp) ? $a : self.$s(\"nil\")));\n        self.comments = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Parser'), 'Source'), 'Comment').$associate_locations(sexp, comments);\n        return (self.eof_content = Opal.const_get_relative($nesting, 'EofContent').$new(tokens, self.source).$eof());\n      }, TMP_Compiler_parse_7.$$arity = 0);\n      \n      Opal.defn(self, '$source_map', TMP_Compiler_source_map_8 = function $$source_map(source_file) {\n        var $a, self = this;\n\n        if (source_file == null) {\n          source_file = nil;\n        }\n        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'SourceMap').$new(self.fragments, ($truthy($a = source_file) ? $a : self.$file()))\n      }, TMP_Compiler_source_map_8.$$arity = -1);\n      \n      Opal.defn(self, '$helpers', TMP_Compiler_helpers_9 = function $$helpers() {\n        var $a, self = this;\n\n        return (self.helpers = ($truthy($a = self.helpers) ? $a : Opal.const_get_relative($nesting, 'Set').$new([\"breaker\", \"slice\"])))\n      }, TMP_Compiler_helpers_9.$$arity = 0);\n      \n      Opal.defn(self, '$operator_helpers', TMP_Compiler_operator_helpers_10 = function $$operator_helpers() {\n        var $a, self = this;\n\n        return (self.operator_helpers = ($truthy($a = self.operator_helpers) ? $a : Opal.const_get_relative($nesting, 'Set').$new()))\n      }, TMP_Compiler_operator_helpers_10.$$arity = 0);\n      \n      Opal.defn(self, '$method_calls', TMP_Compiler_method_calls_11 = function $$method_calls() {\n        var $a, self = this;\n\n        return (self.method_calls = ($truthy($a = self.method_calls) ? $a : Opal.const_get_relative($nesting, 'Set').$new()))\n      }, TMP_Compiler_method_calls_11.$$arity = 0);\n      \n      Opal.defn(self, '$error', TMP_Compiler_error_12 = function $$error(msg, line) {\n        var self = this;\n\n        if (line == null) {\n          line = nil;\n        }\n        return self.$raise(Opal.const_get_relative($nesting, 'SyntaxError'), \"\" + (msg) + \" :\" + (self.$file()) + \":\" + (line))\n      }, TMP_Compiler_error_12.$$arity = -2);\n      \n      Opal.defn(self, '$warning', TMP_Compiler_warning_13 = function $$warning(msg, line) {\n        var self = this;\n\n        if (line == null) {\n          line = nil;\n        }\n        return self.$warn(\"\" + \"WARNING: \" + (msg) + \" -- \" + (self.$file()) + \":\" + (line))\n      }, TMP_Compiler_warning_13.$$arity = -2);\n      \n      Opal.defn(self, '$parser_indent', TMP_Compiler_parser_indent_14 = function $$parser_indent() {\n        var self = this;\n\n        return self.indent\n      }, TMP_Compiler_parser_indent_14.$$arity = 0);\n      \n      Opal.defn(self, '$s', TMP_Compiler_s_15 = function $$s(type, $a_rest) {\n        var self = this, children;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        children = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          children[$arg_idx - 1] = arguments[$arg_idx];\n        }\n        return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Opal'), 'AST'), 'Node').$new(type, children)\n      }, TMP_Compiler_s_15.$$arity = -2);\n      \n      Opal.defn(self, '$fragment', TMP_Compiler_fragment_16 = function $$fragment(str, scope, sexp) {\n        var self = this;\n\n        if (sexp == null) {\n          sexp = nil;\n        }\n        return Opal.const_get_relative($nesting, 'Fragment').$new(str, scope, sexp)\n      }, TMP_Compiler_fragment_16.$$arity = -3);\n      \n      Opal.defn(self, '$unique_temp', TMP_Compiler_unique_temp_17 = function $$unique_temp(name) {\n        var $a, self = this, unique = nil;\n\n        \n        name = name.$to_s();\n        if ($truthy(($truthy($a = name) ? name['$empty?']()['$!']() : $a))) {\n          name = ((\"\" + \"_\") + (name)).$gsub(\"?\", \"$q\").$gsub(\"!\", \"$B\").$gsub(\"=\", \"$eq\").$gsub(\"<\", \"$lt\").$gsub(\">\", \"$gt\").$gsub(/[^\\w\\$]/, \"$\")};\n        unique = (self.unique = $rb_plus(self.unique, 1));\n        return \"\" + \"TMP\" + (name) + \"_\" + (unique);\n      }, TMP_Compiler_unique_temp_17.$$arity = 1);\n      \n      Opal.defn(self, '$helper', TMP_Compiler_helper_18 = function $$helper(name) {\n        var self = this;\n\n        return self.$helpers()['$<<'](name)\n      }, TMP_Compiler_helper_18.$$arity = 1);\n      \n      Opal.defn(self, '$indent', TMP_Compiler_indent_19 = function $$indent() {\n        var self = this, $iter = TMP_Compiler_indent_19.$$p, block = $iter || nil, indent = nil, res = nil;\n\n        if ($iter) TMP_Compiler_indent_19.$$p = null;\n        \n        indent = self.indent;\n        self.indent = $rb_plus(self.indent, Opal.const_get_relative($nesting, 'INDENT'));\n        self.space = \"\" + \"\\n\" + (self.indent);\n        res = Opal.yieldX(block, []);\n        self.indent = indent;\n        self.space = \"\" + \"\\n\" + (self.indent);\n        return res;\n      }, TMP_Compiler_indent_19.$$arity = 0);\n      \n      Opal.defn(self, '$with_temp', TMP_Compiler_with_temp_20 = function $$with_temp() {\n        var self = this, $iter = TMP_Compiler_with_temp_20.$$p, block = $iter || nil, tmp = nil, res = nil;\n\n        if ($iter) TMP_Compiler_with_temp_20.$$p = null;\n        \n        tmp = self.scope.$new_temp();\n        res = Opal.yield1(block, tmp);\n        self.scope.$queue_temp(tmp);\n        return res;\n      }, TMP_Compiler_with_temp_20.$$arity = 0);\n      \n      Opal.defn(self, '$in_while', TMP_Compiler_in_while_21 = function $$in_while() {\n        var TMP_22, self = this, $iter = TMP_Compiler_in_while_21.$$p, $yield = $iter || nil, result = nil;\n\n        if ($iter) TMP_Compiler_in_while_21.$$p = null;\n        \n        if (($yield !== nil)) {\n          } else {\n          return nil\n        };\n        self.while_loop = self.scope.$push_while();\n        result = $send(self, 'indent', [], (TMP_22 = function(){var self = TMP_22.$$s || this;\n\n        return Opal.yieldX($yield, []);}, TMP_22.$$s = self, TMP_22.$$arity = 0, TMP_22));\n        self.scope.$pop_while();\n        return result;\n      }, TMP_Compiler_in_while_21.$$arity = 0);\n      \n      Opal.defn(self, '$in_ensure', TMP_Compiler_in_ensure_23 = function $$in_ensure() {\n        var self = this, $iter = TMP_Compiler_in_ensure_23.$$p, $yield = $iter || nil, result = nil;\n\n        if ($iter) TMP_Compiler_in_ensure_23.$$p = null;\n        \n        if (($yield !== nil)) {\n          } else {\n          return nil\n        };\n        self.in_ensure = true;\n        result = Opal.yieldX($yield, []);\n        self.in_ensure = false;\n        return result;\n      }, TMP_Compiler_in_ensure_23.$$arity = 0);\n      \n      Opal.defn(self, '$in_ensure?', TMP_Compiler_in_ensure$q_24 = function() {\n        var self = this;\n\n        return self.in_ensure['$!']()['$!']()\n      }, TMP_Compiler_in_ensure$q_24.$$arity = 0);\n      \n      Opal.defn(self, '$in_case', TMP_Compiler_in_case_25 = function $$in_case() {\n        var self = this, $iter = TMP_Compiler_in_case_25.$$p, $yield = $iter || nil, old = nil;\n\n        if ($iter) TMP_Compiler_in_case_25.$$p = null;\n        \n        if (($yield !== nil)) {\n          } else {\n          return nil\n        };\n        old = self.case_stmt;\n        self.case_stmt = $hash2([], {});\n        Opal.yieldX($yield, []);\n        return (self.case_stmt = old);\n      }, TMP_Compiler_in_case_25.$$arity = 0);\n      \n      Opal.defn(self, '$in_while?', TMP_Compiler_in_while$q_26 = function() {\n        var self = this;\n\n        return self.scope['$in_while?']()\n      }, TMP_Compiler_in_while$q_26.$$arity = 0);\n      \n      Opal.defn(self, '$process', TMP_Compiler_process_27 = function $$process(sexp, level) {\n        var self = this, handler = nil;\n\n        if (level == null) {\n          level = \"expr\";\n        }\n        \n        if (sexp['$=='](nil)) {\n          return self.$fragment(\"\", self.$scope())};\n        if ($truthy((handler = self.$handlers()['$[]'](sexp.$type())))) {\n          return handler.$new(sexp, level, self).$compile_to_fragments()\n          } else {\n          return self.$error(\"\" + \"Unsupported sexp: \" + (sexp.$type()))\n        };\n      }, TMP_Compiler_process_27.$$arity = -2);\n      \n      Opal.defn(self, '$handlers', TMP_Compiler_handlers_28 = function $$handlers() {\n        var $a, self = this;\n\n        return (self.handlers = ($truthy($a = self.handlers) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'Nodes'), 'Base').$handlers()))\n      }, TMP_Compiler_handlers_28.$$arity = 0);\n      \n      Opal.defn(self, '$requires', TMP_Compiler_requires_29 = function $$requires() {\n        var $a, self = this;\n\n        return (self.requires = ($truthy($a = self.requires) ? $a : []))\n      }, TMP_Compiler_requires_29.$$arity = 0);\n      \n      Opal.defn(self, '$required_trees', TMP_Compiler_required_trees_30 = function $$required_trees() {\n        var $a, self = this;\n\n        return (self.required_trees = ($truthy($a = self.required_trees) ? $a : []))\n      }, TMP_Compiler_required_trees_30.$$arity = 0);\n      \n      Opal.defn(self, '$returns', TMP_Compiler_returns_35 = function $$returns(sexp) {\n        var $a, $b, TMP_31, TMP_32, TMP_33, TMP_34, self = this, $case = nil, when_sexp = nil, then_sexp = nil, body_sexp = nil, resbodies = nil, else_sexp = nil, klass = nil, lvar = nil, body = nil, rescue_sexp = nil, ensure_body = nil, rest = nil, last = nil, strs = nil, multiline = nil, first_child = nil, rest_children = nil, old_value = nil, cond = nil, true_body = nil, false_body = nil;\n\n        \n        if ($truthy(sexp)) {\n          } else {\n          return self.$returns(self.$s(\"nil\"))\n        };\n        return (function() {$case = sexp.$type();\n        if (\"undef\"['$===']($case)) {return self.$returns(self.$s(\"begin\", sexp, self.$s(\"nil\")))}\n        else if (\"break\"['$===']($case) || \"next\"['$===']($case) || \"redo\"['$===']($case)) {return sexp}\n        else if (\"yield\"['$===']($case)) {return sexp.$updated(\"returnable_yield\", nil)}\n        else if (\"when\"['$===']($case)) {\n        $a = [].concat(Opal.to_a(sexp)), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (when_sexp = $slice.call($a, 0, $b)), (then_sexp = ($a[$b] == null ? nil : $a[$b])), $a;\n        return sexp.$updated(nil, [].concat(Opal.to_a(when_sexp)).concat([self.$returns(then_sexp)]));}\n        else if (\"rescue\"['$===']($case)) {\n        $a = [].concat(Opal.to_a(sexp)), (body_sexp = ($a[0] == null ? nil : $a[0])), $b = $a.length - 1, $b = ($b < 1) ? 1 : $b, (resbodies = $slice.call($a, 1, $b)), (else_sexp = ($a[$b] == null ? nil : $a[$b])), $a;\n        resbodies = $send(resbodies, 'map', [], (TMP_31 = function(resbody){var self = TMP_31.$$s || this;\nif (resbody == null) resbody = nil;\n        return self.$returns(resbody)}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31));\n        if ($truthy(else_sexp)) {\n          else_sexp = self.$returns(else_sexp)};\n        return sexp.$updated(nil, [self.$returns(body_sexp)].concat(Opal.to_a(resbodies)).concat([else_sexp]));}\n        else if (\"resbody\"['$===']($case)) {\n        $a = [].concat(Opal.to_a(sexp)), (klass = ($a[0] == null ? nil : $a[0])), (lvar = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), $a;\n        return sexp.$updated(nil, [klass, lvar, self.$returns(body)]);}\n        else if (\"ensure\"['$===']($case)) {\n        $a = [].concat(Opal.to_a(sexp)), (rescue_sexp = ($a[0] == null ? nil : $a[0])), (ensure_body = ($a[1] == null ? nil : $a[1])), $a;\n        sexp = sexp.$updated(nil, [self.$returns(rescue_sexp), ensure_body]);\n        return self.$s(\"js_return\", sexp);}\n        else if (\"begin\"['$===']($case) || \"kwbegin\"['$===']($case)) {\n        $a = [].concat(Opal.to_a(sexp)), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (rest = $slice.call($a, 0, $b)), (last = ($a[$b] == null ? nil : $a[$b])), $a;\n        return sexp.$updated(nil, [].concat(Opal.to_a(rest)).concat([self.$returns(last)]));}\n        else if (\"while\"['$===']($case) || \"until\"['$===']($case) || \"while_post\"['$===']($case) || \"until_post\"['$===']($case)) {return sexp}\n        else if (\"return\"['$===']($case) || \"js_return\"['$===']($case) || \"returnable_yield\"['$===']($case)) {return sexp}\n        else if (\"xstr\"['$===']($case)) {if ($truthy(sexp.$children()['$any?']())) {\n          \n          strs = $send($send(sexp.$children(), 'select', [], (TMP_32 = function(child){var self = TMP_32.$$s || this;\nif (child == null) child = nil;\n          return child.$type()['$=='](\"str\")}, TMP_32.$$s = self, TMP_32.$$arity = 1, TMP_32)), 'map', [], (TMP_33 = function(child){var self = TMP_33.$$s || this;\nif (child == null) child = nil;\n          return child.$children()['$[]'](0)}, TMP_33.$$s = self, TMP_33.$$arity = 1, TMP_33));\n          multiline = $send(strs, 'any?', [], (TMP_34 = function(str){var self = TMP_34.$$s || this;\nif (str == null) str = nil;\n          return str['$end_with?'](\";\\n\")}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34));\n          $a = [].concat(Opal.to_a(sexp)), (first_child = ($a[0] == null ? nil : $a[0])), (rest_children = $slice.call($a, 1)), $a;\n          if ($truthy(multiline)) {\n            return sexp\n          } else if (first_child.$type()['$=='](\"str\")) {\n            \n            old_value = first_child.$children()['$[]'](0);\n            if ($truthy(old_value['$include?'](\"return\"))) {\n              return sexp\n              } else {\n              \n              first_child = self.$s(\"js_return\", first_child);\n              return sexp.$updated(nil, [first_child].concat(Opal.to_a(rest_children)));\n            };\n            } else {\n            return self.$s(\"js_return\", sexp)\n          };\n          } else {\n          return self.$returns(self.$s(\"str\", \"\"))\n        }}\n        else if (\"if\"['$===']($case)) {\n        $a = [].concat(Opal.to_a(sexp)), (cond = ($a[0] == null ? nil : $a[0])), (true_body = ($a[1] == null ? nil : $a[1])), (false_body = ($a[2] == null ? nil : $a[2])), $a;\n        return sexp.$updated(nil, [cond, self.$returns(true_body), self.$returns(false_body)]);}\n        else {return self.$s(\"js_return\", sexp).$updated(nil, nil, $hash2([\"location\"], {\"location\": sexp.$loc()}))}})();\n      }, TMP_Compiler_returns_35.$$arity = 1);\n      return (Opal.defn(self, '$handle_block_given_call', TMP_Compiler_handle_block_given_call_36 = function $$handle_block_given_call(sexp) {\n        var $a, self = this, scope = nil;\n\n        \n        self.scope['$uses_block!']();\n        if ($truthy(self.scope.$block_name())) {\n          return self.$fragment(\"\" + \"(\" + (self.scope.$block_name()) + \" !== nil)\", self.$scope(), sexp)\n        } else if ($truthy(($truthy($a = (scope = self.scope.$find_parent_def())) ? scope.$block_name() : $a))) {\n          return self.$fragment(\"\" + \"(\" + (scope.$block_name()) + \" !== nil)\", scope, sexp)\n          } else {\n          return self.$fragment(\"false\", scope, sexp)\n        };\n      }, TMP_Compiler_handle_block_given_call_36.$$arity = 1), nil) && 'handle_block_given_call';\n    })($nesting[0], null, $nesting);\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal/erb\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$require', '$compile', '$new', '$fix_quotes', '$find_contents', '$find_code', '$wrap_compiled', '$require_erb', '$prepared_source', '$gsub', '$+', '$=~', '$sub']);\n  \n  self.$require(\"opal/compiler\");\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $ERB, self = $ERB = $module($base, 'ERB');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ERB_compile_1;\n\n      \n      Opal.defs(self, '$compile', TMP_ERB_compile_1 = function $$compile(source, file_name) {\n        var self = this;\n\n        if (file_name == null) {\n          file_name = \"(erb)\";\n        }\n        return Opal.const_get_relative($nesting, 'Compiler').$new(source, file_name).$compile()\n      }, TMP_ERB_compile_1.$$arity = -2);\n      (function($base, $super, $parent_nesting) {\n        function $Compiler(){};\n        var self = $Compiler = $klass($base, $super, 'Compiler', $Compiler);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Compiler_initialize_2, TMP_Compiler_prepared_source_3, TMP_Compiler_compile_4, TMP_Compiler_fix_quotes_5, TMP_Compiler_require_erb_6, TMP_Compiler_find_contents_8, TMP_Compiler_find_code_10, TMP_Compiler_wrap_compiled_11;\n\n        def.prepared_source = def.source = def.file_name = nil;\n        \n        Opal.const_set($nesting[0], 'BLOCK_EXPR', /\\s+(do|\\{)(\\s*\\|[^|]*\\|)?\\s*\\Z/);\n        \n        Opal.defn(self, '$initialize', TMP_Compiler_initialize_2 = function $$initialize(source, file_name) {\n          var $a, self = this;\n\n          if (file_name == null) {\n            file_name = \"(erb)\";\n          }\n          return $a = [source, file_name, source], (self.source = $a[0]), (self.file_name = $a[1]), (self.result = $a[2]), $a\n        }, TMP_Compiler_initialize_2.$$arity = -2);\n        \n        Opal.defn(self, '$prepared_source', TMP_Compiler_prepared_source_3 = function $$prepared_source() {\n          var $a, self = this, source = nil;\n\n          return (self.prepared_source = ($truthy($a = self.prepared_source) ? $a : ((source = self.source), (source = self.$fix_quotes(source)), (source = self.$find_contents(source)), (source = self.$find_code(source)), (source = self.$wrap_compiled(source)), (source = self.$require_erb(source)), source)))\n        }, TMP_Compiler_prepared_source_3.$$arity = 0);\n        \n        Opal.defn(self, '$compile', TMP_Compiler_compile_4 = function $$compile() {\n          var self = this;\n\n          return Opal.const_get_relative($nesting, 'Opal').$compile(self.$prepared_source())\n        }, TMP_Compiler_compile_4.$$arity = 0);\n        \n        Opal.defn(self, '$fix_quotes', TMP_Compiler_fix_quotes_5 = function $$fix_quotes(result) {\n          var self = this;\n\n          return result.$gsub(\"\\\"\", \"\\\\\\\"\")\n        }, TMP_Compiler_fix_quotes_5.$$arity = 1);\n        \n        Opal.defn(self, '$require_erb', TMP_Compiler_require_erb_6 = function $$require_erb(result) {\n          var self = this;\n\n          return $rb_plus(\"require \\\"erb\\\";\", result)\n        }, TMP_Compiler_require_erb_6.$$arity = 1);\n        \n        Opal.defn(self, '$find_contents', TMP_Compiler_find_contents_8 = function $$find_contents(result) {\n          var TMP_7, self = this;\n\n          return $send(result, 'gsub', [/<%=([\\s\\S]+?)%>/], (TMP_7 = function(){var self = TMP_7.$$s || this, $a, inner = nil;\n\n          \n            inner = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$gsub(/\\\\'/, \"'\").$gsub(/\\\\\"/, \"\\\"\");\n            if ($truthy(inner['$=~'](Opal.const_get_relative($nesting, 'BLOCK_EXPR')))) {\n              return \"\" + \"\\\")\\noutput_buffer.append= \" + (inner) + \"\\noutput_buffer.append(\\\"\"\n              } else {\n              return \"\" + \"\\\")\\noutput_buffer.append=(\" + (inner) + \")\\noutput_buffer.append(\\\"\"\n            };}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7))\n        }, TMP_Compiler_find_contents_8.$$arity = 1);\n        \n        Opal.defn(self, '$find_code', TMP_Compiler_find_code_10 = function $$find_code(result) {\n          var TMP_9, self = this;\n\n          return $send(result, 'gsub', [/<%([\\s\\S]+?)%>/], (TMP_9 = function(){var self = TMP_9.$$s || this, $a, inner = nil;\n\n          \n            inner = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$gsub(/\\\\\"/, \"\\\"\");\n            return \"\" + \"\\\")\\n\" + (inner) + \"\\noutput_buffer.append(\\\"\";}, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9))\n        }, TMP_Compiler_find_code_10.$$arity = 1);\n        return (Opal.defn(self, '$wrap_compiled', TMP_Compiler_wrap_compiled_11 = function $$wrap_compiled(result) {\n          var self = this, path = nil;\n\n          \n          path = self.file_name.$sub(new RegExp(\"\" + \"\\\\.opalerb\" + (Opal.const_get_relative($nesting, 'REGEXP_END'))), \"\");\n          return (result = \"\" + \"Template.new('\" + (path) + \"') do |output_buffer|\\noutput_buffer.append(\\\"\" + (result) + \"\\\")\\noutput_buffer.join\\nend\\n\");\n        }, TMP_Compiler_wrap_compiled_11.$$arity = 1), nil) && 'wrap_compiled';\n      })($nesting[0], null, $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"opal-parser\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$coerce_to!', '$merge', '$compile', '$eval']);\n  \n  self.$require(\"opal/compiler\");\n  self.$require(\"opal/erb\");\n  self.$require(\"opal/version\");\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_eval_1, TMP_Kernel_require_remote_2;\n\n    \n    \n    Opal.defn(self, '$eval', TMP_Kernel_eval_1 = function(str) {\n      var self = this, default_eval_options = nil, compiling_options = nil, code = nil;\n\n      \n      str = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](str, Opal.const_get_relative($nesting, 'String'), \"to_str\");\n      default_eval_options = $hash2([\"file\", \"eval\"], {\"file\": \"(eval)\", \"eval\": true});\n      compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);\n      code = Opal.const_get_relative($nesting, 'Opal').$compile(str, compiling_options);\n      \n      return (function(self) {\n        return eval(code);\n      })(self)\n    ;\n    }, TMP_Kernel_eval_1.$$arity = 1);\n    \n    Opal.defn(self, '$require_remote', TMP_Kernel_require_remote_2 = function $$require_remote(url) {\n      var self = this;\n\n      \n      \n      var r = new XMLHttpRequest();\n      r.open(\"GET\", url, false);\n      r.send('');\n    ;\n      return self.$eval(r.responseText);\n    }, TMP_Kernel_require_remote_2.$$arity = 1);\n  })($nesting[0], $nesting);\n  \n  Opal.compile = function(str, options) {\n    if (options) {\n      options = Opal.hash(options);\n    }\n    return Opal.Opal.$compile(str, options);\n  };\n\n  Opal['eval'] = function(str, options) {\n   return eval(Opal.compile(str, options));\n  };\n\n  function run_ruby_scripts() {\n    var tag, tags = document.getElementsByTagName('script');\n\n    for (var i = 0, len = tags.length; i < len; i++) {\n      tag = tags[i];\n      if (tag.type === \"text/ruby\") {\n        if (tag.src)       Opal.Kernel.$require_remote(tag.src);\n        if (tag.innerHTML) Opal.Kernel.$eval(tag.innerHTML);\n      }\n    }\n  }\n\n  if (typeof(document) !== 'undefined') {\n    if (window.addEventListener) {\n      window.addEventListener('DOMContentLoaded', run_ruby_scripts, false);\n    }\n    else {\n      window.attachEvent('onload', run_ruby_scripts);\n    }\n  }\n;\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/effects\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$DOM', '$[]=', '$style', '$-', '$==', '$[]', '$style!', '$show', '$hide']);\n  return (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $DOM, self = $DOM = $module($base, 'DOM');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $Document(){};\n        var self = $Document = $klass($base, $super, 'Document', $Document);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Document_active_element_1;\n\n        def[\"native\"] = nil;\n        return (Opal.defn(self, '$active_element', TMP_Document_active_element_1 = function $$active_element() {\n          var self = this;\n\n          return self.$DOM(self[\"native\"].activeElement)\n        }, TMP_Document_active_element_1.$$arity = 0), nil) && 'active_element'\n      })($nesting[0], Opal.const_get_relative($nesting, 'Element'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $Element(){};\n        var self = $Element = $klass($base, $super, 'Element', $Element);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Element_show_2, TMP_Element_hide_3, TMP_Element_toggle_4, TMP_Element_focus_5, TMP_Element_blur_6, TMP_Element_focused$q_7;\n\n        def[\"native\"] = nil;\n        \n        \n        Opal.defn(self, '$show', TMP_Element_show_2 = function $$show(what) {\n          var self = this, $writer = nil;\n\n          if (what == null) {\n            what = \"block\";\n          }\n          \n          $writer = [\"display\", what];\n          $send(self.$style(), '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        }, TMP_Element_show_2.$$arity = -1);\n        \n        Opal.defn(self, '$hide', TMP_Element_hide_3 = function $$hide() {\n          var self = this, $writer = nil;\n\n          \n          $writer = [\"display\", \"none\"];\n          $send(self.$style(), '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        }, TMP_Element_hide_3.$$arity = 0);\n        \n        Opal.defn(self, '$toggle', TMP_Element_toggle_4 = function $$toggle() {\n          var self = this;\n\n          if (self['$style!']()['$[]'](\"display\")['$=='](\"none\")) {\n            return self.$show()\n            } else {\n            return self.$hide()\n          }\n        }, TMP_Element_toggle_4.$$arity = 0);\n        \n        Opal.defn(self, '$focus', TMP_Element_focus_5 = function $$focus() {\n          var self = this;\n\n          return self[\"native\"].focus()\n        }, TMP_Element_focus_5.$$arity = 0);\n        \n        Opal.defn(self, '$blur', TMP_Element_blur_6 = function $$blur() {\n          var self = this;\n\n          return self[\"native\"].blur()\n        }, TMP_Element_blur_6.$$arity = 0);\n        return (Opal.defn(self, '$focused?', TMP_Element_focused$q_7 = function() {\n          var self = this;\n\n          return self[\"native\"].hasFocus\n        }, TMP_Element_focused$q_7.$$arity = 0), nil) && 'focused?';\n      })($nesting[0], null, $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"repl\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars, $range = Opal.range, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$start', '$open', '$add_to_page', '$new', '$!', '$close', '$detach_input_event_handler', '$started?', '$raise', '$[]=', '$attributes', '$[]', '$-', '$to!', '$scroll', '$focus', '$==', '$open?', '$remove', '$remove_from_page', '$create_element', '$id=', '$inner_html=', '$append_to', '$on', '$body', '$capture_console', '$disable_multiline', '$set_context', '$Native', '$attach_input_event_handler', '$ctrl?', '$key', '$===', '$enable_multiline', '$prev_history', '$next_history', '$input_command', '$prevent', '$empty?', '$contenteditable_text', '$max', '$set_input_from_history', '$min', '$count', '$+', '$<', '$set_input', '$inner_text=', '$index', '$last', '$<<', '$off', '$update_prompt', '$to_ary', '$css', '$inner_text', '$join', '$map', '$content', '$format_indent', '$prompt_text', '$content=', '$nil?', '$add_history', '$clear_input', '$eval_repl', '$eval_ruby', '$repl_eval', '$inspect', '$class', '$message', '$first', '$split', '$include?', '$send', '$strip', '$length', '$puts', '$stop', '$each_with_index', '$=~', '$to_i', '$between?', '$is_a?', '$lines', '$*', '$chomp', '$context_name', '$text=', '$capture_console_log', '$capture_console_warn', '$capture_console_error', '$merge', '$compile', '$proc']);\n  \n  self.$require(\"opal-parser\");\n  self.$require(\"browser/effects\");\n  (function($base, $super, $parent_nesting) {\n    function $REPL(){};\n    var self = $REPL = $klass($base, $super, 'REPL', $REPL);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_REPL_run_1, TMP_REPL_start_2, TMP_REPL_started$q_3, TMP_REPL_stop_4, TMP_REPL_stopped$q_5, TMP_REPL_open_6, TMP_REPL_open$q_7, TMP_REPL_close_8, TMP_REPL_closed$q_9, TMP_REPL_rescue_10, TMP_REPL_rescue$q_11, TMP_REPL_remove_from_page_12, TMP_REPL_add_to_page_14, TMP_REPL_initialize_15, TMP_REPL_attach_input_event_handler_18, TMP_REPL_prev_history_19, TMP_REPL_next_history_20, TMP_REPL_set_input_from_history_21, TMP_REPL_set_input_22, TMP_REPL_send_key_to_input_23, TMP_REPL_add_history_24, TMP_REPL_detach_input_event_handler_25, TMP_REPL_enable_multiline_26, TMP_REPL_disable_multiline_27, TMP_REPL_contenteditable_text_29, TMP_REPL_clear_input_30, TMP_REPL_input_command_31, TMP_REPL_eval_ruby_32, TMP_REPL_eval_repl_33, TMP_REPL_cmd_help_34, TMP_REPL_cmd_exit_35, TMP_REPL_cmd_close_36, TMP_REPL_cmd_history_38, TMP_REPL_cmd_context_39, TMP_REPL_format_indent_41, TMP_REPL_prompt_text_42, TMP_REPL_context_name_43, TMP_REPL_set_context_44, TMP_REPL_update_prompt_45, TMP_REPL_capture_console_46, TMP_REPL_capture_console_log_47, TMP_REPL_capture_console_warn_48, TMP_REPL_capture_console_error_49;\n\n    def.input = def.history = def.saved_input = def.history_index = def.output = def.context = def.context_name = def.multiline = def.prompt = nil;\n    \n    Opal.defs(self, '$run', TMP_REPL_run_1 = function $$run($a_rest) {\n      var self = this, args;\n      if (self.singleton == null) self.singleton = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      $send(Opal.const_get_relative($nesting, 'REPL'), 'start', Opal.to_a(args));\n      Opal.const_get_relative($nesting, 'REPL').$open();\n      return self.singleton;\n    }, TMP_REPL_run_1.$$arity = -1);\n    Opal.defs(self, '$start', TMP_REPL_start_2 = function $$start(context, keep_local_vars, input_id, output_id, prompt_id, console_id) {\n      var $a, self = this;\n      if (self.singleton == null) self.singleton = nil;\n\n      if (context == null) {\n        context = \"main\";\n      }\n      if (keep_local_vars == null) {\n        keep_local_vars = true;\n      }\n      if (input_id == null) {\n        input_id = \"repl-input\";\n      }\n      if (output_id == null) {\n        output_id = \"repl-output\";\n      }\n      if (prompt_id == null) {\n        prompt_id = \"repl-prompt\";\n      }\n      if (console_id == null) {\n        console_id = \"repl-console\";\n      }\n      \n      Opal.const_get_relative($nesting, 'REPL').$add_to_page();\n      self.input_id = input_id;\n      self.console_id = console_id;\n      return (self.singleton = ($truthy($a = self.singleton) ? $a : self.$new(context, keep_local_vars, input_id, output_id, prompt_id)));\n    }, TMP_REPL_start_2.$$arity = -1);\n    Opal.defs(self, '$started?', TMP_REPL_started$q_3 = function() {\n      var self = this;\n      if (self.singleton == null) self.singleton = nil;\n\n      return self.singleton['$!']()['$!']()\n    }, TMP_REPL_started$q_3.$$arity = 0);\n    Opal.defs(self, '$stop', TMP_REPL_stop_4 = function $$stop() {\n      var self = this;\n      if (self.singleton == null) self.singleton = nil;\n\n      \n      Opal.const_get_relative($nesting, 'REPL').$close();\n      self.singleton.$detach_input_event_handler();\n      return (self.singleton = nil);\n    }, TMP_REPL_stop_4.$$arity = 0);\n    Opal.defs(self, '$stopped?', TMP_REPL_stopped$q_5 = function() {\n      var self = this;\n\n      return self['$started?']()['$!']()\n    }, TMP_REPL_stopped$q_5.$$arity = 0);\n    Opal.defs(self, '$open', TMP_REPL_open_6 = function $$open() {\n      var self = this, $writer = nil;\n      if (self.console_id == null) self.console_id = nil;\n      if (self.input_id == null) self.input_id = nil;\n      if ($gvars.document == null) $gvars.document = nil;\n\n      \n      if ($truthy(self['$started?']())) {\n        } else {\n        self.$raise(\"REPL not started\")\n      };\n      \n      $writer = [\"class\", \"repl-open\"];\n      $send($gvars.document['$[]'](self.console_id).$attributes(), '[]=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      $gvars.document['$[]'](self.input_id).$scroll()['$to!']();\n      return $gvars.document['$[]'](self.input_id).$focus();\n    }, TMP_REPL_open_6.$$arity = 0);\n    Opal.defs(self, '$open?', TMP_REPL_open$q_7 = function() {\n      var self = this;\n      if (self.console_id == null) self.console_id = nil;\n      if ($gvars.document == null) $gvars.document = nil;\n\n      \n      if ($truthy(self['$started?']())) {\n        } else {\n        return false\n      };\n      return $gvars.document['$[]'](self.console_id).$attributes()['$[]'](\"class\")['$=='](\"repl-open\");\n    }, TMP_REPL_open$q_7.$$arity = 0);\n    Opal.defs(self, '$close', TMP_REPL_close_8 = function $$close() {\n      var self = this, $writer = nil;\n      if (self.console_id == null) self.console_id = nil;\n      if ($gvars.document == null) $gvars.document = nil;\n\n      \n      $writer = [\"class\", \"repl-close\"];\n      $send($gvars.document['$[]'](self.console_id).$attributes(), '[]=', Opal.to_a($writer));\n      return $writer[$rb_minus($writer[\"length\"], 1)];\n    }, TMP_REPL_close_8.$$arity = 0);\n    Opal.defs(self, '$closed?', TMP_REPL_closed$q_9 = function() {\n      var self = this;\n\n      return self['$open?']()['$!']()\n    }, TMP_REPL_closed$q_9.$$arity = 0);\n    Opal.defs(self, '$rescue', TMP_REPL_rescue_10 = function $$rescue(context) {\n      var self = this, $iter = TMP_REPL_rescue_10.$$p, block = $iter || nil;\n\n      if (context == null) {\n        context = \"main\";\n      }\n      if ($iter) TMP_REPL_rescue_10.$$p = null;\n      \n      try {\n        return Opal.yieldX(block, []);\n      } catch ($err) {\n        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {\n          try {\n            \n            self.rescue = true;\n            Opal.const_get_relative($nesting, 'REPL').$start(context);\n            return Opal.const_get_relative($nesting, 'REPL').$open();\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      };\n    }, TMP_REPL_rescue_10.$$arity = -1);\n    Opal.defs(self, '$rescue?', TMP_REPL_rescue$q_11 = function() {\n      var self = this;\n      if (self.rescue == null) self.rescue = nil;\n\n      return self.rescue['$!']()['$!']()\n    }, TMP_REPL_rescue$q_11.$$arity = 0);\n    Opal.defs(self, '$remove_from_page', TMP_REPL_remove_from_page_12 = function $$remove_from_page() {\n      var self = this, e = nil;\n      if ($gvars.document == null) $gvars.document = nil;\n\n      if ($truthy((e = $gvars.document['$[]'](\"repl-container\")))) {\n        return e.$remove()\n        } else {\n        return nil\n      }\n    }, TMP_REPL_remove_from_page_12.$$arity = 0);\n    Opal.defs(self, '$add_to_page', TMP_REPL_add_to_page_14 = function $$add_to_page(container) {\n      var TMP_13, self = this, e = nil, $writer = nil;\n      if ($gvars.document == null) $gvars.document = nil;\n\n      if (container == null) {\n        container = $gvars.document.$body();\n      }\n      \n      Opal.const_get_relative($nesting, 'REPL').$remove_from_page();\n      e = $gvars.document.$create_element(\"div\");\n      \n      $writer = [\"repl-container\"];\n      $send(e, 'id=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      \n      $writer = [\"\" + \"\\n\" + \"<style type=\\\"text/css\\\" media=\\\"all\\\">\\n\" + \"  #repl-container {\\n\" + \"    width: 100%;\\n\" + \"    position: fixed;\\n\" + \"    bottom: 0;\\n\" + \"    z-index: 999;\\n\" + \"  }\\n\" + \"  #repl-button {\\n\" + \"    margin: 0.5rem; \\n\" + \"  }\\n\" + \"  #repl-console {\\n\" + \"    width: 100%;\\n\" + \"    grid-template-columns: auto 1fr;\\n\" + \"  }\\n\" + \"  #repl-output {\\n\" + \"    grid-row: 1;\\n\" + \"    grid-column: 1 / span 2;\\n\" + \"    background-color: #555;\\n\" + \"    color:            #ccc;\\n\" + \"    white-space: pre-wrap;\\n\" + \"    word-break: break-all;\\n\" + \"  }\\n\" + \"  #repl-prompt {\\n\" + \"    grid-row: 2;\\n\" + \"    grid-column: 1;\\n\" + \"    background-color: #666;\\n\" + \"    color:            #eee;\\n\" + \"    white-space: pre;\\n\" + \"  }\\n\" + \"  #repl-input {\\n\" + \"    grid-row: 2;\\n\" + \"    grid-column: 2;\\n\" + \"    background-color: #666;\\n\" + \"    color:            #eee;\\n\" + \"    caret-color:      #fff;\\n\" + \"    border-style: none;\\n\" + \"    padding: 0;\\n\" + \"    white-space: pre-wrap;\\n\" + \"  }\\n\" + \"  .repl-open {\\n\" + \"    display: grid;\\n\" + \"  }\\n\" + \"  .repl-close {\\n\" + \"    display: none;\\n\" + \"  }\\n\" + \"  .repl-part {\\n\" + \"    font-family:      monospace;\\n\" + \"    font-style:       normal;\\n\" + \"    font-weight:      normal;\\n\" + \"    font-size:        16pt;\\n\" + \"    margin: 0;\\n\" + \"  }\\n\" + \"</style>\\n\" + \"<button id=\\\"repl-button\\\">Toggle REPL</button>\\n\" + \"<div id=\\\"repl-console\\\" class=\\\"repl-close\\\">\\n\" + \"  <div id=\\\"repl-output\\\" class=\\\"repl-part\\\"></div>\\n\" + \"  <div id=\\\"repl-prompt\\\" class=\\\"repl-part\\\">&nbsp;&gt;&nbsp;</div>\\n\" + \"  <div id=\\\"repl-input\\\"  class=\\\"repl-part\\\" contenteditable=\\\"true\\\"></div>\\n\" + \"</div>\"];\n      $send(e, 'inner_html=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      e.$append_to(container);\n      return $send($gvars.document['$[]'](\"repl-button\"), 'on', [\"click\"], (TMP_13 = function(){var self = TMP_13.$$s || this;\n\n      \n        if ($truthy(Opal.const_get_relative($nesting, 'REPL')['$started?']())) {\n          } else {\n          Opal.const_get_relative($nesting, 'REPL').$start()\n        };\n        if ($truthy(Opal.const_get_relative($nesting, 'REPL')['$open?']())) {\n          return Opal.const_get_relative($nesting, 'REPL').$close()\n          } else {\n          return Opal.const_get_relative($nesting, 'REPL').$open()\n        };}, TMP_13.$$s = self, TMP_13.$$arity = 0, TMP_13));\n    }, TMP_REPL_add_to_page_14.$$arity = -1);\n    \n    Opal.defn(self, '$initialize', TMP_REPL_initialize_15 = function $$initialize(context, keep_local_vars, input_id, output_id, prompt_id) {\n      var self = this;\n      if ($gvars.document == null) $gvars.document = nil;\n\n      if (context == null) {\n        context = \"main\";\n      }\n      if (keep_local_vars == null) {\n        keep_local_vars = true;\n      }\n      if (input_id == null) {\n        input_id = \"repl-input\";\n      }\n      if (output_id == null) {\n        output_id = \"repl-output\";\n      }\n      if (prompt_id == null) {\n        prompt_id = \"repl-prompt\";\n      }\n      \n      self.input_id = input_id;\n      self.input = $gvars.document['$[]'](input_id);\n      self.output_id = output_id;\n      self.output = $gvars.document['$[]'](output_id);\n      self.prompt_id = prompt_id;\n      self.prompt = $gvars.document['$[]'](prompt_id);\n      self.$capture_console();\n      self.input.$scroll()['$to!']();\n      self.input.$focus();\n      self.history = [];\n      self.history_index = 0;\n      self.$disable_multiline();\n      self.$set_context(context);\n      if ($truthy(keep_local_vars)) {\n        self.$Native(Opal.irb_vars = {})};\n      return self.$attach_input_event_handler();\n    }, TMP_REPL_initialize_15.$$arity = -1);\n    \n    Opal.defn(self, '$attach_input_event_handler', TMP_REPL_attach_input_event_handler_18 = function $$attach_input_event_handler() {\n      var TMP_16, TMP_17, self = this;\n\n      \n      $send(self.input, 'on', [\"keypress\"], (TMP_16 = function(event){var self = TMP_16.$$s || this, $case = nil;\n        if (self.multiline == null) self.multiline = nil;\nif (event == null) event = nil;\n      if ($truthy(event['$ctrl?']())) {\n          return (function() {$case = event.$key();\n          if (\"m\"['$===']($case)) {return self.$enable_multiline()}\n          else if (\"ArrowUp\"['$===']($case)) {return self.$prev_history()}\n          else if (\"ArrowDown\"['$===']($case)) {return self.$next_history()}\n          else if (\"Enter\"['$===']($case)) {if ($truthy(self.multiline)) {\n            \n            self.saved_input = nil;\n            self.$input_command();\n            self.$disable_multiline();\n            return event.$prevent();\n            } else {\n            return nil\n          }}\n          else { return nil }})()\n          } else {\n          return (function() {$case = event.$key();\n          if (\"Enter\"['$===']($case)) {if ($truthy(self.multiline)) {\n            return nil\n            } else {\n            \n            self.saved_input = nil;\n            self.$input_command();\n            return event.$prevent();\n          }}\n          else { return nil }})()\n        }}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16));\n      return $send(self.input, 'on', [\"input\"], (TMP_17 = function(event){var self = TMP_17.$$s || this;\nif (event == null) event = nil;\n      return (self.saved_input = nil)}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17));\n    }, TMP_REPL_attach_input_event_handler_18.$$arity = 0);\n    \n    Opal.defn(self, '$prev_history', TMP_REPL_prev_history_19 = function $$prev_history() {\n      var $a, self = this;\n\n      if ($truthy(self.history['$empty?']())) {\n        return nil\n        } else {\n        \n        self.saved_input = ($truthy($a = self.saved_input) ? $a : self.$contenteditable_text());\n        self.history_index = [0, $rb_minus(self.history_index, 1)].$max();\n        return self.$set_input_from_history(self.history_index);\n      }\n    }, TMP_REPL_prev_history_19.$$arity = 0);\n    \n    Opal.defn(self, '$next_history', TMP_REPL_next_history_20 = function $$next_history() {\n      var $a, self = this;\n\n      if ($truthy(self.history['$empty?']())) {\n        return nil\n        } else {\n        \n        self.saved_input = ($truthy($a = self.saved_input) ? $a : self.$contenteditable_text());\n        self.history_index = [self.history.$count(), $rb_plus(self.history_index, 1)].$min();\n        if ($truthy($rb_lt(self.history_index, self.history.$count()))) {\n          return self.$set_input_from_history(self.history_index)\n          } else {\n          return self.$set_input(self.saved_input)\n        };\n      }\n    }, TMP_REPL_next_history_20.$$arity = 0);\n    \n    Opal.defn(self, '$set_input_from_history', TMP_REPL_set_input_from_history_21 = function $$set_input_from_history(index) {\n      var self = this, cmd = nil;\n\n      \n      cmd = self.history['$[]'](index);\n      return self.$set_input(cmd);\n    }, TMP_REPL_set_input_from_history_21.$$arity = 1);\n    \n    Opal.defn(self, '$set_input', TMP_REPL_set_input_22 = function $$set_input(cmd) {\n      var self = this, $writer = nil;\n\n      \n      \n      $writer = [cmd];\n      $send(self.input, 'inner_text=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      if ($truthy(cmd.$index(\"\\n\"))) {\n        self.$enable_multiline()\n        } else {\n        self.$disable_multiline()\n      };\n      return self.input.$scroll()['$to!']();\n    }, TMP_REPL_set_input_22.$$arity = 1);\n    \n    Opal.defn(self, '$send_key_to_input', TMP_REPL_send_key_to_input_23 = function $$send_key_to_input() {\n      var self = this;\n\n      \n      var e = new Event(\"keypress\");  // may need to trigger keydown ? or whole sequence of keyboard events ?\n      e.key=\"X\";\n      e.keyCode=e.key.charCodeAt(0);\n      e.which=e.keyCode;\n      e.altKey=false;\n      e.ctrlKey=true;\n      e.shiftKey=false;\n      e.metaKey=false;\n      e.bubbles=true;\n      document.getElementById('repl-input').dispatchEvent(e);\n    \n    }, TMP_REPL_send_key_to_input_23.$$arity = 0);\n    \n    Opal.defn(self, '$add_history', TMP_REPL_add_history_24 = function $$add_history(cmd) {\n      var self = this;\n\n      if (cmd['$=='](self.history.$last())) {\n        return nil\n        } else {\n        \n        self.history['$<<'](cmd);\n        return (self.history_index = self.history.$count());\n      }\n    }, TMP_REPL_add_history_24.$$arity = 1);\n    \n    Opal.defn(self, '$detach_input_event_handler', TMP_REPL_detach_input_event_handler_25 = function $$detach_input_event_handler() {\n      var self = this;\n\n      return self.input.$off(\"keypress\")\n    }, TMP_REPL_detach_input_event_handler_25.$$arity = 0);\n    \n    Opal.defn(self, '$enable_multiline', TMP_REPL_enable_multiline_26 = function $$enable_multiline() {\n      var self = this;\n\n      \n      self.multiline = true;\n      return self.$update_prompt();\n    }, TMP_REPL_enable_multiline_26.$$arity = 0);\n    \n    Opal.defn(self, '$disable_multiline', TMP_REPL_disable_multiline_27 = function $$disable_multiline() {\n      var self = this;\n\n      \n      self.multiline = false;\n      return self.$update_prompt();\n    }, TMP_REPL_disable_multiline_27.$$arity = 0);\n    \n    Opal.defn(self, '$contenteditable_text', TMP_REPL_contenteditable_text_29 = function $$contenteditable_text() {\n      var TMP_28, self = this, divs = nil;\n\n      \n      divs = self.input.$css(\"div\").$to_ary();\n      if ($truthy(divs['$empty?']())) {\n        return self.input.$inner_text()\n        } else {\n        return $send(divs, 'map', [], (TMP_28 = function(div){var self = TMP_28.$$s || this;\nif (div == null) div = nil;\n        return div.$inner_text()}, TMP_28.$$s = self, TMP_28.$$arity = 1, TMP_28)).$join(\"\\n\")\n      };\n    }, TMP_REPL_contenteditable_text_29.$$arity = 0);\n    \n    Opal.defn(self, '$clear_input', TMP_REPL_clear_input_30 = function $$clear_input() {\n      var self = this, $writer = nil;\n\n      \n      $writer = [\"\"];\n      $send(self.input, 'inner_text=', Opal.to_a($writer));\n      return $writer[$rb_minus($writer[\"length\"], 1)];\n    }, TMP_REPL_clear_input_30.$$arity = 0);\n    \n    Opal.defn(self, '$input_command', TMP_REPL_input_command_31 = function $$input_command() {\n      var $a, self = this, cmd = nil, $writer = nil;\n\n      \n      cmd = self.$contenteditable_text();\n      \n      $writer = [$rb_plus(self.output.$content(), self.$format_indent(self.$prompt_text(), cmd))];\n      $send(self.output, 'content=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      if ($truthy(($truthy($a = cmd['$nil?']()) ? $a : cmd['$empty?']()))) {\n        } else {\n        \n        self.$add_history(cmd);\n        self.$clear_input();\n        \n        if (cmd['$[]'](0)['$=='](\".\")) {self.$eval_repl(cmd['$[]']($range(1, -1, false)))}\n        else {self.$eval_ruby(cmd)};\n      };\n      self.input.$scroll()['$to!']();\n      return self.input.$focus();\n    }, TMP_REPL_input_command_31.$$arity = 0);\n    \n    Opal.defn(self, '$eval_ruby', TMP_REPL_eval_ruby_32 = function $$eval_ruby(cmd) {\n      var self = this, result = nil, $writer = nil, e = nil;\n\n      \n      try {\n        \n        result = (function() {if (self.context['$=='](\"main\")) {\n          return self.$repl_eval(cmd, false)\n          } else {\n          return self.context.$repl_eval(cmd)\n        }; return nil; })();\n        \n        $writer = [$rb_plus(self.output.$content(), \"\" + \"=> \" + (result.$inspect()) + \"\\n\")];\n        $send(self.output, 'content=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return result;\n      } catch ($err) {\n        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {e = $err;\n          try {\n            \n            \n            $writer = [$rb_plus(self.output.$content(), \"\" + (e.$class()) + \": \" + (e.$message()) + \"\\n\")];\n            $send(self.output, 'content=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            return e;\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      };\n    }, TMP_REPL_eval_ruby_32.$$arity = 1);\n    Opal.const_set($nesting[0], 'COMMANDS', [\"help\", \"history\", \"context\", \"close\", \"exit\"]);\n    \n    Opal.defn(self, '$eval_repl', TMP_REPL_eval_repl_33 = function $$eval_repl(cmd) {\n      var self = this, cmd_name = nil;\n\n      \n      cmd_name = cmd.$split().$first();\n      if ($truthy(Opal.const_get_relative($nesting, 'COMMANDS')['$include?'](cmd_name))) {\n        return self.$send(\"\" + \"cmd_\" + (cmd_name), cmd['$[]'](Opal.Range.$new(cmd_name.$length(), -1, false)).$strip())\n        } else {\n        return self.$puts(\"\" + \"Error: Unknown console command '\" + (cmd_name) + \"'. Enter '.help' to see all console commands.\")\n      };\n    }, TMP_REPL_eval_repl_33.$$arity = 1);\n    \n    Opal.defn(self, '$cmd_help', TMP_REPL_cmd_help_34 = function $$cmd_help(arg) {\n      var self = this, $writer = nil;\n\n      \n      \n      $writer = [$rb_plus(self.output.$content(), \".close   : Close console\\n\")];\n      $send(self.output, 'content=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      \n      $writer = [$rb_plus(self.output.$content(), \".exit    : Exit and close console\\n\")];\n      $send(self.output, 'content=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      \n      $writer = [$rb_plus(self.output.$content(), \".help    : This list of commands\\n\")];\n      $send(self.output, 'content=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      \n      $writer = [$rb_plus(self.output.$content(), \".history : Command history\\n\")];\n      $send(self.output, 'content=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      \n      $writer = [$rb_plus(self.output.$content(), \".context : Execution context (self)\\n\")];\n      $send(self.output, 'content=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      \n      $writer = [$rb_plus(self.output.$content(), \"Enter '.help command' for command-specific help\\n\")];\n      $send(self.output, 'content=', Opal.to_a($writer));\n      return $writer[$rb_minus($writer[\"length\"], 1)];;\n    }, TMP_REPL_cmd_help_34.$$arity = 1);\n    \n    Opal.defn(self, '$cmd_exit', TMP_REPL_cmd_exit_35 = function $$cmd_exit() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'REPL').$stop()\n    }, TMP_REPL_cmd_exit_35.$$arity = 0);\n    \n    Opal.defn(self, '$cmd_close', TMP_REPL_cmd_close_36 = function $$cmd_close() {\n      var self = this;\n\n      return Opal.const_get_relative($nesting, 'REPL').$close()\n    }, TMP_REPL_cmd_close_36.$$arity = 0);\n    \n    Opal.defn(self, '$cmd_history', TMP_REPL_cmd_history_38 = function $$cmd_history(arg) {\n      var $a, TMP_37, self = this, $writer = nil, index = nil;\n\n      \n      if ($truthy(($truthy($a = arg['$nil?']()) ? $a : arg['$empty?']()))) {\n        \n        $send(self.history, 'each_with_index', [], (TMP_37 = function(cmd, i){var self = TMP_37.$$s || this, $writer = nil;\n          if (self.output == null) self.output = nil;\nif (cmd == null) cmd = nil;if (i == null) i = nil;\n        \n          $writer = [$rb_plus(self.output.$content(), self.$format_indent(\"\" + (i) + \": \", cmd))];\n          $send(self.output, 'content=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_37.$$s = self, TMP_37.$$arity = 2, TMP_37));\n        return nil;};\n      if ($truthy(arg['$=~'](/^\\d+$/))) {\n        } else {\n        \n        \n        $writer = [$rb_plus(self.output.$content(), \"\" + \"Invalid number \" + (arg) + \"\\n\")];\n        $send(self.output, 'content=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return nil;\n      };\n      index = arg.$to_i();\n      if ($truthy(index['$between?'](0, $rb_minus(self.history.$count(), 1)))) {\n        } else {\n        \n        \n        $writer = [$rb_plus(self.output.$content(), \"\" + \"No history at index \" + (index) + \"\\n\")];\n        $send(self.output, 'content=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return nil;\n      };\n      return self.$set_input_from_history(index);\n    }, TMP_REPL_cmd_history_38.$$arity = 1);\n    \n    Opal.defn(self, '$cmd_context', TMP_REPL_cmd_context_39 = function $$cmd_context(arg) {\n      var $a, self = this, $writer = nil, new_context = nil;\n\n      \n      if ($truthy(($truthy($a = arg['$nil?']()) ? $a : arg['$empty?']()))) {\n        \n        \n        $writer = [$rb_plus(self.output.$content(), \"No context provided\\n\")];\n        $send(self.output, 'content=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return nil;};\n      new_context = (function() {if ($truthy(arg['$=='](\"main\"))) {\n        return \"main\"\n        } else {\n        return self.$eval_ruby(arg)\n      }; return nil; })();\n      if ($truthy(new_context['$is_a?'](Opal.const_get_relative($nesting, 'Exception')))) {\n        return nil\n        } else {\n        return self.$set_context(new_context)\n      };\n    }, TMP_REPL_cmd_context_39.$$arity = 1);\n    \n    Opal.defn(self, '$format_indent', TMP_REPL_format_indent_41 = function $$format_indent(prefix, cmd) {\n      var TMP_40, self = this, lines = nil, $writer = nil;\n\n      \n      lines = $send(cmd.$lines(), 'map', [], (TMP_40 = function(line){var self = TMP_40.$$s || this;\nif (line == null) line = nil;\n      return \"\" + ($rb_times(\" \", prefix.$length())) + (line.$chomp()) + \"\\n\"}, TMP_40.$$s = self, TMP_40.$$arity = 1, TMP_40));\n      \n      $writer = [0, \"\" + (prefix) + (cmd.$lines().$first().$chomp()) + \"\\n\"];\n      $send(lines, '[]=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      return lines.$join();\n    }, TMP_REPL_format_indent_41.$$arity = 2);\n    \n    Opal.defn(self, '$prompt_text', TMP_REPL_prompt_text_42 = function $$prompt_text() {\n      var self = this;\n\n      return \"\" + \"(\" + (self.context_name) + \") \" + ((function() {if ($truthy(self.multiline)) {\n        return \"#\"\n        } else {\n        return \">\"\n      }; return nil; })()) + \" \"\n    }, TMP_REPL_prompt_text_42.$$arity = 0);\n    \n    Opal.defn(self, '$context_name', TMP_REPL_context_name_43 = function $$context_name() {\n      var self = this;\n\n      \n      if (self.context['$=='](\"main\")) {\n        return \"main\"};\n      return self.context.$repl_eval(\"self.to_s\");\n    }, TMP_REPL_context_name_43.$$arity = 0);\n    \n    Opal.defn(self, '$set_context', TMP_REPL_set_context_44 = function $$set_context(context) {\n      var self = this;\n\n      \n      self.context = context;\n      self.context_name = self.$context_name();\n      return self.$update_prompt();\n    }, TMP_REPL_set_context_44.$$arity = 1);\n    \n    Opal.defn(self, '$update_prompt', TMP_REPL_update_prompt_45 = function $$update_prompt() {\n      var self = this, $writer = nil;\n\n      \n      $writer = [self.$prompt_text()];\n      $send(self.prompt, 'text=', Opal.to_a($writer));\n      return $writer[$rb_minus($writer[\"length\"], 1)];\n    }, TMP_REPL_update_prompt_45.$$arity = 0);\n    \n    Opal.defn(self, '$capture_console', TMP_REPL_capture_console_46 = function $$capture_console() {\n      var self = this;\n\n      \n      self.$capture_console_log();\n      self.$capture_console_warn();\n      return self.$capture_console_error();\n    }, TMP_REPL_capture_console_46.$$arity = 0);\n    \n    Opal.defn(self, '$capture_console_log', TMP_REPL_capture_console_log_47 = function $$capture_console_log() {\n      var self = this;\n\n      \n      console_log_original = console.log;;\n      return console.log = function(text) { console_log_original(text); document.getElementById('repl-output').textContent += text; };;\n    }, TMP_REPL_capture_console_log_47.$$arity = 0);\n    \n    Opal.defn(self, '$capture_console_warn', TMP_REPL_capture_console_warn_48 = function $$capture_console_warn() {\n      var self = this;\n\n      \n      console_warn_original = console.warn;;\n      return console.warn = function(text) { console_warn_original(text); document.getElementById('repl-output').textContent += text; };;\n    }, TMP_REPL_capture_console_warn_48.$$arity = 0);\n    return (Opal.defn(self, '$capture_console_error', TMP_REPL_capture_console_error_49 = function $$capture_console_error() {\n      var self = this;\n\n      \n      console_error_original = console.error;;\n      return console.error = function(text) { console_error_original(text); document.getElementById('repl-output').textContent += text; };;\n    }, TMP_REPL_capture_console_error_49.$$arity = 0), nil) && 'capture_console_error';\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $BasicObject(){};\n    var self = $BasicObject = $klass($base, $super, 'BasicObject', $BasicObject);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BasicObject_repl_eval_51;\n\n    return (Opal.defn(self, '$repl_eval', TMP_BasicObject_repl_eval_51 = function $$repl_eval(cmd, eval_in_self, keep_local_vars) {\n      var TMP_50, self = this, repl_eval_options = nil, compiling_options = nil, compiled = nil, block = nil;\n\n      if (eval_in_self == null) {\n        eval_in_self = true;\n      }\n      if (keep_local_vars == null) {\n        keep_local_vars = true;\n      }\n      \n      repl_eval_options = $hash2([\"file\", \"eval\", \"irb\"], {\"file\": \"(eval)\", \"eval\": eval_in_self, \"irb\": keep_local_vars});\n      compiling_options = Opal.hash({ arity_check: false }).$merge(repl_eval_options);\n      compiled = Opal.const_get_qualified('::', 'Opal').$compile(cmd, compiling_options);\n      block = $send(Opal.const_get_qualified('::', 'Kernel'), 'proc', [], (TMP_50 = function(){var self = TMP_50.$$s || this;\n\n      \n        return (function(self) {\n          return eval(compiled);\n        })(self)\n      }, TMP_50.$$s = self, TMP_50.$$arity = 0, TMP_50));\n      \n      var old = block.$$s,\n          result;\n      block.$$s = null;\n      // Need to pass $$eval so that method definitions know if this is\n      // being done on a class/module. Cannot be compiler driven since\n      // send(:instance_eval) needs to work.\n      if (self.$$is_a_module) {\n        self.$$eval = true;\n        try {\n          result = block.call(self, self);\n        }\n        finally {\n          self.$$eval = false;\n        }\n      }\n      else {\n        result = block.call(self, self);\n      }\n      block.$$s = old;\n      return result;\n    ;\n    }, TMP_BasicObject_repl_eval_51.$$arity = -2), nil) && 'repl_eval'\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"browser/interval\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$attr_reader', '$convert', '$nil?', '$stopped?', '$aborted?', '$raise', '$call', '$tap', '$new', '$to_proc', '$every', '$every!']);\n  \n  (function($base, $parent_nesting) {\n    var $Browser, self = $Browser = $module($base, 'Browser');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    (function($base, $super, $parent_nesting) {\n      function $Interval(){};\n      var self = $Interval = $klass($base, $super, 'Interval', $Interval);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Interval_initialize_1, TMP_Interval_stopped$q_2, TMP_Interval_aborted$q_3, TMP_Interval_abort_4, TMP_Interval_stop_5, TMP_Interval_start_6, TMP_Interval_call_7;\n\n      def.id = def.aborted = def.window = def.block = def.every = nil;\n      \n      self.$attr_reader(\"every\");\n      \n      Opal.defn(self, '$initialize', TMP_Interval_initialize_1 = function $$initialize(window, time) {\n        var self = this, $iter = TMP_Interval_initialize_1.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Interval_initialize_1.$$p = null;\n        \n        self.window = Opal.const_get_relative($nesting, 'Native').$convert(window);\n        self.every = time;\n        self.block = block;\n        return (self.aborted = false);\n      }, TMP_Interval_initialize_1.$$arity = 2);\n      \n      Opal.defn(self, '$stopped?', TMP_Interval_stopped$q_2 = function() {\n        var self = this;\n\n        return self.id['$nil?']()\n      }, TMP_Interval_stopped$q_2.$$arity = 0);\n      \n      Opal.defn(self, '$aborted?', TMP_Interval_aborted$q_3 = function() {\n        var self = this;\n\n        return self.aborted\n      }, TMP_Interval_aborted$q_3.$$arity = 0);\n      \n      Opal.defn(self, '$abort', TMP_Interval_abort_4 = function $$abort() {\n        var self = this;\n\n        \n        self.window.clearInterval(self.id);\n        self.aborted = true;\n        return (self.id = nil);\n      }, TMP_Interval_abort_4.$$arity = 0);\n      \n      Opal.defn(self, '$stop', TMP_Interval_stop_5 = function $$stop() {\n        var self = this;\n\n        \n        if ($truthy(self['$stopped?']())) {\n          return nil};\n        self.window.clearInterval(self.id);\n        self.stopped = true;\n        return (self.id = nil);\n      }, TMP_Interval_stop_5.$$arity = 0);\n      \n      Opal.defn(self, '$start', TMP_Interval_start_6 = function $$start() {\n        var self = this;\n\n        \n        if ($truthy(self['$aborted?']())) {\n          self.$raise(\"the interval has been aborted\")};\n        if ($truthy(self['$stopped?']())) {\n          } else {\n          return nil\n        };\n        return (self.id = self.window.setInterval(self.block, self.every * 1000));\n      }, TMP_Interval_start_6.$$arity = 0);\n      return (Opal.defn(self, '$call', TMP_Interval_call_7 = function $$call() {\n        var self = this;\n\n        return self.block.$call()\n      }, TMP_Interval_call_7.$$arity = 0), nil) && 'call';\n    })($nesting[0], null, $nesting);\n    (function($base, $super, $parent_nesting) {\n      function $Window(){};\n      var self = $Window = $klass($base, $super, 'Window', $Window);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Window_every_8, TMP_Window_every$B_9;\n\n      def[\"native\"] = nil;\n      \n      \n      Opal.defn(self, '$every', TMP_Window_every_8 = function $$every(time) {\n        var self = this, $iter = TMP_Window_every_8.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Window_every_8.$$p = null;\n        return $send($send(Opal.const_get_relative($nesting, 'Interval'), 'new', [self[\"native\"], time], block.$to_proc()), 'tap', [], \"start\".$to_proc())\n      }, TMP_Window_every_8.$$arity = 1);\n      return (Opal.defn(self, '$every!', TMP_Window_every$B_9 = function(time) {\n        var self = this, $iter = TMP_Window_every$B_9.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Window_every$B_9.$$p = null;\n        return $send(Opal.const_get_relative($nesting, 'Interval'), 'new', [self[\"native\"], time], block.$to_proc())\n      }, TMP_Window_every$B_9.$$arity = 1), nil) && 'every!';\n    })($nesting[0], null, $nesting);\n  })($nesting[0], $nesting);\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_every_10, TMP_Kernel_every$B_11;\n\n    \n    \n    Opal.defn(self, '$every', TMP_Kernel_every_10 = function $$every(time) {\n      var self = this, $iter = TMP_Kernel_every_10.$$p, block = $iter || nil;\n      if ($gvars.window == null) $gvars.window = nil;\n\n      if ($iter) TMP_Kernel_every_10.$$p = null;\n      return $send($gvars.window, 'every', [time], block.$to_proc())\n    }, TMP_Kernel_every_10.$$arity = 1);\n    \n    Opal.defn(self, '$every!', TMP_Kernel_every$B_11 = function(time) {\n      var self = this, $iter = TMP_Kernel_every$B_11.$$p, block = $iter || nil;\n      if ($gvars.window == null) $gvars.window = nil;\n\n      if ($iter) TMP_Kernel_every$B_11.$$p = null;\n      return $send($gvars.window, 'every!', [time], block.$to_proc())\n    }, TMP_Kernel_every$B_11.$$arity = 1);\n  })($nesting[0], $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $Proc(){};\n    var self = $Proc = $klass($base, $super, 'Proc', $Proc);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Proc_every_12, TMP_Proc_every$B_13;\n\n    \n    \n    Opal.defn(self, '$every', TMP_Proc_every_12 = function $$every(time) {\n      var self = this;\n      if ($gvars.window == null) $gvars.window = nil;\n\n      return $send($gvars.window, 'every', [time], self.$to_proc())\n    }, TMP_Proc_every_12.$$arity = 1);\n    return (Opal.defn(self, '$every!', TMP_Proc_every$B_13 = function(time) {\n      var self = this;\n      if ($gvars.window == null) $gvars.window = nil;\n\n      return $send($gvars.window, 'every!', [time], self.$to_proc())\n    }, TMP_Proc_every$B_13.$$arity = 1), nil) && 'every!';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"pitch/version\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;\n\n  return (function($base, $parent_nesting) {\n    var $Pitch, self = $Pitch = $module($base, 'Pitch');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    Opal.const_set($nesting[0], 'VERSION', \"0.1.0\")\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"pitch/detector\"] = function(Opal) {\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$each_cons', '$count_negative_zero_crossings', '$/', '$*', '$Float', '$count', '$trim_sample_pairs_to_negative_zero_crossings', '$zero?', '$-', '$+', '$each_with_object', '$negative_zero_crossing?', '$<<', '$empty?', '$[]', '$[]=', '$pop', '$sum', '$alias_method', '$drop_while', '$!', '$reverse_each', '$<', '$>=', '$<=>']);\n  return (function($base, $parent_nesting) {\n    var $Pitch, self = $Pitch = $module($base, 'Pitch');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Detector(){};\n      var self = $Detector = $klass($base, $super, 'Detector', $Detector);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Detector_detect1_1, TMP_Detector_detect2_2, TMP_Detector_detect3_4, TMP_Detector_count_negative_zero_crossings_6, TMP_Detector_trim_sample_pairs_to_negative_zero_crossings_9, TMP_Detector_negative_zero_crossing$q_10, TMP_Detector_sign_11;\n\n      \n      Opal.defs(self, '$detect1', TMP_Detector_detect1_1 = function $$detect1(samples, $kwargs) {\n        var self = this, rate, pairs = nil, negative_zero_cross_count = nil, freq = nil;\n\n        if ($kwargs == null || !$kwargs.$$is_hash) {\n          if ($kwargs == null) {\n            $kwargs = $hash2([], {});\n          } else {\n            throw Opal.ArgumentError.$new('expected kwargs');\n          }\n        }\n        rate = $kwargs.$$smap[\"rate\"];\n        if (rate == null) {\n          rate = 44100\n        }\n        \n        pairs = samples.$each_cons(2);\n        negative_zero_cross_count = self.$count_negative_zero_crossings(pairs);\n        return (freq = $rb_divide($rb_times(self.$Float(rate), negative_zero_cross_count), samples.$count()));\n      }, TMP_Detector_detect1_1.$$arity = -2);\n      Opal.defs(self, '$detect2', TMP_Detector_detect2_2 = function $$detect2(samples, $kwargs) {\n        var self = this, rate, pairs = nil, pairs_between_first_and_last_crossings = nil, negative_zero_cross_count = nil, freq = nil;\n\n        if ($kwargs == null || !$kwargs.$$is_hash) {\n          if ($kwargs == null) {\n            $kwargs = $hash2([], {});\n          } else {\n            throw Opal.ArgumentError.$new('expected kwargs');\n          }\n        }\n        rate = $kwargs.$$smap[\"rate\"];\n        if (rate == null) {\n          rate = 44100\n        }\n        \n        pairs = samples.$each_cons(2);\n        pairs_between_first_and_last_crossings = self.$trim_sample_pairs_to_negative_zero_crossings(pairs);\n        negative_zero_cross_count = self.$count_negative_zero_crossings(pairs_between_first_and_last_crossings);\n        return (freq = (function() {if ($truthy(negative_zero_cross_count['$zero?']())) {\n          return 0.0\n          } else {\n          return $rb_divide($rb_times(self.$Float(rate), $rb_minus(negative_zero_cross_count, 1)), $rb_plus(pairs_between_first_and_last_crossings.$count(), 1))\n        }; return nil; })());\n      }, TMP_Detector_detect2_2.$$arity = -2);\n      Opal.defs(self, '$detect3', TMP_Detector_detect3_4 = function $$detect3(samples, $kwargs) {\n        var TMP_3, self = this, rate, pairs = nil, periods = nil, average_period = nil, freq = nil;\n\n        if ($kwargs == null || !$kwargs.$$is_hash) {\n          if ($kwargs == null) {\n            $kwargs = $hash2([], {});\n          } else {\n            throw Opal.ArgumentError.$new('expected kwargs');\n          }\n        }\n        rate = $kwargs.$$smap[\"rate\"];\n        if (rate == null) {\n          rate = 44100\n        }\n        \n        pairs = samples.$each_cons(2);\n        periods = $send(pairs, 'each_with_object', [[]], (TMP_3 = function($a, periods){var self = TMP_3.$$s || this, $a_args, previous, current, $writer = nil;\n\n          if ($a == null) {\n            $a = nil;\n          }\n          $a = Opal.to_ary($a);\n          $a_args = Opal.slice.call($a, 0, $a.length);\n          previous = $a_args.splice(0,1)[0];\n          if (previous == null) {\n            previous = nil;\n          }\n          current = $a_args.splice(0,1)[0];\n          if (current == null) {\n            current = nil;\n          }if (periods == null) periods = nil;\n        \n          if ($truthy(self['$negative_zero_crossing?'](previous, current))) {\n            \n            periods['$<<'](1);\n            return nil;;};\n          if ($truthy(periods['$empty?']())) {\n            return nil;};\n          \n          $writer = [-1, $rb_plus(periods['$[]'](-1), 1)];\n          $send(periods, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];;}, TMP_3.$$s = self, TMP_3.$$arity = 2, TMP_3.$$has_top_level_mlhs_arg = true, TMP_3));\n        periods.$pop();\n        if ($truthy(periods['$empty?']())) {\n          return 0.0};\n        average_period = $rb_divide(self.$Float(periods.$sum()), periods.$count());\n        return (freq = $rb_divide(rate, average_period));\n      }, TMP_Detector_detect3_4.$$arity = -2);\n      (function(self, $parent_nesting) {\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return self.$alias_method(\"detect\", \"detect3\")\n      })(Opal.get_singleton_class(self), $nesting);\n      Opal.defs(self, '$count_negative_zero_crossings', TMP_Detector_count_negative_zero_crossings_6 = function $$count_negative_zero_crossings(pairs) {\n        var TMP_5, self = this;\n\n        return $send(pairs, 'count', [], (TMP_5 = function(previous, current){var self = TMP_5.$$s || this;\nif (previous == null) previous = nil;if (current == null) current = nil;\n        return self['$negative_zero_crossing?'](previous, current)}, TMP_5.$$s = self, TMP_5.$$arity = 2, TMP_5))\n      }, TMP_Detector_count_negative_zero_crossings_6.$$arity = 1);\n      Opal.defs(self, '$trim_sample_pairs_to_negative_zero_crossings', TMP_Detector_trim_sample_pairs_to_negative_zero_crossings_9 = function $$trim_sample_pairs_to_negative_zero_crossings(pairs) {\n        var TMP_7, TMP_8, self = this, pairs_after_first_crossing = nil, pairs_between_first_and_last_crossings = nil;\n\n        \n        pairs_after_first_crossing = $send(pairs, 'drop_while', [], (TMP_7 = function(previous, current){var self = TMP_7.$$s || this;\nif (previous == null) previous = nil;if (current == null) current = nil;\n        return self['$negative_zero_crossing?'](previous, current)['$!']()}, TMP_7.$$s = self, TMP_7.$$arity = 2, TMP_7));\n        return (pairs_between_first_and_last_crossings = $send(pairs_after_first_crossing.$reverse_each(), 'drop_while', [], (TMP_8 = function(previous, current){var self = TMP_8.$$s || this;\nif (previous == null) previous = nil;if (current == null) current = nil;\n        return self['$negative_zero_crossing?'](previous, current)['$!']()}, TMP_8.$$s = self, TMP_8.$$arity = 2, TMP_8)).$reverse_each());\n      }, TMP_Detector_trim_sample_pairs_to_negative_zero_crossings_9.$$arity = 1);\n      Opal.defs(self, '$negative_zero_crossing?', TMP_Detector_negative_zero_crossing$q_10 = function(previous, current) {\n        var $a, self = this;\n\n        return ($truthy($a = $rb_lt(current, 0)) ? $rb_ge(previous, 0) : $a)\n      }, TMP_Detector_negative_zero_crossing$q_10.$$arity = 2);\n      return Opal.defs(self, '$sign', TMP_Detector_sign_11 = function $$sign(n) {\n        var self = this;\n\n        return n['$<=>'](0)\n      }, TMP_Detector_sign_11.$$arity = 1);\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"pitch/note\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send;\n\n  Opal.add_stubs(['$new', '$name', '$octave', '$+', '$round', '$*', '$log2', '$/', '$**', '$-', '$floor', '$count', '$[]', '$%']);\n  return (function($base, $parent_nesting) {\n    var $Pitch, self = $Pitch = $module($base, 'Pitch');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Pitch_1, TMP_Pitch_note_3;\n\n    \n    Opal.const_set($nesting[0], 'REF_FREQ', 440.0);\n    Opal.const_set($nesting[0], 'REF_INDEX', 57);\n    Opal.const_set($nesting[0], 'NOTE_NAMES', [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]);\n    Opal.const_set($nesting[0], 'Note', $send(Opal.const_get_relative($nesting, 'Struct'), 'new', [\"freq\", \"pitch\", \"cents\", \"octave\", \"name\"], (TMP_Pitch_1 = function(){var self = TMP_Pitch_1.$$s || this, TMP_fullname_2;\n\n    return (Opal.def(self, '$fullname', TMP_fullname_2 = function $$fullname() {\n        var self = this;\n\n        return \"\" + (self.$name()) + (self.$octave())\n      }, TMP_fullname_2.$$arity = 0), nil) && 'fullname'}, TMP_Pitch_1.$$s = self, TMP_Pitch_1.$$arity = 0, TMP_Pitch_1)));\n    Opal.defs(self, '$note', TMP_Pitch_note_3 = function $$note(freq) {\n      var self = this, index = nil, pitch = nil, cents = nil, octave = nil, name = nil;\n\n      \n      index = $rb_plus($rb_times(Opal.const_get_relative($nesting, 'Math').$log2($rb_divide(freq, Opal.const_get_relative($nesting, 'REF_FREQ'))), 12.0).$round(), Opal.const_get_relative($nesting, 'REF_INDEX'));\n      return Opal.const_get_relative($nesting, 'Note').$new(freq, (pitch = $rb_times((2)['$**']($rb_divide($rb_minus(index, Opal.const_get_relative($nesting, 'REF_INDEX')), 12.0)), Opal.const_get_relative($nesting, 'REF_FREQ'))), (cents = $rb_times(Opal.const_get_relative($nesting, 'Math').$log2($rb_divide(freq, pitch)), 1200).$round()), (octave = $rb_divide(index, Opal.const_get_relative($nesting, 'NOTE_NAMES').$count()).$floor()), (name = Opal.const_get_relative($nesting, 'NOTE_NAMES')['$[]'](index['$%'](Opal.const_get_relative($nesting, 'NOTE_NAMES').$count()))));\n    }, TMP_Pitch_note_3.$$arity = 1);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"pitch\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"pitch/version\");\n  self.$require(\"pitch/detector\");\n  return self.$require(\"pitch/note\");\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"vue\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$include', '$attr_accessor', '$initialize_component', '$initialize_app', '$resolve_data', '$data', '$class', '$methods_hash', '$methods', '$computed', '$to_proc', '$method', '$Native', '$to_n', '$template', '$props', '$name', '$new', '$nil?', '$is_a?', '$call', '$[]', '$each', '$native_data_accessor', '$native_data_reader', '$native_data_writer', '$define_method', '$+', '$[]=', '$-', '$empty?', '$native_prop_accessor', '$native_prop_reader', '$native_prop_writer', '$inject', '$create_data_accessors', '$create_prop_accessors']);\n  \n  self.$require(\"native\");\n  return (function($base, $super, $parent_nesting) {\n    function $Vue(){};\n    var self = $Vue = $klass($base, $super, 'Vue', $Vue);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Vue_initialize_1, TMP_Vue_initialize_app_2, TMP_Vue_initialize_component_3, TMP_Vue_component_4, TMP_Vue_data_5, TMP_Vue_resolve_data_7, TMP_Vue_create_data_accessors_9, TMP_Vue_native_data_accessor_10, TMP_Vue_native_data_reader_12, TMP_Vue_native_data_writer_14, TMP_Vue_props_15, TMP_Vue_create_prop_accessors_17, TMP_Vue_native_prop_accessor_18, TMP_Vue_native_prop_reader_20, TMP_Vue_native_prop_writer_22, TMP_Vue_methods_23, TMP_Vue_computed_24, TMP_Vue_name_25, TMP_Vue_template_26, TMP_Vue_methods_hash_28, TMP_Vue_created_29, TMP_Vue_mounted_30;\n\n    def.vue = def.config = def[\"native\"] = nil;\n    \n    self.$include(Opal.const_get_relative($nesting, 'Native'));\n    self.$attr_accessor(\"native\");\n    \n    Opal.defn(self, '$initialize', TMP_Vue_initialize_1 = function $$initialize(element, component) {\n      var self = this;\n\n      if (element == null) {\n        element = nil;\n      }\n      if (component == null) {\n        component = false;\n      }\n      if ($truthy(component)) {\n        return self.$initialize_component()\n        } else {\n        return self.$initialize_app(element)\n      }\n    }, TMP_Vue_initialize_1.$$arity = -1);\n    \n    Opal.defn(self, '$initialize_app', TMP_Vue_initialize_app_2 = function $$initialize_app(element) {\n      var self = this;\n\n      \n      self.config = $hash2([\"el\", \"data\", \"methods\", \"computed\", \"mounted\", \"beforeCreate\", \"created\"], {\"el\": element, \"data\": self.$resolve_data(self.$class().$data()), \"methods\": self.$methods_hash(self.$class().$methods()), \"computed\": self.$methods_hash(self.$class().$computed()), \"mounted\": self.$method(\"mounted\").$to_proc(), \"beforeCreate\": function() { self.vue = this }, \"created\": self.$method(\"created\").$to_proc()});\n      return self.$Native(tuner = new Vue(self.config.$to_n()));\n    }, TMP_Vue_initialize_app_2.$$arity = 1);\n    \n    Opal.defn(self, '$initialize_component', TMP_Vue_initialize_component_3 = function $$initialize_component() {\n      var self = this;\n\n      \n      self.config = $hash2([\"template\", \"props\", \"methods\", \"computed\", \"mounted\", \"beforeCreate\", \"created\"], {\"template\": self.$class().$template(), \"props\": self.$class().$props(), \"methods\": self.$methods_hash(self.$class().$methods()), \"computed\": self.$methods_hash(self.$class().$computed()), \"mounted\": self.$method(\"mounted\").$to_proc(), \"beforeCreate\": function() { self.vue = this }, \"created\": self.$method(\"created\").$to_proc()});\n      return self.$Native(comp = Vue.component(self.$class().$name(),self.config.$to_n()));\n    }, TMP_Vue_initialize_component_3.$$arity = 0);\n    Opal.defs(self, '$component', TMP_Vue_component_4 = function $$component() {\n      var self = this;\n\n      return self.$new(nil, true)\n    }, TMP_Vue_component_4.$$arity = 0);\n    Opal.defs(self, '$data', TMP_Vue_data_5 = function $$data(data_option) {\n      var self = this;\n      if (self.vue_data == null) self.vue_data = nil;\n\n      if (data_option == null) {\n        data_option = nil;\n      }\n      \n      if ($truthy(data_option['$nil?']())) {\n        return self.vue_data};\n      return (self.vue_data = data_option);\n    }, TMP_Vue_data_5.$$arity = -1);\n    \n    Opal.defn(self, '$resolve_data', TMP_Vue_resolve_data_7 = function $$resolve_data(data_option) {\n      var $a, TMP_6, self = this;\n\n      \n      if ($truthy(($truthy($a = data_option['$is_a?'](Opal.const_get_relative($nesting, 'Symbol'))) ? $a : data_option['$is_a?'](Opal.const_get_relative($nesting, 'String'))))) {\n        return $send(Opal.const_get_relative($nesting, 'Proc'), 'new', [], (TMP_6 = function(){var self = TMP_6.$$s || this;\n\n        return self.$method(data_option).$call().$to_n()}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6))};\n      return data_option;\n    }, TMP_Vue_resolve_data_7.$$arity = 1);\n    \n    Opal.defn(self, '$create_data_accessors', TMP_Vue_create_data_accessors_9 = function $$create_data_accessors() {\n      var TMP_8, self = this, names = nil;\n\n      \n      names = Object.keys(self[\"native\"]['$[]'](\"$data\").$to_n());\n      return $send(names, 'each', [], (TMP_8 = function(name){var self = TMP_8.$$s || this;\nif (name == null) name = nil;\n      return self.$native_data_accessor(name)}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8));\n    }, TMP_Vue_create_data_accessors_9.$$arity = 0);\n    \n    Opal.defn(self, '$native_data_accessor', TMP_Vue_native_data_accessor_10 = function $$native_data_accessor(name) {\n      var self = this;\n\n      \n      self.$native_data_reader(name);\n      return self.$native_data_writer(name);\n    }, TMP_Vue_native_data_accessor_10.$$arity = 1);\n    \n    Opal.defn(self, '$native_data_reader', TMP_Vue_native_data_reader_12 = function $$native_data_reader(name) {\n      var TMP_11, self = this;\n\n      return $send(self.$class(), 'define_method', [name], (TMP_11 = function(){var self = TMP_11.$$s || this;\n        if (self[\"native\"] == null) self[\"native\"] = nil;\n\n      return self[\"native\"]['$[]'](\"$data\")['$[]'](name)}, TMP_11.$$s = self, TMP_11.$$arity = 0, TMP_11))\n    }, TMP_Vue_native_data_reader_12.$$arity = 1);\n    \n    Opal.defn(self, '$native_data_writer', TMP_Vue_native_data_writer_14 = function $$native_data_writer(name) {\n      var TMP_13, self = this;\n\n      return $send(self.$class(), 'define_method', [$rb_plus(name, \"=\")], (TMP_13 = function(arg){var self = TMP_13.$$s || this, $writer = nil;\n        if (self[\"native\"] == null) self[\"native\"] = nil;\nif (arg == null) arg = nil;\n      \n        $writer = [name, arg];\n        $send(self[\"native\"]['$[]'](\"$data\"), '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13))\n    }, TMP_Vue_native_data_writer_14.$$arity = 1);\n    Opal.defs(self, '$props', TMP_Vue_props_15 = function $$props($a_rest) {\n      var self = this, props;\n      if (self.vue_props == null) self.vue_props = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      props = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        props[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if ($truthy(props['$empty?']())) {\n        return self.vue_props};\n      return (self.vue_props = props);\n    }, TMP_Vue_props_15.$$arity = -1);\n    \n    Opal.defn(self, '$create_prop_accessors', TMP_Vue_create_prop_accessors_17 = function $$create_prop_accessors() {\n      var TMP_16, self = this, props = nil, names = nil;\n\n      if ($truthy((props = self[\"native\"]['$[]'](\"$props\")))) {\n        \n        names = Object.keys(props.$to_n());\n        return $send(names, 'each', [], (TMP_16 = function(name){var self = TMP_16.$$s || this;\nif (name == null) name = nil;\n        return self.$native_prop_accessor(name)}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16));\n        } else {\n        return nil\n      }\n    }, TMP_Vue_create_prop_accessors_17.$$arity = 0);\n    \n    Opal.defn(self, '$native_prop_accessor', TMP_Vue_native_prop_accessor_18 = function $$native_prop_accessor(name) {\n      var self = this;\n\n      \n      self.$native_prop_reader(name);\n      return self.$native_prop_writer(name);\n    }, TMP_Vue_native_prop_accessor_18.$$arity = 1);\n    \n    Opal.defn(self, '$native_prop_reader', TMP_Vue_native_prop_reader_20 = function $$native_prop_reader(name) {\n      var TMP_19, self = this;\n\n      return $send(self.$class(), 'define_method', [name], (TMP_19 = function(){var self = TMP_19.$$s || this;\n        if (self[\"native\"] == null) self[\"native\"] = nil;\n\n      return self[\"native\"]['$[]'](\"$props\")['$[]'](name)}, TMP_19.$$s = self, TMP_19.$$arity = 0, TMP_19))\n    }, TMP_Vue_native_prop_reader_20.$$arity = 1);\n    \n    Opal.defn(self, '$native_prop_writer', TMP_Vue_native_prop_writer_22 = function $$native_prop_writer(name) {\n      var TMP_21, self = this;\n\n      return $send(self.$class(), 'define_method', [$rb_plus(name, \"=\")], (TMP_21 = function(arg){var self = TMP_21.$$s || this, $writer = nil;\n        if (self[\"native\"] == null) self[\"native\"] = nil;\nif (arg == null) arg = nil;\n      \n        $writer = [name, arg];\n        $send(self[\"native\"]['$[]'](\"$props\"), '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21))\n    }, TMP_Vue_native_prop_writer_22.$$arity = 1);\n    Opal.defs(self, '$methods', TMP_Vue_methods_23 = function $$methods($a_rest) {\n      var self = this, names;\n      if (self.vue_methods == null) self.vue_methods = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if ($truthy(names['$empty?']())) {\n        return self.vue_methods};\n      return (self.vue_methods = names);\n    }, TMP_Vue_methods_23.$$arity = -1);\n    Opal.defs(self, '$computed', TMP_Vue_computed_24 = function $$computed($a_rest) {\n      var self = this, names;\n      if (self.vue_computed == null) self.vue_computed = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if ($truthy(names['$empty?']())) {\n        return self.vue_computed};\n      return (self.vue_computed = names);\n    }, TMP_Vue_computed_24.$$arity = -1);\n    Opal.defs(self, '$name', TMP_Vue_name_25 = function $$name(name) {\n      var self = this;\n      if (self.vue_name == null) self.vue_name = nil;\n\n      if (name == null) {\n        name = nil;\n      }\n      \n      if ($truthy(name['$nil?']())) {\n        return self.vue_name};\n      return (self.vue_name = name);\n    }, TMP_Vue_name_25.$$arity = -1);\n    Opal.defs(self, '$template', TMP_Vue_template_26 = function $$template(name) {\n      var self = this;\n      if (self.vue_template == null) self.vue_template = nil;\n\n      if (name == null) {\n        name = nil;\n      }\n      \n      if ($truthy(name['$nil?']())) {\n        return self.vue_template};\n      return (self.vue_template = name);\n    }, TMP_Vue_template_26.$$arity = -1);\n    \n    Opal.defn(self, '$methods_hash', TMP_Vue_methods_hash_28 = function $$methods_hash(names) {\n      var TMP_27, self = this;\n\n      \n      if ($truthy(names['$nil?']())) {\n        return $hash2([], {})};\n      return $send(names, 'inject', [$hash2([], {})], (TMP_27 = function(mh, name){var self = TMP_27.$$s || this, $writer = nil;\nif (mh == null) mh = nil;if (name == null) name = nil;\n      \n        \n        $writer = [name, self.$method(name).$to_proc()];\n        $send(mh, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        return mh;}, TMP_27.$$s = self, TMP_27.$$arity = 2, TMP_27));\n    }, TMP_Vue_methods_hash_28.$$arity = 1);\n    \n    Opal.defn(self, '$created', TMP_Vue_created_29 = function $$created() {\n      var self = this;\n\n      \n      self[\"native\"] = self.$Native(self.vue);\n      self.$create_data_accessors();\n      return self.$create_prop_accessors();\n    }, TMP_Vue_created_29.$$arity = 0);\n    return (Opal.defn(self, '$mounted', TMP_Vue_mounted_30 = function $$mounted() {\n      var self = this;\n\n      return nil\n    }, TMP_Vue_mounted_30.$$arity = 0), nil) && 'mounted';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"vue_app\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $gvars = Opal.gvars, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$methods', '$data', '$listening', '$stop_listening', '$start_listening']);\n  \n  self.$require(\"vue\");\n  return (function($base, $super, $parent_nesting) {\n    function $VueApp(){};\n    var self = $VueApp = $klass($base, $super, 'VueApp', $VueApp);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_VueApp_toggle_listening_1, TMP_VueApp_test_data_method_2;\n\n    \n    self.$methods(\"toggle_listening\");\n    self.$data(\"test_data_method\");\n    \n    Opal.defn(self, '$toggle_listening', TMP_VueApp_toggle_listening_1 = function $$toggle_listening() {\n      var self = this;\n      if ($gvars.tuner == null) $gvars.tuner = nil;\n\n      if ($truthy(self.$listening())) {\n        return $gvars.tuner.$stop_listening()\n        } else {\n        return $gvars.tuner.$start_listening()\n      }\n    }, TMP_VueApp_toggle_listening_1.$$arity = 0);\n    return (Opal.defn(self, '$test_data_method', TMP_VueApp_test_data_method_2 = function $$test_data_method() {\n      var self = this;\n\n      return $hash2([\"listening\", \"note\", \"cents\", \"freq\", \"rate\", \"freq_data\"], {\"listening\": false, \"note\": \"\", \"cents\": 0, \"freq\": 0, \"rate\": 0, \"freq_data\": []})\n    }, TMP_VueApp_test_data_method_2.$$arity = 0), nil) && 'test_data_method';\n  })($nesting[0], Opal.const_get_relative($nesting, 'Vue'), $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"vue_note\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass;\n\n  Opal.add_stubs(['$require', '$name', '$template', '$props']);\n  \n  self.$require(\"vue\");\n  return (function($base, $super, $parent_nesting) {\n    function $VueNote(){};\n    var self = $VueNote = $klass($base, $super, 'VueNote', $VueNote);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    self.$name(\"note\");\n    self.$template(\"#note-template\");\n    return self.$props(\"note\", \"cents\");\n  })($nesting[0], Opal.const_get_relative($nesting, 'Vue'), $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"vue_frequency\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass;\n\n  Opal.add_stubs(['$require', '$name', '$template', '$props']);\n  \n  self.$require(\"vue\");\n  return (function($base, $super, $parent_nesting) {\n    function $VueFrequency(){};\n    var self = $VueFrequency = $klass($base, $super, 'VueFrequency', $VueFrequency);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    self.$name(\"frequency\");\n    self.$template(\"#frequency-template\");\n    return self.$props(\"freq\");\n  })($nesting[0], Opal.const_get_relative($nesting, 'Vue'), $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"vue_freq_graph\"] = function(Opal) {\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$name', '$template', '$props', '$computed', '$take', '$freq_data', '$/', '$count', '$join', '$map', '$each_with_index', '$-', '$==', '$rate', '$floor', '$log2', '$upper_freq_limit', '$times', '$to_n', '$to_i', '$*', '$**', '$round', '$freq']);\n  \n  self.$require(\"vue\");\n  return (function($base, $super, $parent_nesting) {\n    function $VueFreqGraph(){};\n    var self = $VueFreqGraph = $klass($base, $super, 'VueFreqGraph', $VueFreqGraph);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_VueFreqGraph_points_2, TMP_VueFreqGraph_grid_4, TMP_VueFreqGraph_indicator_5, TMP_VueFreqGraph_upper_freq_limit_6;\n\n    \n    self.$name(\"freq-graph\");\n    self.$template(\"#freq-graph-template\");\n    self.$props(\"freq\", \"freq_data\", \"rate\");\n    self.$computed(\"points\", \"grid\", \"indicator\");\n    Opal.const_set($nesting[0], 'GRAPH_FFT_WINDOW', 1);\n    Opal.const_set($nesting[0], 'GRAPH_WIDTH', 1024);\n    \n    Opal.defn(self, '$points', TMP_VueFreqGraph_points_2 = function $$points() {\n      var TMP_1, self = this, fft_to_graph = nil;\n\n      \n      fft_to_graph = self.$freq_data().$take($rb_divide(self.$freq_data().$count(), Opal.const_get_relative($nesting, 'GRAPH_FFT_WINDOW')));\n      return $send(fft_to_graph.$each_with_index(), 'map', [], (TMP_1 = function(amp, i){var self = TMP_1.$$s || this;\nif (amp == null) amp = nil;if (i == null) i = nil;\n      return \"\" + (i) + \",\" + ($rb_minus(255, amp))}, TMP_1.$$s = self, TMP_1.$$arity = 2, TMP_1)).$join(\" \");\n    }, TMP_VueFreqGraph_points_2.$$arity = 0);\n    \n    Opal.defn(self, '$grid', TMP_VueFreqGraph_grid_4 = function $$grid() {\n      var TMP_3, self = this, lower_freq_limit = nil, lower_octaves = nil, upper_octaves = nil;\n\n      \n      if (self.$rate()['$=='](0)) {\n        return []};\n      lower_freq_limit = 55;\n      lower_octaves = Opal.const_get_relative($nesting, 'Math').$log2(lower_freq_limit).$floor();\n      upper_octaves = Opal.const_get_relative($nesting, 'Math').$log2(self.$upper_freq_limit()).$floor();\n      return $send($rb_minus(upper_octaves, lower_octaves).$times(), 'map', [], (TMP_3 = function(octave){var self = TMP_3.$$s || this, oct_freq = nil;\nif (octave == null) octave = nil;\n      return $hash2([\"freq\", \"x\"], {\"freq\": (oct_freq = $rb_times(55, (2)['$**'](octave)).$to_i()), \"x\": $rb_times(Opal.const_get_relative($nesting, 'GRAPH_WIDTH'), $rb_divide(oct_freq, self.$upper_freq_limit())).$round()}).$to_n()}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3));\n    }, TMP_VueFreqGraph_grid_4.$$arity = 0);\n    \n    Opal.defn(self, '$indicator', TMP_VueFreqGraph_indicator_5 = function $$indicator() {\n      var self = this;\n\n      \n      if (self.$rate()['$=='](0)) {\n        return $hash2([], {})};\n      return $hash2([\"freq\", \"x\"], {\"freq\": self.$freq().$round(), \"x\": $rb_times(Opal.const_get_relative($nesting, 'GRAPH_WIDTH'), $rb_divide(self.$freq(), self.$upper_freq_limit())).$round()}).$to_n();\n    }, TMP_VueFreqGraph_indicator_5.$$arity = 0);\n    return (Opal.defn(self, '$upper_freq_limit', TMP_VueFreqGraph_upper_freq_limit_6 = function $$upper_freq_limit() {\n      var self = this;\n\n      return $rb_divide($rb_divide(self.$rate(), 2), Opal.const_get_relative($nesting, 'GRAPH_FFT_WINDOW'))\n    }, TMP_VueFreqGraph_upper_freq_limit_6.$$arity = 0), nil) && 'upper_freq_limit';\n  })($nesting[0], Opal.const_get_relative($nesting, 'Vue'), $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\nOpal.modules[\"tuner\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$component', '$new', '$abort', '$close', '$listening=', '$-', '$MODIFY_AUDIO_SETTINGS', '$permissions', '$plugins', '$cordova', '$RECORD_AUDIO', '$requestPermissions', '$proc', '$hasPermission', '$Native', '$permission_granted', '$permission_refused', '$permission_error', '$get_user_media', '$alert', '$fail', '$then', '$getUserMedia', '$mediaDevices', '$navigator', '$got_stream', '$create_stream_source', '$create_gain', '$create_filter', '$create_analyser', '$connect', '$every', '$update_note', '$update_freq_graph', '$createMediaStreamSource', '$createGain', '$value=', '$gain', '$createBiquadFilter', '$type=', '$frequency', '$createAnalyser', '$fftSize=', '$frequencyBinCount', '$getFloatTimeDomainData', '$Array', '$detect3', '$sampleRate', '$freq=', '$==', '$note', '$name', '$note=', '$cents', '$cents=', '$getByteFrequencyData', '$freq_data=', '$rate=']);\n  \n  self.$require(\"browser/interval\");\n  self.$require(\"pitch\");\n  self.$require(\"vue_app\");\n  self.$require(\"vue_note\");\n  self.$require(\"vue_frequency\");\n  self.$require(\"vue_freq_graph\");\n  return (function($base, $super, $parent_nesting) {\n    function $Tuner(){};\n    var self = $Tuner = $klass($base, $super, 'Tuner', $Tuner);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Tuner_initialize_1, TMP_Tuner_stop_listening_2, TMP_Tuner_start_listening_5, TMP_Tuner_permission_granted_6, TMP_Tuner_permission_refused_7, TMP_Tuner_permission_error_8, TMP_Tuner_get_user_media_11, TMP_Tuner_got_stream_13, TMP_Tuner_create_stream_source_14, TMP_Tuner_create_gain_15, TMP_Tuner_create_filter_16, TMP_Tuner_create_analyser_17, TMP_Tuner_update_note_18, TMP_Tuner_update_freq_graph_19;\n\n    def.listening_loop = def.audio_context = def.vue = def.source = def.gain = def.filter = def.analyser = def.float32array = def.buffer = nil;\n    \n    Opal.const_set($nesting[0], 'LATENCY_HINT', \"interactive\");\n    Opal.const_set($nesting[0], 'SAMPLE_RATE', 2048);\n    Opal.const_set($nesting[0], 'FFT_SIZE', 2048);\n    Opal.const_set($nesting[0], 'LOWPASS_FILTER_CUTOFF', 82);\n    Opal.const_set($nesting[0], 'GAIN', 1.0);\n    Opal.const_set($nesting[0], 'INTERVAL', 0.1);\n    \n    Opal.defn(self, '$initialize', TMP_Tuner_initialize_1 = function $$initialize() {\n      var self = this;\n\n      \n      self.vue_note = Opal.const_get_relative($nesting, 'VueNote').$component();\n      self.vue_freq = Opal.const_get_relative($nesting, 'VueFrequency').$component();\n      self.vue_freq_graph = Opal.const_get_relative($nesting, 'VueFreqGraph').$component();\n      return (self.vue = Opal.const_get_relative($nesting, 'VueApp').$new(\"#app\"));\n    }, TMP_Tuner_initialize_1.$$arity = 0);\n    \n    Opal.defn(self, '$stop_listening', TMP_Tuner_stop_listening_2 = function $$stop_listening() {\n      var self = this, $writer = nil;\n\n      \n      self.listening_loop.$abort();\n      self.audio_context.$close();\n      \n      $writer = [false];\n      $send(self.vue, 'listening=', Opal.to_a($writer));\n      return $writer[$rb_minus($writer[\"length\"], 1)];;\n    }, TMP_Tuner_stop_listening_2.$$arity = 0);\n    \n    Opal.defn(self, '$start_listening', TMP_Tuner_start_listening_5 = function $$start_listening() {\n      var TMP_3, TMP_4, self = this, permissions = nil;\n      if ($gvars.$ == null) $gvars.$ = nil;\n\n      \n      permissions = [$gvars.$.$cordova().$plugins().$permissions().$MODIFY_AUDIO_SETTINGS(), $gvars.$.$cordova().$plugins().$permissions().$RECORD_AUDIO()];\n      return $gvars.$.$cordova().$plugins().$permissions().$requestPermissions(permissions, $send(self, 'proc', [], (TMP_3 = function(status){var self = TMP_3.$$s || this;\nif (status == null) status = nil;\n      if ($truthy(self.$Native(status).$hasPermission())) {\n          return self.$permission_granted()\n          } else {\n          return self.$permission_refused()\n        }}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3)), $send(self, 'proc', [], (TMP_4 = function(){var self = TMP_4.$$s || this;\n\n      return self.$permission_error()}, TMP_4.$$s = self, TMP_4.$$arity = 0, TMP_4)));\n    }, TMP_Tuner_start_listening_5.$$arity = 0);\n    \n    Opal.defn(self, '$permission_granted', TMP_Tuner_permission_granted_6 = function $$permission_granted() {\n      var self = this;\n\n      return self.$get_user_media()\n    }, TMP_Tuner_permission_granted_6.$$arity = 0);\n    \n    Opal.defn(self, '$permission_refused', TMP_Tuner_permission_refused_7 = function $$permission_refused() {\n      var self = this;\n\n      return self.$alert(\"Cannot access microphone without permission. Please grant permission.\")\n    }, TMP_Tuner_permission_refused_7.$$arity = 0);\n    \n    Opal.defn(self, '$permission_error', TMP_Tuner_permission_error_8 = function $$permission_error() {\n      var self = this;\n\n      return self.$alert(\"Error getting permssion. Try setting permissions, or reinstall app.\")\n    }, TMP_Tuner_permission_error_8.$$arity = 0);\n    \n    Opal.defn(self, '$get_user_media', TMP_Tuner_get_user_media_11 = function $$get_user_media() {\n      var TMP_9, TMP_10, self = this;\n      if ($gvars.$ == null) $gvars.$ = nil;\n\n      return $send($send($gvars.$.$navigator().$mediaDevices().$getUserMedia($hash2([\"audio\"], {\"audio\": true})), 'then', [], (TMP_9 = function(stream){var self = TMP_9.$$s || this;\nif (stream == null) stream = nil;\n      return self.$got_stream(stream)}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9)), 'fail', [], (TMP_10 = function(){var self = TMP_10.$$s || this;\n\n      return self.$alert(\"Unable to access microphone.\")}, TMP_10.$$s = self, TMP_10.$$arity = 0, TMP_10))\n    }, TMP_Tuner_get_user_media_11.$$arity = 0);\n    \n    Opal.defn(self, '$got_stream', TMP_Tuner_got_stream_13 = function $$got_stream(stream) {\n      var TMP_12, self = this, $writer = nil;\n\n      \n      self.audio_context = self.$Native(new AudioContext({latencyHint: Opal.const_get_relative($nesting, 'LATENCY_HINT'), sampleRate: Opal.const_get_relative($nesting, 'SAMPLE_RATE')}));\n      self.source = self.$create_stream_source(stream);\n      self.gain = self.$create_gain();\n      self.filter = self.$create_filter();\n      self.analyser = self.$create_analyser();\n      self.source.$connect(self.gain);\n      self.gain.$connect(self.filter);\n      self.filter.$connect(self.analyser);\n      \n      $writer = [true];\n      $send(self.vue, 'listening=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      return (self.listening_loop = $send(self, 'every', [Opal.const_get_relative($nesting, 'INTERVAL')], (TMP_12 = function(){var self = TMP_12.$$s || this;\n\n      \n        self.$update_note();\n        return self.$update_freq_graph();}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12)));\n    }, TMP_Tuner_got_stream_13.$$arity = 1);\n    \n    Opal.defn(self, '$create_stream_source', TMP_Tuner_create_stream_source_14 = function $$create_stream_source(stream) {\n      var self = this;\n\n      return self.audio_context.$createMediaStreamSource(stream)\n    }, TMP_Tuner_create_stream_source_14.$$arity = 1);\n    \n    Opal.defn(self, '$create_gain', TMP_Tuner_create_gain_15 = function $$create_gain() {\n      var self = this, gain = nil, $writer = nil;\n\n      \n      gain = self.audio_context.$createGain();\n      \n      $writer = [Opal.const_get_relative($nesting, 'GAIN')];\n      $send(gain.$gain(), 'value=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      return gain;\n    }, TMP_Tuner_create_gain_15.$$arity = 0);\n    \n    Opal.defn(self, '$create_filter', TMP_Tuner_create_filter_16 = function $$create_filter() {\n      var self = this, filter = nil, $writer = nil;\n\n      \n      filter = self.audio_context.$createBiquadFilter();\n      \n      $writer = [\"lowpass\"];\n      $send(filter, 'type=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      \n      $writer = [Opal.const_get_relative($nesting, 'LOWPASS_FILTER_CUTOFF')];\n      $send(filter.$frequency(), 'value=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      return filter;\n    }, TMP_Tuner_create_filter_16.$$arity = 0);\n    \n    Opal.defn(self, '$create_analyser', TMP_Tuner_create_analyser_17 = function $$create_analyser() {\n      var self = this, analyser = nil, $writer = nil;\n\n      \n      analyser = self.audio_context.$createAnalyser();\n      \n      $writer = [Opal.const_get_relative($nesting, 'FFT_SIZE')];\n      $send(analyser, 'fftSize=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      return analyser;\n    }, TMP_Tuner_create_analyser_17.$$arity = 0);\n    \n    Opal.defn(self, '$update_note', TMP_Tuner_update_note_18 = function $$update_note() {\n      var $a, self = this, detected_freq = nil, $writer = nil, detected_note = nil;\n\n      \n      self.float32array = ($truthy($a = self.float32array) ? $a : new Float32Array( self.audio_context.$frequencyBinCount() ));\n      self.analyser.$getFloatTimeDomainData(self.float32array);\n      self.buffer = self.$Array(self.float32array);\n      detected_freq = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Pitch'), 'Detector').$detect3(self.buffer, $hash2([\"rate\"], {\"rate\": self.audio_context.$sampleRate()}));\n      \n      $writer = [detected_freq];\n      $send(self.vue, 'freq=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      if (detected_freq['$=='](0)) {\n        return nil\n        } else {\n        \n        detected_note = Opal.const_get_relative($nesting, 'Pitch').$note(detected_freq);\n        \n        $writer = [detected_note.$name()];\n        $send(self.vue, 'note=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [detected_note.$cents()];\n        $send(self.vue, 'cents=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];;\n      };\n    }, TMP_Tuner_update_note_18.$$arity = 0);\n    return (Opal.defn(self, '$update_freq_graph', TMP_Tuner_update_freq_graph_19 = function $$update_freq_graph() {\n      var $a, self = this, uint8array = nil, $writer = nil;\n\n      \n      uint8array = ($truthy($a = uint8array) ? $a : new Uint8Array( self.analyser.$frequencyBinCount() ));\n      self.analyser.$getByteFrequencyData(uint8array);\n      \n      $writer = [self.$Array(uint8array)];\n      $send(self.vue, 'freq_data=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      \n      $writer = [self.audio_context.$sampleRate()];\n      $send(self.vue, 'rate=', Opal.to_a($writer));\n      return $writer[$rb_minus($writer[\"length\"], 1)];;\n    }, TMP_Tuner_update_freq_graph_19.$$arity = 0), nil) && 'update_freq_graph';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.3 */\n(function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var TMP_1, TMP_on_deviceready_3, TMP_create_tuner_4, TMP_show_app_5, TMP_bind_cordova_events_15, TMP_on_pause_16, TMP_on_resume_17, TMP_on_backbutton_18, TMP_on_menubutton_19, TMP_on_searchbutton_20, TMP_on_startcallbutton_21, TMP_on_endcallbutton_22, TMP_on_volumeupbutton_23, TMP_on_volumedownbutton_24, self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $send = Opal.send, $gvars = Opal.gvars;\n  if ($gvars.document == null) $gvars.document = nil;\n\n  Opal.add_stubs(['$require', '$puts', '$ready', '$on', '$on_deviceready', '$create_tuner', '$show_app', '$bind_cordova_events', '$new', '$[]=', '$attributes', '$[]', '$-', '$addEventListener', '$Native', '$on_pause', '$on_resume', '$on_backbutton', '$on_menubutton', '$on_searchbutton', '$on_startcallbutton', '$on_endcallbutton', '$on_volumeupbutton', '$on_volumedownbutton']);\n  \n  self.$require(\"opal\");\n  self.$require(\"opal/version\");\n  self.$require(\"browser\");\n  self.$require(\"native\");\n  self.$require(\"repl\");\n  self.$require(\"tuner\");\n  self.$puts(\"\" + \"Opal \" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'VERSION')));\n  $send($gvars.document, 'ready', [], (TMP_1 = function(){var self = TMP_1.$$s || this, TMP_2;\n    if ($gvars.document == null) $gvars.document = nil;\n\n  return $send($gvars.document, 'on', [\"deviceready\"], (TMP_2 = function(event){var self = TMP_2.$$s || this;\nif (event == null) event = nil;\n    return self.$on_deviceready(event)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1));\n  \n  Opal.defn(Opal.Object, '$on_deviceready', TMP_on_deviceready_3 = function $$on_deviceready(event) {\n    var self = this;\n\n    \n    self.$puts(\"cordova:deviceready\");\n    self.$create_tuner();\n    self.$show_app();\n    return self.$bind_cordova_events();\n  }, TMP_on_deviceready_3.$$arity = 1);\n  \n  Opal.defn(Opal.Object, '$create_tuner', TMP_create_tuner_4 = function $$create_tuner() {\n    var self = this;\n\n    return ($gvars.tuner = Opal.const_get_relative($nesting, 'Tuner').$new())\n  }, TMP_create_tuner_4.$$arity = 0);\n  \n  Opal.defn(Opal.Object, '$show_app', TMP_show_app_5 = function $$show_app() {\n    var self = this, $writer = nil;\n    if ($gvars.document == null) $gvars.document = nil;\n\n    \n    $writer = [\"class\", \"visible\"];\n    $send($gvars.document['$[]'](\"app\").$attributes(), '[]=', Opal.to_a($writer));\n    return $writer[$rb_minus($writer[\"length\"], 1)];\n  }, TMP_show_app_5.$$arity = 0);\n  \n  Opal.defn(Opal.Object, '$bind_cordova_events', TMP_bind_cordova_events_15 = function $$bind_cordova_events() {\n    var TMP_6, TMP_7, TMP_8, TMP_9, TMP_10, TMP_11, TMP_12, TMP_13, TMP_14, self = this;\n\n    \n    $send(self.$Native(document), 'addEventListener', [\"pause\"], (TMP_6 = function(){var self = TMP_6.$$s || this;\n\n    return self.$on_pause()}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6));\n    $send(self.$Native(document), 'addEventListener', [\"resume\"], (TMP_7 = function(){var self = TMP_7.$$s || this;\n\n    return self.$on_resume()}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7));\n    $send(self.$Native(document), 'addEventListener', [\"backbutton\"], (TMP_8 = function(){var self = TMP_8.$$s || this;\n\n    return self.$on_backbutton()}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8));\n    $send(self.$Native(document), 'addEventListener', [\"menubutton\"], (TMP_9 = function(){var self = TMP_9.$$s || this;\n\n    return self.$on_menubutton()}, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9));\n    $send(self.$Native(document), 'addEventListener', [\"searchbutton\"], (TMP_10 = function(){var self = TMP_10.$$s || this;\n\n    return self.$on_searchbutton()}, TMP_10.$$s = self, TMP_10.$$arity = 0, TMP_10));\n    $send(self.$Native(document), 'addEventListener', [\"startcallbutton\"], (TMP_11 = function(){var self = TMP_11.$$s || this;\n\n    return self.$on_startcallbutton()}, TMP_11.$$s = self, TMP_11.$$arity = 0, TMP_11));\n    $send(self.$Native(document), 'addEventListener', [\"endcallbutton\"], (TMP_12 = function(){var self = TMP_12.$$s || this;\n\n    return self.$on_endcallbutton()}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12));\n    $send(self.$Native(document), 'addEventListener', [\"volumeupbutton\"], (TMP_13 = function(){var self = TMP_13.$$s || this;\n\n    return self.$on_volumeupbutton()}, TMP_13.$$s = self, TMP_13.$$arity = 0, TMP_13));\n    return $send(self.$Native(document), 'addEventListener', [\"volumedownbutton\"], (TMP_14 = function(){var self = TMP_14.$$s || this;\n\n    return self.$on_volumedownbutton()}, TMP_14.$$s = self, TMP_14.$$arity = 0, TMP_14));\n  }, TMP_bind_cordova_events_15.$$arity = 0);\n  \n  Opal.defn(Opal.Object, '$on_pause', TMP_on_pause_16 = function $$on_pause() {\n    var self = this;\n\n    return self.$puts(\"cordova:pause\")\n  }, TMP_on_pause_16.$$arity = 0);\n  \n  Opal.defn(Opal.Object, '$on_resume', TMP_on_resume_17 = function $$on_resume() {\n    var self = this;\n\n    return self.$puts(\"cordova:resume\")\n  }, TMP_on_resume_17.$$arity = 0);\n  \n  Opal.defn(Opal.Object, '$on_backbutton', TMP_on_backbutton_18 = function $$on_backbutton() {\n    var self = this;\n\n    return self.$puts(\"cordova:backbutton\")\n  }, TMP_on_backbutton_18.$$arity = 0);\n  \n  Opal.defn(Opal.Object, '$on_menubutton', TMP_on_menubutton_19 = function $$on_menubutton() {\n    var self = this;\n\n    return self.$puts(\"cordova:menubutton\")\n  }, TMP_on_menubutton_19.$$arity = 0);\n  \n  Opal.defn(Opal.Object, '$on_searchbutton', TMP_on_searchbutton_20 = function $$on_searchbutton() {\n    var self = this;\n\n    return self.$puts(\"cordova:searchbutton\")\n  }, TMP_on_searchbutton_20.$$arity = 0);\n  \n  Opal.defn(Opal.Object, '$on_startcallbutton', TMP_on_startcallbutton_21 = function $$on_startcallbutton() {\n    var self = this;\n\n    return self.$puts(\"cordova:startcallbutton\")\n  }, TMP_on_startcallbutton_21.$$arity = 0);\n  \n  Opal.defn(Opal.Object, '$on_endcallbutton', TMP_on_endcallbutton_22 = function $$on_endcallbutton() {\n    var self = this;\n\n    return self.$puts(\"cordova:endcallbutton\")\n  }, TMP_on_endcallbutton_22.$$arity = 0);\n  \n  Opal.defn(Opal.Object, '$on_volumeupbutton', TMP_on_volumeupbutton_23 = function $$on_volumeupbutton() {\n    var self = this;\n\n    return self.$puts(\"cordova:volumeupbutton\")\n  }, TMP_on_volumeupbutton_23.$$arity = 0);\n  return (Opal.defn(Opal.Object, '$on_volumedownbutton', TMP_on_volumedownbutton_24 = function $$on_volumedownbutton() {\n    var self = this;\n\n    return self.$puts(\"cordova:volumedownbutton\")\n  }, TMP_on_volumedownbutton_24.$$arity = 0), nil) && 'on_volumedownbutton';\n})(Opal);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./app/index.rb?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1.js":
/*!******************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var asn1 = exports;\n\nasn1.bignum = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\n\nasn1.define = __webpack_require__(/*! ./asn1/api */ \"./node_modules/asn1.js/lib/asn1/api.js\").define;\nasn1.base = __webpack_require__(/*! ./asn1/base */ \"./node_modules/asn1.js/lib/asn1/base/index.js\");\nasn1.constants = __webpack_require__(/*! ./asn1/constants */ \"./node_modules/asn1.js/lib/asn1/constants/index.js\");\nasn1.decoders = __webpack_require__(/*! ./asn1/decoders */ \"./node_modules/asn1.js/lib/asn1/decoders/index.js\");\nasn1.encoders = __webpack_require__(/*! ./asn1/encoders */ \"./node_modules/asn1.js/lib/asn1/encoders/index.js\");\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/api.js":
/*!**********************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/api.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var asn1 = __webpack_require__(/*! ../asn1 */ \"./node_modules/asn1.js/lib/asn1.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar api = exports;\n\napi.define = function define(name, body) {\n  return new Entity(name, body);\n};\n\nfunction Entity(name, body) {\n  this.name = name;\n  this.body = body;\n\n  this.decoders = {};\n  this.encoders = {};\n};\n\nEntity.prototype._createNamed = function createNamed(base) {\n  var named;\n  try {\n    named = __webpack_require__(/*! vm */ \"./node_modules/vm-browserify/index.js\").runInThisContext(\n      '(function ' + this.name + '(entity) {\\n' +\n      '  this._initNamed(entity);\\n' +\n      '})'\n    );\n  } catch (e) {\n    named = function (entity) {\n      this._initNamed(entity);\n    };\n  }\n  inherits(named, base);\n  named.prototype._initNamed = function initnamed(entity) {\n    base.call(this, entity);\n  };\n\n  return new named(this);\n};\n\nEntity.prototype._getDecoder = function _getDecoder(enc) {\n  enc = enc || 'der';\n  // Lazily create decoder\n  if (!this.decoders.hasOwnProperty(enc))\n    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);\n  return this.decoders[enc];\n};\n\nEntity.prototype.decode = function decode(data, enc, options) {\n  return this._getDecoder(enc).decode(data, options);\n};\n\nEntity.prototype._getEncoder = function _getEncoder(enc) {\n  enc = enc || 'der';\n  // Lazily create encoder\n  if (!this.encoders.hasOwnProperty(enc))\n    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);\n  return this.encoders[enc];\n};\n\nEntity.prototype.encode = function encode(data, enc, /* internal */ reporter) {\n  return this._getEncoder(enc).encode(data, reporter);\n};\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/api.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Reporter = __webpack_require__(/*! ../base */ \"./node_modules/asn1.js/lib/asn1/base/index.js\").Reporter;\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nfunction DecoderBuffer(base, options) {\n  Reporter.call(this, options);\n  if (!Buffer.isBuffer(base)) {\n    this.error('Input not Buffer');\n    return;\n  }\n\n  this.base = base;\n  this.offset = 0;\n  this.length = base.length;\n}\ninherits(DecoderBuffer, Reporter);\nexports.DecoderBuffer = DecoderBuffer;\n\nDecoderBuffer.prototype.save = function save() {\n  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };\n};\n\nDecoderBuffer.prototype.restore = function restore(save) {\n  // Return skipped data\n  var res = new DecoderBuffer(this.base);\n  res.offset = save.offset;\n  res.length = this.offset;\n\n  this.offset = save.offset;\n  Reporter.prototype.restore.call(this, save.reporter);\n\n  return res;\n};\n\nDecoderBuffer.prototype.isEmpty = function isEmpty() {\n  return this.offset === this.length;\n};\n\nDecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {\n  if (this.offset + 1 <= this.length)\n    return this.base.readUInt8(this.offset++, true);\n  else\n    return this.error(fail || 'DecoderBuffer overrun');\n}\n\nDecoderBuffer.prototype.skip = function skip(bytes, fail) {\n  if (!(this.offset + bytes <= this.length))\n    return this.error(fail || 'DecoderBuffer overrun');\n\n  var res = new DecoderBuffer(this.base);\n\n  // Share reporter state\n  res._reporterState = this._reporterState;\n\n  res.offset = this.offset;\n  res.length = this.offset + bytes;\n  this.offset += bytes;\n  return res;\n}\n\nDecoderBuffer.prototype.raw = function raw(save) {\n  return this.base.slice(save ? save.offset : this.offset, this.length);\n}\n\nfunction EncoderBuffer(value, reporter) {\n  if (Array.isArray(value)) {\n    this.length = 0;\n    this.value = value.map(function(item) {\n      if (!(item instanceof EncoderBuffer))\n        item = new EncoderBuffer(item, reporter);\n      this.length += item.length;\n      return item;\n    }, this);\n  } else if (typeof value === 'number') {\n    if (!(0 <= value && value <= 0xff))\n      return reporter.error('non-byte EncoderBuffer value');\n    this.value = value;\n    this.length = 1;\n  } else if (typeof value === 'string') {\n    this.value = value;\n    this.length = Buffer.byteLength(value);\n  } else if (Buffer.isBuffer(value)) {\n    this.value = value;\n    this.length = value.length;\n  } else {\n    return reporter.error('Unsupported type: ' + typeof value);\n  }\n}\nexports.EncoderBuffer = EncoderBuffer;\n\nEncoderBuffer.prototype.join = function join(out, offset) {\n  if (!out)\n    out = new Buffer(this.length);\n  if (!offset)\n    offset = 0;\n\n  if (this.length === 0)\n    return out;\n\n  if (Array.isArray(this.value)) {\n    this.value.forEach(function(item) {\n      item.join(out, offset);\n      offset += item.length;\n    });\n  } else {\n    if (typeof this.value === 'number')\n      out[offset] = this.value;\n    else if (typeof this.value === 'string')\n      out.write(this.value, offset);\n    else if (Buffer.isBuffer(this.value))\n      this.value.copy(out, offset);\n    offset += this.length;\n  }\n\n  return out;\n};\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/base/buffer.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var base = exports;\n\nbase.Reporter = __webpack_require__(/*! ./reporter */ \"./node_modules/asn1.js/lib/asn1/base/reporter.js\").Reporter;\nbase.DecoderBuffer = __webpack_require__(/*! ./buffer */ \"./node_modules/asn1.js/lib/asn1/base/buffer.js\").DecoderBuffer;\nbase.EncoderBuffer = __webpack_require__(/*! ./buffer */ \"./node_modules/asn1.js/lib/asn1/base/buffer.js\").EncoderBuffer;\nbase.Node = __webpack_require__(/*! ./node */ \"./node_modules/asn1.js/lib/asn1/base/node.js\");\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/base/index.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/node.js":
/*!****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/node.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Reporter = __webpack_require__(/*! ../base */ \"./node_modules/asn1.js/lib/asn1/base/index.js\").Reporter;\nvar EncoderBuffer = __webpack_require__(/*! ../base */ \"./node_modules/asn1.js/lib/asn1/base/index.js\").EncoderBuffer;\nvar DecoderBuffer = __webpack_require__(/*! ../base */ \"./node_modules/asn1.js/lib/asn1/base/index.js\").DecoderBuffer;\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\n// Supported tags\nvar tags = [\n  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',\n  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',\n  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',\n  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'\n];\n\n// Public methods list\nvar methods = [\n  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',\n  'any', 'contains'\n].concat(tags);\n\n// Overrided methods list\nvar overrided = [\n  '_peekTag', '_decodeTag', '_use',\n  '_decodeStr', '_decodeObjid', '_decodeTime',\n  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',\n\n  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',\n  '_encodeNull', '_encodeInt', '_encodeBool'\n];\n\nfunction Node(enc, parent) {\n  var state = {};\n  this._baseState = state;\n\n  state.enc = enc;\n\n  state.parent = parent || null;\n  state.children = null;\n\n  // State\n  state.tag = null;\n  state.args = null;\n  state.reverseArgs = null;\n  state.choice = null;\n  state.optional = false;\n  state.any = false;\n  state.obj = false;\n  state.use = null;\n  state.useDecoder = null;\n  state.key = null;\n  state['default'] = null;\n  state.explicit = null;\n  state.implicit = null;\n  state.contains = null;\n\n  // Should create new instance on each method\n  if (!state.parent) {\n    state.children = [];\n    this._wrap();\n  }\n}\nmodule.exports = Node;\n\nvar stateProps = [\n  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',\n  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',\n  'implicit', 'contains'\n];\n\nNode.prototype.clone = function clone() {\n  var state = this._baseState;\n  var cstate = {};\n  stateProps.forEach(function(prop) {\n    cstate[prop] = state[prop];\n  });\n  var res = new this.constructor(cstate.parent);\n  res._baseState = cstate;\n  return res;\n};\n\nNode.prototype._wrap = function wrap() {\n  var state = this._baseState;\n  methods.forEach(function(method) {\n    this[method] = function _wrappedMethod() {\n      var clone = new this.constructor(this);\n      state.children.push(clone);\n      return clone[method].apply(clone, arguments);\n    };\n  }, this);\n};\n\nNode.prototype._init = function init(body) {\n  var state = this._baseState;\n\n  assert(state.parent === null);\n  body.call(this);\n\n  // Filter children\n  state.children = state.children.filter(function(child) {\n    return child._baseState.parent === this;\n  }, this);\n  assert.equal(state.children.length, 1, 'Root node can have only one child');\n};\n\nNode.prototype._useArgs = function useArgs(args) {\n  var state = this._baseState;\n\n  // Filter children and args\n  var children = args.filter(function(arg) {\n    return arg instanceof this.constructor;\n  }, this);\n  args = args.filter(function(arg) {\n    return !(arg instanceof this.constructor);\n  }, this);\n\n  if (children.length !== 0) {\n    assert(state.children === null);\n    state.children = children;\n\n    // Replace parent to maintain backward link\n    children.forEach(function(child) {\n      child._baseState.parent = this;\n    }, this);\n  }\n  if (args.length !== 0) {\n    assert(state.args === null);\n    state.args = args;\n    state.reverseArgs = args.map(function(arg) {\n      if (typeof arg !== 'object' || arg.constructor !== Object)\n        return arg;\n\n      var res = {};\n      Object.keys(arg).forEach(function(key) {\n        if (key == (key | 0))\n          key |= 0;\n        var value = arg[key];\n        res[value] = key;\n      });\n      return res;\n    });\n  }\n};\n\n//\n// Overrided methods\n//\n\noverrided.forEach(function(method) {\n  Node.prototype[method] = function _overrided() {\n    var state = this._baseState;\n    throw new Error(method + ' not implemented for encoding: ' + state.enc);\n  };\n});\n\n//\n// Public methods\n//\n\ntags.forEach(function(tag) {\n  Node.prototype[tag] = function _tagMethod() {\n    var state = this._baseState;\n    var args = Array.prototype.slice.call(arguments);\n\n    assert(state.tag === null);\n    state.tag = tag;\n\n    this._useArgs(args);\n\n    return this;\n  };\n});\n\nNode.prototype.use = function use(item) {\n  assert(item);\n  var state = this._baseState;\n\n  assert(state.use === null);\n  state.use = item;\n\n  return this;\n};\n\nNode.prototype.optional = function optional() {\n  var state = this._baseState;\n\n  state.optional = true;\n\n  return this;\n};\n\nNode.prototype.def = function def(val) {\n  var state = this._baseState;\n\n  assert(state['default'] === null);\n  state['default'] = val;\n  state.optional = true;\n\n  return this;\n};\n\nNode.prototype.explicit = function explicit(num) {\n  var state = this._baseState;\n\n  assert(state.explicit === null && state.implicit === null);\n  state.explicit = num;\n\n  return this;\n};\n\nNode.prototype.implicit = function implicit(num) {\n  var state = this._baseState;\n\n  assert(state.explicit === null && state.implicit === null);\n  state.implicit = num;\n\n  return this;\n};\n\nNode.prototype.obj = function obj() {\n  var state = this._baseState;\n  var args = Array.prototype.slice.call(arguments);\n\n  state.obj = true;\n\n  if (args.length !== 0)\n    this._useArgs(args);\n\n  return this;\n};\n\nNode.prototype.key = function key(newKey) {\n  var state = this._baseState;\n\n  assert(state.key === null);\n  state.key = newKey;\n\n  return this;\n};\n\nNode.prototype.any = function any() {\n  var state = this._baseState;\n\n  state.any = true;\n\n  return this;\n};\n\nNode.prototype.choice = function choice(obj) {\n  var state = this._baseState;\n\n  assert(state.choice === null);\n  state.choice = obj;\n  this._useArgs(Object.keys(obj).map(function(key) {\n    return obj[key];\n  }));\n\n  return this;\n};\n\nNode.prototype.contains = function contains(item) {\n  var state = this._baseState;\n\n  assert(state.use === null);\n  state.contains = item;\n\n  return this;\n};\n\n//\n// Decoding\n//\n\nNode.prototype._decode = function decode(input, options) {\n  var state = this._baseState;\n\n  // Decode root node\n  if (state.parent === null)\n    return input.wrapResult(state.children[0]._decode(input, options));\n\n  var result = state['default'];\n  var present = true;\n\n  var prevKey = null;\n  if (state.key !== null)\n    prevKey = input.enterKey(state.key);\n\n  // Check if tag is there\n  if (state.optional) {\n    var tag = null;\n    if (state.explicit !== null)\n      tag = state.explicit;\n    else if (state.implicit !== null)\n      tag = state.implicit;\n    else if (state.tag !== null)\n      tag = state.tag;\n\n    if (tag === null && !state.any) {\n      // Trial and Error\n      var save = input.save();\n      try {\n        if (state.choice === null)\n          this._decodeGeneric(state.tag, input, options);\n        else\n          this._decodeChoice(input, options);\n        present = true;\n      } catch (e) {\n        present = false;\n      }\n      input.restore(save);\n    } else {\n      present = this._peekTag(input, tag, state.any);\n\n      if (input.isError(present))\n        return present;\n    }\n  }\n\n  // Push object on stack\n  var prevObj;\n  if (state.obj && present)\n    prevObj = input.enterObject();\n\n  if (present) {\n    // Unwrap explicit values\n    if (state.explicit !== null) {\n      var explicit = this._decodeTag(input, state.explicit);\n      if (input.isError(explicit))\n        return explicit;\n      input = explicit;\n    }\n\n    var start = input.offset;\n\n    // Unwrap implicit and normal values\n    if (state.use === null && state.choice === null) {\n      if (state.any)\n        var save = input.save();\n      var body = this._decodeTag(\n        input,\n        state.implicit !== null ? state.implicit : state.tag,\n        state.any\n      );\n      if (input.isError(body))\n        return body;\n\n      if (state.any)\n        result = input.raw(save);\n      else\n        input = body;\n    }\n\n    if (options && options.track && state.tag !== null)\n      options.track(input.path(), start, input.length, 'tagged');\n\n    if (options && options.track && state.tag !== null)\n      options.track(input.path(), input.offset, input.length, 'content');\n\n    // Select proper method for tag\n    if (state.any)\n      result = result;\n    else if (state.choice === null)\n      result = this._decodeGeneric(state.tag, input, options);\n    else\n      result = this._decodeChoice(input, options);\n\n    if (input.isError(result))\n      return result;\n\n    // Decode children\n    if (!state.any && state.choice === null && state.children !== null) {\n      state.children.forEach(function decodeChildren(child) {\n        // NOTE: We are ignoring errors here, to let parser continue with other\n        // parts of encoded data\n        child._decode(input, options);\n      });\n    }\n\n    // Decode contained/encoded by schema, only in bit or octet strings\n    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {\n      var data = new DecoderBuffer(result);\n      result = this._getUse(state.contains, input._reporterState.obj)\n          ._decode(data, options);\n    }\n  }\n\n  // Pop object\n  if (state.obj && present)\n    result = input.leaveObject(prevObj);\n\n  // Set key\n  if (state.key !== null && (result !== null || present === true))\n    input.leaveKey(prevKey, state.key, result);\n  else if (prevKey !== null)\n    input.exitKey(prevKey);\n\n  return result;\n};\n\nNode.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {\n  var state = this._baseState;\n\n  if (tag === 'seq' || tag === 'set')\n    return null;\n  if (tag === 'seqof' || tag === 'setof')\n    return this._decodeList(input, tag, state.args[0], options);\n  else if (/str$/.test(tag))\n    return this._decodeStr(input, tag, options);\n  else if (tag === 'objid' && state.args)\n    return this._decodeObjid(input, state.args[0], state.args[1], options);\n  else if (tag === 'objid')\n    return this._decodeObjid(input, null, null, options);\n  else if (tag === 'gentime' || tag === 'utctime')\n    return this._decodeTime(input, tag, options);\n  else if (tag === 'null_')\n    return this._decodeNull(input, options);\n  else if (tag === 'bool')\n    return this._decodeBool(input, options);\n  else if (tag === 'objDesc')\n    return this._decodeStr(input, tag, options);\n  else if (tag === 'int' || tag === 'enum')\n    return this._decodeInt(input, state.args && state.args[0], options);\n\n  if (state.use !== null) {\n    return this._getUse(state.use, input._reporterState.obj)\n        ._decode(input, options);\n  } else {\n    return input.error('unknown tag: ' + tag);\n  }\n};\n\nNode.prototype._getUse = function _getUse(entity, obj) {\n\n  var state = this._baseState;\n  // Create altered use decoder if implicit is set\n  state.useDecoder = this._use(entity, obj);\n  assert(state.useDecoder._baseState.parent === null);\n  state.useDecoder = state.useDecoder._baseState.children[0];\n  if (state.implicit !== state.useDecoder._baseState.implicit) {\n    state.useDecoder = state.useDecoder.clone();\n    state.useDecoder._baseState.implicit = state.implicit;\n  }\n  return state.useDecoder;\n};\n\nNode.prototype._decodeChoice = function decodeChoice(input, options) {\n  var state = this._baseState;\n  var result = null;\n  var match = false;\n\n  Object.keys(state.choice).some(function(key) {\n    var save = input.save();\n    var node = state.choice[key];\n    try {\n      var value = node._decode(input, options);\n      if (input.isError(value))\n        return false;\n\n      result = { type: key, value: value };\n      match = true;\n    } catch (e) {\n      input.restore(save);\n      return false;\n    }\n    return true;\n  }, this);\n\n  if (!match)\n    return input.error('Choice not matched');\n\n  return result;\n};\n\n//\n// Encoding\n//\n\nNode.prototype._createEncoderBuffer = function createEncoderBuffer(data) {\n  return new EncoderBuffer(data, this.reporter);\n};\n\nNode.prototype._encode = function encode(data, reporter, parent) {\n  var state = this._baseState;\n  if (state['default'] !== null && state['default'] === data)\n    return;\n\n  var result = this._encodeValue(data, reporter, parent);\n  if (result === undefined)\n    return;\n\n  if (this._skipDefault(result, reporter, parent))\n    return;\n\n  return result;\n};\n\nNode.prototype._encodeValue = function encode(data, reporter, parent) {\n  var state = this._baseState;\n\n  // Decode root node\n  if (state.parent === null)\n    return state.children[0]._encode(data, reporter || new Reporter());\n\n  var result = null;\n\n  // Set reporter to share it with a child class\n  this.reporter = reporter;\n\n  // Check if data is there\n  if (state.optional && data === undefined) {\n    if (state['default'] !== null)\n      data = state['default']\n    else\n      return;\n  }\n\n  // Encode children first\n  var content = null;\n  var primitive = false;\n  if (state.any) {\n    // Anything that was given is translated to buffer\n    result = this._createEncoderBuffer(data);\n  } else if (state.choice) {\n    result = this._encodeChoice(data, reporter);\n  } else if (state.contains) {\n    content = this._getUse(state.contains, parent)._encode(data, reporter);\n    primitive = true;\n  } else if (state.children) {\n    content = state.children.map(function(child) {\n      if (child._baseState.tag === 'null_')\n        return child._encode(null, reporter, data);\n\n      if (child._baseState.key === null)\n        return reporter.error('Child should have a key');\n      var prevKey = reporter.enterKey(child._baseState.key);\n\n      if (typeof data !== 'object')\n        return reporter.error('Child expected, but input is not object');\n\n      var res = child._encode(data[child._baseState.key], reporter, data);\n      reporter.leaveKey(prevKey);\n\n      return res;\n    }, this).filter(function(child) {\n      return child;\n    });\n    content = this._createEncoderBuffer(content);\n  } else {\n    if (state.tag === 'seqof' || state.tag === 'setof') {\n      // TODO(indutny): this should be thrown on DSL level\n      if (!(state.args && state.args.length === 1))\n        return reporter.error('Too many args for : ' + state.tag);\n\n      if (!Array.isArray(data))\n        return reporter.error('seqof/setof, but data is not Array');\n\n      var child = this.clone();\n      child._baseState.implicit = null;\n      content = this._createEncoderBuffer(data.map(function(item) {\n        var state = this._baseState;\n\n        return this._getUse(state.args[0], data)._encode(item, reporter);\n      }, child));\n    } else if (state.use !== null) {\n      result = this._getUse(state.use, parent)._encode(data, reporter);\n    } else {\n      content = this._encodePrimitive(state.tag, data);\n      primitive = true;\n    }\n  }\n\n  // Encode data itself\n  var result;\n  if (!state.any && state.choice === null) {\n    var tag = state.implicit !== null ? state.implicit : state.tag;\n    var cls = state.implicit === null ? 'universal' : 'context';\n\n    if (tag === null) {\n      if (state.use === null)\n        reporter.error('Tag could be omitted only for .use()');\n    } else {\n      if (state.use === null)\n        result = this._encodeComposite(tag, primitive, cls, content);\n    }\n  }\n\n  // Wrap in explicit\n  if (state.explicit !== null)\n    result = this._encodeComposite(state.explicit, false, 'context', result);\n\n  return result;\n};\n\nNode.prototype._encodeChoice = function encodeChoice(data, reporter) {\n  var state = this._baseState;\n\n  var node = state.choice[data.type];\n  if (!node) {\n    assert(\n        false,\n        data.type + ' not found in ' +\n            JSON.stringify(Object.keys(state.choice)));\n  }\n  return node._encode(data.value, reporter);\n};\n\nNode.prototype._encodePrimitive = function encodePrimitive(tag, data) {\n  var state = this._baseState;\n\n  if (/str$/.test(tag))\n    return this._encodeStr(data, tag);\n  else if (tag === 'objid' && state.args)\n    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);\n  else if (tag === 'objid')\n    return this._encodeObjid(data, null, null);\n  else if (tag === 'gentime' || tag === 'utctime')\n    return this._encodeTime(data, tag);\n  else if (tag === 'null_')\n    return this._encodeNull();\n  else if (tag === 'int' || tag === 'enum')\n    return this._encodeInt(data, state.args && state.reverseArgs[0]);\n  else if (tag === 'bool')\n    return this._encodeBool(data);\n  else if (tag === 'objDesc')\n    return this._encodeStr(data, tag);\n  else\n    throw new Error('Unsupported tag: ' + tag);\n};\n\nNode.prototype._isNumstr = function isNumstr(str) {\n  return /^[0-9 ]*$/.test(str);\n};\n\nNode.prototype._isPrintstr = function isPrintstr(str) {\n  return /^[A-Za-z0-9 '\\(\\)\\+,\\-\\.\\/:=\\?]*$/.test(str);\n};\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/base/node.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/reporter.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/reporter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nfunction Reporter(options) {\n  this._reporterState = {\n    obj: null,\n    path: [],\n    options: options || {},\n    errors: []\n  };\n}\nexports.Reporter = Reporter;\n\nReporter.prototype.isError = function isError(obj) {\n  return obj instanceof ReporterError;\n};\n\nReporter.prototype.save = function save() {\n  var state = this._reporterState;\n\n  return { obj: state.obj, pathLen: state.path.length };\n};\n\nReporter.prototype.restore = function restore(data) {\n  var state = this._reporterState;\n\n  state.obj = data.obj;\n  state.path = state.path.slice(0, data.pathLen);\n};\n\nReporter.prototype.enterKey = function enterKey(key) {\n  return this._reporterState.path.push(key);\n};\n\nReporter.prototype.exitKey = function exitKey(index) {\n  var state = this._reporterState;\n\n  state.path = state.path.slice(0, index - 1);\n};\n\nReporter.prototype.leaveKey = function leaveKey(index, key, value) {\n  var state = this._reporterState;\n\n  this.exitKey(index);\n  if (state.obj !== null)\n    state.obj[key] = value;\n};\n\nReporter.prototype.path = function path() {\n  return this._reporterState.path.join('/');\n};\n\nReporter.prototype.enterObject = function enterObject() {\n  var state = this._reporterState;\n\n  var prev = state.obj;\n  state.obj = {};\n  return prev;\n};\n\nReporter.prototype.leaveObject = function leaveObject(prev) {\n  var state = this._reporterState;\n\n  var now = state.obj;\n  state.obj = prev;\n  return now;\n};\n\nReporter.prototype.error = function error(msg) {\n  var err;\n  var state = this._reporterState;\n\n  var inherited = msg instanceof ReporterError;\n  if (inherited) {\n    err = msg;\n  } else {\n    err = new ReporterError(state.path.map(function(elem) {\n      return '[' + JSON.stringify(elem) + ']';\n    }).join(''), msg.message || msg, msg.stack);\n  }\n\n  if (!state.options.partial)\n    throw err;\n\n  if (!inherited)\n    state.errors.push(err);\n\n  return err;\n};\n\nReporter.prototype.wrapResult = function wrapResult(result) {\n  var state = this._reporterState;\n  if (!state.options.partial)\n    return result;\n\n  return {\n    result: this.isError(result) ? null : result,\n    errors: state.errors\n  };\n};\n\nfunction ReporterError(path, msg) {\n  this.path = path;\n  this.rethrow(msg);\n};\ninherits(ReporterError, Error);\n\nReporterError.prototype.rethrow = function rethrow(msg) {\n  this.message = msg + ' at: ' + (this.path || '(shallow)');\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, ReporterError);\n\n  if (!this.stack) {\n    try {\n      // IE only adds stack when thrown\n      throw new Error(this.message);\n    } catch (e) {\n      this.stack = e.stack;\n    }\n  }\n  return this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/base/reporter.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/der.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/der.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var constants = __webpack_require__(/*! ../constants */ \"./node_modules/asn1.js/lib/asn1/constants/index.js\");\n\nexports.tagClass = {\n  0: 'universal',\n  1: 'application',\n  2: 'context',\n  3: 'private'\n};\nexports.tagClassByName = constants._reverse(exports.tagClass);\n\nexports.tag = {\n  0x00: 'end',\n  0x01: 'bool',\n  0x02: 'int',\n  0x03: 'bitstr',\n  0x04: 'octstr',\n  0x05: 'null_',\n  0x06: 'objid',\n  0x07: 'objDesc',\n  0x08: 'external',\n  0x09: 'real',\n  0x0a: 'enum',\n  0x0b: 'embed',\n  0x0c: 'utf8str',\n  0x0d: 'relativeOid',\n  0x10: 'seq',\n  0x11: 'set',\n  0x12: 'numstr',\n  0x13: 'printstr',\n  0x14: 't61str',\n  0x15: 'videostr',\n  0x16: 'ia5str',\n  0x17: 'utctime',\n  0x18: 'gentime',\n  0x19: 'graphstr',\n  0x1a: 'iso646str',\n  0x1b: 'genstr',\n  0x1c: 'unistr',\n  0x1d: 'charstr',\n  0x1e: 'bmpstr'\n};\nexports.tagByName = constants._reverse(exports.tag);\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/constants/der.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var constants = exports;\n\n// Helper\nconstants._reverse = function reverse(map) {\n  var res = {};\n\n  Object.keys(map).forEach(function(key) {\n    // Convert key to integer if it is stringified\n    if ((key | 0) == key)\n      key = key | 0;\n\n    var value = map[key];\n    res[value] = key;\n  });\n\n  return res;\n};\n\nconstants.der = __webpack_require__(/*! ./der */ \"./node_modules/asn1.js/lib/asn1/constants/der.js\");\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/constants/index.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar asn1 = __webpack_require__(/*! ../../asn1 */ \"./node_modules/asn1.js/lib/asn1.js\");\nvar base = asn1.base;\nvar bignum = asn1.bignum;\n\n// Import DER constants\nvar der = asn1.constants.der;\n\nfunction DERDecoder(entity) {\n  this.enc = 'der';\n  this.name = entity.name;\n  this.entity = entity;\n\n  // Construct base tree\n  this.tree = new DERNode();\n  this.tree._init(entity.body);\n};\nmodule.exports = DERDecoder;\n\nDERDecoder.prototype.decode = function decode(data, options) {\n  if (!(data instanceof base.DecoderBuffer))\n    data = new base.DecoderBuffer(data, options);\n\n  return this.tree._decode(data, options);\n};\n\n// Tree methods\n\nfunction DERNode(parent) {\n  base.Node.call(this, 'der', parent);\n}\ninherits(DERNode, base.Node);\n\nDERNode.prototype._peekTag = function peekTag(buffer, tag, any) {\n  if (buffer.isEmpty())\n    return false;\n\n  var state = buffer.save();\n  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: \"' + tag + '\"');\n  if (buffer.isError(decodedTag))\n    return decodedTag;\n\n  buffer.restore(state);\n\n  return decodedTag.tag === tag || decodedTag.tagStr === tag ||\n    (decodedTag.tagStr + 'of') === tag || any;\n};\n\nDERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {\n  var decodedTag = derDecodeTag(buffer,\n                                'Failed to decode tag of \"' + tag + '\"');\n  if (buffer.isError(decodedTag))\n    return decodedTag;\n\n  var len = derDecodeLen(buffer,\n                         decodedTag.primitive,\n                         'Failed to get length of \"' + tag + '\"');\n\n  // Failure\n  if (buffer.isError(len))\n    return len;\n\n  if (!any &&\n      decodedTag.tag !== tag &&\n      decodedTag.tagStr !== tag &&\n      decodedTag.tagStr + 'of' !== tag) {\n    return buffer.error('Failed to match tag: \"' + tag + '\"');\n  }\n\n  if (decodedTag.primitive || len !== null)\n    return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\n\n  // Indefinite length... find END tag\n  var state = buffer.save();\n  var res = this._skipUntilEnd(\n      buffer,\n      'Failed to skip indefinite length body: \"' + this.tag + '\"');\n  if (buffer.isError(res))\n    return res;\n\n  len = buffer.offset - state.offset;\n  buffer.restore(state);\n  return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\n};\n\nDERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {\n  while (true) {\n    var tag = derDecodeTag(buffer, fail);\n    if (buffer.isError(tag))\n      return tag;\n    var len = derDecodeLen(buffer, tag.primitive, fail);\n    if (buffer.isError(len))\n      return len;\n\n    var res;\n    if (tag.primitive || len !== null)\n      res = buffer.skip(len)\n    else\n      res = this._skipUntilEnd(buffer, fail);\n\n    // Failure\n    if (buffer.isError(res))\n      return res;\n\n    if (tag.tagStr === 'end')\n      break;\n  }\n};\n\nDERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,\n                                                    options) {\n  var result = [];\n  while (!buffer.isEmpty()) {\n    var possibleEnd = this._peekTag(buffer, 'end');\n    if (buffer.isError(possibleEnd))\n      return possibleEnd;\n\n    var res = decoder.decode(buffer, 'der', options);\n    if (buffer.isError(res) && possibleEnd)\n      break;\n    result.push(res);\n  }\n  return result;\n};\n\nDERNode.prototype._decodeStr = function decodeStr(buffer, tag) {\n  if (tag === 'bitstr') {\n    var unused = buffer.readUInt8();\n    if (buffer.isError(unused))\n      return unused;\n    return { unused: unused, data: buffer.raw() };\n  } else if (tag === 'bmpstr') {\n    var raw = buffer.raw();\n    if (raw.length % 2 === 1)\n      return buffer.error('Decoding of string type: bmpstr length mismatch');\n\n    var str = '';\n    for (var i = 0; i < raw.length / 2; i++) {\n      str += String.fromCharCode(raw.readUInt16BE(i * 2));\n    }\n    return str;\n  } else if (tag === 'numstr') {\n    var numstr = buffer.raw().toString('ascii');\n    if (!this._isNumstr(numstr)) {\n      return buffer.error('Decoding of string type: ' +\n                          'numstr unsupported characters');\n    }\n    return numstr;\n  } else if (tag === 'octstr') {\n    return buffer.raw();\n  } else if (tag === 'objDesc') {\n    return buffer.raw();\n  } else if (tag === 'printstr') {\n    var printstr = buffer.raw().toString('ascii');\n    if (!this._isPrintstr(printstr)) {\n      return buffer.error('Decoding of string type: ' +\n                          'printstr unsupported characters');\n    }\n    return printstr;\n  } else if (/str$/.test(tag)) {\n    return buffer.raw().toString();\n  } else {\n    return buffer.error('Decoding of string type: ' + tag + ' unsupported');\n  }\n};\n\nDERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {\n  var result;\n  var identifiers = [];\n  var ident = 0;\n  while (!buffer.isEmpty()) {\n    var subident = buffer.readUInt8();\n    ident <<= 7;\n    ident |= subident & 0x7f;\n    if ((subident & 0x80) === 0) {\n      identifiers.push(ident);\n      ident = 0;\n    }\n  }\n  if (subident & 0x80)\n    identifiers.push(ident);\n\n  var first = (identifiers[0] / 40) | 0;\n  var second = identifiers[0] % 40;\n\n  if (relative)\n    result = identifiers;\n  else\n    result = [first, second].concat(identifiers.slice(1));\n\n  if (values) {\n    var tmp = values[result.join(' ')];\n    if (tmp === undefined)\n      tmp = values[result.join('.')];\n    if (tmp !== undefined)\n      result = tmp;\n  }\n\n  return result;\n};\n\nDERNode.prototype._decodeTime = function decodeTime(buffer, tag) {\n  var str = buffer.raw().toString();\n  if (tag === 'gentime') {\n    var year = str.slice(0, 4) | 0;\n    var mon = str.slice(4, 6) | 0;\n    var day = str.slice(6, 8) | 0;\n    var hour = str.slice(8, 10) | 0;\n    var min = str.slice(10, 12) | 0;\n    var sec = str.slice(12, 14) | 0;\n  } else if (tag === 'utctime') {\n    var year = str.slice(0, 2) | 0;\n    var mon = str.slice(2, 4) | 0;\n    var day = str.slice(4, 6) | 0;\n    var hour = str.slice(6, 8) | 0;\n    var min = str.slice(8, 10) | 0;\n    var sec = str.slice(10, 12) | 0;\n    if (year < 70)\n      year = 2000 + year;\n    else\n      year = 1900 + year;\n  } else {\n    return buffer.error('Decoding ' + tag + ' time is not supported yet');\n  }\n\n  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);\n};\n\nDERNode.prototype._decodeNull = function decodeNull(buffer) {\n  return null;\n};\n\nDERNode.prototype._decodeBool = function decodeBool(buffer) {\n  var res = buffer.readUInt8();\n  if (buffer.isError(res))\n    return res;\n  else\n    return res !== 0;\n};\n\nDERNode.prototype._decodeInt = function decodeInt(buffer, values) {\n  // Bigint, return as it is (assume big endian)\n  var raw = buffer.raw();\n  var res = new bignum(raw);\n\n  if (values)\n    res = values[res.toString(10)] || res;\n\n  return res;\n};\n\nDERNode.prototype._use = function use(entity, obj) {\n  if (typeof entity === 'function')\n    entity = entity(obj);\n  return entity._getDecoder('der').tree;\n};\n\n// Utility methods\n\nfunction derDecodeTag(buf, fail) {\n  var tag = buf.readUInt8(fail);\n  if (buf.isError(tag))\n    return tag;\n\n  var cls = der.tagClass[tag >> 6];\n  var primitive = (tag & 0x20) === 0;\n\n  // Multi-octet tag - load\n  if ((tag & 0x1f) === 0x1f) {\n    var oct = tag;\n    tag = 0;\n    while ((oct & 0x80) === 0x80) {\n      oct = buf.readUInt8(fail);\n      if (buf.isError(oct))\n        return oct;\n\n      tag <<= 7;\n      tag |= oct & 0x7f;\n    }\n  } else {\n    tag &= 0x1f;\n  }\n  var tagStr = der.tag[tag];\n\n  return {\n    cls: cls,\n    primitive: primitive,\n    tag: tag,\n    tagStr: tagStr\n  };\n}\n\nfunction derDecodeLen(buf, primitive, fail) {\n  var len = buf.readUInt8(fail);\n  if (buf.isError(len))\n    return len;\n\n  // Indefinite form\n  if (!primitive && len === 0x80)\n    return null;\n\n  // Definite form\n  if ((len & 0x80) === 0) {\n    // Short form\n    return len;\n  }\n\n  // Long form\n  var num = len & 0x7f;\n  if (num > 4)\n    return buf.error('length octect is too long');\n\n  len = 0;\n  for (var i = 0; i < num; i++) {\n    len <<= 8;\n    var j = buf.readUInt8(fail);\n    if (buf.isError(j))\n      return j;\n    len |= j;\n  }\n\n  return len;\n}\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/decoders/der.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var decoders = exports;\n\ndecoders.der = __webpack_require__(/*! ./der */ \"./node_modules/asn1.js/lib/asn1/decoders/der.js\");\ndecoders.pem = __webpack_require__(/*! ./pem */ \"./node_modules/asn1.js/lib/asn1/decoders/pem.js\");\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/decoders/index.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar DERDecoder = __webpack_require__(/*! ./der */ \"./node_modules/asn1.js/lib/asn1/decoders/der.js\");\n\nfunction PEMDecoder(entity) {\n  DERDecoder.call(this, entity);\n  this.enc = 'pem';\n};\ninherits(PEMDecoder, DERDecoder);\nmodule.exports = PEMDecoder;\n\nPEMDecoder.prototype.decode = function decode(data, options) {\n  var lines = data.toString().split(/[\\r\\n]+/g);\n\n  var label = options.label.toUpperCase();\n\n  var re = /^-----(BEGIN|END) ([^-]+)-----$/;\n  var start = -1;\n  var end = -1;\n  for (var i = 0; i < lines.length; i++) {\n    var match = lines[i].match(re);\n    if (match === null)\n      continue;\n\n    if (match[2] !== label)\n      continue;\n\n    if (start === -1) {\n      if (match[1] !== 'BEGIN')\n        break;\n      start = i;\n    } else {\n      if (match[1] !== 'END')\n        break;\n      end = i;\n      break;\n    }\n  }\n  if (start === -1 || end === -1)\n    throw new Error('PEM section not found for: ' + label);\n\n  var base64 = lines.slice(start + 1, end).join('');\n  // Remove excessive symbols\n  base64.replace(/[^a-z0-9\\+\\/=]+/gi, '');\n\n  var input = new Buffer(base64, 'base64');\n  return DERDecoder.prototype.decode.call(this, input, options);\n};\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/decoders/pem.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar asn1 = __webpack_require__(/*! ../../asn1 */ \"./node_modules/asn1.js/lib/asn1.js\");\nvar base = asn1.base;\n\n// Import DER constants\nvar der = asn1.constants.der;\n\nfunction DEREncoder(entity) {\n  this.enc = 'der';\n  this.name = entity.name;\n  this.entity = entity;\n\n  // Construct base tree\n  this.tree = new DERNode();\n  this.tree._init(entity.body);\n};\nmodule.exports = DEREncoder;\n\nDEREncoder.prototype.encode = function encode(data, reporter) {\n  return this.tree._encode(data, reporter).join();\n};\n\n// Tree methods\n\nfunction DERNode(parent) {\n  base.Node.call(this, 'der', parent);\n}\ninherits(DERNode, base.Node);\n\nDERNode.prototype._encodeComposite = function encodeComposite(tag,\n                                                              primitive,\n                                                              cls,\n                                                              content) {\n  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);\n\n  // Short form\n  if (content.length < 0x80) {\n    var header = new Buffer(2);\n    header[0] = encodedTag;\n    header[1] = content.length;\n    return this._createEncoderBuffer([ header, content ]);\n  }\n\n  // Long form\n  // Count octets required to store length\n  var lenOctets = 1;\n  for (var i = content.length; i >= 0x100; i >>= 8)\n    lenOctets++;\n\n  var header = new Buffer(1 + 1 + lenOctets);\n  header[0] = encodedTag;\n  header[1] = 0x80 | lenOctets;\n\n  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)\n    header[i] = j & 0xff;\n\n  return this._createEncoderBuffer([ header, content ]);\n};\n\nDERNode.prototype._encodeStr = function encodeStr(str, tag) {\n  if (tag === 'bitstr') {\n    return this._createEncoderBuffer([ str.unused | 0, str.data ]);\n  } else if (tag === 'bmpstr') {\n    var buf = new Buffer(str.length * 2);\n    for (var i = 0; i < str.length; i++) {\n      buf.writeUInt16BE(str.charCodeAt(i), i * 2);\n    }\n    return this._createEncoderBuffer(buf);\n  } else if (tag === 'numstr') {\n    if (!this._isNumstr(str)) {\n      return this.reporter.error('Encoding of string type: numstr supports ' +\n                                 'only digits and space');\n    }\n    return this._createEncoderBuffer(str);\n  } else if (tag === 'printstr') {\n    if (!this._isPrintstr(str)) {\n      return this.reporter.error('Encoding of string type: printstr supports ' +\n                                 'only latin upper and lower case letters, ' +\n                                 'digits, space, apostrophe, left and rigth ' +\n                                 'parenthesis, plus sign, comma, hyphen, ' +\n                                 'dot, slash, colon, equal sign, ' +\n                                 'question mark');\n    }\n    return this._createEncoderBuffer(str);\n  } else if (/str$/.test(tag)) {\n    return this._createEncoderBuffer(str);\n  } else if (tag === 'objDesc') {\n    return this._createEncoderBuffer(str);\n  } else {\n    return this.reporter.error('Encoding of string type: ' + tag +\n                               ' unsupported');\n  }\n};\n\nDERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {\n  if (typeof id === 'string') {\n    if (!values)\n      return this.reporter.error('string objid given, but no values map found');\n    if (!values.hasOwnProperty(id))\n      return this.reporter.error('objid not found in values map');\n    id = values[id].split(/[\\s\\.]+/g);\n    for (var i = 0; i < id.length; i++)\n      id[i] |= 0;\n  } else if (Array.isArray(id)) {\n    id = id.slice();\n    for (var i = 0; i < id.length; i++)\n      id[i] |= 0;\n  }\n\n  if (!Array.isArray(id)) {\n    return this.reporter.error('objid() should be either array or string, ' +\n                               'got: ' + JSON.stringify(id));\n  }\n\n  if (!relative) {\n    if (id[1] >= 40)\n      return this.reporter.error('Second objid identifier OOB');\n    id.splice(0, 2, id[0] * 40 + id[1]);\n  }\n\n  // Count number of octets\n  var size = 0;\n  for (var i = 0; i < id.length; i++) {\n    var ident = id[i];\n    for (size++; ident >= 0x80; ident >>= 7)\n      size++;\n  }\n\n  var objid = new Buffer(size);\n  var offset = objid.length - 1;\n  for (var i = id.length - 1; i >= 0; i--) {\n    var ident = id[i];\n    objid[offset--] = ident & 0x7f;\n    while ((ident >>= 7) > 0)\n      objid[offset--] = 0x80 | (ident & 0x7f);\n  }\n\n  return this._createEncoderBuffer(objid);\n};\n\nfunction two(num) {\n  if (num < 10)\n    return '0' + num;\n  else\n    return num;\n}\n\nDERNode.prototype._encodeTime = function encodeTime(time, tag) {\n  var str;\n  var date = new Date(time);\n\n  if (tag === 'gentime') {\n    str = [\n      two(date.getFullYear()),\n      two(date.getUTCMonth() + 1),\n      two(date.getUTCDate()),\n      two(date.getUTCHours()),\n      two(date.getUTCMinutes()),\n      two(date.getUTCSeconds()),\n      'Z'\n    ].join('');\n  } else if (tag === 'utctime') {\n    str = [\n      two(date.getFullYear() % 100),\n      two(date.getUTCMonth() + 1),\n      two(date.getUTCDate()),\n      two(date.getUTCHours()),\n      two(date.getUTCMinutes()),\n      two(date.getUTCSeconds()),\n      'Z'\n    ].join('');\n  } else {\n    this.reporter.error('Encoding ' + tag + ' time is not supported yet');\n  }\n\n  return this._encodeStr(str, 'octstr');\n};\n\nDERNode.prototype._encodeNull = function encodeNull() {\n  return this._createEncoderBuffer('');\n};\n\nDERNode.prototype._encodeInt = function encodeInt(num, values) {\n  if (typeof num === 'string') {\n    if (!values)\n      return this.reporter.error('String int or enum given, but no values map');\n    if (!values.hasOwnProperty(num)) {\n      return this.reporter.error('Values map doesn\\'t contain: ' +\n                                 JSON.stringify(num));\n    }\n    num = values[num];\n  }\n\n  // Bignum, assume big endian\n  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {\n    var numArray = num.toArray();\n    if (!num.sign && numArray[0] & 0x80) {\n      numArray.unshift(0);\n    }\n    num = new Buffer(numArray);\n  }\n\n  if (Buffer.isBuffer(num)) {\n    var size = num.length;\n    if (num.length === 0)\n      size++;\n\n    var out = new Buffer(size);\n    num.copy(out);\n    if (num.length === 0)\n      out[0] = 0\n    return this._createEncoderBuffer(out);\n  }\n\n  if (num < 0x80)\n    return this._createEncoderBuffer(num);\n\n  if (num < 0x100)\n    return this._createEncoderBuffer([0, num]);\n\n  var size = 1;\n  for (var i = num; i >= 0x100; i >>= 8)\n    size++;\n\n  var out = new Array(size);\n  for (var i = out.length - 1; i >= 0; i--) {\n    out[i] = num & 0xff;\n    num >>= 8;\n  }\n  if(out[0] & 0x80) {\n    out.unshift(0);\n  }\n\n  return this._createEncoderBuffer(new Buffer(out));\n};\n\nDERNode.prototype._encodeBool = function encodeBool(value) {\n  return this._createEncoderBuffer(value ? 0xff : 0);\n};\n\nDERNode.prototype._use = function use(entity, obj) {\n  if (typeof entity === 'function')\n    entity = entity(obj);\n  return entity._getEncoder('der').tree;\n};\n\nDERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {\n  var state = this._baseState;\n  var i;\n  if (state['default'] === null)\n    return false;\n\n  var data = dataBuffer.join();\n  if (state.defaultBuffer === undefined)\n    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();\n\n  if (data.length !== state.defaultBuffer.length)\n    return false;\n\n  for (i=0; i < data.length; i++)\n    if (data[i] !== state.defaultBuffer[i])\n      return false;\n\n  return true;\n};\n\n// Utility methods\n\nfunction encodeTag(tag, primitive, cls, reporter) {\n  var res;\n\n  if (tag === 'seqof')\n    tag = 'seq';\n  else if (tag === 'setof')\n    tag = 'set';\n\n  if (der.tagByName.hasOwnProperty(tag))\n    res = der.tagByName[tag];\n  else if (typeof tag === 'number' && (tag | 0) === tag)\n    res = tag;\n  else\n    return reporter.error('Unknown tag: ' + tag);\n\n  if (res >= 0x1f)\n    return reporter.error('Multi-octet tag encoding unsupported');\n\n  if (!primitive)\n    res |= 0x20;\n\n  res |= (der.tagClassByName[cls || 'universal'] << 6);\n\n  return res;\n}\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/encoders/der.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var encoders = exports;\n\nencoders.der = __webpack_require__(/*! ./der */ \"./node_modules/asn1.js/lib/asn1/encoders/der.js\");\nencoders.pem = __webpack_require__(/*! ./pem */ \"./node_modules/asn1.js/lib/asn1/encoders/pem.js\");\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/encoders/index.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar DEREncoder = __webpack_require__(/*! ./der */ \"./node_modules/asn1.js/lib/asn1/encoders/der.js\");\n\nfunction PEMEncoder(entity) {\n  DEREncoder.call(this, entity);\n  this.enc = 'pem';\n};\ninherits(PEMEncoder, DEREncoder);\nmodule.exports = PEMEncoder;\n\nPEMEncoder.prototype.encode = function encode(data, options) {\n  var buf = DEREncoder.prototype.encode.call(this, data);\n\n  var p = buf.toString('base64');\n  var out = [ '-----BEGIN ' + options.label + '-----' ];\n  for (var i = 0; i < p.length; i += 64)\n    out.push(p.slice(i, i + 64));\n  out.push('-----END ' + options.label + '-----');\n  return out.join('\\n');\n};\n\n\n//# sourceURL=webpack:///./node_modules/asn1.js/lib/asn1/encoders/pem.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/bn.js/lib/bn.js":
/*!**************************************!*\
  !*** ./node_modules/bn.js/lib/bn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    Buffer = __webpack_require__(/*! buffer */ 2).Buffer;\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this.strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [ number & 0x3ffffff ];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [ 0 ];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this.strip();\n  };\n\n  function parseHex (str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r <<= 4;\n\n      // 'a' - 'f'\n      if (c >= 49 && c <= 54) {\n        r |= c - 49 + 0xa;\n\n      // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        r |= c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r |= c & 0xf;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    // Scan 24-bit chunks and add them to the number\n    var off = 0;\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n      off += 24;\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n    }\n    this.strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        r += c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        r += c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r += c;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [ 0 ];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype.strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  BN.prototype.inspect = function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  };\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16);\n  };\n\n  BN.prototype.toBuffer = function toBuffer (endian, length) {\n    assert(typeof Buffer !== 'undefined');\n    return this.toArrayLike(Buffer, endian, length);\n  };\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    this.strip();\n    var littleEndian = endian === 'le';\n    var res = new ArrayType(reqLength);\n\n    var b, i;\n    var q = this.clone();\n    if (!littleEndian) {\n      // Assume big-endian\n      for (i = 0; i < reqLength - byteLength; i++) {\n        res[i] = 0;\n      }\n\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[reqLength - i - 1] = b;\n      }\n    } else {\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[i] = b;\n      }\n\n      for (; i < reqLength; i++) {\n        res[i] = 0;\n      }\n    }\n\n    return res;\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this.strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this.strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this.strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    var fftm = new FFTM();\n    return fftm.mulp(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out.strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this.strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) < num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this.strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this.strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q.strip();\n    }\n    a.strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modn = function modn (num) {\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return acc;\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this.strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      r.strip();\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n    return a.umod(this.m)._forceRed(this);\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})(typeof module === 'undefined' || module, this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/bn.js/lib/bn.js?");

/***/ }),

/***/ "./node_modules/brorand/index.js":
/*!***************************************!*\
  !*** ./node_modules/brorand/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var r;\n\nmodule.exports = function rand(len) {\n  if (!r)\n    r = new Rand(null);\n\n  return r.generate(len);\n};\n\nfunction Rand(rand) {\n  this.rand = rand;\n}\nmodule.exports.Rand = Rand;\n\nRand.prototype.generate = function generate(len) {\n  return this._rand(len);\n};\n\n// Emulate crypto API using randy\nRand.prototype._rand = function _rand(n) {\n  if (this.rand.getBytes)\n    return this.rand.getBytes(n);\n\n  var res = new Uint8Array(n);\n  for (var i = 0; i < res.length; i++)\n    res[i] = this.rand.getByte();\n  return res;\n};\n\nif (typeof self === 'object') {\n  if (self.crypto && self.crypto.getRandomValues) {\n    // Modern browsers\n    Rand.prototype._rand = function _rand(n) {\n      var arr = new Uint8Array(n);\n      self.crypto.getRandomValues(arr);\n      return arr;\n    };\n  } else if (self.msCrypto && self.msCrypto.getRandomValues) {\n    // IE\n    Rand.prototype._rand = function _rand(n) {\n      var arr = new Uint8Array(n);\n      self.msCrypto.getRandomValues(arr);\n      return arr;\n    };\n\n  // Safari's WebWorkers do not have `crypto`\n  } else if (typeof window === 'object') {\n    // Old junk\n    Rand.prototype._rand = function() {\n      throw new Error('Not implemented yet');\n    };\n  }\n} else {\n  // Node.js or Web worker with no crypto support\n  try {\n    var crypto = __webpack_require__(/*! crypto */ 3);\n    if (typeof crypto.randomBytes !== 'function')\n      throw new Error('Not supported');\n\n    Rand.prototype._rand = function _rand(n) {\n      return crypto.randomBytes(n);\n    };\n  } catch (e) {\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/brorand/index.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/aes.js":
/*!********************************************!*\
  !*** ./node_modules/browserify-aes/aes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// based on the aes implimentation in triple sec\n// https://github.com/keybase/triplesec\n// which is in turn based on the one from crypto-js\n// https://code.google.com/p/crypto-js/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nfunction asUInt32Array (buf) {\n  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n\n  var len = (buf.length / 4) | 0\n  var out = new Array(len)\n\n  for (var i = 0; i < len; i++) {\n    out[i] = buf.readUInt32BE(i * 4)\n  }\n\n  return out\n}\n\nfunction scrubVec (v) {\n  for (var i = 0; i < v.length; v++) {\n    v[i] = 0\n  }\n}\n\nfunction cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {\n  var SUB_MIX0 = SUB_MIX[0]\n  var SUB_MIX1 = SUB_MIX[1]\n  var SUB_MIX2 = SUB_MIX[2]\n  var SUB_MIX3 = SUB_MIX[3]\n\n  var s0 = M[0] ^ keySchedule[0]\n  var s1 = M[1] ^ keySchedule[1]\n  var s2 = M[2] ^ keySchedule[2]\n  var s3 = M[3] ^ keySchedule[3]\n  var t0, t1, t2, t3\n  var ksRow = 4\n\n  for (var round = 1; round < nRounds; round++) {\n    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]\n    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]\n    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]\n    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]\n    s0 = t0\n    s1 = t1\n    s2 = t2\n    s3 = t3\n  }\n\n  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]\n  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]\n  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]\n  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]\n  t0 = t0 >>> 0\n  t1 = t1 >>> 0\n  t2 = t2 >>> 0\n  t3 = t3 >>> 0\n\n  return [t0, t1, t2, t3]\n}\n\n// AES constants\nvar RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]\nvar G = (function () {\n  // Compute double table\n  var d = new Array(256)\n  for (var j = 0; j < 256; j++) {\n    if (j < 128) {\n      d[j] = j << 1\n    } else {\n      d[j] = (j << 1) ^ 0x11b\n    }\n  }\n\n  var SBOX = []\n  var INV_SBOX = []\n  var SUB_MIX = [[], [], [], []]\n  var INV_SUB_MIX = [[], [], [], []]\n\n  // Walk GF(2^8)\n  var x = 0\n  var xi = 0\n  for (var i = 0; i < 256; ++i) {\n    // Compute sbox\n    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)\n    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63\n    SBOX[x] = sx\n    INV_SBOX[sx] = x\n\n    // Compute multiplication\n    var x2 = d[x]\n    var x4 = d[x2]\n    var x8 = d[x4]\n\n    // Compute sub bytes, mix columns tables\n    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)\n    SUB_MIX[0][x] = (t << 24) | (t >>> 8)\n    SUB_MIX[1][x] = (t << 16) | (t >>> 16)\n    SUB_MIX[2][x] = (t << 8) | (t >>> 24)\n    SUB_MIX[3][x] = t\n\n    // Compute inv sub bytes, inv mix columns tables\n    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)\n    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)\n    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)\n    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)\n    INV_SUB_MIX[3][sx] = t\n\n    if (x === 0) {\n      x = xi = 1\n    } else {\n      x = x2 ^ d[d[d[x8 ^ x2]]]\n      xi ^= d[d[xi]]\n    }\n  }\n\n  return {\n    SBOX: SBOX,\n    INV_SBOX: INV_SBOX,\n    SUB_MIX: SUB_MIX,\n    INV_SUB_MIX: INV_SUB_MIX\n  }\n})()\n\nfunction AES (key) {\n  this._key = asUInt32Array(key)\n  this._reset()\n}\n\nAES.blockSize = 4 * 4\nAES.keySize = 256 / 8\nAES.prototype.blockSize = AES.blockSize\nAES.prototype.keySize = AES.keySize\nAES.prototype._reset = function () {\n  var keyWords = this._key\n  var keySize = keyWords.length\n  var nRounds = keySize + 6\n  var ksRows = (nRounds + 1) * 4\n\n  var keySchedule = []\n  for (var k = 0; k < keySize; k++) {\n    keySchedule[k] = keyWords[k]\n  }\n\n  for (k = keySize; k < ksRows; k++) {\n    var t = keySchedule[k - 1]\n\n    if (k % keySize === 0) {\n      t = (t << 8) | (t >>> 24)\n      t =\n        (G.SBOX[t >>> 24] << 24) |\n        (G.SBOX[(t >>> 16) & 0xff] << 16) |\n        (G.SBOX[(t >>> 8) & 0xff] << 8) |\n        (G.SBOX[t & 0xff])\n\n      t ^= RCON[(k / keySize) | 0] << 24\n    } else if (keySize > 6 && k % keySize === 4) {\n      t =\n        (G.SBOX[t >>> 24] << 24) |\n        (G.SBOX[(t >>> 16) & 0xff] << 16) |\n        (G.SBOX[(t >>> 8) & 0xff] << 8) |\n        (G.SBOX[t & 0xff])\n    }\n\n    keySchedule[k] = keySchedule[k - keySize] ^ t\n  }\n\n  var invKeySchedule = []\n  for (var ik = 0; ik < ksRows; ik++) {\n    var ksR = ksRows - ik\n    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]\n\n    if (ik < 4 || ksR <= 4) {\n      invKeySchedule[ik] = tt\n    } else {\n      invKeySchedule[ik] =\n        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^\n        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^\n        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^\n        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]\n    }\n  }\n\n  this._nRounds = nRounds\n  this._keySchedule = keySchedule\n  this._invKeySchedule = invKeySchedule\n}\n\nAES.prototype.encryptBlockRaw = function (M) {\n  M = asUInt32Array(M)\n  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)\n}\n\nAES.prototype.encryptBlock = function (M) {\n  var out = this.encryptBlockRaw(M)\n  var buf = Buffer.allocUnsafe(16)\n  buf.writeUInt32BE(out[0], 0)\n  buf.writeUInt32BE(out[1], 4)\n  buf.writeUInt32BE(out[2], 8)\n  buf.writeUInt32BE(out[3], 12)\n  return buf\n}\n\nAES.prototype.decryptBlock = function (M) {\n  M = asUInt32Array(M)\n\n  // swap\n  var m1 = M[1]\n  M[1] = M[3]\n  M[3] = m1\n\n  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)\n  var buf = Buffer.allocUnsafe(16)\n  buf.writeUInt32BE(out[0], 0)\n  buf.writeUInt32BE(out[3], 4)\n  buf.writeUInt32BE(out[2], 8)\n  buf.writeUInt32BE(out[1], 12)\n  return buf\n}\n\nAES.prototype.scrub = function () {\n  scrubVec(this._keySchedule)\n  scrubVec(this._invKeySchedule)\n  scrubVec(this._key)\n}\n\nmodule.exports.AES = AES\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/aes.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/authCipher.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/authCipher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var aes = __webpack_require__(/*! ./aes */ \"./node_modules/browserify-aes/aes.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar Transform = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar GHASH = __webpack_require__(/*! ./ghash */ \"./node_modules/browserify-aes/ghash.js\")\nvar xor = __webpack_require__(/*! buffer-xor */ \"./node_modules/buffer-xor/index.js\")\nvar incr32 = __webpack_require__(/*! ./incr32 */ \"./node_modules/browserify-aes/incr32.js\")\n\nfunction xorTest (a, b) {\n  var out = 0\n  if (a.length !== b.length) out++\n\n  var len = Math.min(a.length, b.length)\n  for (var i = 0; i < len; ++i) {\n    out += (a[i] ^ b[i])\n  }\n\n  return out\n}\n\nfunction calcIv (self, iv, ck) {\n  if (iv.length === 12) {\n    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])\n    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])\n  }\n  var ghash = new GHASH(ck)\n  var len = iv.length\n  var toPad = len % 16\n  ghash.update(iv)\n  if (toPad) {\n    toPad = 16 - toPad\n    ghash.update(Buffer.alloc(toPad, 0))\n  }\n  ghash.update(Buffer.alloc(8, 0))\n  var ivBits = len * 8\n  var tail = Buffer.alloc(8)\n  tail.writeUIntBE(ivBits, 0, 8)\n  ghash.update(tail)\n  self._finID = ghash.state\n  var out = Buffer.from(self._finID)\n  incr32(out)\n  return out\n}\nfunction StreamCipher (mode, key, iv, decrypt) {\n  Transform.call(this)\n\n  var h = Buffer.alloc(4, 0)\n\n  this._cipher = new aes.AES(key)\n  var ck = this._cipher.encryptBlock(h)\n  this._ghash = new GHASH(ck)\n  iv = calcIv(this, iv, ck)\n\n  this._prev = Buffer.from(iv)\n  this._cache = Buffer.allocUnsafe(0)\n  this._secCache = Buffer.allocUnsafe(0)\n  this._decrypt = decrypt\n  this._alen = 0\n  this._len = 0\n  this._mode = mode\n\n  this._authTag = null\n  this._called = false\n}\n\ninherits(StreamCipher, Transform)\n\nStreamCipher.prototype._update = function (chunk) {\n  if (!this._called && this._alen) {\n    var rump = 16 - (this._alen % 16)\n    if (rump < 16) {\n      rump = Buffer.alloc(rump, 0)\n      this._ghash.update(rump)\n    }\n  }\n\n  this._called = true\n  var out = this._mode.encrypt(this, chunk)\n  if (this._decrypt) {\n    this._ghash.update(chunk)\n  } else {\n    this._ghash.update(out)\n  }\n  this._len += chunk.length\n  return out\n}\n\nStreamCipher.prototype._final = function () {\n  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')\n\n  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))\n  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')\n\n  this._authTag = tag\n  this._cipher.scrub()\n}\n\nStreamCipher.prototype.getAuthTag = function getAuthTag () {\n  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')\n\n  return this._authTag\n}\n\nStreamCipher.prototype.setAuthTag = function setAuthTag (tag) {\n  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')\n\n  this._authTag = tag\n}\n\nStreamCipher.prototype.setAAD = function setAAD (buf) {\n  if (this._called) throw new Error('Attempting to set AAD in unsupported state')\n\n  this._ghash.update(buf)\n  this._alen += buf.length\n}\n\nmodule.exports = StreamCipher\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/authCipher.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/browser.js":
/*!************************************************!*\
  !*** ./node_modules/browserify-aes/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ciphers = __webpack_require__(/*! ./encrypter */ \"./node_modules/browserify-aes/encrypter.js\")\nvar deciphers = __webpack_require__(/*! ./decrypter */ \"./node_modules/browserify-aes/decrypter.js\")\nvar modes = __webpack_require__(/*! ./modes/list.json */ \"./node_modules/browserify-aes/modes/list.json\")\n\nfunction getCiphers () {\n  return Object.keys(modes)\n}\n\nexports.createCipher = exports.Cipher = ciphers.createCipher\nexports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv\nexports.createDecipher = exports.Decipher = deciphers.createDecipher\nexports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv\nexports.listCiphers = exports.getCiphers = getCiphers\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/browser.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/decrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/decrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var AuthCipher = __webpack_require__(/*! ./authCipher */ \"./node_modules/browserify-aes/authCipher.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar MODES = __webpack_require__(/*! ./modes */ \"./node_modules/browserify-aes/modes/index.js\")\nvar StreamCipher = __webpack_require__(/*! ./streamCipher */ \"./node_modules/browserify-aes/streamCipher.js\")\nvar Transform = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar aes = __webpack_require__(/*! ./aes */ \"./node_modules/browserify-aes/aes.js\")\nvar ebtk = __webpack_require__(/*! evp_bytestokey */ \"./node_modules/evp_bytestokey/index.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\n\nfunction Decipher (mode, key, iv) {\n  Transform.call(this)\n\n  this._cache = new Splitter()\n  this._last = void 0\n  this._cipher = new aes.AES(key)\n  this._prev = Buffer.from(iv)\n  this._mode = mode\n  this._autopadding = true\n}\n\ninherits(Decipher, Transform)\n\nDecipher.prototype._update = function (data) {\n  this._cache.add(data)\n  var chunk\n  var thing\n  var out = []\n  while ((chunk = this._cache.get(this._autopadding))) {\n    thing = this._mode.decrypt(this, chunk)\n    out.push(thing)\n  }\n  return Buffer.concat(out)\n}\n\nDecipher.prototype._final = function () {\n  var chunk = this._cache.flush()\n  if (this._autopadding) {\n    return unpad(this._mode.decrypt(this, chunk))\n  } else if (chunk) {\n    throw new Error('data not multiple of block length')\n  }\n}\n\nDecipher.prototype.setAutoPadding = function (setTo) {\n  this._autopadding = !!setTo\n  return this\n}\n\nfunction Splitter () {\n  this.cache = Buffer.allocUnsafe(0)\n}\n\nSplitter.prototype.add = function (data) {\n  this.cache = Buffer.concat([this.cache, data])\n}\n\nSplitter.prototype.get = function (autoPadding) {\n  var out\n  if (autoPadding) {\n    if (this.cache.length > 16) {\n      out = this.cache.slice(0, 16)\n      this.cache = this.cache.slice(16)\n      return out\n    }\n  } else {\n    if (this.cache.length >= 16) {\n      out = this.cache.slice(0, 16)\n      this.cache = this.cache.slice(16)\n      return out\n    }\n  }\n\n  return null\n}\n\nSplitter.prototype.flush = function () {\n  if (this.cache.length) return this.cache\n}\n\nfunction unpad (last) {\n  var padded = last[15]\n  if (padded < 1 || padded > 16) {\n    throw new Error('unable to decrypt data')\n  }\n  var i = -1\n  while (++i < padded) {\n    if (last[(i + (16 - padded))] !== padded) {\n      throw new Error('unable to decrypt data')\n    }\n  }\n  if (padded === 16) return\n\n  return last.slice(0, 16 - padded)\n}\n\nfunction createDecipheriv (suite, password, iv) {\n  var config = MODES[suite.toLowerCase()]\n  if (!config) throw new TypeError('invalid suite type')\n\n  if (typeof iv === 'string') iv = Buffer.from(iv)\n  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)\n\n  if (typeof password === 'string') password = Buffer.from(password)\n  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)\n\n  if (config.type === 'stream') {\n    return new StreamCipher(config.module, password, iv, true)\n  } else if (config.type === 'auth') {\n    return new AuthCipher(config.module, password, iv, true)\n  }\n\n  return new Decipher(config.module, password, iv)\n}\n\nfunction createDecipher (suite, password) {\n  var config = MODES[suite.toLowerCase()]\n  if (!config) throw new TypeError('invalid suite type')\n\n  var keys = ebtk(password, false, config.key, config.iv)\n  return createDecipheriv(suite, keys.key, keys.iv)\n}\n\nexports.createDecipher = createDecipher\nexports.createDecipheriv = createDecipheriv\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/decrypter.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/encrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/encrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var MODES = __webpack_require__(/*! ./modes */ \"./node_modules/browserify-aes/modes/index.js\")\nvar AuthCipher = __webpack_require__(/*! ./authCipher */ \"./node_modules/browserify-aes/authCipher.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar StreamCipher = __webpack_require__(/*! ./streamCipher */ \"./node_modules/browserify-aes/streamCipher.js\")\nvar Transform = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar aes = __webpack_require__(/*! ./aes */ \"./node_modules/browserify-aes/aes.js\")\nvar ebtk = __webpack_require__(/*! evp_bytestokey */ \"./node_modules/evp_bytestokey/index.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\n\nfunction Cipher (mode, key, iv) {\n  Transform.call(this)\n\n  this._cache = new Splitter()\n  this._cipher = new aes.AES(key)\n  this._prev = Buffer.from(iv)\n  this._mode = mode\n  this._autopadding = true\n}\n\ninherits(Cipher, Transform)\n\nCipher.prototype._update = function (data) {\n  this._cache.add(data)\n  var chunk\n  var thing\n  var out = []\n\n  while ((chunk = this._cache.get())) {\n    thing = this._mode.encrypt(this, chunk)\n    out.push(thing)\n  }\n\n  return Buffer.concat(out)\n}\n\nvar PADDING = Buffer.alloc(16, 0x10)\n\nCipher.prototype._final = function () {\n  var chunk = this._cache.flush()\n  if (this._autopadding) {\n    chunk = this._mode.encrypt(this, chunk)\n    this._cipher.scrub()\n    return chunk\n  }\n\n  if (!chunk.equals(PADDING)) {\n    this._cipher.scrub()\n    throw new Error('data not multiple of block length')\n  }\n}\n\nCipher.prototype.setAutoPadding = function (setTo) {\n  this._autopadding = !!setTo\n  return this\n}\n\nfunction Splitter () {\n  this.cache = Buffer.allocUnsafe(0)\n}\n\nSplitter.prototype.add = function (data) {\n  this.cache = Buffer.concat([this.cache, data])\n}\n\nSplitter.prototype.get = function () {\n  if (this.cache.length > 15) {\n    var out = this.cache.slice(0, 16)\n    this.cache = this.cache.slice(16)\n    return out\n  }\n  return null\n}\n\nSplitter.prototype.flush = function () {\n  var len = 16 - this.cache.length\n  var padBuff = Buffer.allocUnsafe(len)\n\n  var i = -1\n  while (++i < len) {\n    padBuff.writeUInt8(len, i)\n  }\n\n  return Buffer.concat([this.cache, padBuff])\n}\n\nfunction createCipheriv (suite, password, iv) {\n  var config = MODES[suite.toLowerCase()]\n  if (!config) throw new TypeError('invalid suite type')\n\n  if (typeof password === 'string') password = Buffer.from(password)\n  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)\n\n  if (typeof iv === 'string') iv = Buffer.from(iv)\n  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)\n\n  if (config.type === 'stream') {\n    return new StreamCipher(config.module, password, iv)\n  } else if (config.type === 'auth') {\n    return new AuthCipher(config.module, password, iv)\n  }\n\n  return new Cipher(config.module, password, iv)\n}\n\nfunction createCipher (suite, password) {\n  var config = MODES[suite.toLowerCase()]\n  if (!config) throw new TypeError('invalid suite type')\n\n  var keys = ebtk(password, false, config.key, config.iv)\n  return createCipheriv(suite, keys.key, keys.iv)\n}\n\nexports.createCipheriv = createCipheriv\nexports.createCipher = createCipher\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/encrypter.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/ghash.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-aes/ghash.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar ZEROES = Buffer.alloc(16, 0)\n\nfunction toArray (buf) {\n  return [\n    buf.readUInt32BE(0),\n    buf.readUInt32BE(4),\n    buf.readUInt32BE(8),\n    buf.readUInt32BE(12)\n  ]\n}\n\nfunction fromArray (out) {\n  var buf = Buffer.allocUnsafe(16)\n  buf.writeUInt32BE(out[0] >>> 0, 0)\n  buf.writeUInt32BE(out[1] >>> 0, 4)\n  buf.writeUInt32BE(out[2] >>> 0, 8)\n  buf.writeUInt32BE(out[3] >>> 0, 12)\n  return buf\n}\n\nfunction GHASH (key) {\n  this.h = key\n  this.state = Buffer.alloc(16, 0)\n  this.cache = Buffer.allocUnsafe(0)\n}\n\n// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html\n// by Juho Vähä-Herttua\nGHASH.prototype.ghash = function (block) {\n  var i = -1\n  while (++i < block.length) {\n    this.state[i] ^= block[i]\n  }\n  this._multiply()\n}\n\nGHASH.prototype._multiply = function () {\n  var Vi = toArray(this.h)\n  var Zi = [0, 0, 0, 0]\n  var j, xi, lsbVi\n  var i = -1\n  while (++i < 128) {\n    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0\n    if (xi) {\n      // Z_i+1 = Z_i ^ V_i\n      Zi[0] ^= Vi[0]\n      Zi[1] ^= Vi[1]\n      Zi[2] ^= Vi[2]\n      Zi[3] ^= Vi[3]\n    }\n\n    // Store the value of LSB(V_i)\n    lsbVi = (Vi[3] & 1) !== 0\n\n    // V_i+1 = V_i >> 1\n    for (j = 3; j > 0; j--) {\n      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)\n    }\n    Vi[0] = Vi[0] >>> 1\n\n    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R\n    if (lsbVi) {\n      Vi[0] = Vi[0] ^ (0xe1 << 24)\n    }\n  }\n  this.state = fromArray(Zi)\n}\n\nGHASH.prototype.update = function (buf) {\n  this.cache = Buffer.concat([this.cache, buf])\n  var chunk\n  while (this.cache.length >= 16) {\n    chunk = this.cache.slice(0, 16)\n    this.cache = this.cache.slice(16)\n    this.ghash(chunk)\n  }\n}\n\nGHASH.prototype.final = function (abl, bl) {\n  if (this.cache.length) {\n    this.ghash(Buffer.concat([this.cache, ZEROES], 16))\n  }\n\n  this.ghash(fromArray([0, abl, 0, bl]))\n  return this.state\n}\n\nmodule.exports = GHASH\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/ghash.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/incr32.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-aes/incr32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function incr32 (iv) {\n  var len = iv.length\n  var item\n  while (len--) {\n    item = iv.readUInt8(len)\n    if (item === 255) {\n      iv.writeUInt8(0, len)\n    } else {\n      item++\n      iv.writeUInt8(item, len)\n      break\n    }\n  }\n}\nmodule.exports = incr32\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/incr32.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/cbc.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cbc.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var xor = __webpack_require__(/*! buffer-xor */ \"./node_modules/buffer-xor/index.js\")\n\nexports.encrypt = function (self, block) {\n  var data = xor(block, self._prev)\n\n  self._prev = self._cipher.encryptBlock(data)\n  return self._prev\n}\n\nexports.decrypt = function (self, block) {\n  var pad = self._prev\n\n  self._prev = block\n  var out = self._cipher.decryptBlock(block)\n\n  return xor(out, pad)\n}\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/modes/cbc.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar xor = __webpack_require__(/*! buffer-xor */ \"./node_modules/buffer-xor/index.js\")\n\nfunction encryptStart (self, data, decrypt) {\n  var len = data.length\n  var out = xor(data, self._cache)\n  self._cache = self._cache.slice(len)\n  self._prev = Buffer.concat([self._prev, decrypt ? data : out])\n  return out\n}\n\nexports.encrypt = function (self, data, decrypt) {\n  var out = Buffer.allocUnsafe(0)\n  var len\n\n  while (data.length) {\n    if (self._cache.length === 0) {\n      self._cache = self._cipher.encryptBlock(self._prev)\n      self._prev = Buffer.allocUnsafe(0)\n    }\n\n    if (self._cache.length <= data.length) {\n      len = self._cache.length\n      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])\n      data = data.slice(len)\n    } else {\n      out = Buffer.concat([out, encryptStart(self, data, decrypt)])\n      break\n    }\n  }\n\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/modes/cfb.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb1.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb1.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nfunction encryptByte (self, byteParam, decrypt) {\n  var pad\n  var i = -1\n  var len = 8\n  var out = 0\n  var bit, value\n  while (++i < len) {\n    pad = self._cipher.encryptBlock(self._prev)\n    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0\n    value = pad[0] ^ bit\n    out += ((value & 0x80) >> (i % 8))\n    self._prev = shiftIn(self._prev, decrypt ? bit : value)\n  }\n  return out\n}\n\nfunction shiftIn (buffer, value) {\n  var len = buffer.length\n  var i = -1\n  var out = Buffer.allocUnsafe(buffer.length)\n  buffer = Buffer.concat([buffer, Buffer.from([value])])\n\n  while (++i < len) {\n    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)\n  }\n\n  return out\n}\n\nexports.encrypt = function (self, chunk, decrypt) {\n  var len = chunk.length\n  var out = Buffer.allocUnsafe(len)\n  var i = -1\n\n  while (++i < len) {\n    out[i] = encryptByte(self, chunk[i], decrypt)\n  }\n\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/modes/cfb1.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb8.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nfunction encryptByte (self, byteParam, decrypt) {\n  var pad = self._cipher.encryptBlock(self._prev)\n  var out = pad[0] ^ byteParam\n\n  self._prev = Buffer.concat([\n    self._prev.slice(1),\n    Buffer.from([decrypt ? byteParam : out])\n  ])\n\n  return out\n}\n\nexports.encrypt = function (self, chunk, decrypt) {\n  var len = chunk.length\n  var out = Buffer.allocUnsafe(len)\n  var i = -1\n\n  while (++i < len) {\n    out[i] = encryptByte(self, chunk[i], decrypt)\n  }\n\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/modes/cfb8.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/ctr.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ctr.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var xor = __webpack_require__(/*! buffer-xor */ \"./node_modules/buffer-xor/index.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar incr32 = __webpack_require__(/*! ../incr32 */ \"./node_modules/browserify-aes/incr32.js\")\n\nfunction getBlock (self) {\n  var out = self._cipher.encryptBlockRaw(self._prev)\n  incr32(self._prev)\n  return out\n}\n\nvar blockSize = 16\nexports.encrypt = function (self, chunk) {\n  var chunkNum = Math.ceil(chunk.length / blockSize)\n  var start = self._cache.length\n  self._cache = Buffer.concat([\n    self._cache,\n    Buffer.allocUnsafe(chunkNum * blockSize)\n  ])\n  for (var i = 0; i < chunkNum; i++) {\n    var out = getBlock(self)\n    var offset = start + i * blockSize\n    self._cache.writeUInt32BE(out[0], offset + 0)\n    self._cache.writeUInt32BE(out[1], offset + 4)\n    self._cache.writeUInt32BE(out[2], offset + 8)\n    self._cache.writeUInt32BE(out[3], offset + 12)\n  }\n  var pad = self._cache.slice(0, chunk.length)\n  self._cache = self._cache.slice(chunk.length)\n  return xor(chunk, pad)\n}\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/modes/ctr.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/ecb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ecb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.encrypt = function (self, block) {\n  return self._cipher.encryptBlock(block)\n}\n\nexports.decrypt = function (self, block) {\n  return self._cipher.decryptBlock(block)\n}\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/modes/ecb.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/index.js":
/*!****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var modeModules = {\n  ECB: __webpack_require__(/*! ./ecb */ \"./node_modules/browserify-aes/modes/ecb.js\"),\n  CBC: __webpack_require__(/*! ./cbc */ \"./node_modules/browserify-aes/modes/cbc.js\"),\n  CFB: __webpack_require__(/*! ./cfb */ \"./node_modules/browserify-aes/modes/cfb.js\"),\n  CFB8: __webpack_require__(/*! ./cfb8 */ \"./node_modules/browserify-aes/modes/cfb8.js\"),\n  CFB1: __webpack_require__(/*! ./cfb1 */ \"./node_modules/browserify-aes/modes/cfb1.js\"),\n  OFB: __webpack_require__(/*! ./ofb */ \"./node_modules/browserify-aes/modes/ofb.js\"),\n  CTR: __webpack_require__(/*! ./ctr */ \"./node_modules/browserify-aes/modes/ctr.js\"),\n  GCM: __webpack_require__(/*! ./ctr */ \"./node_modules/browserify-aes/modes/ctr.js\")\n}\n\nvar modes = __webpack_require__(/*! ./list.json */ \"./node_modules/browserify-aes/modes/list.json\")\n\nfor (var key in modes) {\n  modes[key].module = modeModules[modes[key].mode]\n}\n\nmodule.exports = modes\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/modes/index.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/list.json":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/list.json ***!
  \*****************************************************/
/*! exports provided: aes-128-ecb, aes-192-ecb, aes-256-ecb, aes-128-cbc, aes-192-cbc, aes-256-cbc, aes128, aes192, aes256, aes-128-cfb, aes-192-cfb, aes-256-cfb, aes-128-cfb8, aes-192-cfb8, aes-256-cfb8, aes-128-cfb1, aes-192-cfb1, aes-256-cfb1, aes-128-ofb, aes-192-ofb, aes-256-ofb, aes-128-ctr, aes-192-ctr, aes-256-ctr, aes-128-gcm, aes-192-gcm, aes-256-gcm, default */
/***/ (function(module) {

eval("module.exports = {\"aes-128-ecb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-192-ecb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-256-ecb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-128-cbc\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-192-cbc\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-256-cbc\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes128\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes192\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes256\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-128-cfb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-192-cfb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-256-cfb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-128-cfb8\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-192-cfb8\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-256-cfb8\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-128-cfb1\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-192-cfb1\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-256-cfb1\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-128-ofb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-192-ofb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-256-ofb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-128-ctr\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-192-ctr\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-256-ctr\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-128-gcm\":{\"cipher\":\"AES\",\"key\":128,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"},\"aes-192-gcm\":{\"cipher\":\"AES\",\"key\":192,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"},\"aes-256-gcm\":{\"cipher\":\"AES\",\"key\":256,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"}};\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/modes/list.json?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/ofb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ofb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(/*! buffer-xor */ \"./node_modules/buffer-xor/index.js\")\n\nfunction getBlock (self) {\n  self._prev = self._cipher.encryptBlock(self._prev)\n  return self._prev\n}\n\nexports.encrypt = function (self, chunk) {\n  while (self._cache.length < chunk.length) {\n    self._cache = Buffer.concat([self._cache, getBlock(self)])\n  }\n\n  var pad = self._cache.slice(0, chunk.length)\n  self._cache = self._cache.slice(chunk.length)\n  return xor(chunk, pad)\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/modes/ofb.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/streamCipher.js":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/streamCipher.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var aes = __webpack_require__(/*! ./aes */ \"./node_modules/browserify-aes/aes.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar Transform = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\n\nfunction StreamCipher (mode, key, iv, decrypt) {\n  Transform.call(this)\n\n  this._cipher = new aes.AES(key)\n  this._prev = Buffer.from(iv)\n  this._cache = Buffer.allocUnsafe(0)\n  this._secCache = Buffer.allocUnsafe(0)\n  this._decrypt = decrypt\n  this._mode = mode\n}\n\ninherits(StreamCipher, Transform)\n\nStreamCipher.prototype._update = function (chunk) {\n  return this._mode.encrypt(this, chunk, this._decrypt)\n}\n\nStreamCipher.prototype._final = function () {\n  this._cipher.scrub()\n}\n\nmodule.exports = StreamCipher\n\n\n//# sourceURL=webpack:///./node_modules/browserify-aes/streamCipher.js?");

/***/ }),

/***/ "./node_modules/browserify-cipher/browser.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-cipher/browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var DES = __webpack_require__(/*! browserify-des */ \"./node_modules/browserify-des/index.js\")\nvar aes = __webpack_require__(/*! browserify-aes/browser */ \"./node_modules/browserify-aes/browser.js\")\nvar aesModes = __webpack_require__(/*! browserify-aes/modes */ \"./node_modules/browserify-aes/modes/index.js\")\nvar desModes = __webpack_require__(/*! browserify-des/modes */ \"./node_modules/browserify-des/modes.js\")\nvar ebtk = __webpack_require__(/*! evp_bytestokey */ \"./node_modules/evp_bytestokey/index.js\")\n\nfunction createCipher (suite, password) {\n  suite = suite.toLowerCase()\n\n  var keyLen, ivLen\n  if (aesModes[suite]) {\n    keyLen = aesModes[suite].key\n    ivLen = aesModes[suite].iv\n  } else if (desModes[suite]) {\n    keyLen = desModes[suite].key * 8\n    ivLen = desModes[suite].iv\n  } else {\n    throw new TypeError('invalid suite type')\n  }\n\n  var keys = ebtk(password, false, keyLen, ivLen)\n  return createCipheriv(suite, keys.key, keys.iv)\n}\n\nfunction createDecipher (suite, password) {\n  suite = suite.toLowerCase()\n\n  var keyLen, ivLen\n  if (aesModes[suite]) {\n    keyLen = aesModes[suite].key\n    ivLen = aesModes[suite].iv\n  } else if (desModes[suite]) {\n    keyLen = desModes[suite].key * 8\n    ivLen = desModes[suite].iv\n  } else {\n    throw new TypeError('invalid suite type')\n  }\n\n  var keys = ebtk(password, false, keyLen, ivLen)\n  return createDecipheriv(suite, keys.key, keys.iv)\n}\n\nfunction createCipheriv (suite, key, iv) {\n  suite = suite.toLowerCase()\n  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)\n  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })\n\n  throw new TypeError('invalid suite type')\n}\n\nfunction createDecipheriv (suite, key, iv) {\n  suite = suite.toLowerCase()\n  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)\n  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })\n\n  throw new TypeError('invalid suite type')\n}\n\nfunction getCiphers () {\n  return Object.keys(desModes).concat(aes.getCiphers())\n}\n\nexports.createCipher = exports.Cipher = createCipher\nexports.createCipheriv = exports.Cipheriv = createCipheriv\nexports.createDecipher = exports.Decipher = createDecipher\nexports.createDecipheriv = exports.Decipheriv = createDecipheriv\nexports.listCiphers = exports.getCiphers = getCiphers\n\n\n//# sourceURL=webpack:///./node_modules/browserify-cipher/browser.js?");

/***/ }),

/***/ "./node_modules/browserify-des/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var CipherBase = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar des = __webpack_require__(/*! des.js */ \"./node_modules/des.js/lib/des.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar modes = {\n  'des-ede3-cbc': des.CBC.instantiate(des.EDE),\n  'des-ede3': des.EDE,\n  'des-ede-cbc': des.CBC.instantiate(des.EDE),\n  'des-ede': des.EDE,\n  'des-cbc': des.CBC.instantiate(des.DES),\n  'des-ecb': des.DES\n}\nmodes.des = modes['des-cbc']\nmodes.des3 = modes['des-ede3-cbc']\nmodule.exports = DES\ninherits(DES, CipherBase)\nfunction DES (opts) {\n  CipherBase.call(this)\n  var modeName = opts.mode.toLowerCase()\n  var mode = modes[modeName]\n  var type\n  if (opts.decrypt) {\n    type = 'decrypt'\n  } else {\n    type = 'encrypt'\n  }\n  var key = opts.key\n  if (!Buffer.isBuffer(key)) {\n    key = Buffer.from(key)\n  }\n  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {\n    key = Buffer.concat([key, key.slice(0, 8)])\n  }\n  var iv = opts.iv\n  if (!Buffer.isBuffer(iv)) {\n    iv = Buffer.from(iv)\n  }\n  this._des = mode.create({\n    key: key,\n    iv: iv,\n    type: type\n  })\n}\nDES.prototype._update = function (data) {\n  return Buffer.from(this._des.update(data))\n}\nDES.prototype._final = function () {\n  return Buffer.from(this._des.final())\n}\n\n\n//# sourceURL=webpack:///./node_modules/browserify-des/index.js?");

/***/ }),

/***/ "./node_modules/browserify-des/modes.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/modes.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports['des-ecb'] = {\n  key: 8,\n  iv: 0\n}\nexports['des-cbc'] = exports.des = {\n  key: 8,\n  iv: 8\n}\nexports['des-ede3-cbc'] = exports.des3 = {\n  key: 24,\n  iv: 8\n}\nexports['des-ede3'] = {\n  key: 24,\n  iv: 0\n}\nexports['des-ede-cbc'] = {\n  key: 16,\n  iv: 8\n}\nexports['des-ede'] = {\n  key: 16,\n  iv: 0\n}\n\n\n//# sourceURL=webpack:///./node_modules/browserify-des/modes.js?");

/***/ }),

/***/ "./node_modules/browserify-rsa/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-rsa/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar randomBytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\");\nmodule.exports = crt;\nfunction blind(priv) {\n  var r = getr(priv);\n  var blinder = r.toRed(bn.mont(priv.modulus))\n  .redPow(new bn(priv.publicExponent)).fromRed();\n  return {\n    blinder: blinder,\n    unblinder:r.invm(priv.modulus)\n  };\n}\nfunction crt(msg, priv) {\n  var blinds = blind(priv);\n  var len = priv.modulus.byteLength();\n  var mod = bn.mont(priv.modulus);\n  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);\n  var c1 = blinded.toRed(bn.mont(priv.prime1));\n  var c2 = blinded.toRed(bn.mont(priv.prime2));\n  var qinv = priv.coefficient;\n  var p = priv.prime1;\n  var q = priv.prime2;\n  var m1 = c1.redPow(priv.exponent1);\n  var m2 = c2.redPow(priv.exponent2);\n  m1 = m1.fromRed();\n  m2 = m2.fromRed();\n  var h = m1.isub(m2).imul(qinv).umod(p);\n  h.imul(q);\n  m2.iadd(h);\n  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));\n}\ncrt.getr = getr;\nfunction getr(priv) {\n  var len = priv.modulus.byteLength();\n  var r = new bn(randomBytes(len));\n  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {\n    r = new bn(randomBytes(len));\n  }\n  return r;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/browserify-rsa/index.js?");

/***/ }),

/***/ "./node_modules/browserify-sign/algos.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-sign/algos.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./browser/algorithms.json */ \"./node_modules/browserify-sign/browser/algorithms.json\")\n\n\n//# sourceURL=webpack:///./node_modules/browserify-sign/algos.js?");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/algorithms.json":
/*!**************************************************************!*\
  !*** ./node_modules/browserify-sign/browser/algorithms.json ***!
  \**************************************************************/
/*! exports provided: sha224WithRSAEncryption, RSA-SHA224, sha256WithRSAEncryption, RSA-SHA256, sha384WithRSAEncryption, RSA-SHA384, sha512WithRSAEncryption, RSA-SHA512, RSA-SHA1, ecdsa-with-SHA1, sha256, sha224, sha384, sha512, DSA-SHA, DSA-SHA1, DSA, DSA-WITH-SHA224, DSA-SHA224, DSA-WITH-SHA256, DSA-SHA256, DSA-WITH-SHA384, DSA-SHA384, DSA-WITH-SHA512, DSA-SHA512, DSA-RIPEMD160, ripemd160WithRSA, RSA-RIPEMD160, md5WithRSAEncryption, RSA-MD5, default */
/***/ (function(module) {

eval("module.exports = {\"sha224WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha224\",\"id\":\"302d300d06096086480165030402040500041c\"},\"RSA-SHA224\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha224\",\"id\":\"302d300d06096086480165030402040500041c\"},\"sha256WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha256\",\"id\":\"3031300d060960864801650304020105000420\"},\"RSA-SHA256\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha256\",\"id\":\"3031300d060960864801650304020105000420\"},\"sha384WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha384\",\"id\":\"3041300d060960864801650304020205000430\"},\"RSA-SHA384\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha384\",\"id\":\"3041300d060960864801650304020205000430\"},\"sha512WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha512\",\"id\":\"3051300d060960864801650304020305000440\"},\"RSA-SHA512\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha512\",\"id\":\"3051300d060960864801650304020305000440\"},\"RSA-SHA1\":{\"sign\":\"rsa\",\"hash\":\"sha1\",\"id\":\"3021300906052b0e03021a05000414\"},\"ecdsa-with-SHA1\":{\"sign\":\"ecdsa\",\"hash\":\"sha1\",\"id\":\"\"},\"sha256\":{\"sign\":\"ecdsa\",\"hash\":\"sha256\",\"id\":\"\"},\"sha224\":{\"sign\":\"ecdsa\",\"hash\":\"sha224\",\"id\":\"\"},\"sha384\":{\"sign\":\"ecdsa\",\"hash\":\"sha384\",\"id\":\"\"},\"sha512\":{\"sign\":\"ecdsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-SHA\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA-SHA1\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA-WITH-SHA224\":{\"sign\":\"dsa\",\"hash\":\"sha224\",\"id\":\"\"},\"DSA-SHA224\":{\"sign\":\"dsa\",\"hash\":\"sha224\",\"id\":\"\"},\"DSA-WITH-SHA256\":{\"sign\":\"dsa\",\"hash\":\"sha256\",\"id\":\"\"},\"DSA-SHA256\":{\"sign\":\"dsa\",\"hash\":\"sha256\",\"id\":\"\"},\"DSA-WITH-SHA384\":{\"sign\":\"dsa\",\"hash\":\"sha384\",\"id\":\"\"},\"DSA-SHA384\":{\"sign\":\"dsa\",\"hash\":\"sha384\",\"id\":\"\"},\"DSA-WITH-SHA512\":{\"sign\":\"dsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-SHA512\":{\"sign\":\"dsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-RIPEMD160\":{\"sign\":\"dsa\",\"hash\":\"rmd160\",\"id\":\"\"},\"ripemd160WithRSA\":{\"sign\":\"rsa\",\"hash\":\"rmd160\",\"id\":\"3021300906052b2403020105000414\"},\"RSA-RIPEMD160\":{\"sign\":\"rsa\",\"hash\":\"rmd160\",\"id\":\"3021300906052b2403020105000414\"},\"md5WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"md5\",\"id\":\"3020300c06082a864886f70d020505000410\"},\"RSA-MD5\":{\"sign\":\"rsa\",\"hash\":\"md5\",\"id\":\"3020300c06082a864886f70d020505000410\"}};\n\n//# sourceURL=webpack:///./node_modules/browserify-sign/browser/algorithms.json?");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/curves.json":
/*!**********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/curves.json ***!
  \**********************************************************/
/*! exports provided: 1.3.132.0.10, 1.3.132.0.33, 1.2.840.10045.3.1.1, 1.2.840.10045.3.1.7, 1.3.132.0.34, 1.3.132.0.35, default */
/***/ (function(module) {

eval("module.exports = {\"1.3.132.0.10\":\"secp256k1\",\"1.3.132.0.33\":\"p224\",\"1.2.840.10045.3.1.1\":\"p192\",\"1.2.840.10045.3.1.7\":\"p256\",\"1.3.132.0.34\":\"p384\",\"1.3.132.0.35\":\"p521\"};\n\n//# sourceURL=webpack:///./node_modules/browserify-sign/browser/curves.json?");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\")\nvar stream = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar sign = __webpack_require__(/*! ./sign */ \"./node_modules/browserify-sign/browser/sign.js\")\nvar verify = __webpack_require__(/*! ./verify */ \"./node_modules/browserify-sign/browser/verify.js\")\n\nvar algorithms = __webpack_require__(/*! ./algorithms.json */ \"./node_modules/browserify-sign/browser/algorithms.json\")\nObject.keys(algorithms).forEach(function (key) {\n  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')\n  algorithms[key.toLowerCase()] = algorithms[key]\n})\n\nfunction Sign (algorithm) {\n  stream.Writable.call(this)\n\n  var data = algorithms[algorithm]\n  if (!data) throw new Error('Unknown message digest')\n\n  this._hashType = data.hash\n  this._hash = createHash(data.hash)\n  this._tag = data.id\n  this._signType = data.sign\n}\ninherits(Sign, stream.Writable)\n\nSign.prototype._write = function _write (data, _, done) {\n  this._hash.update(data)\n  done()\n}\n\nSign.prototype.update = function update (data, enc) {\n  if (typeof data === 'string') data = new Buffer(data, enc)\n\n  this._hash.update(data)\n  return this\n}\n\nSign.prototype.sign = function signMethod (key, enc) {\n  this.end()\n  var hash = this._hash.digest()\n  var sig = sign(hash, key, this._hashType, this._signType, this._tag)\n\n  return enc ? sig.toString(enc) : sig\n}\n\nfunction Verify (algorithm) {\n  stream.Writable.call(this)\n\n  var data = algorithms[algorithm]\n  if (!data) throw new Error('Unknown message digest')\n\n  this._hash = createHash(data.hash)\n  this._tag = data.id\n  this._signType = data.sign\n}\ninherits(Verify, stream.Writable)\n\nVerify.prototype._write = function _write (data, _, done) {\n  this._hash.update(data)\n  done()\n}\n\nVerify.prototype.update = function update (data, enc) {\n  if (typeof data === 'string') data = new Buffer(data, enc)\n\n  this._hash.update(data)\n  return this\n}\n\nVerify.prototype.verify = function verifyMethod (key, sig, enc) {\n  if (typeof sig === 'string') sig = new Buffer(sig, enc)\n\n  this.end()\n  var hash = this._hash.digest()\n  return verify(sig, hash, key, this._signType, this._tag)\n}\n\nfunction createSign (algorithm) {\n  return new Sign(algorithm)\n}\n\nfunction createVerify (algorithm) {\n  return new Verify(algorithm)\n}\n\nmodule.exports = {\n  Sign: createSign,\n  Verify: createVerify,\n  createSign: createSign,\n  createVerify: createVerify\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/browserify-sign/browser/index.js?");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/sign.js":
/*!******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/sign.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\nvar createHmac = __webpack_require__(/*! create-hmac */ \"./node_modules/create-hmac/browser.js\")\nvar crt = __webpack_require__(/*! browserify-rsa */ \"./node_modules/browserify-rsa/index.js\")\nvar EC = __webpack_require__(/*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\").ec\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\")\nvar parseKeys = __webpack_require__(/*! parse-asn1 */ \"./node_modules/parse-asn1/index.js\")\nvar curves = __webpack_require__(/*! ./curves.json */ \"./node_modules/browserify-sign/browser/curves.json\")\n\nfunction sign (hash, key, hashType, signType, tag) {\n  var priv = parseKeys(key)\n  if (priv.curve) {\n    // rsa keys can be interpreted as ecdsa ones in openssl\n    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')\n    return ecSign(hash, priv)\n  } else if (priv.type === 'dsa') {\n    if (signType !== 'dsa') throw new Error('wrong private key type')\n    return dsaSign(hash, priv, hashType)\n  } else {\n    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')\n  }\n  hash = Buffer.concat([tag, hash])\n  var len = priv.modulus.byteLength()\n  var pad = [ 0, 1 ]\n  while (hash.length + pad.length + 1 < len) pad.push(0xff)\n  pad.push(0x00)\n  var i = -1\n  while (++i < hash.length) pad.push(hash[i])\n\n  var out = crt(pad, priv)\n  return out\n}\n\nfunction ecSign (hash, priv) {\n  var curveId = curves[priv.curve.join('.')]\n  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))\n\n  var curve = new EC(curveId)\n  var key = curve.keyFromPrivate(priv.privateKey)\n  var out = key.sign(hash)\n\n  return new Buffer(out.toDER())\n}\n\nfunction dsaSign (hash, priv, algo) {\n  var x = priv.params.priv_key\n  var p = priv.params.p\n  var q = priv.params.q\n  var g = priv.params.g\n  var r = new BN(0)\n  var k\n  var H = bits2int(hash, q).mod(q)\n  var s = false\n  var kv = getKey(x, q, hash, algo)\n  while (s === false) {\n    k = makeKey(q, kv, algo)\n    r = makeR(g, k, p, q)\n    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)\n    if (s.cmpn(0) === 0) {\n      s = false\n      r = new BN(0)\n    }\n  }\n  return toDER(r, s)\n}\n\nfunction toDER (r, s) {\n  r = r.toArray()\n  s = s.toArray()\n\n  // Pad values\n  if (r[0] & 0x80) r = [ 0 ].concat(r)\n  if (s[0] & 0x80) s = [ 0 ].concat(s)\n\n  var total = r.length + s.length + 4\n  var res = [ 0x30, total, 0x02, r.length ]\n  res = res.concat(r, [ 0x02, s.length ], s)\n  return new Buffer(res)\n}\n\nfunction getKey (x, q, hash, algo) {\n  x = new Buffer(x.toArray())\n  if (x.length < q.byteLength()) {\n    var zeros = new Buffer(q.byteLength() - x.length)\n    zeros.fill(0)\n    x = Buffer.concat([ zeros, x ])\n  }\n  var hlen = hash.length\n  var hbits = bits2octets(hash, q)\n  var v = new Buffer(hlen)\n  v.fill(1)\n  var k = new Buffer(hlen)\n  k.fill(0)\n  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()\n  v = createHmac(algo, k).update(v).digest()\n  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()\n  v = createHmac(algo, k).update(v).digest()\n  return { k: k, v: v }\n}\n\nfunction bits2int (obits, q) {\n  var bits = new BN(obits)\n  var shift = (obits.length << 3) - q.bitLength()\n  if (shift > 0) bits.ishrn(shift)\n  return bits\n}\n\nfunction bits2octets (bits, q) {\n  bits = bits2int(bits, q)\n  bits = bits.mod(q)\n  var out = new Buffer(bits.toArray())\n  if (out.length < q.byteLength()) {\n    var zeros = new Buffer(q.byteLength() - out.length)\n    zeros.fill(0)\n    out = Buffer.concat([ zeros, out ])\n  }\n  return out\n}\n\nfunction makeKey (q, kv, algo) {\n  var t\n  var k\n\n  do {\n    t = new Buffer(0)\n\n    while (t.length * 8 < q.bitLength()) {\n      kv.v = createHmac(algo, kv.k).update(kv.v).digest()\n      t = Buffer.concat([ t, kv.v ])\n    }\n\n    k = bits2int(t, q)\n    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()\n    kv.v = createHmac(algo, kv.k).update(kv.v).digest()\n  } while (k.cmp(q) !== -1)\n\n  return k\n}\n\nfunction makeR (g, k, p, q) {\n  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)\n}\n\nmodule.exports = sign\nmodule.exports.getKey = getKey\nmodule.exports.makeKey = makeKey\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/browserify-sign/browser/sign.js?");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/verify.js":
/*!********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/verify.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\")\nvar EC = __webpack_require__(/*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\").ec\nvar parseKeys = __webpack_require__(/*! parse-asn1 */ \"./node_modules/parse-asn1/index.js\")\nvar curves = __webpack_require__(/*! ./curves.json */ \"./node_modules/browserify-sign/browser/curves.json\")\n\nfunction verify (sig, hash, key, signType, tag) {\n  var pub = parseKeys(key)\n  if (pub.type === 'ec') {\n    // rsa keys can be interpreted as ecdsa ones in openssl\n    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')\n    return ecVerify(sig, hash, pub)\n  } else if (pub.type === 'dsa') {\n    if (signType !== 'dsa') throw new Error('wrong public key type')\n    return dsaVerify(sig, hash, pub)\n  } else {\n    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')\n  }\n  hash = Buffer.concat([tag, hash])\n  var len = pub.modulus.byteLength()\n  var pad = [ 1 ]\n  var padNum = 0\n  while (hash.length + pad.length + 2 < len) {\n    pad.push(0xff)\n    padNum++\n  }\n  pad.push(0x00)\n  var i = -1\n  while (++i < hash.length) {\n    pad.push(hash[i])\n  }\n  pad = new Buffer(pad)\n  var red = BN.mont(pub.modulus)\n  sig = new BN(sig).toRed(red)\n\n  sig = sig.redPow(new BN(pub.publicExponent))\n  sig = new Buffer(sig.fromRed().toArray())\n  var out = padNum < 8 ? 1 : 0\n  len = Math.min(sig.length, pad.length)\n  if (sig.length !== pad.length) out = 1\n\n  i = -1\n  while (++i < len) out |= sig[i] ^ pad[i]\n  return out === 0\n}\n\nfunction ecVerify (sig, hash, pub) {\n  var curveId = curves[pub.data.algorithm.curve.join('.')]\n  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))\n\n  var curve = new EC(curveId)\n  var pubkey = pub.data.subjectPrivateKey.data\n\n  return curve.verify(hash, sig, pubkey)\n}\n\nfunction dsaVerify (sig, hash, pub) {\n  var p = pub.data.p\n  var q = pub.data.q\n  var g = pub.data.g\n  var y = pub.data.pub_key\n  var unpacked = parseKeys.signature.decode(sig, 'der')\n  var s = unpacked.s\n  var r = unpacked.r\n  checkValue(s, q)\n  checkValue(r, q)\n  var montp = BN.mont(p)\n  var w = s.invm(q)\n  var v = g.toRed(montp)\n    .redPow(new BN(hash).mul(w).mod(q))\n    .fromRed()\n    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())\n    .mod(p)\n    .mod(q)\n  return v.cmp(r) === 0\n}\n\nfunction checkValue (b, q) {\n  if (b.cmpn(0) <= 0) throw new Error('invalid sig')\n  if (b.cmp(q) >= q) throw new Error('invalid sig')\n}\n\nmodule.exports = verify\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/browserify-sign/browser/verify.js?");

/***/ }),

/***/ "./node_modules/buffer-xor/index.js":
/*!******************************************!*\
  !*** ./node_modules/buffer-xor/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {\n  var length = Math.min(a.length, b.length)\n  var buffer = new Buffer(length)\n\n  for (var i = 0; i < length; ++i) {\n    buffer[i] = a[i] ^ b[i]\n  }\n\n  return buffer\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/buffer-xor/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/cipher-base/index.js":
/*!*******************************************!*\
  !*** ./node_modules/cipher-base/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar Transform = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\").Transform\nvar StringDecoder = __webpack_require__(/*! string_decoder */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\n\nfunction CipherBase (hashMode) {\n  Transform.call(this)\n  this.hashMode = typeof hashMode === 'string'\n  if (this.hashMode) {\n    this[hashMode] = this._finalOrDigest\n  } else {\n    this.final = this._finalOrDigest\n  }\n  if (this._final) {\n    this.__final = this._final\n    this._final = null\n  }\n  this._decoder = null\n  this._encoding = null\n}\ninherits(CipherBase, Transform)\n\nCipherBase.prototype.update = function (data, inputEnc, outputEnc) {\n  if (typeof data === 'string') {\n    data = Buffer.from(data, inputEnc)\n  }\n\n  var outData = this._update(data)\n  if (this.hashMode) return this\n\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc)\n  }\n\n  return outData\n}\n\nCipherBase.prototype.setAutoPadding = function () {}\nCipherBase.prototype.getAuthTag = function () {\n  throw new Error('trying to get auth tag in unsupported state')\n}\n\nCipherBase.prototype.setAuthTag = function () {\n  throw new Error('trying to set auth tag in unsupported state')\n}\n\nCipherBase.prototype.setAAD = function () {\n  throw new Error('trying to set aad in unsupported state')\n}\n\nCipherBase.prototype._transform = function (data, _, next) {\n  var err\n  try {\n    if (this.hashMode) {\n      this._update(data)\n    } else {\n      this.push(this._update(data))\n    }\n  } catch (e) {\n    err = e\n  } finally {\n    next(err)\n  }\n}\nCipherBase.prototype._flush = function (done) {\n  var err\n  try {\n    this.push(this.__final())\n  } catch (e) {\n    err = e\n  }\n\n  done(err)\n}\nCipherBase.prototype._finalOrDigest = function (outputEnc) {\n  var outData = this.__final() || Buffer.alloc(0)\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc, true)\n  }\n  return outData\n}\n\nCipherBase.prototype._toString = function (value, enc, fin) {\n  if (!this._decoder) {\n    this._decoder = new StringDecoder(enc)\n    this._encoding = enc\n  }\n\n  if (this._encoding !== enc) throw new Error('can\\'t switch encodings')\n\n  var out = this._decoder.write(value)\n  if (fin) {\n    out += this._decoder.end()\n  }\n\n  return out\n}\n\nmodule.exports = CipherBase\n\n\n//# sourceURL=webpack:///./node_modules/cipher-base/index.js?");

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/core-util-is/lib/util.js?");

/***/ }),

/***/ "./node_modules/create-ecdh/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-ecdh/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(/*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\")\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\")\n\nmodule.exports = function createECDH (curve) {\n  return new ECDH(curve)\n}\n\nvar aliases = {\n  secp256k1: {\n    name: 'secp256k1',\n    byteLength: 32\n  },\n  secp224r1: {\n    name: 'p224',\n    byteLength: 28\n  },\n  prime256v1: {\n    name: 'p256',\n    byteLength: 32\n  },\n  prime192v1: {\n    name: 'p192',\n    byteLength: 24\n  },\n  ed25519: {\n    name: 'ed25519',\n    byteLength: 32\n  },\n  secp384r1: {\n    name: 'p384',\n    byteLength: 48\n  },\n  secp521r1: {\n    name: 'p521',\n    byteLength: 66\n  }\n}\n\naliases.p224 = aliases.secp224r1\naliases.p256 = aliases.secp256r1 = aliases.prime256v1\naliases.p192 = aliases.secp192r1 = aliases.prime192v1\naliases.p384 = aliases.secp384r1\naliases.p521 = aliases.secp521r1\n\nfunction ECDH (curve) {\n  this.curveType = aliases[curve]\n  if (!this.curveType) {\n    this.curveType = {\n      name: curve\n    }\n  }\n  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap\n  this.keys = void 0\n}\n\nECDH.prototype.generateKeys = function (enc, format) {\n  this.keys = this.curve.genKeyPair()\n  return this.getPublicKey(enc, format)\n}\n\nECDH.prototype.computeSecret = function (other, inenc, enc) {\n  inenc = inenc || 'utf8'\n  if (!Buffer.isBuffer(other)) {\n    other = new Buffer(other, inenc)\n  }\n  var otherPub = this.curve.keyFromPublic(other).getPublic()\n  var out = otherPub.mul(this.keys.getPrivate()).getX()\n  return formatReturnValue(out, enc, this.curveType.byteLength)\n}\n\nECDH.prototype.getPublicKey = function (enc, format) {\n  var key = this.keys.getPublic(format === 'compressed', true)\n  if (format === 'hybrid') {\n    if (key[key.length - 1] % 2) {\n      key[0] = 7\n    } else {\n      key[0] = 6\n    }\n  }\n  return formatReturnValue(key, enc)\n}\n\nECDH.prototype.getPrivateKey = function (enc) {\n  return formatReturnValue(this.keys.getPrivate(), enc)\n}\n\nECDH.prototype.setPublicKey = function (pub, enc) {\n  enc = enc || 'utf8'\n  if (!Buffer.isBuffer(pub)) {\n    pub = new Buffer(pub, enc)\n  }\n  this.keys._importPublic(pub)\n  return this\n}\n\nECDH.prototype.setPrivateKey = function (priv, enc) {\n  enc = enc || 'utf8'\n  if (!Buffer.isBuffer(priv)) {\n    priv = new Buffer(priv, enc)\n  }\n\n  var _priv = new BN(priv)\n  _priv = _priv.toString(16)\n  this.keys = this.curve.genKeyPair()\n  this.keys._importPrivate(_priv)\n  return this\n}\n\nfunction formatReturnValue (bn, enc, len) {\n  if (!Array.isArray(bn)) {\n    bn = bn.toArray()\n  }\n  var buf = new Buffer(bn)\n  if (len && buf.length < len) {\n    var zeros = new Buffer(len - buf.length)\n    zeros.fill(0)\n    buf = Buffer.concat([zeros, buf])\n  }\n  if (!enc) {\n    return buf\n  } else {\n    return buf.toString(enc)\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/create-ecdh/browser.js?");

/***/ }),

/***/ "./node_modules/create-hash/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hash/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar MD5 = __webpack_require__(/*! md5.js */ \"./node_modules/md5.js/index.js\")\nvar RIPEMD160 = __webpack_require__(/*! ripemd160 */ \"./node_modules/ripemd160/index.js\")\nvar sha = __webpack_require__(/*! sha.js */ \"./node_modules/sha.js/index.js\")\nvar Base = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\n\nfunction Hash (hash) {\n  Base.call(this, 'digest')\n\n  this._hash = hash\n}\n\ninherits(Hash, Base)\n\nHash.prototype._update = function (data) {\n  this._hash.update(data)\n}\n\nHash.prototype._final = function () {\n  return this._hash.digest()\n}\n\nmodule.exports = function createHash (alg) {\n  alg = alg.toLowerCase()\n  if (alg === 'md5') return new MD5()\n  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()\n\n  return new Hash(sha(alg))\n}\n\n\n//# sourceURL=webpack:///./node_modules/create-hash/browser.js?");

/***/ }),

/***/ "./node_modules/create-hash/md5.js":
/*!*****************************************!*\
  !*** ./node_modules/create-hash/md5.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var MD5 = __webpack_require__(/*! md5.js */ \"./node_modules/md5.js/index.js\")\n\nmodule.exports = function (buffer) {\n  return new MD5().update(buffer).digest()\n}\n\n\n//# sourceURL=webpack:///./node_modules/create-hash/md5.js?");

/***/ }),

/***/ "./node_modules/create-hmac/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hmac/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Legacy = __webpack_require__(/*! ./legacy */ \"./node_modules/create-hmac/legacy.js\")\nvar Base = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar md5 = __webpack_require__(/*! create-hash/md5 */ \"./node_modules/create-hash/md5.js\")\nvar RIPEMD160 = __webpack_require__(/*! ripemd160 */ \"./node_modules/ripemd160/index.js\")\n\nvar sha = __webpack_require__(/*! sha.js */ \"./node_modules/sha.js/index.js\")\n\nvar ZEROS = Buffer.alloc(128)\n\nfunction Hmac (alg, key) {\n  Base.call(this, 'digest')\n  if (typeof key === 'string') {\n    key = Buffer.from(key)\n  }\n\n  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64\n\n  this._alg = alg\n  this._key = key\n  if (key.length > blocksize) {\n    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)\n    key = hash.update(key).digest()\n  } else if (key.length < blocksize) {\n    key = Buffer.concat([key, ZEROS], blocksize)\n  }\n\n  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)\n  var opad = this._opad = Buffer.allocUnsafe(blocksize)\n\n  for (var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)\n  this._hash.update(ipad)\n}\n\ninherits(Hmac, Base)\n\nHmac.prototype._update = function (data) {\n  this._hash.update(data)\n}\n\nHmac.prototype._final = function () {\n  var h = this._hash.digest()\n  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)\n  return hash.update(this._opad).update(h).digest()\n}\n\nmodule.exports = function createHmac (alg, key) {\n  alg = alg.toLowerCase()\n  if (alg === 'rmd160' || alg === 'ripemd160') {\n    return new Hmac('rmd160', key)\n  }\n  if (alg === 'md5') {\n    return new Legacy(md5, key)\n  }\n  return new Hmac(alg, key)\n}\n\n\n//# sourceURL=webpack:///./node_modules/create-hmac/browser.js?");

/***/ }),

/***/ "./node_modules/create-hmac/legacy.js":
/*!********************************************!*\
  !*** ./node_modules/create-hmac/legacy.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar Base = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\n\nvar ZEROS = Buffer.alloc(128)\nvar blocksize = 64\n\nfunction Hmac (alg, key) {\n  Base.call(this, 'digest')\n  if (typeof key === 'string') {\n    key = Buffer.from(key)\n  }\n\n  this._alg = alg\n  this._key = key\n\n  if (key.length > blocksize) {\n    key = alg(key)\n  } else if (key.length < blocksize) {\n    key = Buffer.concat([key, ZEROS], blocksize)\n  }\n\n  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)\n  var opad = this._opad = Buffer.allocUnsafe(blocksize)\n\n  for (var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  this._hash = [ipad]\n}\n\ninherits(Hmac, Base)\n\nHmac.prototype._update = function (data) {\n  this._hash.push(data)\n}\n\nHmac.prototype._final = function () {\n  var h = this._alg(Buffer.concat(this._hash))\n  return this._alg(Buffer.concat([this._opad, h]))\n}\nmodule.exports = Hmac\n\n\n//# sourceURL=webpack:///./node_modules/create-hmac/legacy.js?");

/***/ }),

/***/ "./node_modules/crypto-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\")\nexports.createHash = exports.Hash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\")\nexports.createHmac = exports.Hmac = __webpack_require__(/*! create-hmac */ \"./node_modules/create-hmac/browser.js\")\n\nvar algos = __webpack_require__(/*! browserify-sign/algos */ \"./node_modules/browserify-sign/algos.js\")\nvar algoKeys = Object.keys(algos)\nvar hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)\nexports.getHashes = function () {\n  return hashes\n}\n\nvar p = __webpack_require__(/*! pbkdf2 */ \"./node_modules/pbkdf2/browser.js\")\nexports.pbkdf2 = p.pbkdf2\nexports.pbkdf2Sync = p.pbkdf2Sync\n\nvar aes = __webpack_require__(/*! browserify-cipher */ \"./node_modules/browserify-cipher/browser.js\")\n\nexports.Cipher = aes.Cipher\nexports.createCipher = aes.createCipher\nexports.Cipheriv = aes.Cipheriv\nexports.createCipheriv = aes.createCipheriv\nexports.Decipher = aes.Decipher\nexports.createDecipher = aes.createDecipher\nexports.Decipheriv = aes.Decipheriv\nexports.createDecipheriv = aes.createDecipheriv\nexports.getCiphers = aes.getCiphers\nexports.listCiphers = aes.listCiphers\n\nvar dh = __webpack_require__(/*! diffie-hellman */ \"./node_modules/diffie-hellman/browser.js\")\n\nexports.DiffieHellmanGroup = dh.DiffieHellmanGroup\nexports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup\nexports.getDiffieHellman = dh.getDiffieHellman\nexports.createDiffieHellman = dh.createDiffieHellman\nexports.DiffieHellman = dh.DiffieHellman\n\nvar sign = __webpack_require__(/*! browserify-sign */ \"./node_modules/browserify-sign/browser/index.js\")\n\nexports.createSign = sign.createSign\nexports.Sign = sign.Sign\nexports.createVerify = sign.createVerify\nexports.Verify = sign.Verify\n\nexports.createECDH = __webpack_require__(/*! create-ecdh */ \"./node_modules/create-ecdh/browser.js\")\n\nvar publicEncrypt = __webpack_require__(/*! public-encrypt */ \"./node_modules/public-encrypt/browser.js\")\n\nexports.publicEncrypt = publicEncrypt.publicEncrypt\nexports.privateEncrypt = publicEncrypt.privateEncrypt\nexports.publicDecrypt = publicEncrypt.publicDecrypt\nexports.privateDecrypt = publicEncrypt.privateDecrypt\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n// ;[\n//   'createCredentials'\n// ].forEach(function (name) {\n//   exports[name] = function () {\n//     throw new Error([\n//       'sorry, ' + name + ' is not implemented yet',\n//       'we accept pull requests',\n//       'https://github.com/crypto-browserify/crypto-browserify'\n//     ].join('\\n'))\n//   }\n// })\n\nvar rf = __webpack_require__(/*! randomfill */ \"./node_modules/randomfill/browser.js\")\n\nexports.randomFill = rf.randomFill\nexports.randomFillSync = rf.randomFillSync\n\nexports.createCredentials = function () {\n  throw new Error([\n    'sorry, createCredentials is not implemented yet',\n    'we accept pull requests',\n    'https://github.com/crypto-browserify/crypto-browserify'\n  ].join('\\n'))\n}\n\nexports.constants = {\n  'DH_CHECK_P_NOT_SAFE_PRIME': 2,\n  'DH_CHECK_P_NOT_PRIME': 1,\n  'DH_UNABLE_TO_CHECK_GENERATOR': 4,\n  'DH_NOT_SUITABLE_GENERATOR': 8,\n  'NPN_ENABLED': 1,\n  'ALPN_ENABLED': 1,\n  'RSA_PKCS1_PADDING': 1,\n  'RSA_SSLV23_PADDING': 2,\n  'RSA_NO_PADDING': 3,\n  'RSA_PKCS1_OAEP_PADDING': 4,\n  'RSA_X931_PADDING': 5,\n  'RSA_PKCS1_PSS_PADDING': 6,\n  'POINT_CONVERSION_COMPRESSED': 2,\n  'POINT_CONVERSION_UNCOMPRESSED': 4,\n  'POINT_CONVERSION_HYBRID': 6\n}\n\n\n//# sourceURL=webpack:///./node_modules/crypto-browserify/index.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des.js":
/*!****************************************!*\
  !*** ./node_modules/des.js/lib/des.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.utils = __webpack_require__(/*! ./des/utils */ \"./node_modules/des.js/lib/des/utils.js\");\nexports.Cipher = __webpack_require__(/*! ./des/cipher */ \"./node_modules/des.js/lib/des/cipher.js\");\nexports.DES = __webpack_require__(/*! ./des/des */ \"./node_modules/des.js/lib/des/des.js\");\nexports.CBC = __webpack_require__(/*! ./des/cbc */ \"./node_modules/des.js/lib/des/cbc.js\");\nexports.EDE = __webpack_require__(/*! ./des/ede */ \"./node_modules/des.js/lib/des/ede.js\");\n\n\n//# sourceURL=webpack:///./node_modules/des.js/lib/des.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des/cbc.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/cbc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar proto = {};\n\nfunction CBCState(iv) {\n  assert.equal(iv.length, 8, 'Invalid IV length');\n\n  this.iv = new Array(8);\n  for (var i = 0; i < this.iv.length; i++)\n    this.iv[i] = iv[i];\n}\n\nfunction instantiate(Base) {\n  function CBC(options) {\n    Base.call(this, options);\n    this._cbcInit();\n  }\n  inherits(CBC, Base);\n\n  var keys = Object.keys(proto);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    CBC.prototype[key] = proto[key];\n  }\n\n  CBC.create = function create(options) {\n    return new CBC(options);\n  };\n\n  return CBC;\n}\n\nexports.instantiate = instantiate;\n\nproto._cbcInit = function _cbcInit() {\n  var state = new CBCState(this.options.iv);\n  this._cbcState = state;\n};\n\nproto._update = function _update(inp, inOff, out, outOff) {\n  var state = this._cbcState;\n  var superProto = this.constructor.super_.prototype;\n\n  var iv = state.iv;\n  if (this.type === 'encrypt') {\n    for (var i = 0; i < this.blockSize; i++)\n      iv[i] ^= inp[inOff + i];\n\n    superProto._update.call(this, iv, 0, out, outOff);\n\n    for (var i = 0; i < this.blockSize; i++)\n      iv[i] = out[outOff + i];\n  } else {\n    superProto._update.call(this, inp, inOff, out, outOff);\n\n    for (var i = 0; i < this.blockSize; i++)\n      out[outOff + i] ^= iv[i];\n\n    for (var i = 0; i < this.blockSize; i++)\n      iv[i] = inp[inOff + i];\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/des.js/lib/des/cbc.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des/cipher.js":
/*!***********************************************!*\
  !*** ./node_modules/des.js/lib/des/cipher.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction Cipher(options) {\n  this.options = options;\n\n  this.type = this.options.type;\n  this.blockSize = 8;\n  this._init();\n\n  this.buffer = new Array(this.blockSize);\n  this.bufferOff = 0;\n}\nmodule.exports = Cipher;\n\nCipher.prototype._init = function _init() {\n  // Might be overrided\n};\n\nCipher.prototype.update = function update(data) {\n  if (data.length === 0)\n    return [];\n\n  if (this.type === 'decrypt')\n    return this._updateDecrypt(data);\n  else\n    return this._updateEncrypt(data);\n};\n\nCipher.prototype._buffer = function _buffer(data, off) {\n  // Append data to buffer\n  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);\n  for (var i = 0; i < min; i++)\n    this.buffer[this.bufferOff + i] = data[off + i];\n  this.bufferOff += min;\n\n  // Shift next\n  return min;\n};\n\nCipher.prototype._flushBuffer = function _flushBuffer(out, off) {\n  this._update(this.buffer, 0, out, off);\n  this.bufferOff = 0;\n  return this.blockSize;\n};\n\nCipher.prototype._updateEncrypt = function _updateEncrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;\n  var out = new Array(count * this.blockSize);\n\n  if (this.bufferOff !== 0) {\n    inputOff += this._buffer(data, inputOff);\n\n    if (this.bufferOff === this.buffer.length)\n      outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Write blocks\n  var max = data.length - ((data.length - inputOff) % this.blockSize);\n  for (; inputOff < max; inputOff += this.blockSize) {\n    this._update(data, inputOff, out, outputOff);\n    outputOff += this.blockSize;\n  }\n\n  // Queue rest\n  for (; inputOff < data.length; inputOff++, this.bufferOff++)\n    this.buffer[this.bufferOff] = data[inputOff];\n\n  return out;\n};\n\nCipher.prototype._updateDecrypt = function _updateDecrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;\n  var out = new Array(count * this.blockSize);\n\n  // TODO(indutny): optimize it, this is far from optimal\n  for (; count > 0; count--) {\n    inputOff += this._buffer(data, inputOff);\n    outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Buffer rest of the input\n  inputOff += this._buffer(data, inputOff);\n\n  return out;\n};\n\nCipher.prototype.final = function final(buffer) {\n  var first;\n  if (buffer)\n    first = this.update(buffer);\n\n  var last;\n  if (this.type === 'encrypt')\n    last = this._finalEncrypt();\n  else\n    last = this._finalDecrypt();\n\n  if (first)\n    return first.concat(last);\n  else\n    return last;\n};\n\nCipher.prototype._pad = function _pad(buffer, off) {\n  if (off === 0)\n    return false;\n\n  while (off < buffer.length)\n    buffer[off++] = 0;\n\n  return true;\n};\n\nCipher.prototype._finalEncrypt = function _finalEncrypt() {\n  if (!this._pad(this.buffer, this.bufferOff))\n    return [];\n\n  var out = new Array(this.blockSize);\n  this._update(this.buffer, 0, out, 0);\n  return out;\n};\n\nCipher.prototype._unpad = function _unpad(buffer) {\n  return buffer;\n};\n\nCipher.prototype._finalDecrypt = function _finalDecrypt() {\n  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');\n  var out = new Array(this.blockSize);\n  this._flushBuffer(out, 0);\n\n  return this._unpad(out);\n};\n\n\n//# sourceURL=webpack:///./node_modules/des.js/lib/des/cipher.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des/des.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/des.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar des = __webpack_require__(/*! ../des */ \"./node_modules/des.js/lib/des.js\");\nvar utils = des.utils;\nvar Cipher = des.Cipher;\n\nfunction DESState() {\n  this.tmp = new Array(2);\n  this.keys = null;\n}\n\nfunction DES(options) {\n  Cipher.call(this, options);\n\n  var state = new DESState();\n  this._desState = state;\n\n  this.deriveKeys(state, options.key);\n}\ninherits(DES, Cipher);\nmodule.exports = DES;\n\nDES.create = function create(options) {\n  return new DES(options);\n};\n\nvar shiftTable = [\n  1, 1, 2, 2, 2, 2, 2, 2,\n  1, 2, 2, 2, 2, 2, 2, 1\n];\n\nDES.prototype.deriveKeys = function deriveKeys(state, key) {\n  state.keys = new Array(16 * 2);\n\n  assert.equal(key.length, this.blockSize, 'Invalid key length');\n\n  var kL = utils.readUInt32BE(key, 0);\n  var kR = utils.readUInt32BE(key, 4);\n\n  utils.pc1(kL, kR, state.tmp, 0);\n  kL = state.tmp[0];\n  kR = state.tmp[1];\n  for (var i = 0; i < state.keys.length; i += 2) {\n    var shift = shiftTable[i >>> 1];\n    kL = utils.r28shl(kL, shift);\n    kR = utils.r28shl(kR, shift);\n    utils.pc2(kL, kR, state.keys, i);\n  }\n};\n\nDES.prototype._update = function _update(inp, inOff, out, outOff) {\n  var state = this._desState;\n\n  var l = utils.readUInt32BE(inp, inOff);\n  var r = utils.readUInt32BE(inp, inOff + 4);\n\n  // Initial Permutation\n  utils.ip(l, r, state.tmp, 0);\n  l = state.tmp[0];\n  r = state.tmp[1];\n\n  if (this.type === 'encrypt')\n    this._encrypt(state, l, r, state.tmp, 0);\n  else\n    this._decrypt(state, l, r, state.tmp, 0);\n\n  l = state.tmp[0];\n  r = state.tmp[1];\n\n  utils.writeUInt32BE(out, l, outOff);\n  utils.writeUInt32BE(out, r, outOff + 4);\n};\n\nDES.prototype._pad = function _pad(buffer, off) {\n  var value = buffer.length - off;\n  for (var i = off; i < buffer.length; i++)\n    buffer[i] = value;\n\n  return true;\n};\n\nDES.prototype._unpad = function _unpad(buffer) {\n  var pad = buffer[buffer.length - 1];\n  for (var i = buffer.length - pad; i < buffer.length; i++)\n    assert.equal(buffer[i], pad);\n\n  return buffer.slice(0, buffer.length - pad);\n};\n\nDES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {\n  var l = lStart;\n  var r = rStart;\n\n  // Apply f() x16 times\n  for (var i = 0; i < state.keys.length; i += 2) {\n    var keyL = state.keys[i];\n    var keyR = state.keys[i + 1];\n\n    // f(r, k)\n    utils.expand(r, state.tmp, 0);\n\n    keyL ^= state.tmp[0];\n    keyR ^= state.tmp[1];\n    var s = utils.substitute(keyL, keyR);\n    var f = utils.permute(s);\n\n    var t = r;\n    r = (l ^ f) >>> 0;\n    l = t;\n  }\n\n  // Reverse Initial Permutation\n  utils.rip(r, l, out, off);\n};\n\nDES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {\n  var l = rStart;\n  var r = lStart;\n\n  // Apply f() x16 times\n  for (var i = state.keys.length - 2; i >= 0; i -= 2) {\n    var keyL = state.keys[i];\n    var keyR = state.keys[i + 1];\n\n    // f(r, k)\n    utils.expand(l, state.tmp, 0);\n\n    keyL ^= state.tmp[0];\n    keyR ^= state.tmp[1];\n    var s = utils.substitute(keyL, keyR);\n    var f = utils.permute(s);\n\n    var t = l;\n    l = (r ^ f) >>> 0;\n    r = t;\n  }\n\n  // Reverse Initial Permutation\n  utils.rip(l, r, out, off);\n};\n\n\n//# sourceURL=webpack:///./node_modules/des.js/lib/des/des.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des/ede.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/ede.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar des = __webpack_require__(/*! ../des */ \"./node_modules/des.js/lib/des.js\");\nvar Cipher = des.Cipher;\nvar DES = des.DES;\n\nfunction EDEState(type, key) {\n  assert.equal(key.length, 24, 'Invalid key length');\n\n  var k1 = key.slice(0, 8);\n  var k2 = key.slice(8, 16);\n  var k3 = key.slice(16, 24);\n\n  if (type === 'encrypt') {\n    this.ciphers = [\n      DES.create({ type: 'encrypt', key: k1 }),\n      DES.create({ type: 'decrypt', key: k2 }),\n      DES.create({ type: 'encrypt', key: k3 })\n    ];\n  } else {\n    this.ciphers = [\n      DES.create({ type: 'decrypt', key: k3 }),\n      DES.create({ type: 'encrypt', key: k2 }),\n      DES.create({ type: 'decrypt', key: k1 })\n    ];\n  }\n}\n\nfunction EDE(options) {\n  Cipher.call(this, options);\n\n  var state = new EDEState(this.type, this.options.key);\n  this._edeState = state;\n}\ninherits(EDE, Cipher);\n\nmodule.exports = EDE;\n\nEDE.create = function create(options) {\n  return new EDE(options);\n};\n\nEDE.prototype._update = function _update(inp, inOff, out, outOff) {\n  var state = this._edeState;\n\n  state.ciphers[0]._update(inp, inOff, out, outOff);\n  state.ciphers[1]._update(out, outOff, out, outOff);\n  state.ciphers[2]._update(out, outOff, out, outOff);\n};\n\nEDE.prototype._pad = DES.prototype._pad;\nEDE.prototype._unpad = DES.prototype._unpad;\n\n\n//# sourceURL=webpack:///./node_modules/des.js/lib/des/ede.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/des.js/lib/des/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.readUInt32BE = function readUInt32BE(bytes, off) {\n  var res =  (bytes[0 + off] << 24) |\n             (bytes[1 + off] << 16) |\n             (bytes[2 + off] << 8) |\n             bytes[3 + off];\n  return res >>> 0;\n};\n\nexports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {\n  bytes[0 + off] = value >>> 24;\n  bytes[1 + off] = (value >>> 16) & 0xff;\n  bytes[2 + off] = (value >>> 8) & 0xff;\n  bytes[3 + off] = value & 0xff;\n};\n\nexports.ip = function ip(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  for (var i = 6; i >= 0; i -= 2) {\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inR >>> (j + i)) & 1;\n    }\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inL >>> (j + i)) & 1;\n    }\n  }\n\n  for (var i = 6; i >= 0; i -= 2) {\n    for (var j = 1; j <= 25; j += 8) {\n      outR <<= 1;\n      outR |= (inR >>> (j + i)) & 1;\n    }\n    for (var j = 1; j <= 25; j += 8) {\n      outR <<= 1;\n      outR |= (inL >>> (j + i)) & 1;\n    }\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.rip = function rip(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  for (var i = 0; i < 4; i++) {\n    for (var j = 24; j >= 0; j -= 8) {\n      outL <<= 1;\n      outL |= (inR >>> (j + i)) & 1;\n      outL <<= 1;\n      outL |= (inL >>> (j + i)) & 1;\n    }\n  }\n  for (var i = 4; i < 8; i++) {\n    for (var j = 24; j >= 0; j -= 8) {\n      outR <<= 1;\n      outR |= (inR >>> (j + i)) & 1;\n      outR <<= 1;\n      outR |= (inL >>> (j + i)) & 1;\n    }\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.pc1 = function pc1(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  // 7, 15, 23, 31, 39, 47, 55, 63\n  // 6, 14, 22, 30, 39, 47, 55, 63\n  // 5, 13, 21, 29, 39, 47, 55, 63\n  // 4, 12, 20, 28\n  for (var i = 7; i >= 5; i--) {\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inR >> (j + i)) & 1;\n    }\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inL >> (j + i)) & 1;\n    }\n  }\n  for (var j = 0; j <= 24; j += 8) {\n    outL <<= 1;\n    outL |= (inR >> (j + i)) & 1;\n  }\n\n  // 1, 9, 17, 25, 33, 41, 49, 57\n  // 2, 10, 18, 26, 34, 42, 50, 58\n  // 3, 11, 19, 27, 35, 43, 51, 59\n  // 36, 44, 52, 60\n  for (var i = 1; i <= 3; i++) {\n    for (var j = 0; j <= 24; j += 8) {\n      outR <<= 1;\n      outR |= (inR >> (j + i)) & 1;\n    }\n    for (var j = 0; j <= 24; j += 8) {\n      outR <<= 1;\n      outR |= (inL >> (j + i)) & 1;\n    }\n  }\n  for (var j = 0; j <= 24; j += 8) {\n    outR <<= 1;\n    outR |= (inL >> (j + i)) & 1;\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.r28shl = function r28shl(num, shift) {\n  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));\n};\n\nvar pc2table = [\n  // inL => outL\n  14, 11, 17, 4, 27, 23, 25, 0,\n  13, 22, 7, 18, 5, 9, 16, 24,\n  2, 20, 12, 21, 1, 8, 15, 26,\n\n  // inR => outR\n  15, 4, 25, 19, 9, 1, 26, 16,\n  5, 11, 23, 8, 12, 7, 17, 0,\n  22, 3, 10, 14, 6, 20, 27, 24\n];\n\nexports.pc2 = function pc2(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  var len = pc2table.length >>> 1;\n  for (var i = 0; i < len; i++) {\n    outL <<= 1;\n    outL |= (inL >>> pc2table[i]) & 0x1;\n  }\n  for (var i = len; i < pc2table.length; i++) {\n    outR <<= 1;\n    outR |= (inR >>> pc2table[i]) & 0x1;\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.expand = function expand(r, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  outL = ((r & 1) << 5) | (r >>> 27);\n  for (var i = 23; i >= 15; i -= 4) {\n    outL <<= 6;\n    outL |= (r >>> i) & 0x3f;\n  }\n  for (var i = 11; i >= 3; i -= 4) {\n    outR |= (r >>> i) & 0x3f;\n    outR <<= 6;\n  }\n  outR |= ((r & 0x1f) << 1) | (r >>> 31);\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nvar sTable = [\n  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,\n  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,\n  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,\n  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,\n\n  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,\n  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,\n  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,\n  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,\n\n  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,\n  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,\n  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,\n  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,\n\n  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,\n  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,\n  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,\n  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,\n\n  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,\n  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,\n  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,\n  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,\n\n  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,\n  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,\n  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,\n  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,\n\n  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,\n  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,\n  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,\n  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,\n\n  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,\n  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,\n  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,\n  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11\n];\n\nexports.substitute = function substitute(inL, inR) {\n  var out = 0;\n  for (var i = 0; i < 4; i++) {\n    var b = (inL >>> (18 - i * 6)) & 0x3f;\n    var sb = sTable[i * 0x40 + b];\n\n    out <<= 4;\n    out |= sb;\n  }\n  for (var i = 0; i < 4; i++) {\n    var b = (inR >>> (18 - i * 6)) & 0x3f;\n    var sb = sTable[4 * 0x40 + i * 0x40 + b];\n\n    out <<= 4;\n    out |= sb;\n  }\n  return out >>> 0;\n};\n\nvar permuteTable = [\n  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,\n  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7\n];\n\nexports.permute = function permute(num) {\n  var out = 0;\n  for (var i = 0; i < permuteTable.length; i++) {\n    out <<= 1;\n    out |= (num >>> permuteTable[i]) & 0x1;\n  }\n  return out >>> 0;\n};\n\nexports.padSplit = function padSplit(num, size, group) {\n  var str = num.toString(2);\n  while (str.length < size)\n    str = '0' + str;\n\n  var out = [];\n  for (var i = 0; i < size; i += group)\n    out.push(str.slice(i, i + group));\n  return out.join(' ');\n};\n\n\n//# sourceURL=webpack:///./node_modules/des.js/lib/des/utils.js?");

/***/ }),

/***/ "./node_modules/diffie-hellman/browser.js":
/*!************************************************!*\
  !*** ./node_modules/diffie-hellman/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(/*! ./lib/generatePrime */ \"./node_modules/diffie-hellman/lib/generatePrime.js\")\nvar primes = __webpack_require__(/*! ./lib/primes.json */ \"./node_modules/diffie-hellman/lib/primes.json\")\n\nvar DH = __webpack_require__(/*! ./lib/dh */ \"./node_modules/diffie-hellman/lib/dh.js\")\n\nfunction getDiffieHellman (mod) {\n  var prime = new Buffer(primes[mod].prime, 'hex')\n  var gen = new Buffer(primes[mod].gen, 'hex')\n\n  return new DH(prime, gen)\n}\n\nvar ENCODINGS = {\n  'binary': true, 'hex': true, 'base64': true\n}\n\nfunction createDiffieHellman (prime, enc, generator, genc) {\n  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {\n    return createDiffieHellman(prime, 'binary', enc, generator)\n  }\n\n  enc = enc || 'binary'\n  genc = genc || 'binary'\n  generator = generator || new Buffer([2])\n\n  if (!Buffer.isBuffer(generator)) {\n    generator = new Buffer(generator, genc)\n  }\n\n  if (typeof prime === 'number') {\n    return new DH(generatePrime(prime, generator), generator, true)\n  }\n\n  if (!Buffer.isBuffer(prime)) {\n    prime = new Buffer(prime, enc)\n  }\n\n  return new DH(prime, generator, true)\n}\n\nexports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman\nexports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/diffie-hellman/browser.js?");

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/dh.js":
/*!***********************************************!*\
  !*** ./node_modules/diffie-hellman/lib/dh.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar MillerRabin = __webpack_require__(/*! miller-rabin */ \"./node_modules/miller-rabin/lib/mr.js\");\nvar millerRabin = new MillerRabin();\nvar TWENTYFOUR = new BN(24);\nvar ELEVEN = new BN(11);\nvar TEN = new BN(10);\nvar THREE = new BN(3);\nvar SEVEN = new BN(7);\nvar primes = __webpack_require__(/*! ./generatePrime */ \"./node_modules/diffie-hellman/lib/generatePrime.js\");\nvar randomBytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\");\nmodule.exports = DH;\n\nfunction setPublicKey(pub, enc) {\n  enc = enc || 'utf8';\n  if (!Buffer.isBuffer(pub)) {\n    pub = new Buffer(pub, enc);\n  }\n  this._pub = new BN(pub);\n  return this;\n}\n\nfunction setPrivateKey(priv, enc) {\n  enc = enc || 'utf8';\n  if (!Buffer.isBuffer(priv)) {\n    priv = new Buffer(priv, enc);\n  }\n  this._priv = new BN(priv);\n  return this;\n}\n\nvar primeCache = {};\nfunction checkPrime(prime, generator) {\n  var gen = generator.toString('hex');\n  var hex = [gen, prime.toString(16)].join('_');\n  if (hex in primeCache) {\n    return primeCache[hex];\n  }\n  var error = 0;\n\n  if (prime.isEven() ||\n    !primes.simpleSieve ||\n    !primes.fermatTest(prime) ||\n    !millerRabin.test(prime)) {\n    //not a prime so +1\n    error += 1;\n\n    if (gen === '02' || gen === '05') {\n      // we'd be able to check the generator\n      // it would fail so +8\n      error += 8;\n    } else {\n      //we wouldn't be able to test the generator\n      // so +4\n      error += 4;\n    }\n    primeCache[hex] = error;\n    return error;\n  }\n  if (!millerRabin.test(prime.shrn(1))) {\n    //not a safe prime\n    error += 2;\n  }\n  var rem;\n  switch (gen) {\n    case '02':\n      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {\n        // unsuidable generator\n        error += 8;\n      }\n      break;\n    case '05':\n      rem = prime.mod(TEN);\n      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {\n        // prime mod 10 needs to equal 3 or 7\n        error += 8;\n      }\n      break;\n    default:\n      error += 4;\n  }\n  primeCache[hex] = error;\n  return error;\n}\n\nfunction DH(prime, generator, malleable) {\n  this.setGenerator(generator);\n  this.__prime = new BN(prime);\n  this._prime = BN.mont(this.__prime);\n  this._primeLen = prime.length;\n  this._pub = undefined;\n  this._priv = undefined;\n  this._primeCode = undefined;\n  if (malleable) {\n    this.setPublicKey = setPublicKey;\n    this.setPrivateKey = setPrivateKey;\n  } else {\n    this._primeCode = 8;\n  }\n}\nObject.defineProperty(DH.prototype, 'verifyError', {\n  enumerable: true,\n  get: function () {\n    if (typeof this._primeCode !== 'number') {\n      this._primeCode = checkPrime(this.__prime, this.__gen);\n    }\n    return this._primeCode;\n  }\n});\nDH.prototype.generateKeys = function () {\n  if (!this._priv) {\n    this._priv = new BN(randomBytes(this._primeLen));\n  }\n  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();\n  return this.getPublicKey();\n};\n\nDH.prototype.computeSecret = function (other) {\n  other = new BN(other);\n  other = other.toRed(this._prime);\n  var secret = other.redPow(this._priv).fromRed();\n  var out = new Buffer(secret.toArray());\n  var prime = this.getPrime();\n  if (out.length < prime.length) {\n    var front = new Buffer(prime.length - out.length);\n    front.fill(0);\n    out = Buffer.concat([front, out]);\n  }\n  return out;\n};\n\nDH.prototype.getPublicKey = function getPublicKey(enc) {\n  return formatReturnValue(this._pub, enc);\n};\n\nDH.prototype.getPrivateKey = function getPrivateKey(enc) {\n  return formatReturnValue(this._priv, enc);\n};\n\nDH.prototype.getPrime = function (enc) {\n  return formatReturnValue(this.__prime, enc);\n};\n\nDH.prototype.getGenerator = function (enc) {\n  return formatReturnValue(this._gen, enc);\n};\n\nDH.prototype.setGenerator = function (gen, enc) {\n  enc = enc || 'utf8';\n  if (!Buffer.isBuffer(gen)) {\n    gen = new Buffer(gen, enc);\n  }\n  this.__gen = gen;\n  this._gen = new BN(gen);\n  return this;\n};\n\nfunction formatReturnValue(bn, enc) {\n  var buf = new Buffer(bn.toArray());\n  if (!enc) {\n    return buf;\n  } else {\n    return buf.toString(enc);\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/diffie-hellman/lib/dh.js?");

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/generatePrime.js":
/*!**********************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/generatePrime.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var randomBytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\");\nmodule.exports = findPrime;\nfindPrime.simpleSieve = simpleSieve;\nfindPrime.fermatTest = fermatTest;\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar TWENTYFOUR = new BN(24);\nvar MillerRabin = __webpack_require__(/*! miller-rabin */ \"./node_modules/miller-rabin/lib/mr.js\");\nvar millerRabin = new MillerRabin();\nvar ONE = new BN(1);\nvar TWO = new BN(2);\nvar FIVE = new BN(5);\nvar SIXTEEN = new BN(16);\nvar EIGHT = new BN(8);\nvar TEN = new BN(10);\nvar THREE = new BN(3);\nvar SEVEN = new BN(7);\nvar ELEVEN = new BN(11);\nvar FOUR = new BN(4);\nvar TWELVE = new BN(12);\nvar primes = null;\n\nfunction _getPrimes() {\n  if (primes !== null)\n    return primes;\n\n  var limit = 0x100000;\n  var res = [];\n  res[0] = 2;\n  for (var i = 1, k = 3; k < limit; k += 2) {\n    var sqrt = Math.ceil(Math.sqrt(k));\n    for (var j = 0; j < i && res[j] <= sqrt; j++)\n      if (k % res[j] === 0)\n        break;\n\n    if (i !== j && res[j] <= sqrt)\n      continue;\n\n    res[i++] = k;\n  }\n  primes = res;\n  return res;\n}\n\nfunction simpleSieve(p) {\n  var primes = _getPrimes();\n\n  for (var i = 0; i < primes.length; i++)\n    if (p.modn(primes[i]) === 0) {\n      if (p.cmpn(primes[i]) === 0) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n  return true;\n}\n\nfunction fermatTest(p) {\n  var red = BN.mont(p);\n  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;\n}\n\nfunction findPrime(bits, gen) {\n  if (bits < 16) {\n    // this is what openssl does\n    if (gen === 2 || gen === 5) {\n      return new BN([0x8c, 0x7b]);\n    } else {\n      return new BN([0x8c, 0x27]);\n    }\n  }\n  gen = new BN(gen);\n\n  var num, n2;\n\n  while (true) {\n    num = new BN(randomBytes(Math.ceil(bits / 8)));\n    while (num.bitLength() > bits) {\n      num.ishrn(1);\n    }\n    if (num.isEven()) {\n      num.iadd(ONE);\n    }\n    if (!num.testn(1)) {\n      num.iadd(TWO);\n    }\n    if (!gen.cmp(TWO)) {\n      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {\n        num.iadd(FOUR);\n      }\n    } else if (!gen.cmp(FIVE)) {\n      while (num.mod(TEN).cmp(THREE)) {\n        num.iadd(FOUR);\n      }\n    }\n    n2 = num.shrn(1);\n    if (simpleSieve(n2) && simpleSieve(num) &&\n      fermatTest(n2) && fermatTest(num) &&\n      millerRabin.test(n2) && millerRabin.test(num)) {\n      return num;\n    }\n  }\n\n}\n\n\n//# sourceURL=webpack:///./node_modules/diffie-hellman/lib/generatePrime.js?");

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/primes.json":
/*!*****************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/primes.json ***!
  \*****************************************************/
/*! exports provided: modp1, modp2, modp5, modp14, modp15, modp16, modp17, modp18, default */
/***/ (function(module) {

eval("module.exports = {\"modp1\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff\"},\"modp2\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff\"},\"modp5\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff\"},\"modp14\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff\"},\"modp15\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff\"},\"modp16\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff\"},\"modp17\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff\"},\"modp18\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff\"}};\n\n//# sourceURL=webpack:///./node_modules/diffie-hellman/lib/primes.json?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic.js":
/*!***********************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar elliptic = exports;\n\nelliptic.version = __webpack_require__(/*! ../package.json */ \"./node_modules/elliptic/package.json\").version;\nelliptic.utils = __webpack_require__(/*! ./elliptic/utils */ \"./node_modules/elliptic/lib/elliptic/utils.js\");\nelliptic.rand = __webpack_require__(/*! brorand */ \"./node_modules/brorand/index.js\");\nelliptic.curve = __webpack_require__(/*! ./elliptic/curve */ \"./node_modules/elliptic/lib/elliptic/curve/index.js\");\nelliptic.curves = __webpack_require__(/*! ./elliptic/curves */ \"./node_modules/elliptic/lib/elliptic/curves.js\");\n\n// Protocols\nelliptic.ec = __webpack_require__(/*! ./elliptic/ec */ \"./node_modules/elliptic/lib/elliptic/ec/index.js\");\nelliptic.eddsa = __webpack_require__(/*! ./elliptic/eddsa */ \"./node_modules/elliptic/lib/elliptic/eddsa/index.js\");\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/base.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  for (var j = 0; j < naf.length; j += doubles.step) {\n    var nafW = 0;\n    for (var k = j + doubles.step - 1; k >= j; k--)\n      nafW = (nafW << 1) + naf[k];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (var j = 0; j < repr.length; j++) {\n      var nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var k = 0; i >= 0 && naf[i] === 0; i--)\n      k++;\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n                                                       points,\n                                                       coeffs,\n                                                       len,\n                                                       jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  for (var i = 0; i < len; i++) {\n    var p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (var i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a]);\n      naf[b] = getNAF(coeffs[b], wndWidth[b]);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b] /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (var j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (var i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (var j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (var j = 0; j < len; j++) {\n      var z = tmp[j];\n      var p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (var i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n                          bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/curve/base.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/edwards.js":
/*!*************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/edwards.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curve = __webpack_require__(/*! ../curve */ \"./node_modules/elliptic/lib/elliptic/curve/index.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Base = curve.base;\n\nvar assert = elliptic.utils.assert;\n\nfunction EdwardsCurve(conf) {\n  // NOTE: Important as we are creating point in Base.call()\n  this.twisted = (conf.a | 0) !== 1;\n  this.mOneA = this.twisted && (conf.a | 0) === -1;\n  this.extended = this.mOneA;\n\n  Base.call(this, 'edwards', conf);\n\n  this.a = new BN(conf.a, 16).umod(this.red.m);\n  this.a = this.a.toRed(this.red);\n  this.c = new BN(conf.c, 16).toRed(this.red);\n  this.c2 = this.c.redSqr();\n  this.d = new BN(conf.d, 16).toRed(this.red);\n  this.dd = this.d.redAdd(this.d);\n\n  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);\n  this.oneC = (conf.c | 0) === 1;\n}\ninherits(EdwardsCurve, Base);\nmodule.exports = EdwardsCurve;\n\nEdwardsCurve.prototype._mulA = function _mulA(num) {\n  if (this.mOneA)\n    return num.redNeg();\n  else\n    return this.a.redMul(num);\n};\n\nEdwardsCurve.prototype._mulC = function _mulC(num) {\n  if (this.oneC)\n    return num;\n  else\n    return this.c.redMul(num);\n};\n\n// Just for compatibility with Short curve\nEdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {\n  return this.point(x, y, z, t);\n};\n\nEdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var x2 = x.redSqr();\n  var rhs = this.c2.redSub(this.a.redMul(x2));\n  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));\n\n  var y2 = rhs.redMul(lhs.redInvm());\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nEdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {\n  y = new BN(y, 16);\n  if (!y.red)\n    y = y.toRed(this.red);\n\n  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)\n  var y2 = y.redSqr();\n  var lhs = y2.redSub(this.c2);\n  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);\n  var x2 = lhs.redMul(rhs.redInvm());\n\n  if (x2.cmp(this.zero) === 0) {\n    if (odd)\n      throw new Error('invalid point');\n    else\n      return this.point(this.zero, y);\n  }\n\n  var x = x2.redSqrt();\n  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  if (x.fromRed().isOdd() !== odd)\n    x = x.redNeg();\n\n  return this.point(x, y);\n};\n\nEdwardsCurve.prototype.validate = function validate(point) {\n  if (point.isInfinity())\n    return true;\n\n  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)\n  point.normalize();\n\n  var x2 = point.x.redSqr();\n  var y2 = point.y.redSqr();\n  var lhs = x2.redMul(this.a).redAdd(y2);\n  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));\n\n  return lhs.cmp(rhs) === 0;\n};\n\nfunction Point(curve, x, y, z, t) {\n  Base.BasePoint.call(this, curve, 'projective');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.zero;\n    this.y = this.curve.one;\n    this.z = this.curve.one;\n    this.t = this.curve.zero;\n    this.zOne = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = z ? new BN(z, 16) : this.curve.one;\n    this.t = t && new BN(t, 16);\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n    if (this.t && !this.t.red)\n      this.t = this.t.toRed(this.curve.red);\n    this.zOne = this.z === this.curve.one;\n\n    // Use extended coordinates\n    if (this.curve.extended && !this.t) {\n      this.t = this.x.redMul(this.y);\n      if (!this.zOne)\n        this.t = this.t.redMul(this.z.redInvm());\n    }\n  }\n}\ninherits(Point, Base.BasePoint);\n\nEdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {\n  return Point.fromJSON(this, obj);\n};\n\nEdwardsCurve.prototype.point = function point(x, y, z, t) {\n  return new Point(this, x, y, z, t);\n};\n\nPoint.fromJSON = function fromJSON(curve, obj) {\n  return new Point(curve, obj[0], obj[1], obj[2]);\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) +\n      ' z: ' + this.z.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.x.cmpn(0) === 0 &&\n    (this.y.cmp(this.z) === 0 ||\n    (this.zOne && this.y.cmp(this.curve.c) === 0));\n};\n\nPoint.prototype._extDbl = function _extDbl() {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html\n  //     #doubling-dbl-2008-hwcd\n  // 4M + 4S\n\n  // A = X1^2\n  var a = this.x.redSqr();\n  // B = Y1^2\n  var b = this.y.redSqr();\n  // C = 2 * Z1^2\n  var c = this.z.redSqr();\n  c = c.redIAdd(c);\n  // D = a * A\n  var d = this.curve._mulA(a);\n  // E = (X1 + Y1)^2 - A - B\n  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);\n  // G = D + B\n  var g = d.redAdd(b);\n  // F = G - C\n  var f = g.redSub(c);\n  // H = D - B\n  var h = d.redSub(b);\n  // X3 = E * F\n  var nx = e.redMul(f);\n  // Y3 = G * H\n  var ny = g.redMul(h);\n  // T3 = E * H\n  var nt = e.redMul(h);\n  // Z3 = F * G\n  var nz = f.redMul(g);\n  return this.curve.point(nx, ny, nz, nt);\n};\n\nPoint.prototype._projDbl = function _projDbl() {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html\n  //     #doubling-dbl-2008-bbjlp\n  //     #doubling-dbl-2007-bl\n  // and others\n  // Generally 3M + 4S or 2M + 4S\n\n  // B = (X1 + Y1)^2\n  var b = this.x.redAdd(this.y).redSqr();\n  // C = X1^2\n  var c = this.x.redSqr();\n  // D = Y1^2\n  var d = this.y.redSqr();\n\n  var nx;\n  var ny;\n  var nz;\n  if (this.curve.twisted) {\n    // E = a * C\n    var e = this.curve._mulA(c);\n    // F = E + D\n    var f = e.redAdd(d);\n    if (this.zOne) {\n      // X3 = (B - C - D) * (F - 2)\n      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));\n      // Y3 = F * (E - D)\n      ny = f.redMul(e.redSub(d));\n      // Z3 = F^2 - 2 * F\n      nz = f.redSqr().redSub(f).redSub(f);\n    } else {\n      // H = Z1^2\n      var h = this.z.redSqr();\n      // J = F - 2 * H\n      var j = f.redSub(h).redISub(h);\n      // X3 = (B-C-D)*J\n      nx = b.redSub(c).redISub(d).redMul(j);\n      // Y3 = F * (E - D)\n      ny = f.redMul(e.redSub(d));\n      // Z3 = F * J\n      nz = f.redMul(j);\n    }\n  } else {\n    // E = C + D\n    var e = c.redAdd(d);\n    // H = (c * Z1)^2\n    var h = this.curve._mulC(this.z).redSqr();\n    // J = E - 2 * H\n    var j = e.redSub(h).redSub(h);\n    // X3 = c * (B - E) * J\n    nx = this.curve._mulC(b.redISub(e)).redMul(j);\n    // Y3 = c * E * (C - D)\n    ny = this.curve._mulC(e).redMul(c.redISub(d));\n    // Z3 = E * J\n    nz = e.redMul(j);\n  }\n  return this.curve.point(nx, ny, nz);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  // Double in extended coordinates\n  if (this.curve.extended)\n    return this._extDbl();\n  else\n    return this._projDbl();\n};\n\nPoint.prototype._extAdd = function _extAdd(p) {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html\n  //     #addition-add-2008-hwcd-3\n  // 8M\n\n  // A = (Y1 - X1) * (Y2 - X2)\n  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));\n  // B = (Y1 + X1) * (Y2 + X2)\n  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));\n  // C = T1 * k * T2\n  var c = this.t.redMul(this.curve.dd).redMul(p.t);\n  // D = Z1 * 2 * Z2\n  var d = this.z.redMul(p.z.redAdd(p.z));\n  // E = B - A\n  var e = b.redSub(a);\n  // F = D - C\n  var f = d.redSub(c);\n  // G = D + C\n  var g = d.redAdd(c);\n  // H = B + A\n  var h = b.redAdd(a);\n  // X3 = E * F\n  var nx = e.redMul(f);\n  // Y3 = G * H\n  var ny = g.redMul(h);\n  // T3 = E * H\n  var nt = e.redMul(h);\n  // Z3 = F * G\n  var nz = f.redMul(g);\n  return this.curve.point(nx, ny, nz, nt);\n};\n\nPoint.prototype._projAdd = function _projAdd(p) {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html\n  //     #addition-add-2008-bbjlp\n  //     #addition-add-2007-bl\n  // 10M + 1S\n\n  // A = Z1 * Z2\n  var a = this.z.redMul(p.z);\n  // B = A^2\n  var b = a.redSqr();\n  // C = X1 * X2\n  var c = this.x.redMul(p.x);\n  // D = Y1 * Y2\n  var d = this.y.redMul(p.y);\n  // E = d * C * D\n  var e = this.curve.d.redMul(c).redMul(d);\n  // F = B - E\n  var f = b.redSub(e);\n  // G = B + E\n  var g = b.redAdd(e);\n  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)\n  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);\n  var nx = a.redMul(f).redMul(tmp);\n  var ny;\n  var nz;\n  if (this.curve.twisted) {\n    // Y3 = A * G * (D - a * C)\n    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));\n    // Z3 = F * G\n    nz = f.redMul(g);\n  } else {\n    // Y3 = A * G * (D - C)\n    ny = a.redMul(g).redMul(d.redSub(c));\n    // Z3 = c * F * G\n    nz = this.curve._mulC(f).redMul(g);\n  }\n  return this.curve.point(nx, ny, nz);\n};\n\nPoint.prototype.add = function add(p) {\n  if (this.isInfinity())\n    return p;\n  if (p.isInfinity())\n    return this;\n\n  if (this.curve.extended)\n    return this._extAdd(p);\n  else\n    return this._projAdd(p);\n};\n\nPoint.prototype.mul = function mul(k) {\n  if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p, k2) {\n  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p, k2) {\n  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);\n};\n\nPoint.prototype.normalize = function normalize() {\n  if (this.zOne)\n    return this;\n\n  // Normalize coordinates\n  var zi = this.z.redInvm();\n  this.x = this.x.redMul(zi);\n  this.y = this.y.redMul(zi);\n  if (this.t)\n    this.t = this.t.redMul(zi);\n  this.z = this.curve.one;\n  this.zOne = true;\n  return this;\n};\n\nPoint.prototype.neg = function neg() {\n  return this.curve.point(this.x.redNeg(),\n                          this.y,\n                          this.z,\n                          this.t && this.t.redNeg());\n};\n\nPoint.prototype.getX = function getX() {\n  this.normalize();\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  this.normalize();\n  return this.y.fromRed();\n};\n\nPoint.prototype.eq = function eq(other) {\n  return this === other ||\n         this.getX().cmp(other.getX()) === 0 &&\n         this.getY().cmp(other.getY()) === 0;\n};\n\nPoint.prototype.eqXToP = function eqXToP(x) {\n  var rx = x.toRed(this.curve.red).redMul(this.z);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(this.z);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\n// Compatibility with BaseCurve\nPoint.prototype.toP = Point.prototype.normalize;\nPoint.prototype.mixedAdd = Point.prototype.add;\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/curve/edwards.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curve = exports;\n\ncurve.base = __webpack_require__(/*! ./base */ \"./node_modules/elliptic/lib/elliptic/curve/base.js\");\ncurve.short = __webpack_require__(/*! ./short */ \"./node_modules/elliptic/lib/elliptic/curve/short.js\");\ncurve.mont = __webpack_require__(/*! ./mont */ \"./node_modules/elliptic/lib/elliptic/curve/mont.js\");\ncurve.edwards = __webpack_require__(/*! ./edwards */ \"./node_modules/elliptic/lib/elliptic/curve/edwards.js\");\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/curve/index.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/mont.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/mont.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curve = __webpack_require__(/*! ../curve */ \"./node_modules/elliptic/lib/elliptic/curve/index.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Base = curve.base;\n\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\n\nfunction MontCurve(conf) {\n  Base.call(this, 'mont', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.i4 = new BN(4).toRed(this.red).redInvm();\n  this.two = new BN(2).toRed(this.red);\n  this.a24 = this.i4.redMul(this.a.redAdd(this.two));\n}\ninherits(MontCurve, Base);\nmodule.exports = MontCurve;\n\nMontCurve.prototype.validate = function validate(point) {\n  var x = point.normalize().x;\n  var x2 = x.redSqr();\n  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);\n  var y = rhs.redSqrt();\n\n  return y.redSqr().cmp(rhs) === 0;\n};\n\nfunction Point(curve, x, z) {\n  Base.BasePoint.call(this, curve, 'projective');\n  if (x === null && z === null) {\n    this.x = this.curve.one;\n    this.z = this.curve.zero;\n  } else {\n    this.x = new BN(x, 16);\n    this.z = new BN(z, 16);\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n  }\n}\ninherits(Point, Base.BasePoint);\n\nMontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  return this.point(utils.toArray(bytes, enc), 1);\n};\n\nMontCurve.prototype.point = function point(x, z) {\n  return new Point(this, x, z);\n};\n\nMontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {\n  return Point.fromJSON(this, obj);\n};\n\nPoint.prototype.precompute = function precompute() {\n  // No-op\n};\n\nPoint.prototype._encode = function _encode() {\n  return this.getX().toArray('be', this.curve.p.byteLength());\n};\n\nPoint.fromJSON = function fromJSON(curve, obj) {\n  return new Point(curve, obj[0], obj[1] || curve.one);\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' z: ' + this.z.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n\nPoint.prototype.dbl = function dbl() {\n  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3\n  // 2M + 2S + 4A\n\n  // A = X1 + Z1\n  var a = this.x.redAdd(this.z);\n  // AA = A^2\n  var aa = a.redSqr();\n  // B = X1 - Z1\n  var b = this.x.redSub(this.z);\n  // BB = B^2\n  var bb = b.redSqr();\n  // C = AA - BB\n  var c = aa.redSub(bb);\n  // X3 = AA * BB\n  var nx = aa.redMul(bb);\n  // Z3 = C * (BB + A24 * C)\n  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));\n  return this.curve.point(nx, nz);\n};\n\nPoint.prototype.add = function add() {\n  throw new Error('Not supported on Montgomery curve');\n};\n\nPoint.prototype.diffAdd = function diffAdd(p, diff) {\n  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3\n  // 4M + 2S + 6A\n\n  // A = X2 + Z2\n  var a = this.x.redAdd(this.z);\n  // B = X2 - Z2\n  var b = this.x.redSub(this.z);\n  // C = X3 + Z3\n  var c = p.x.redAdd(p.z);\n  // D = X3 - Z3\n  var d = p.x.redSub(p.z);\n  // DA = D * A\n  var da = d.redMul(a);\n  // CB = C * B\n  var cb = c.redMul(b);\n  // X5 = Z1 * (DA + CB)^2\n  var nx = diff.z.redMul(da.redAdd(cb).redSqr());\n  // Z5 = X1 * (DA - CB)^2\n  var nz = diff.x.redMul(da.redISub(cb).redSqr());\n  return this.curve.point(nx, nz);\n};\n\nPoint.prototype.mul = function mul(k) {\n  var t = k.clone();\n  var a = this; // (N / 2) * Q + Q\n  var b = this.curve.point(null, null); // (N / 2) * Q\n  var c = this; // Q\n\n  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))\n    bits.push(t.andln(1));\n\n  for (var i = bits.length - 1; i >= 0; i--) {\n    if (bits[i] === 0) {\n      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q\n      a = a.diffAdd(b, c);\n      // N * Q = 2 * ((N / 2) * Q + Q))\n      b = b.dbl();\n    } else {\n      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)\n      b = a.diffAdd(b, c);\n      // N * Q + Q = 2 * ((N / 2) * Q + Q)\n      a = a.dbl();\n    }\n  }\n  return b;\n};\n\nPoint.prototype.mulAdd = function mulAdd() {\n  throw new Error('Not supported on Montgomery curve');\n};\n\nPoint.prototype.jumlAdd = function jumlAdd() {\n  throw new Error('Not supported on Montgomery curve');\n};\n\nPoint.prototype.eq = function eq(other) {\n  return this.getX().cmp(other.getX()) === 0;\n};\n\nPoint.prototype.normalize = function normalize() {\n  this.x = this.x.redMul(this.z.redInvm());\n  this.z = this.curve.one;\n  return this;\n};\n\nPoint.prototype.getX = function getX() {\n  // Normalize coordinates\n  this.normalize();\n\n  return this.x.fromRed();\n};\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/curve/mont.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/short.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/short.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curve = __webpack_require__(/*! ../curve */ \"./node_modules/elliptic/lib/elliptic/curve/index.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Base = curve.base;\n\nvar assert = elliptic.utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16)\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 }\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n  var npoints = this._endoWnafT1;\n  var ncoeffs = this._endoWnafT2;\n  for (var i = 0; i < points.length; i++) {\n    var split = this._endoSplit(coeffs[i]);\n    var p = points[i];\n    var beta = p._getBeta();\n\n    if (split.k1.negative) {\n      split.k1.ineg();\n      p = p.neg(true);\n    }\n    if (split.k2.negative) {\n      split.k2.ineg();\n      beta = beta.neg(true);\n    }\n\n    npoints[i * 2] = p;\n    npoints[i * 2 + 1] = beta;\n    ncoeffs[i * 2] = split.k1;\n    ncoeffs[i * 2 + 1] = split.k2;\n  }\n  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n  // Clean-up references to points and coefficients\n  for (var j = 0; j < i * 2; j++) {\n    npoints[j] = null;\n    ncoeffs[j] = null;\n  }\n  return res;\n};\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul)\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul)\n      }\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1)\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1)\n    }\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point))\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point))\n    }\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n\n  if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate)\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate)\n      }\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (var i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (var i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/curve/short.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curves.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curves.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curves = exports;\n\nvar hash = __webpack_require__(/*! hash.js */ \"./node_modules/hash.js/lib/hash.js\");\nvar elliptic = __webpack_require__(/*! ../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\n\nvar assert = elliptic.utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new elliptic.curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new elliptic.curve.edwards(options);\n  else\n    this.curve = new elliptic.curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve\n      });\n      return curve;\n    }\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'\n  ]\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'\n  ]\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'\n  ]\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'\n  ]\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650'\n  ]\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9'\n  ]\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658'\n  ]\n});\n\nvar pre;\ntry {\n  pre = __webpack_require__(/*! ./precomputed/secp256k1 */ \"./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js\");\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3'\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15'\n    }\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre\n  ]\n});\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/curves.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/index.js":
/*!********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar HmacDRBG = __webpack_require__(/*! hmac-drbg */ \"./node_modules/hmac-drbg/lib/hmac-drbg.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\n\nvar KeyPair = __webpack_require__(/*! ./key */ \"./node_modules/elliptic/lib/elliptic/ec/key.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"./node_modules/elliptic/lib/elliptic/ec/signature.js\");\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);\n\n    options = elliptic.curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof elliptic.curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray()\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  do {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  } while (true);\n};\n\nEC.prototype._truncateToN = function truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8'\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; true; iter++) {\n    var k = options.k ?\n        options.k(iter) :\n        new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n\n  if (!this.curve._maxwellTrick) {\n    var p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  var p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/ec/index.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/key.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/ec/key.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/signature.js":
/*!************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/signature.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\n\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n  }\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0 && (r[1] & 0x80)) {\n    r = r.slice(1);\n  }\n  if (s[0] === 0 && (s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/ec/signature.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar hash = __webpack_require__(/*! hash.js */ \"./node_modules/hash.js/lib/hash.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar KeyPair = __webpack_require__(/*! ./key */ \"./node_modules/elliptic/lib/elliptic/eddsa/key.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"./node_modules/elliptic/lib/elliptic/eddsa/signature.js\");\n\nfunction EDDSA(curve) {\n  assert(curve === 'ed25519', 'only tested with ed25519 so far');\n\n  if (!(this instanceof EDDSA))\n    return new EDDSA(curve);\n\n  var curve = elliptic.curves[curve].curve;\n  this.curve = curve;\n  this.g = curve.g;\n  this.g.precompute(curve.n.bitLength() + 1);\n\n  this.pointClass = curve.point().constructor;\n  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);\n  this.hash = hash.sha512;\n}\n\nmodule.exports = EDDSA;\n\n/**\n* @param {Array|String} message - message bytes\n* @param {Array|String|KeyPair} secret - secret bytes or a keypair\n* @returns {Signature} - signature\n*/\nEDDSA.prototype.sign = function sign(message, secret) {\n  message = parseBytes(message);\n  var key = this.keyFromSecret(secret);\n  var r = this.hashInt(key.messagePrefix(), message);\n  var R = this.g.mul(r);\n  var Rencoded = this.encodePoint(R);\n  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)\n               .mul(key.priv());\n  var S = r.add(s_).umod(this.curve.n);\n  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });\n};\n\n/**\n* @param {Array} message - message bytes\n* @param {Array|String|Signature} sig - sig bytes\n* @param {Array|String|Point|KeyPair} pub - public key\n* @returns {Boolean} - true if public key matches sig of message\n*/\nEDDSA.prototype.verify = function verify(message, sig, pub) {\n  message = parseBytes(message);\n  sig = this.makeSignature(sig);\n  var key = this.keyFromPublic(pub);\n  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\n  var SG = this.g.mul(sig.S());\n  var RplusAh = sig.R().add(key.pub().mul(h));\n  return RplusAh.eq(SG);\n};\n\nEDDSA.prototype.hashInt = function hashInt() {\n  var hash = this.hash();\n  for (var i = 0; i < arguments.length; i++)\n    hash.update(arguments[i]);\n  return utils.intFromLE(hash.digest()).umod(this.curve.n);\n};\n\nEDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\n  return KeyPair.fromPublic(this, pub);\n};\n\nEDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\n  return KeyPair.fromSecret(this, secret);\n};\n\nEDDSA.prototype.makeSignature = function makeSignature(sig) {\n  if (sig instanceof Signature)\n    return sig;\n  return new Signature(this, sig);\n};\n\n/**\n* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2\n*\n* EDDSA defines methods for encoding and decoding points and integers. These are\n* helper convenience methods, that pass along to utility functions implied\n* parameters.\n*\n*/\nEDDSA.prototype.encodePoint = function encodePoint(point) {\n  var enc = point.getY().toArray('le', this.encodingLength);\n  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\n  return enc;\n};\n\nEDDSA.prototype.decodePoint = function decodePoint(bytes) {\n  bytes = utils.parseBytes(bytes);\n\n  var lastIx = bytes.length - 1;\n  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\n  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\n\n  var y = utils.intFromLE(normed);\n  return this.curve.pointFromY(y, xIsOdd);\n};\n\nEDDSA.prototype.encodeInt = function encodeInt(num) {\n  return num.toArray('le', this.encodingLength);\n};\n\nEDDSA.prototype.decodeInt = function decodeInt(bytes) {\n  return utils.intFromLE(bytes);\n};\n\nEDDSA.prototype.isPoint = function isPoint(val) {\n  return val instanceof this.pointClass;\n};\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/eddsa/index.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/key.js":
/*!*********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/key.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar cachedProperty = utils.cachedProperty;\n\n/**\n* @param {EDDSA} eddsa - instance\n* @param {Object} params - public/private key parameters\n*\n* @param {Array<Byte>} [params.secret] - secret seed bytes\n* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)\n* @param {Array<Byte>} [params.pub] - public key point encoded as bytes\n*\n*/\nfunction KeyPair(eddsa, params) {\n  this.eddsa = eddsa;\n  this._secret = parseBytes(params.secret);\n  if (eddsa.isPoint(params.pub))\n    this._pub = params.pub;\n  else\n    this._pubBytes = parseBytes(params.pub);\n}\n\nKeyPair.fromPublic = function fromPublic(eddsa, pub) {\n  if (pub instanceof KeyPair)\n    return pub;\n  return new KeyPair(eddsa, { pub: pub });\n};\n\nKeyPair.fromSecret = function fromSecret(eddsa, secret) {\n  if (secret instanceof KeyPair)\n    return secret;\n  return new KeyPair(eddsa, { secret: secret });\n};\n\nKeyPair.prototype.secret = function secret() {\n  return this._secret;\n};\n\ncachedProperty(KeyPair, 'pubBytes', function pubBytes() {\n  return this.eddsa.encodePoint(this.pub());\n});\n\ncachedProperty(KeyPair, 'pub', function pub() {\n  if (this._pubBytes)\n    return this.eddsa.decodePoint(this._pubBytes);\n  return this.eddsa.g.mul(this.priv());\n});\n\ncachedProperty(KeyPair, 'privBytes', function privBytes() {\n  var eddsa = this.eddsa;\n  var hash = this.hash();\n  var lastIx = eddsa.encodingLength - 1;\n\n  var a = hash.slice(0, eddsa.encodingLength);\n  a[0] &= 248;\n  a[lastIx] &= 127;\n  a[lastIx] |= 64;\n\n  return a;\n});\n\ncachedProperty(KeyPair, 'priv', function priv() {\n  return this.eddsa.decodeInt(this.privBytes());\n});\n\ncachedProperty(KeyPair, 'hash', function hash() {\n  return this.eddsa.hash().update(this.secret()).digest();\n});\n\ncachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {\n  return this.hash().slice(this.eddsa.encodingLength);\n});\n\nKeyPair.prototype.sign = function sign(message) {\n  assert(this._secret, 'KeyPair can only verify');\n  return this.eddsa.sign(message, this);\n};\n\nKeyPair.prototype.verify = function verify(message, sig) {\n  return this.eddsa.verify(message, sig, this);\n};\n\nKeyPair.prototype.getSecret = function getSecret(enc) {\n  assert(this._secret, 'KeyPair is public only');\n  return utils.encode(this.secret(), enc);\n};\n\nKeyPair.prototype.getPublic = function getPublic(enc) {\n  return utils.encode(this.pubBytes(), enc);\n};\n\nmodule.exports = KeyPair;\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/eddsa/key.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js":
/*!***************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/signature.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\nvar cachedProperty = utils.cachedProperty;\nvar parseBytes = utils.parseBytes;\n\n/**\n* @param {EDDSA} eddsa - eddsa instance\n* @param {Array<Bytes>|Object} sig -\n* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes\n* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes\n* @param {Array<Bytes>} [sig.Rencoded] - R point encoded\n* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded\n*/\nfunction Signature(eddsa, sig) {\n  this.eddsa = eddsa;\n\n  if (typeof sig !== 'object')\n    sig = parseBytes(sig);\n\n  if (Array.isArray(sig)) {\n    sig = {\n      R: sig.slice(0, eddsa.encodingLength),\n      S: sig.slice(eddsa.encodingLength)\n    };\n  }\n\n  assert(sig.R && sig.S, 'Signature without R or S');\n\n  if (eddsa.isPoint(sig.R))\n    this._R = sig.R;\n  if (sig.S instanceof BN)\n    this._S = sig.S;\n\n  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;\n  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;\n}\n\ncachedProperty(Signature, 'S', function S() {\n  return this.eddsa.decodeInt(this.Sencoded());\n});\n\ncachedProperty(Signature, 'R', function R() {\n  return this.eddsa.decodePoint(this.Rencoded());\n});\n\ncachedProperty(Signature, 'Rencoded', function Rencoded() {\n  return this.eddsa.encodePoint(this.R());\n});\n\ncachedProperty(Signature, 'Sencoded', function Sencoded() {\n  return this.eddsa.encodeInt(this.S());\n});\n\nSignature.prototype.toBytes = function toBytes() {\n  return this.Rencoded().concat(this.Sencoded());\n};\n\nSignature.prototype.toHex = function toHex() {\n  return utils.encode(this.toBytes(), 'hex').toUpperCase();\n};\n\nmodule.exports = Signature;\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/eddsa/signature.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":
/*!*********************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  doubles: {\n    step: 4,\n    points: [\n      [\n        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',\n        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'\n      ],\n      [\n        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',\n        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'\n      ],\n      [\n        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',\n        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'\n      ],\n      [\n        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',\n        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'\n      ],\n      [\n        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',\n        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'\n      ],\n      [\n        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',\n        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'\n      ],\n      [\n        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',\n        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'\n      ],\n      [\n        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',\n        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'\n      ],\n      [\n        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',\n        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'\n      ],\n      [\n        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',\n        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'\n      ],\n      [\n        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',\n        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'\n      ],\n      [\n        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',\n        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'\n      ],\n      [\n        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',\n        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'\n      ],\n      [\n        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',\n        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'\n      ],\n      [\n        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',\n        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'\n      ],\n      [\n        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',\n        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'\n      ],\n      [\n        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',\n        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'\n      ],\n      [\n        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',\n        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'\n      ],\n      [\n        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',\n        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'\n      ],\n      [\n        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',\n        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'\n      ],\n      [\n        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',\n        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'\n      ],\n      [\n        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',\n        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'\n      ],\n      [\n        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',\n        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'\n      ],\n      [\n        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',\n        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'\n      ],\n      [\n        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',\n        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'\n      ],\n      [\n        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',\n        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'\n      ],\n      [\n        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',\n        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'\n      ],\n      [\n        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',\n        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'\n      ],\n      [\n        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',\n        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'\n      ],\n      [\n        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',\n        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'\n      ],\n      [\n        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',\n        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'\n      ],\n      [\n        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',\n        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'\n      ],\n      [\n        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',\n        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'\n      ],\n      [\n        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',\n        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'\n      ],\n      [\n        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',\n        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'\n      ],\n      [\n        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',\n        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'\n      ],\n      [\n        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',\n        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'\n      ],\n      [\n        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',\n        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'\n      ],\n      [\n        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',\n        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'\n      ],\n      [\n        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',\n        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'\n      ],\n      [\n        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',\n        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'\n      ],\n      [\n        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',\n        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'\n      ],\n      [\n        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',\n        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'\n      ],\n      [\n        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',\n        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'\n      ],\n      [\n        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',\n        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'\n      ],\n      [\n        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',\n        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'\n      ],\n      [\n        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',\n        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'\n      ],\n      [\n        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',\n        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'\n      ],\n      [\n        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',\n        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'\n      ],\n      [\n        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',\n        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'\n      ],\n      [\n        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',\n        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'\n      ],\n      [\n        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',\n        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'\n      ],\n      [\n        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',\n        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'\n      ],\n      [\n        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',\n        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'\n      ],\n      [\n        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',\n        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'\n      ],\n      [\n        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',\n        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'\n      ],\n      [\n        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',\n        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'\n      ],\n      [\n        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',\n        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'\n      ],\n      [\n        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',\n        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'\n      ],\n      [\n        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',\n        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'\n      ],\n      [\n        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',\n        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'\n      ],\n      [\n        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',\n        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'\n      ],\n      [\n        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',\n        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'\n      ],\n      [\n        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',\n        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'\n      ],\n      [\n        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',\n        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'\n      ]\n    ]\n  },\n  naf: {\n    wnd: 7,\n    points: [\n      [\n        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',\n        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'\n      ],\n      [\n        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',\n        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'\n      ],\n      [\n        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',\n        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'\n      ],\n      [\n        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',\n        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'\n      ],\n      [\n        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',\n        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'\n      ],\n      [\n        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',\n        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'\n      ],\n      [\n        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',\n        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'\n      ],\n      [\n        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',\n        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'\n      ],\n      [\n        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',\n        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'\n      ],\n      [\n        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',\n        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'\n      ],\n      [\n        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',\n        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'\n      ],\n      [\n        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',\n        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'\n      ],\n      [\n        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',\n        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'\n      ],\n      [\n        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',\n        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'\n      ],\n      [\n        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',\n        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'\n      ],\n      [\n        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',\n        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'\n      ],\n      [\n        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',\n        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'\n      ],\n      [\n        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',\n        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'\n      ],\n      [\n        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',\n        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'\n      ],\n      [\n        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',\n        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'\n      ],\n      [\n        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',\n        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'\n      ],\n      [\n        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',\n        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'\n      ],\n      [\n        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',\n        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'\n      ],\n      [\n        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',\n        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'\n      ],\n      [\n        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',\n        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'\n      ],\n      [\n        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',\n        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'\n      ],\n      [\n        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',\n        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'\n      ],\n      [\n        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',\n        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'\n      ],\n      [\n        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',\n        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'\n      ],\n      [\n        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',\n        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'\n      ],\n      [\n        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',\n        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'\n      ],\n      [\n        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',\n        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'\n      ],\n      [\n        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',\n        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'\n      ],\n      [\n        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',\n        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'\n      ],\n      [\n        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',\n        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'\n      ],\n      [\n        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',\n        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'\n      ],\n      [\n        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',\n        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'\n      ],\n      [\n        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',\n        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'\n      ],\n      [\n        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',\n        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'\n      ],\n      [\n        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',\n        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'\n      ],\n      [\n        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',\n        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'\n      ],\n      [\n        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',\n        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'\n      ],\n      [\n        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',\n        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'\n      ],\n      [\n        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',\n        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'\n      ],\n      [\n        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',\n        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'\n      ],\n      [\n        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',\n        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'\n      ],\n      [\n        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',\n        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'\n      ],\n      [\n        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',\n        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'\n      ],\n      [\n        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',\n        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'\n      ],\n      [\n        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',\n        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'\n      ],\n      [\n        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',\n        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'\n      ],\n      [\n        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',\n        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'\n      ],\n      [\n        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',\n        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'\n      ],\n      [\n        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',\n        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'\n      ],\n      [\n        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',\n        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'\n      ],\n      [\n        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',\n        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'\n      ],\n      [\n        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',\n        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'\n      ],\n      [\n        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',\n        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'\n      ],\n      [\n        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',\n        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'\n      ],\n      [\n        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',\n        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'\n      ],\n      [\n        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',\n        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'\n      ],\n      [\n        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',\n        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'\n      ],\n      [\n        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',\n        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'\n      ],\n      [\n        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',\n        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'\n      ],\n      [\n        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',\n        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'\n      ],\n      [\n        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',\n        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'\n      ],\n      [\n        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',\n        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'\n      ],\n      [\n        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',\n        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'\n      ],\n      [\n        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',\n        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'\n      ],\n      [\n        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',\n        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'\n      ],\n      [\n        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',\n        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'\n      ],\n      [\n        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',\n        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'\n      ],\n      [\n        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',\n        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'\n      ],\n      [\n        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',\n        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'\n      ],\n      [\n        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',\n        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'\n      ],\n      [\n        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',\n        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'\n      ],\n      [\n        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',\n        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'\n      ],\n      [\n        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',\n        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'\n      ],\n      [\n        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',\n        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'\n      ],\n      [\n        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',\n        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'\n      ],\n      [\n        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',\n        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'\n      ],\n      [\n        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',\n        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'\n      ],\n      [\n        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',\n        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'\n      ],\n      [\n        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',\n        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'\n      ],\n      [\n        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',\n        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'\n      ],\n      [\n        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',\n        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'\n      ],\n      [\n        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',\n        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'\n      ],\n      [\n        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',\n        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'\n      ],\n      [\n        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',\n        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'\n      ],\n      [\n        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',\n        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'\n      ],\n      [\n        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',\n        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'\n      ],\n      [\n        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',\n        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'\n      ],\n      [\n        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',\n        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'\n      ],\n      [\n        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',\n        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'\n      ],\n      [\n        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',\n        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'\n      ],\n      [\n        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',\n        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'\n      ],\n      [\n        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',\n        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'\n      ],\n      [\n        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',\n        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'\n      ],\n      [\n        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',\n        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'\n      ],\n      [\n        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',\n        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'\n      ],\n      [\n        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',\n        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'\n      ],\n      [\n        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',\n        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'\n      ],\n      [\n        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',\n        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'\n      ],\n      [\n        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',\n        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'\n      ],\n      [\n        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',\n        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'\n      ],\n      [\n        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',\n        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'\n      ],\n      [\n        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',\n        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'\n      ],\n      [\n        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',\n        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'\n      ],\n      [\n        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',\n        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'\n      ],\n      [\n        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',\n        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'\n      ],\n      [\n        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',\n        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'\n      ],\n      [\n        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',\n        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'\n      ],\n      [\n        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',\n        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'\n      ],\n      [\n        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',\n        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'\n      ],\n      [\n        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',\n        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'\n      ],\n      [\n        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',\n        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'\n      ],\n      [\n        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',\n        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'\n      ],\n      [\n        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',\n        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'\n      ],\n      [\n        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',\n        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'\n      ],\n      [\n        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',\n        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'\n      ],\n      [\n        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',\n        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'\n      ],\n      [\n        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',\n        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'\n      ],\n      [\n        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',\n        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'\n      ],\n      [\n        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',\n        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'\n      ],\n      [\n        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',\n        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'\n      ],\n      [\n        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',\n        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'\n      ],\n      [\n        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',\n        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'\n      ]\n    ]\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = exports;\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar minAssert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar minUtils = __webpack_require__(/*! minimalistic-crypto-utils */ \"./node_modules/minimalistic-crypto-utils/lib/utils.js\");\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w) {\n  var naf = [];\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n  while (k.cmpn(1) >= 0) {\n    var z;\n    if (k.isOdd()) {\n      var mod = k.andln(ws - 1);\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n    naf.push(z);\n\n    // Optimization, shift by word if possible\n    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;\n    for (var i = 1; i < shift; i++)\n      naf.push(0);\n    k.iushrn(shift);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    []\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      var m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      var m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n           this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n                                     bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n\n\n//# sourceURL=webpack:///./node_modules/elliptic/lib/elliptic/utils.js?");

/***/ }),

/***/ "./node_modules/elliptic/package.json":
/*!********************************************!*\
  !*** ./node_modules/elliptic/package.json ***!
  \********************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bugs, bundleDependencies, dependencies, deprecated, description, devDependencies, files, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = {\"_from\":\"elliptic@^6.0.0\",\"_id\":\"elliptic@6.4.1\",\"_inBundle\":false,\"_integrity\":\"sha512-BsXLz5sqX8OHcsh7CqBMztyXARmGQ3LWPtGjJi6DiJHq5C/qvi9P3OqgswKSDftbu8+IoI/QDTAm2fFnQ9SZSQ==\",\"_location\":\"/elliptic\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"range\",\"registry\":true,\"raw\":\"elliptic@^6.0.0\",\"name\":\"elliptic\",\"escapedName\":\"elliptic\",\"rawSpec\":\"^6.0.0\",\"saveSpec\":null,\"fetchSpec\":\"^6.0.0\"},\"_requiredBy\":[\"/browserify-sign\",\"/create-ecdh\"],\"_resolved\":\"https://registry.npmjs.org/elliptic/-/elliptic-6.4.1.tgz\",\"_shasum\":\"c2d0b7776911b86722c632c3c06c60f2f819939a\",\"_spec\":\"elliptic@^6.0.0\",\"_where\":\"/home/gerard/dev/opal/cordova_template_opal_webpack/node_modules/browserify-sign\",\"author\":{\"name\":\"Fedor Indutny\",\"email\":\"fedor@indutny.com\"},\"bugs\":{\"url\":\"https://github.com/indutny/elliptic/issues\"},\"bundleDependencies\":false,\"dependencies\":{\"bn.js\":\"^4.4.0\",\"brorand\":\"^1.0.1\",\"hash.js\":\"^1.0.0\",\"hmac-drbg\":\"^1.0.0\",\"inherits\":\"^2.0.1\",\"minimalistic-assert\":\"^1.0.0\",\"minimalistic-crypto-utils\":\"^1.0.0\"},\"deprecated\":false,\"description\":\"EC cryptography\",\"devDependencies\":{\"brfs\":\"^1.4.3\",\"coveralls\":\"^2.11.3\",\"grunt\":\"^0.4.5\",\"grunt-browserify\":\"^5.0.0\",\"grunt-cli\":\"^1.2.0\",\"grunt-contrib-connect\":\"^1.0.0\",\"grunt-contrib-copy\":\"^1.0.0\",\"grunt-contrib-uglify\":\"^1.0.1\",\"grunt-mocha-istanbul\":\"^3.0.1\",\"grunt-saucelabs\":\"^8.6.2\",\"istanbul\":\"^0.4.2\",\"jscs\":\"^2.9.0\",\"jshint\":\"^2.6.0\",\"mocha\":\"^2.1.0\"},\"files\":[\"lib\"],\"homepage\":\"https://github.com/indutny/elliptic\",\"keywords\":[\"EC\",\"Elliptic\",\"curve\",\"Cryptography\"],\"license\":\"MIT\",\"main\":\"lib/elliptic.js\",\"name\":\"elliptic\",\"repository\":{\"type\":\"git\",\"url\":\"git+ssh://git@github.com/indutny/elliptic.git\"},\"scripts\":{\"jscs\":\"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js\",\"jshint\":\"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js\",\"lint\":\"npm run jscs && npm run jshint\",\"test\":\"npm run lint && npm run unit\",\"unit\":\"istanbul test _mocha --reporter=spec test/index.js\",\"version\":\"grunt dist && git add dist/\"},\"version\":\"6.4.1\"};\n\n//# sourceURL=webpack:///./node_modules/elliptic/package.json?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/evp_bytestokey/index.js":
/*!**********************************************!*\
  !*** ./node_modules/evp_bytestokey/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar MD5 = __webpack_require__(/*! md5.js */ \"./node_modules/md5.js/index.js\")\n\n/* eslint-disable camelcase */\nfunction EVP_BytesToKey (password, salt, keyBits, ivLen) {\n  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')\n  if (salt) {\n    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')\n    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')\n  }\n\n  var keyLen = keyBits / 8\n  var key = Buffer.alloc(keyLen)\n  var iv = Buffer.alloc(ivLen || 0)\n  var tmp = Buffer.alloc(0)\n\n  while (keyLen > 0 || ivLen > 0) {\n    var hash = new MD5()\n    hash.update(tmp)\n    hash.update(password)\n    if (salt) hash.update(salt)\n    tmp = hash.digest()\n\n    var used = 0\n\n    if (keyLen > 0) {\n      var keyStart = key.length - keyLen\n      used = Math.min(keyLen, tmp.length)\n      tmp.copy(key, keyStart, 0, used)\n      keyLen -= used\n    }\n\n    if (used < tmp.length && ivLen > 0) {\n      var ivStart = iv.length - ivLen\n      var length = Math.min(ivLen, tmp.length - used)\n      tmp.copy(iv, ivStart, used, used + length)\n      ivLen -= length\n    }\n  }\n\n  tmp.fill(0)\n  return { key: key, iv: iv }\n}\n\nmodule.exports = EVP_BytesToKey\n\n\n//# sourceURL=webpack:///./node_modules/evp_bytestokey/index.js?");

/***/ }),

/***/ "./node_modules/hash-base/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hash-base/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar Transform = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\").Transform\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\n\nfunction throwIfNotStringOrBuffer (val, prefix) {\n  if (!Buffer.isBuffer(val) && typeof val !== 'string') {\n    throw new TypeError(prefix + ' must be a string or a buffer')\n  }\n}\n\nfunction HashBase (blockSize) {\n  Transform.call(this)\n\n  this._block = Buffer.allocUnsafe(blockSize)\n  this._blockSize = blockSize\n  this._blockOffset = 0\n  this._length = [0, 0, 0, 0]\n\n  this._finalized = false\n}\n\ninherits(HashBase, Transform)\n\nHashBase.prototype._transform = function (chunk, encoding, callback) {\n  var error = null\n  try {\n    this.update(chunk, encoding)\n  } catch (err) {\n    error = err\n  }\n\n  callback(error)\n}\n\nHashBase.prototype._flush = function (callback) {\n  var error = null\n  try {\n    this.push(this.digest())\n  } catch (err) {\n    error = err\n  }\n\n  callback(error)\n}\n\nHashBase.prototype.update = function (data, encoding) {\n  throwIfNotStringOrBuffer(data, 'Data')\n  if (this._finalized) throw new Error('Digest already called')\n  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\n\n  // consume data\n  var block = this._block\n  var offset = 0\n  while (this._blockOffset + data.length - offset >= this._blockSize) {\n    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]\n    this._update()\n    this._blockOffset = 0\n  }\n  while (offset < data.length) block[this._blockOffset++] = data[offset++]\n\n  // update length\n  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {\n    this._length[j] += carry\n    carry = (this._length[j] / 0x0100000000) | 0\n    if (carry > 0) this._length[j] -= 0x0100000000 * carry\n  }\n\n  return this\n}\n\nHashBase.prototype._update = function () {\n  throw new Error('_update is not implemented')\n}\n\nHashBase.prototype.digest = function (encoding) {\n  if (this._finalized) throw new Error('Digest already called')\n  this._finalized = true\n\n  var digest = this._digest()\n  if (encoding !== undefined) digest = digest.toString(encoding)\n\n  // reset state\n  this._block.fill(0)\n  this._blockOffset = 0\n  for (var i = 0; i < 4; ++i) this._length[i] = 0\n\n  return digest\n}\n\nHashBase.prototype._digest = function () {\n  throw new Error('_digest is not implemented')\n}\n\nmodule.exports = HashBase\n\n\n//# sourceURL=webpack:///./node_modules/hash-base/index.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash.js":
/*!******************************************!*\
  !*** ./node_modules/hash.js/lib/hash.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var hash = exports;\n\nhash.utils = __webpack_require__(/*! ./hash/utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nhash.common = __webpack_require__(/*! ./hash/common */ \"./node_modules/hash.js/lib/hash/common.js\");\nhash.sha = __webpack_require__(/*! ./hash/sha */ \"./node_modules/hash.js/lib/hash/sha.js\");\nhash.ripemd = __webpack_require__(/*! ./hash/ripemd */ \"./node_modules/hash.js/lib/hash/ripemd.js\");\nhash.hmac = __webpack_require__(/*! ./hash/hmac */ \"./node_modules/hash.js/lib/hash/hmac.js\");\n\n// Proxy hash functions to the main object\nhash.sha1 = hash.sha.sha1;\nhash.sha256 = hash.sha.sha256;\nhash.sha224 = hash.sha.sha224;\nhash.sha384 = hash.sha.sha384;\nhash.sha512 = hash.sha.sha512;\nhash.ripemd160 = hash.ripemd.ripemd160;\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/common.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/common.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction BlockHash() {\n  this.pending = null;\n  this.pendingTotal = 0;\n  this.blockSize = this.constructor.blockSize;\n  this.outSize = this.constructor.outSize;\n  this.hmacStrength = this.constructor.hmacStrength;\n  this.padLength = this.constructor.padLength / 8;\n  this.endian = 'big';\n\n  this._delta8 = this.blockSize / 8;\n  this._delta32 = this.blockSize / 32;\n}\nexports.BlockHash = BlockHash;\n\nBlockHash.prototype.update = function update(msg, enc) {\n  // Convert message to array, pad it, and join into 32bit blocks\n  msg = utils.toArray(msg, enc);\n  if (!this.pending)\n    this.pending = msg;\n  else\n    this.pending = this.pending.concat(msg);\n  this.pendingTotal += msg.length;\n\n  // Enough data, try updating\n  if (this.pending.length >= this._delta8) {\n    msg = this.pending;\n\n    // Process pending data in blocks\n    var r = msg.length % this._delta8;\n    this.pending = msg.slice(msg.length - r, msg.length);\n    if (this.pending.length === 0)\n      this.pending = null;\n\n    msg = utils.join32(msg, 0, msg.length - r, this.endian);\n    for (var i = 0; i < msg.length; i += this._delta32)\n      this._update(msg, i, i + this._delta32);\n  }\n\n  return this;\n};\n\nBlockHash.prototype.digest = function digest(enc) {\n  this.update(this._pad());\n  assert(this.pending === null);\n\n  return this._digest(enc);\n};\n\nBlockHash.prototype._pad = function pad() {\n  var len = this.pendingTotal;\n  var bytes = this._delta8;\n  var k = bytes - ((len + this.padLength) % bytes);\n  var res = new Array(k + this.padLength);\n  res[0] = 0x80;\n  for (var i = 1; i < k; i++)\n    res[i] = 0;\n\n  // Append length\n  len <<= 3;\n  if (this.endian === 'big') {\n    for (var t = 8; t < this.padLength; t++)\n      res[i++] = 0;\n\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = (len >>> 24) & 0xff;\n    res[i++] = (len >>> 16) & 0xff;\n    res[i++] = (len >>> 8) & 0xff;\n    res[i++] = len & 0xff;\n  } else {\n    res[i++] = len & 0xff;\n    res[i++] = (len >>> 8) & 0xff;\n    res[i++] = (len >>> 16) & 0xff;\n    res[i++] = (len >>> 24) & 0xff;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n\n    for (t = 8; t < this.padLength; t++)\n      res[i++] = 0;\n  }\n\n  return res;\n};\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash/common.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/hmac.js":
/*!***********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/hmac.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction Hmac(hash, key, enc) {\n  if (!(this instanceof Hmac))\n    return new Hmac(hash, key, enc);\n  this.Hash = hash;\n  this.blockSize = hash.blockSize / 8;\n  this.outSize = hash.outSize / 8;\n  this.inner = null;\n  this.outer = null;\n\n  this._init(utils.toArray(key, enc));\n}\nmodule.exports = Hmac;\n\nHmac.prototype._init = function init(key) {\n  // Shorten key, if needed\n  if (key.length > this.blockSize)\n    key = new this.Hash().update(key).digest();\n  assert(key.length <= this.blockSize);\n\n  // Add padding to key\n  for (var i = key.length; i < this.blockSize; i++)\n    key.push(0);\n\n  for (i = 0; i < key.length; i++)\n    key[i] ^= 0x36;\n  this.inner = new this.Hash().update(key);\n\n  // 0x36 ^ 0x5c = 0x6a\n  for (i = 0; i < key.length; i++)\n    key[i] ^= 0x6a;\n  this.outer = new this.Hash().update(key);\n};\n\nHmac.prototype.update = function update(msg, enc) {\n  this.inner.update(msg, enc);\n  return this;\n};\n\nHmac.prototype.digest = function digest(enc) {\n  this.outer.update(this.inner.digest());\n  return this.outer.digest(enc);\n};\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash/hmac.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/ripemd.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/ripemd.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/common.js\");\n\nvar rotl32 = utils.rotl32;\nvar sum32 = utils.sum32;\nvar sum32_3 = utils.sum32_3;\nvar sum32_4 = utils.sum32_4;\nvar BlockHash = common.BlockHash;\n\nfunction RIPEMD160() {\n  if (!(this instanceof RIPEMD160))\n    return new RIPEMD160();\n\n  BlockHash.call(this);\n\n  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];\n  this.endian = 'little';\n}\nutils.inherits(RIPEMD160, BlockHash);\nexports.ripemd160 = RIPEMD160;\n\nRIPEMD160.blockSize = 512;\nRIPEMD160.outSize = 160;\nRIPEMD160.hmacStrength = 192;\nRIPEMD160.padLength = 64;\n\nRIPEMD160.prototype._update = function update(msg, start) {\n  var A = this.h[0];\n  var B = this.h[1];\n  var C = this.h[2];\n  var D = this.h[3];\n  var E = this.h[4];\n  var Ah = A;\n  var Bh = B;\n  var Ch = C;\n  var Dh = D;\n  var Eh = E;\n  for (var j = 0; j < 80; j++) {\n    var T = sum32(\n      rotl32(\n        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),\n        s[j]),\n      E);\n    A = E;\n    E = D;\n    D = rotl32(C, 10);\n    C = B;\n    B = T;\n    T = sum32(\n      rotl32(\n        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),\n        sh[j]),\n      Eh);\n    Ah = Eh;\n    Eh = Dh;\n    Dh = rotl32(Ch, 10);\n    Ch = Bh;\n    Bh = T;\n  }\n  T = sum32_3(this.h[1], C, Dh);\n  this.h[1] = sum32_3(this.h[2], D, Eh);\n  this.h[2] = sum32_3(this.h[3], E, Ah);\n  this.h[3] = sum32_3(this.h[4], A, Bh);\n  this.h[4] = sum32_3(this.h[0], B, Ch);\n  this.h[0] = T;\n};\n\nRIPEMD160.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'little');\n  else\n    return utils.split32(this.h, 'little');\n};\n\nfunction f(j, x, y, z) {\n  if (j <= 15)\n    return x ^ y ^ z;\n  else if (j <= 31)\n    return (x & y) | ((~x) & z);\n  else if (j <= 47)\n    return (x | (~y)) ^ z;\n  else if (j <= 63)\n    return (x & z) | (y & (~z));\n  else\n    return x ^ (y | (~z));\n}\n\nfunction K(j) {\n  if (j <= 15)\n    return 0x00000000;\n  else if (j <= 31)\n    return 0x5a827999;\n  else if (j <= 47)\n    return 0x6ed9eba1;\n  else if (j <= 63)\n    return 0x8f1bbcdc;\n  else\n    return 0xa953fd4e;\n}\n\nfunction Kh(j) {\n  if (j <= 15)\n    return 0x50a28be6;\n  else if (j <= 31)\n    return 0x5c4dd124;\n  else if (j <= 47)\n    return 0x6d703ef3;\n  else if (j <= 63)\n    return 0x7a6d76e9;\n  else\n    return 0x00000000;\n}\n\nvar r = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n];\n\nvar rh = [\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n];\n\nvar s = [\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n];\n\nvar sh = [\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n];\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash/ripemd.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha.js":
/*!**********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.sha1 = __webpack_require__(/*! ./sha/1 */ \"./node_modules/hash.js/lib/hash/sha/1.js\");\nexports.sha224 = __webpack_require__(/*! ./sha/224 */ \"./node_modules/hash.js/lib/hash/sha/224.js\");\nexports.sha256 = __webpack_require__(/*! ./sha/256 */ \"./node_modules/hash.js/lib/hash/sha/256.js\");\nexports.sha384 = __webpack_require__(/*! ./sha/384 */ \"./node_modules/hash.js/lib/hash/sha/384.js\");\nexports.sha512 = __webpack_require__(/*! ./sha/512 */ \"./node_modules/hash.js/lib/hash/sha/512.js\");\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash/sha.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/1.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/1.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar shaCommon = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/sha/common.js\");\n\nvar rotl32 = utils.rotl32;\nvar sum32 = utils.sum32;\nvar sum32_5 = utils.sum32_5;\nvar ft_1 = shaCommon.ft_1;\nvar BlockHash = common.BlockHash;\n\nvar sha1_K = [\n  0x5A827999, 0x6ED9EBA1,\n  0x8F1BBCDC, 0xCA62C1D6\n];\n\nfunction SHA1() {\n  if (!(this instanceof SHA1))\n    return new SHA1();\n\n  BlockHash.call(this);\n  this.h = [\n    0x67452301, 0xefcdab89, 0x98badcfe,\n    0x10325476, 0xc3d2e1f0 ];\n  this.W = new Array(80);\n}\n\nutils.inherits(SHA1, BlockHash);\nmodule.exports = SHA1;\n\nSHA1.blockSize = 512;\nSHA1.outSize = 160;\nSHA1.hmacStrength = 80;\nSHA1.padLength = 64;\n\nSHA1.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++)\n    W[i] = msg[start + i];\n\n  for(; i < W.length; i++)\n    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n\n  for (i = 0; i < W.length; i++) {\n    var s = ~~(i / 20);\n    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);\n    e = d;\n    d = c;\n    c = rotl32(b, 30);\n    b = a;\n    a = t;\n  }\n\n  this.h[0] = sum32(this.h[0], a);\n  this.h[1] = sum32(this.h[1], b);\n  this.h[2] = sum32(this.h[2], c);\n  this.h[3] = sum32(this.h[3], d);\n  this.h[4] = sum32(this.h[4], e);\n};\n\nSHA1.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash/sha/1.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/224.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/224.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar SHA256 = __webpack_require__(/*! ./256 */ \"./node_modules/hash.js/lib/hash/sha/256.js\");\n\nfunction SHA224() {\n  if (!(this instanceof SHA224))\n    return new SHA224();\n\n  SHA256.call(this);\n  this.h = [\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];\n}\nutils.inherits(SHA224, SHA256);\nmodule.exports = SHA224;\n\nSHA224.blockSize = 512;\nSHA224.outSize = 224;\nSHA224.hmacStrength = 192;\nSHA224.padLength = 64;\n\nSHA224.prototype._digest = function digest(enc) {\n  // Just truncate output\n  if (enc === 'hex')\n    return utils.toHex32(this.h.slice(0, 7), 'big');\n  else\n    return utils.split32(this.h.slice(0, 7), 'big');\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash/sha/224.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/256.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/256.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar shaCommon = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/sha/common.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nvar sum32 = utils.sum32;\nvar sum32_4 = utils.sum32_4;\nvar sum32_5 = utils.sum32_5;\nvar ch32 = shaCommon.ch32;\nvar maj32 = shaCommon.maj32;\nvar s0_256 = shaCommon.s0_256;\nvar s1_256 = shaCommon.s1_256;\nvar g0_256 = shaCommon.g0_256;\nvar g1_256 = shaCommon.g1_256;\n\nvar BlockHash = common.BlockHash;\n\nvar sha256_K = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n\nfunction SHA256() {\n  if (!(this instanceof SHA256))\n    return new SHA256();\n\n  BlockHash.call(this);\n  this.h = [\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n  ];\n  this.k = sha256_K;\n  this.W = new Array(64);\n}\nutils.inherits(SHA256, BlockHash);\nmodule.exports = SHA256;\n\nSHA256.blockSize = 512;\nSHA256.outSize = 256;\nSHA256.hmacStrength = 192;\nSHA256.padLength = 64;\n\nSHA256.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++)\n    W[i] = msg[start + i];\n  for (; i < W.length; i++)\n    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n  var f = this.h[5];\n  var g = this.h[6];\n  var h = this.h[7];\n\n  assert(this.k.length === W.length);\n  for (i = 0; i < W.length; i++) {\n    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);\n    var T2 = sum32(s0_256(a), maj32(a, b, c));\n    h = g;\n    g = f;\n    f = e;\n    e = sum32(d, T1);\n    d = c;\n    c = b;\n    b = a;\n    a = sum32(T1, T2);\n  }\n\n  this.h[0] = sum32(this.h[0], a);\n  this.h[1] = sum32(this.h[1], b);\n  this.h[2] = sum32(this.h[2], c);\n  this.h[3] = sum32(this.h[3], d);\n  this.h[4] = sum32(this.h[4], e);\n  this.h[5] = sum32(this.h[5], f);\n  this.h[6] = sum32(this.h[6], g);\n  this.h[7] = sum32(this.h[7], h);\n};\n\nSHA256.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash/sha/256.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/384.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/384.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\n\nvar SHA512 = __webpack_require__(/*! ./512 */ \"./node_modules/hash.js/lib/hash/sha/512.js\");\n\nfunction SHA384() {\n  if (!(this instanceof SHA384))\n    return new SHA384();\n\n  SHA512.call(this);\n  this.h = [\n    0xcbbb9d5d, 0xc1059ed8,\n    0x629a292a, 0x367cd507,\n    0x9159015a, 0x3070dd17,\n    0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31,\n    0x8eb44a87, 0x68581511,\n    0xdb0c2e0d, 0x64f98fa7,\n    0x47b5481d, 0xbefa4fa4 ];\n}\nutils.inherits(SHA384, SHA512);\nmodule.exports = SHA384;\n\nSHA384.blockSize = 1024;\nSHA384.outSize = 384;\nSHA384.hmacStrength = 192;\nSHA384.padLength = 128;\n\nSHA384.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h.slice(0, 12), 'big');\n  else\n    return utils.split32(this.h.slice(0, 12), 'big');\n};\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash/sha/384.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/512.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/512.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nvar rotr64_hi = utils.rotr64_hi;\nvar rotr64_lo = utils.rotr64_lo;\nvar shr64_hi = utils.shr64_hi;\nvar shr64_lo = utils.shr64_lo;\nvar sum64 = utils.sum64;\nvar sum64_hi = utils.sum64_hi;\nvar sum64_lo = utils.sum64_lo;\nvar sum64_4_hi = utils.sum64_4_hi;\nvar sum64_4_lo = utils.sum64_4_lo;\nvar sum64_5_hi = utils.sum64_5_hi;\nvar sum64_5_lo = utils.sum64_5_lo;\n\nvar BlockHash = common.BlockHash;\n\nvar sha512_K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction SHA512() {\n  if (!(this instanceof SHA512))\n    return new SHA512();\n\n  BlockHash.call(this);\n  this.h = [\n    0x6a09e667, 0xf3bcc908,\n    0xbb67ae85, 0x84caa73b,\n    0x3c6ef372, 0xfe94f82b,\n    0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1,\n    0x9b05688c, 0x2b3e6c1f,\n    0x1f83d9ab, 0xfb41bd6b,\n    0x5be0cd19, 0x137e2179 ];\n  this.k = sha512_K;\n  this.W = new Array(160);\n}\nutils.inherits(SHA512, BlockHash);\nmodule.exports = SHA512;\n\nSHA512.blockSize = 1024;\nSHA512.outSize = 512;\nSHA512.hmacStrength = 192;\nSHA512.padLength = 128;\n\nSHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\n  var W = this.W;\n\n  // 32 x 32bit words\n  for (var i = 0; i < 32; i++)\n    W[i] = msg[start + i];\n  for (; i < W.length; i += 2) {\n    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2\n    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n    var c1_hi = W[i - 14];  // i - 7\n    var c1_lo = W[i - 13];\n    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15\n    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n    var c3_hi = W[i - 32];  // i - 16\n    var c3_lo = W[i - 31];\n\n    W[i] = sum64_4_hi(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo);\n    W[i + 1] = sum64_4_lo(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo);\n  }\n};\n\nSHA512.prototype._update = function _update(msg, start) {\n  this._prepareBlock(msg, start);\n\n  var W = this.W;\n\n  var ah = this.h[0];\n  var al = this.h[1];\n  var bh = this.h[2];\n  var bl = this.h[3];\n  var ch = this.h[4];\n  var cl = this.h[5];\n  var dh = this.h[6];\n  var dl = this.h[7];\n  var eh = this.h[8];\n  var el = this.h[9];\n  var fh = this.h[10];\n  var fl = this.h[11];\n  var gh = this.h[12];\n  var gl = this.h[13];\n  var hh = this.h[14];\n  var hl = this.h[15];\n\n  assert(this.k.length === W.length);\n  for (var i = 0; i < W.length; i += 2) {\n    var c0_hi = hh;\n    var c0_lo = hl;\n    var c1_hi = s1_512_hi(eh, el);\n    var c1_lo = s1_512_lo(eh, el);\n    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);\n    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n    var c3_hi = this.k[i];\n    var c3_lo = this.k[i + 1];\n    var c4_hi = W[i];\n    var c4_lo = W[i + 1];\n\n    var T1_hi = sum64_5_hi(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo,\n      c4_hi, c4_lo);\n    var T1_lo = sum64_5_lo(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo,\n      c4_hi, c4_lo);\n\n    c0_hi = s0_512_hi(ah, al);\n    c0_lo = s0_512_lo(ah, al);\n    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);\n    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n\n    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);\n    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\n\n    hh = gh;\n    hl = gl;\n\n    gh = fh;\n    gl = fl;\n\n    fh = eh;\n    fl = el;\n\n    eh = sum64_hi(dh, dl, T1_hi, T1_lo);\n    el = sum64_lo(dl, dl, T1_hi, T1_lo);\n\n    dh = ch;\n    dl = cl;\n\n    ch = bh;\n    cl = bl;\n\n    bh = ah;\n    bl = al;\n\n    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);\n    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\n  }\n\n  sum64(this.h, 0, ah, al);\n  sum64(this.h, 2, bh, bl);\n  sum64(this.h, 4, ch, cl);\n  sum64(this.h, 6, dh, dl);\n  sum64(this.h, 8, eh, el);\n  sum64(this.h, 10, fh, fl);\n  sum64(this.h, 12, gh, gl);\n  sum64(this.h, 14, hh, hl);\n};\n\nSHA512.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n\nfunction ch64_hi(xh, xl, yh, yl, zh) {\n  var r = (xh & yh) ^ ((~xh) & zh);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction ch64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = (xl & yl) ^ ((~xl) & zl);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction maj64_hi(xh, xl, yh, yl, zh) {\n  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction maj64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 28);\n  var c1_hi = rotr64_hi(xl, xh, 2);  // 34\n  var c2_hi = rotr64_hi(xl, xh, 7);  // 39\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 28);\n  var c1_lo = rotr64_lo(xl, xh, 2);  // 34\n  var c2_lo = rotr64_lo(xl, xh, 7);  // 39\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 14);\n  var c1_hi = rotr64_hi(xh, xl, 18);\n  var c2_hi = rotr64_hi(xl, xh, 9);  // 41\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 14);\n  var c1_lo = rotr64_lo(xh, xl, 18);\n  var c2_lo = rotr64_lo(xl, xh, 9);  // 41\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 1);\n  var c1_hi = rotr64_hi(xh, xl, 8);\n  var c2_hi = shr64_hi(xh, xl, 7);\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 1);\n  var c1_lo = rotr64_lo(xh, xl, 8);\n  var c2_lo = shr64_lo(xh, xl, 7);\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 19);\n  var c1_hi = rotr64_hi(xl, xh, 29);  // 61\n  var c2_hi = shr64_hi(xh, xl, 6);\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 19);\n  var c1_lo = rotr64_lo(xl, xh, 29);  // 61\n  var c2_lo = shr64_lo(xh, xl, 6);\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash/sha/512.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/common.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar rotr32 = utils.rotr32;\n\nfunction ft_1(s, x, y, z) {\n  if (s === 0)\n    return ch32(x, y, z);\n  if (s === 1 || s === 3)\n    return p32(x, y, z);\n  if (s === 2)\n    return maj32(x, y, z);\n}\nexports.ft_1 = ft_1;\n\nfunction ch32(x, y, z) {\n  return (x & y) ^ ((~x) & z);\n}\nexports.ch32 = ch32;\n\nfunction maj32(x, y, z) {\n  return (x & y) ^ (x & z) ^ (y & z);\n}\nexports.maj32 = maj32;\n\nfunction p32(x, y, z) {\n  return x ^ y ^ z;\n}\nexports.p32 = p32;\n\nfunction s0_256(x) {\n  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n}\nexports.s0_256 = s0_256;\n\nfunction s1_256(x) {\n  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n}\nexports.s1_256 = s1_256;\n\nfunction g0_256(x) {\n  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);\n}\nexports.g0_256 = g0_256;\n\nfunction g1_256(x) {\n  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);\n}\nexports.g1_256 = g1_256;\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash/sha/common.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/utils.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/utils.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports.inherits = inherits;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg === 'string') {\n    if (!enc) {\n      for (var i = 0; i < msg.length; i++) {\n        var c = msg.charCodeAt(i);\n        var hi = c >> 8;\n        var lo = c & 0xff;\n        if (hi)\n          res.push(hi, lo);\n        else\n          res.push(lo);\n      }\n    } else if (enc === 'hex') {\n      msg = msg.replace(/[^a-z0-9]+/ig, '');\n      if (msg.length % 2 !== 0)\n        msg = '0' + msg;\n      for (i = 0; i < msg.length; i += 2)\n        res.push(parseInt(msg[i] + msg[i + 1], 16));\n    }\n  } else {\n    for (i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n  }\n  return res;\n}\nexports.toArray = toArray;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nexports.toHex = toHex;\n\nfunction htonl(w) {\n  var res = (w >>> 24) |\n            ((w >>> 8) & 0xff00) |\n            ((w << 8) & 0xff0000) |\n            ((w & 0xff) << 24);\n  return res >>> 0;\n}\nexports.htonl = htonl;\n\nfunction toHex32(msg, endian) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++) {\n    var w = msg[i];\n    if (endian === 'little')\n      w = htonl(w);\n    res += zero8(w.toString(16));\n  }\n  return res;\n}\nexports.toHex32 = toHex32;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nexports.zero2 = zero2;\n\nfunction zero8(word) {\n  if (word.length === 7)\n    return '0' + word;\n  else if (word.length === 6)\n    return '00' + word;\n  else if (word.length === 5)\n    return '000' + word;\n  else if (word.length === 4)\n    return '0000' + word;\n  else if (word.length === 3)\n    return '00000' + word;\n  else if (word.length === 2)\n    return '000000' + word;\n  else if (word.length === 1)\n    return '0000000' + word;\n  else\n    return word;\n}\nexports.zero8 = zero8;\n\nfunction join32(msg, start, end, endian) {\n  var len = end - start;\n  assert(len % 4 === 0);\n  var res = new Array(len / 4);\n  for (var i = 0, k = start; i < res.length; i++, k += 4) {\n    var w;\n    if (endian === 'big')\n      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\n    else\n      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\n    res[i] = w >>> 0;\n  }\n  return res;\n}\nexports.join32 = join32;\n\nfunction split32(msg, endian) {\n  var res = new Array(msg.length * 4);\n  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n    var m = msg[i];\n    if (endian === 'big') {\n      res[k] = m >>> 24;\n      res[k + 1] = (m >>> 16) & 0xff;\n      res[k + 2] = (m >>> 8) & 0xff;\n      res[k + 3] = m & 0xff;\n    } else {\n      res[k + 3] = m >>> 24;\n      res[k + 2] = (m >>> 16) & 0xff;\n      res[k + 1] = (m >>> 8) & 0xff;\n      res[k] = m & 0xff;\n    }\n  }\n  return res;\n}\nexports.split32 = split32;\n\nfunction rotr32(w, b) {\n  return (w >>> b) | (w << (32 - b));\n}\nexports.rotr32 = rotr32;\n\nfunction rotl32(w, b) {\n  return (w << b) | (w >>> (32 - b));\n}\nexports.rotl32 = rotl32;\n\nfunction sum32(a, b) {\n  return (a + b) >>> 0;\n}\nexports.sum32 = sum32;\n\nfunction sum32_3(a, b, c) {\n  return (a + b + c) >>> 0;\n}\nexports.sum32_3 = sum32_3;\n\nfunction sum32_4(a, b, c, d) {\n  return (a + b + c + d) >>> 0;\n}\nexports.sum32_4 = sum32_4;\n\nfunction sum32_5(a, b, c, d, e) {\n  return (a + b + c + d + e) >>> 0;\n}\nexports.sum32_5 = sum32_5;\n\nfunction sum64(buf, pos, ah, al) {\n  var bh = buf[pos];\n  var bl = buf[pos + 1];\n\n  var lo = (al + bl) >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  buf[pos] = hi >>> 0;\n  buf[pos + 1] = lo;\n}\nexports.sum64 = sum64;\n\nfunction sum64_hi(ah, al, bh, bl) {\n  var lo = (al + bl) >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  return hi >>> 0;\n}\nexports.sum64_hi = sum64_hi;\n\nfunction sum64_lo(ah, al, bh, bl) {\n  var lo = al + bl;\n  return lo >>> 0;\n}\nexports.sum64_lo = sum64_lo;\n\nfunction sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n  var carry = 0;\n  var lo = al;\n  lo = (lo + bl) >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = (lo + cl) >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = (lo + dl) >>> 0;\n  carry += lo < dl ? 1 : 0;\n\n  var hi = ah + bh + ch + dh + carry;\n  return hi >>> 0;\n}\nexports.sum64_4_hi = sum64_4_hi;\n\nfunction sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n  var lo = al + bl + cl + dl;\n  return lo >>> 0;\n}\nexports.sum64_4_lo = sum64_4_lo;\n\nfunction sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var carry = 0;\n  var lo = al;\n  lo = (lo + bl) >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = (lo + cl) >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = (lo + dl) >>> 0;\n  carry += lo < dl ? 1 : 0;\n  lo = (lo + el) >>> 0;\n  carry += lo < el ? 1 : 0;\n\n  var hi = ah + bh + ch + dh + eh + carry;\n  return hi >>> 0;\n}\nexports.sum64_5_hi = sum64_5_hi;\n\nfunction sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var lo = al + bl + cl + dl + el;\n\n  return lo >>> 0;\n}\nexports.sum64_5_lo = sum64_5_lo;\n\nfunction rotr64_hi(ah, al, num) {\n  var r = (al << (32 - num)) | (ah >>> num);\n  return r >>> 0;\n}\nexports.rotr64_hi = rotr64_hi;\n\nfunction rotr64_lo(ah, al, num) {\n  var r = (ah << (32 - num)) | (al >>> num);\n  return r >>> 0;\n}\nexports.rotr64_lo = rotr64_lo;\n\nfunction shr64_hi(ah, al, num) {\n  return ah >>> num;\n}\nexports.shr64_hi = shr64_hi;\n\nfunction shr64_lo(ah, al, num) {\n  var r = (ah << (32 - num)) | (al >>> num);\n  return r >>> 0;\n}\nexports.shr64_lo = shr64_lo;\n\n\n//# sourceURL=webpack:///./node_modules/hash.js/lib/hash/utils.js?");

/***/ }),

/***/ "./node_modules/hmac-drbg/lib/hmac-drbg.js":
/*!*************************************************!*\
  !*** ./node_modules/hmac-drbg/lib/hmac-drbg.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar hash = __webpack_require__(/*! hash.js */ \"./node_modules/hash.js/lib/hash.js\");\nvar utils = __webpack_require__(/*! minimalistic-crypto-utils */ \"./node_modules/minimalistic-crypto-utils/lib/utils.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n\n\n//# sourceURL=webpack:///./node_modules/hmac-drbg/lib/hmac-drbg.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n//# sourceURL=webpack:///./node_modules/indexof/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/md5.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/md5.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar HashBase = __webpack_require__(/*! hash-base */ \"./node_modules/hash-base/index.js\")\n\nvar ARRAY16 = new Array(16)\n\nfunction MD5 () {\n  HashBase.call(this, 64)\n\n  // state\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n}\n\ninherits(MD5, HashBase)\n\nMD5.prototype._update = function () {\n  var M = ARRAY16\n  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)\n\n  var a = this._a\n  var b = this._b\n  var c = this._c\n  var d = this._d\n\n  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)\n  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)\n  c = fnF(c, d, a, b, M[2], 0x242070db, 17)\n  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)\n  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)\n  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)\n  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)\n  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)\n  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)\n  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)\n  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)\n  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)\n  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)\n  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)\n  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)\n  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)\n\n  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)\n  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)\n  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)\n  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)\n  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)\n  d = fnG(d, a, b, c, M[10], 0x02441453, 9)\n  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)\n  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)\n  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)\n  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)\n  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)\n  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)\n  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)\n  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)\n  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)\n  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)\n\n  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)\n  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)\n  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)\n  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)\n  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)\n  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)\n  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)\n  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)\n  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)\n  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)\n  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)\n  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)\n  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)\n  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)\n  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)\n  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)\n\n  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)\n  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)\n  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)\n  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)\n  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)\n  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)\n  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)\n  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)\n  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)\n  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)\n  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)\n  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)\n  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)\n  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)\n  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)\n  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)\n\n  this._a = (this._a + a) | 0\n  this._b = (this._b + b) | 0\n  this._c = (this._c + c) | 0\n  this._d = (this._d + d) | 0\n}\n\nMD5.prototype._digest = function () {\n  // create padding and handle blocks\n  this._block[this._blockOffset++] = 0x80\n  if (this._blockOffset > 56) {\n    this._block.fill(0, this._blockOffset, 64)\n    this._update()\n    this._blockOffset = 0\n  }\n\n  this._block.fill(0, this._blockOffset, 56)\n  this._block.writeUInt32LE(this._length[0], 56)\n  this._block.writeUInt32LE(this._length[1], 60)\n  this._update()\n\n  // produce result\n  var buffer = new Buffer(16)\n  buffer.writeInt32LE(this._a, 0)\n  buffer.writeInt32LE(this._b, 4)\n  buffer.writeInt32LE(this._c, 8)\n  buffer.writeInt32LE(this._d, 12)\n  return buffer\n}\n\nfunction rotl (x, n) {\n  return (x << n) | (x >>> (32 - n))\n}\n\nfunction fnF (a, b, c, d, m, k, s) {\n  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0\n}\n\nfunction fnG (a, b, c, d, m, k, s) {\n  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0\n}\n\nfunction fnH (a, b, c, d, m, k, s) {\n  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0\n}\n\nfunction fnI (a, b, c, d, m, k, s) {\n  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0\n}\n\nmodule.exports = MD5\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/md5.js/index.js?");

/***/ }),

/***/ "./node_modules/miller-rabin/lib/mr.js":
/*!*********************************************!*\
  !*** ./node_modules/miller-rabin/lib/mr.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var bn = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar brorand = __webpack_require__(/*! brorand */ \"./node_modules/brorand/index.js\");\n\nfunction MillerRabin(rand) {\n  this.rand = rand || new brorand.Rand();\n}\nmodule.exports = MillerRabin;\n\nMillerRabin.create = function create(rand) {\n  return new MillerRabin(rand);\n};\n\nMillerRabin.prototype._randbelow = function _randbelow(n) {\n  var len = n.bitLength();\n  var min_bytes = Math.ceil(len / 8);\n\n  // Generage random bytes until a number less than n is found.\n  // This ensures that 0..n-1 have an equal probability of being selected.\n  do\n    var a = new bn(this.rand.generate(min_bytes));\n  while (a.cmp(n) >= 0);\n\n  return a;\n};\n\nMillerRabin.prototype._randrange = function _randrange(start, stop) {\n  // Generate a random number greater than or equal to start and less than stop.\n  var size = stop.sub(start);\n  return start.add(this._randbelow(size));\n};\n\nMillerRabin.prototype.test = function test(n, k, cb) {\n  var len = n.bitLength();\n  var red = bn.mont(n);\n  var rone = new bn(1).toRed(red);\n\n  if (!k)\n    k = Math.max(1, (len / 48) | 0);\n\n  // Find d and s, (n - 1) = (2 ^ s) * d;\n  var n1 = n.subn(1);\n  for (var s = 0; !n1.testn(s); s++) {}\n  var d = n.shrn(s);\n\n  var rn1 = n1.toRed(red);\n\n  var prime = true;\n  for (; k > 0; k--) {\n    var a = this._randrange(new bn(2), n1);\n    if (cb)\n      cb(a);\n\n    var x = a.toRed(red).redPow(d);\n    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)\n      continue;\n\n    for (var i = 1; i < s; i++) {\n      x = x.redSqr();\n\n      if (x.cmp(rone) === 0)\n        return false;\n      if (x.cmp(rn1) === 0)\n        break;\n    }\n\n    if (i === s)\n      return false;\n  }\n\n  return prime;\n};\n\nMillerRabin.prototype.getDivisor = function getDivisor(n, k) {\n  var len = n.bitLength();\n  var red = bn.mont(n);\n  var rone = new bn(1).toRed(red);\n\n  if (!k)\n    k = Math.max(1, (len / 48) | 0);\n\n  // Find d and s, (n - 1) = (2 ^ s) * d;\n  var n1 = n.subn(1);\n  for (var s = 0; !n1.testn(s); s++) {}\n  var d = n.shrn(s);\n\n  var rn1 = n1.toRed(red);\n\n  for (; k > 0; k--) {\n    var a = this._randrange(new bn(2), n1);\n\n    var g = n.gcd(a);\n    if (g.cmpn(1) !== 0)\n      return g;\n\n    var x = a.toRed(red).redPow(d);\n    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)\n      continue;\n\n    for (var i = 1; i < s; i++) {\n      x = x.redSqr();\n\n      if (x.cmp(rone) === 0)\n        return x.fromRed().subn(1).gcd(n);\n      if (x.cmp(rn1) === 0)\n        break;\n    }\n\n    if (i === s) {\n      x = x.redSqr();\n      return x.fromRed().subn(1).gcd(n);\n    }\n  }\n\n  return false;\n};\n\n\n//# sourceURL=webpack:///./node_modules/miller-rabin/lib/mr.js?");

/***/ }),

/***/ "./node_modules/minimalistic-assert/index.js":
/*!***************************************************!*\
  !*** ./node_modules/minimalistic-assert/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n\n\n//# sourceURL=webpack:///./node_modules/minimalistic-assert/index.js?");

/***/ }),

/***/ "./node_modules/minimalistic-crypto-utils/lib/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/minimalistic-crypto-utils/lib/utils.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n\n\n//# sourceURL=webpack:///./node_modules/minimalistic-crypto-utils/lib/utils.js?");

/***/ }),

/***/ "./node_modules/parse-asn1/aesid.json":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/aesid.json ***!
  \********************************************/
/*! exports provided: 2.16.840.1.101.3.4.1.1, 2.16.840.1.101.3.4.1.2, 2.16.840.1.101.3.4.1.3, 2.16.840.1.101.3.4.1.4, 2.16.840.1.101.3.4.1.21, 2.16.840.1.101.3.4.1.22, 2.16.840.1.101.3.4.1.23, 2.16.840.1.101.3.4.1.24, 2.16.840.1.101.3.4.1.41, 2.16.840.1.101.3.4.1.42, 2.16.840.1.101.3.4.1.43, 2.16.840.1.101.3.4.1.44, default */
/***/ (function(module) {

eval("module.exports = {\"2.16.840.1.101.3.4.1.1\":\"aes-128-ecb\",\"2.16.840.1.101.3.4.1.2\":\"aes-128-cbc\",\"2.16.840.1.101.3.4.1.3\":\"aes-128-ofb\",\"2.16.840.1.101.3.4.1.4\":\"aes-128-cfb\",\"2.16.840.1.101.3.4.1.21\":\"aes-192-ecb\",\"2.16.840.1.101.3.4.1.22\":\"aes-192-cbc\",\"2.16.840.1.101.3.4.1.23\":\"aes-192-ofb\",\"2.16.840.1.101.3.4.1.24\":\"aes-192-cfb\",\"2.16.840.1.101.3.4.1.41\":\"aes-256-ecb\",\"2.16.840.1.101.3.4.1.42\":\"aes-256-cbc\",\"2.16.840.1.101.3.4.1.43\":\"aes-256-ofb\",\"2.16.840.1.101.3.4.1.44\":\"aes-256-cfb\"};\n\n//# sourceURL=webpack:///./node_modules/parse-asn1/aesid.json?");

/***/ }),

/***/ "./node_modules/parse-asn1/asn1.js":
/*!*****************************************!*\
  !*** ./node_modules/parse-asn1/asn1.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js\n// Fedor, you are amazing.\n\n\nvar asn1 = __webpack_require__(/*! asn1.js */ \"./node_modules/asn1.js/lib/asn1.js\")\n\nexports.certificate = __webpack_require__(/*! ./certificate */ \"./node_modules/parse-asn1/certificate.js\")\n\nvar RSAPrivateKey = asn1.define('RSAPrivateKey', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('modulus').int(),\n    this.key('publicExponent').int(),\n    this.key('privateExponent').int(),\n    this.key('prime1').int(),\n    this.key('prime2').int(),\n    this.key('exponent1').int(),\n    this.key('exponent2').int(),\n    this.key('coefficient').int()\n  )\n})\nexports.RSAPrivateKey = RSAPrivateKey\n\nvar RSAPublicKey = asn1.define('RSAPublicKey', function () {\n  this.seq().obj(\n    this.key('modulus').int(),\n    this.key('publicExponent').int()\n  )\n})\nexports.RSAPublicKey = RSAPublicKey\n\nvar PublicKey = asn1.define('SubjectPublicKeyInfo', function () {\n  this.seq().obj(\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('subjectPublicKey').bitstr()\n  )\n})\nexports.PublicKey = PublicKey\n\nvar AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {\n  this.seq().obj(\n    this.key('algorithm').objid(),\n    this.key('none').null_().optional(),\n    this.key('curve').objid().optional(),\n    this.key('params').seq().obj(\n      this.key('p').int(),\n      this.key('q').int(),\n      this.key('g').int()\n    ).optional()\n  )\n})\n\nvar PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('subjectPrivateKey').octstr()\n  )\n})\nexports.PrivateKey = PrivateKeyInfo\nvar EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {\n  this.seq().obj(\n    this.key('algorithm').seq().obj(\n      this.key('id').objid(),\n      this.key('decrypt').seq().obj(\n        this.key('kde').seq().obj(\n          this.key('id').objid(),\n          this.key('kdeparams').seq().obj(\n            this.key('salt').octstr(),\n            this.key('iters').int()\n          )\n        ),\n        this.key('cipher').seq().obj(\n          this.key('algo').objid(),\n          this.key('iv').octstr()\n        )\n      )\n    ),\n    this.key('subjectPrivateKey').octstr()\n  )\n})\n\nexports.EncryptedPrivateKey = EncryptedPrivateKeyInfo\n\nvar DSAPrivateKey = asn1.define('DSAPrivateKey', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('p').int(),\n    this.key('q').int(),\n    this.key('g').int(),\n    this.key('pub_key').int(),\n    this.key('priv_key').int()\n  )\n})\nexports.DSAPrivateKey = DSAPrivateKey\n\nexports.DSAparam = asn1.define('DSAparam', function () {\n  this.int()\n})\n\nvar ECPrivateKey = asn1.define('ECPrivateKey', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    this.key('parameters').optional().explicit(0).use(ECParameters),\n    this.key('publicKey').optional().explicit(1).bitstr()\n  )\n})\nexports.ECPrivateKey = ECPrivateKey\n\nvar ECParameters = asn1.define('ECParameters', function () {\n  this.choice({\n    namedCurve: this.objid()\n  })\n})\n\nexports.signature = asn1.define('signature', function () {\n  this.seq().obj(\n    this.key('r').int(),\n    this.key('s').int()\n  )\n})\n\n\n//# sourceURL=webpack:///./node_modules/parse-asn1/asn1.js?");

/***/ }),

/***/ "./node_modules/parse-asn1/certificate.js":
/*!************************************************!*\
  !*** ./node_modules/parse-asn1/certificate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js\n// thanks to @Rantanen\n\n\n\nvar asn = __webpack_require__(/*! asn1.js */ \"./node_modules/asn1.js/lib/asn1.js\")\n\nvar Time = asn.define('Time', function () {\n  this.choice({\n    utcTime: this.utctime(),\n    generalTime: this.gentime()\n  })\n})\n\nvar AttributeTypeValue = asn.define('AttributeTypeValue', function () {\n  this.seq().obj(\n    this.key('type').objid(),\n    this.key('value').any()\n  )\n})\n\nvar AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {\n  this.seq().obj(\n    this.key('algorithm').objid(),\n    this.key('parameters').optional()\n  )\n})\n\nvar SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {\n  this.seq().obj(\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('subjectPublicKey').bitstr()\n  )\n})\n\nvar RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {\n  this.setof(AttributeTypeValue)\n})\n\nvar RDNSequence = asn.define('RDNSequence', function () {\n  this.seqof(RelativeDistinguishedName)\n})\n\nvar Name = asn.define('Name', function () {\n  this.choice({\n    rdnSequence: this.use(RDNSequence)\n  })\n})\n\nvar Validity = asn.define('Validity', function () {\n  this.seq().obj(\n    this.key('notBefore').use(Time),\n    this.key('notAfter').use(Time)\n  )\n})\n\nvar Extension = asn.define('Extension', function () {\n  this.seq().obj(\n    this.key('extnID').objid(),\n    this.key('critical').bool().def(false),\n    this.key('extnValue').octstr()\n  )\n})\n\nvar TBSCertificate = asn.define('TBSCertificate', function () {\n  this.seq().obj(\n    this.key('version').explicit(0).int(),\n    this.key('serialNumber').int(),\n    this.key('signature').use(AlgorithmIdentifier),\n    this.key('issuer').use(Name),\n    this.key('validity').use(Validity),\n    this.key('subject').use(Name),\n    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),\n    this.key('issuerUniqueID').implicit(1).bitstr().optional(),\n    this.key('subjectUniqueID').implicit(2).bitstr().optional(),\n    this.key('extensions').explicit(3).seqof(Extension).optional()\n  )\n})\n\nvar X509Certificate = asn.define('X509Certificate', function () {\n  this.seq().obj(\n    this.key('tbsCertificate').use(TBSCertificate),\n    this.key('signatureAlgorithm').use(AlgorithmIdentifier),\n    this.key('signatureValue').bitstr()\n  )\n})\n\nmodule.exports = X509Certificate\n\n\n//# sourceURL=webpack:///./node_modules/parse-asn1/certificate.js?");

/***/ }),

/***/ "./node_modules/parse-asn1/fixProc.js":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/fixProc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// adapted from https://github.com/apatil/pemstrip\nvar findProc = /Proc-Type: 4,ENCRYPTED[\\n\\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\\n\\r]+([0-9A-z\\n\\r\\+\\/\\=]+)[\\n\\r]+/m\nvar startRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----/m\nvar fullRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----([0-9A-z\\n\\r\\+\\/\\=]+)-----END \\1-----$/m\nvar evp = __webpack_require__(/*! evp_bytestokey */ \"./node_modules/evp_bytestokey/index.js\")\nvar ciphers = __webpack_require__(/*! browserify-aes */ \"./node_modules/browserify-aes/browser.js\")\nmodule.exports = function (okey, password) {\n  var key = okey.toString()\n  var match = key.match(findProc)\n  var decrypted\n  if (!match) {\n    var match2 = key.match(fullRegex)\n    decrypted = new Buffer(match2[2].replace(/[\\r\\n]/g, ''), 'base64')\n  } else {\n    var suite = 'aes' + match[1]\n    var iv = new Buffer(match[2], 'hex')\n    var cipherText = new Buffer(match[3].replace(/[\\r\\n]/g, ''), 'base64')\n    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key\n    var out = []\n    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)\n    out.push(cipher.update(cipherText))\n    out.push(cipher.final())\n    decrypted = Buffer.concat(out)\n  }\n  var tag = key.match(startRegex)[1]\n  return {\n    tag: tag,\n    data: decrypted\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/parse-asn1/fixProc.js?");

/***/ }),

/***/ "./node_modules/parse-asn1/index.js":
/*!******************************************!*\
  !*** ./node_modules/parse-asn1/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var asn1 = __webpack_require__(/*! ./asn1 */ \"./node_modules/parse-asn1/asn1.js\")\nvar aesid = __webpack_require__(/*! ./aesid.json */ \"./node_modules/parse-asn1/aesid.json\")\nvar fixProc = __webpack_require__(/*! ./fixProc */ \"./node_modules/parse-asn1/fixProc.js\")\nvar ciphers = __webpack_require__(/*! browserify-aes */ \"./node_modules/browserify-aes/browser.js\")\nvar compat = __webpack_require__(/*! pbkdf2 */ \"./node_modules/pbkdf2/browser.js\")\nmodule.exports = parseKeys\n\nfunction parseKeys (buffer) {\n  var password\n  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {\n    password = buffer.passphrase\n    buffer = buffer.key\n  }\n  if (typeof buffer === 'string') {\n    buffer = new Buffer(buffer)\n  }\n\n  var stripped = fixProc(buffer, password)\n\n  var type = stripped.tag\n  var data = stripped.data\n  var subtype, ndata\n  switch (type) {\n    case 'CERTIFICATE':\n      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo\n      // falls through\n    case 'PUBLIC KEY':\n      if (!ndata) {\n        ndata = asn1.PublicKey.decode(data, 'der')\n      }\n      subtype = ndata.algorithm.algorithm.join('.')\n      switch (subtype) {\n        case '1.2.840.113549.1.1.1':\n          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')\n        case '1.2.840.10045.2.1':\n          ndata.subjectPrivateKey = ndata.subjectPublicKey\n          return {\n            type: 'ec',\n            data: ndata\n          }\n        case '1.2.840.10040.4.1':\n          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')\n          return {\n            type: 'dsa',\n            data: ndata.algorithm.params\n          }\n        default: throw new Error('unknown key id ' + subtype)\n      }\n      throw new Error('unknown key type ' + type)\n    case 'ENCRYPTED PRIVATE KEY':\n      data = asn1.EncryptedPrivateKey.decode(data, 'der')\n      data = decrypt(data, password)\n      // falls through\n    case 'PRIVATE KEY':\n      ndata = asn1.PrivateKey.decode(data, 'der')\n      subtype = ndata.algorithm.algorithm.join('.')\n      switch (subtype) {\n        case '1.2.840.113549.1.1.1':\n          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')\n        case '1.2.840.10045.2.1':\n          return {\n            curve: ndata.algorithm.curve,\n            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey\n          }\n        case '1.2.840.10040.4.1':\n          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')\n          return {\n            type: 'dsa',\n            params: ndata.algorithm.params\n          }\n        default: throw new Error('unknown key id ' + subtype)\n      }\n      throw new Error('unknown key type ' + type)\n    case 'RSA PUBLIC KEY':\n      return asn1.RSAPublicKey.decode(data, 'der')\n    case 'RSA PRIVATE KEY':\n      return asn1.RSAPrivateKey.decode(data, 'der')\n    case 'DSA PRIVATE KEY':\n      return {\n        type: 'dsa',\n        params: asn1.DSAPrivateKey.decode(data, 'der')\n      }\n    case 'EC PRIVATE KEY':\n      data = asn1.ECPrivateKey.decode(data, 'der')\n      return {\n        curve: data.parameters.value,\n        privateKey: data.privateKey\n      }\n    default: throw new Error('unknown key type ' + type)\n  }\n}\nparseKeys.signature = asn1.signature\nfunction decrypt (data, password) {\n  var salt = data.algorithm.decrypt.kde.kdeparams.salt\n  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)\n  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]\n  var iv = data.algorithm.decrypt.cipher.iv\n  var cipherText = data.subjectPrivateKey\n  var keylen = parseInt(algo.split('-')[1], 10) / 8\n  var key = compat.pbkdf2Sync(password, salt, iters, keylen)\n  var cipher = ciphers.createDecipheriv(algo, key, iv)\n  var out = []\n  out.push(cipher.update(cipherText))\n  out.push(cipher.final())\n  return Buffer.concat(out)\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/parse-asn1/index.js?");

/***/ }),

/***/ "./node_modules/pbkdf2/browser.js":
/*!****************************************!*\
  !*** ./node_modules/pbkdf2/browser.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.pbkdf2 = __webpack_require__(/*! ./lib/async */ \"./node_modules/pbkdf2/lib/async.js\")\nexports.pbkdf2Sync = __webpack_require__(/*! ./lib/sync */ \"./node_modules/pbkdf2/lib/sync-browser.js\")\n\n\n//# sourceURL=webpack:///./node_modules/pbkdf2/browser.js?");

/***/ }),

/***/ "./node_modules/pbkdf2/lib/async.js":
/*!******************************************!*\
  !*** ./node_modules/pbkdf2/lib/async.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {var checkParameters = __webpack_require__(/*! ./precondition */ \"./node_modules/pbkdf2/lib/precondition.js\")\nvar defaultEncoding = __webpack_require__(/*! ./default-encoding */ \"./node_modules/pbkdf2/lib/default-encoding.js\")\nvar sync = __webpack_require__(/*! ./sync */ \"./node_modules/pbkdf2/lib/sync-browser.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar ZERO_BUF\nvar subtle = global.crypto && global.crypto.subtle\nvar toBrowser = {\n  'sha': 'SHA-1',\n  'sha-1': 'SHA-1',\n  'sha1': 'SHA-1',\n  'sha256': 'SHA-256',\n  'sha-256': 'SHA-256',\n  'sha384': 'SHA-384',\n  'sha-384': 'SHA-384',\n  'sha-512': 'SHA-512',\n  'sha512': 'SHA-512'\n}\nvar checks = []\nfunction checkNative (algo) {\n  if (global.process && !global.process.browser) {\n    return Promise.resolve(false)\n  }\n  if (!subtle || !subtle.importKey || !subtle.deriveBits) {\n    return Promise.resolve(false)\n  }\n  if (checks[algo] !== undefined) {\n    return checks[algo]\n  }\n  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)\n  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)\n    .then(function () {\n      return true\n    }).catch(function () {\n      return false\n    })\n  checks[algo] = prom\n  return prom\n}\n\nfunction browserPbkdf2 (password, salt, iterations, length, algo) {\n  return subtle.importKey(\n    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']\n  ).then(function (key) {\n    return subtle.deriveBits({\n      name: 'PBKDF2',\n      salt: salt,\n      iterations: iterations,\n      hash: {\n        name: algo\n      }\n    }, key, length << 3)\n  }).then(function (res) {\n    return Buffer.from(res)\n  })\n}\n\nfunction resolvePromise (promise, callback) {\n  promise.then(function (out) {\n    process.nextTick(function () {\n      callback(null, out)\n    })\n  }, function (e) {\n    process.nextTick(function () {\n      callback(e)\n    })\n  })\n}\nmodule.exports = function (password, salt, iterations, keylen, digest, callback) {\n  if (typeof digest === 'function') {\n    callback = digest\n    digest = undefined\n  }\n\n  digest = digest || 'sha1'\n  var algo = toBrowser[digest.toLowerCase()]\n\n  if (!algo || typeof global.Promise !== 'function') {\n    return process.nextTick(function () {\n      var out\n      try {\n        out = sync(password, salt, iterations, keylen, digest)\n      } catch (e) {\n        return callback(e)\n      }\n      callback(null, out)\n    })\n  }\n\n  checkParameters(password, salt, iterations, keylen)\n  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')\n  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)\n  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)\n\n  resolvePromise(checkNative(algo).then(function (resp) {\n    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)\n\n    return sync(password, salt, iterations, keylen, digest)\n  }), callback)\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/pbkdf2/lib/async.js?");

/***/ }),

/***/ "./node_modules/pbkdf2/lib/default-encoding.js":
/*!*****************************************************!*\
  !*** ./node_modules/pbkdf2/lib/default-encoding.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var defaultEncoding\n/* istanbul ignore next */\nif (process.browser) {\n  defaultEncoding = 'utf-8'\n} else {\n  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)\n\n  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'\n}\nmodule.exports = defaultEncoding\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/pbkdf2/lib/default-encoding.js?");

/***/ }),

/***/ "./node_modules/pbkdf2/lib/precondition.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/precondition.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs\n\nfunction checkBuffer (buf, name) {\n  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {\n    throw new TypeError(name + ' must be a buffer or string')\n  }\n}\n\nmodule.exports = function (password, salt, iterations, keylen) {\n  checkBuffer(password, 'Password')\n  checkBuffer(salt, 'Salt')\n\n  if (typeof iterations !== 'number') {\n    throw new TypeError('Iterations not a number')\n  }\n\n  if (iterations < 0) {\n    throw new TypeError('Bad iterations')\n  }\n\n  if (typeof keylen !== 'number') {\n    throw new TypeError('Key length not a number')\n  }\n\n  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */\n    throw new TypeError('Bad key length')\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/pbkdf2/lib/precondition.js?");

/***/ }),

/***/ "./node_modules/pbkdf2/lib/sync-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/sync-browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var md5 = __webpack_require__(/*! create-hash/md5 */ \"./node_modules/create-hash/md5.js\")\nvar rmd160 = __webpack_require__(/*! ripemd160 */ \"./node_modules/ripemd160/index.js\")\nvar sha = __webpack_require__(/*! sha.js */ \"./node_modules/sha.js/index.js\")\n\nvar checkParameters = __webpack_require__(/*! ./precondition */ \"./node_modules/pbkdf2/lib/precondition.js\")\nvar defaultEncoding = __webpack_require__(/*! ./default-encoding */ \"./node_modules/pbkdf2/lib/default-encoding.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar ZEROS = Buffer.alloc(128)\nvar sizes = {\n  md5: 16,\n  sha1: 20,\n  sha224: 28,\n  sha256: 32,\n  sha384: 48,\n  sha512: 64,\n  rmd160: 20,\n  ripemd160: 20\n}\n\nfunction Hmac (alg, key, saltLen) {\n  var hash = getDigest(alg)\n  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64\n\n  if (key.length > blocksize) {\n    key = hash(key)\n  } else if (key.length < blocksize) {\n    key = Buffer.concat([key, ZEROS], blocksize)\n  }\n\n  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])\n  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])\n  for (var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)\n  ipad.copy(ipad1, 0, 0, blocksize)\n  this.ipad1 = ipad1\n  this.ipad2 = ipad\n  this.opad = opad\n  this.alg = alg\n  this.blocksize = blocksize\n  this.hash = hash\n  this.size = sizes[alg]\n}\n\nHmac.prototype.run = function (data, ipad) {\n  data.copy(ipad, this.blocksize)\n  var h = this.hash(ipad)\n  h.copy(this.opad, this.blocksize)\n  return this.hash(this.opad)\n}\n\nfunction getDigest (alg) {\n  function shaFunc (data) {\n    return sha(alg).update(data).digest()\n  }\n\n  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160\n  if (alg === 'md5') return md5\n  return shaFunc\n}\n\nfunction pbkdf2 (password, salt, iterations, keylen, digest) {\n  checkParameters(password, salt, iterations, keylen)\n\n  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)\n  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)\n\n  digest = digest || 'sha1'\n\n  var hmac = new Hmac(digest, password, salt.length)\n\n  var DK = Buffer.allocUnsafe(keylen)\n  var block1 = Buffer.allocUnsafe(salt.length + 4)\n  salt.copy(block1, 0, 0, salt.length)\n\n  var destPos = 0\n  var hLen = sizes[digest]\n  var l = Math.ceil(keylen / hLen)\n\n  for (var i = 1; i <= l; i++) {\n    block1.writeUInt32BE(i, salt.length)\n\n    var T = hmac.run(block1, hmac.ipad1)\n    var U = T\n\n    for (var j = 1; j < iterations; j++) {\n      U = hmac.run(U, hmac.ipad2)\n      for (var k = 0; k < hLen; k++) T[k] ^= U[k]\n    }\n\n    T.copy(DK, destPos)\n    destPos += hLen\n  }\n\n  return DK\n}\n\nmodule.exports = pbkdf2\n\n\n//# sourceURL=webpack:///./node_modules/pbkdf2/lib/sync-browser.js?");

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/process-nextick-args/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/browser.js":
/*!************************************************!*\
  !*** ./node_modules/public-encrypt/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.publicEncrypt = __webpack_require__(/*! ./publicEncrypt */ \"./node_modules/public-encrypt/publicEncrypt.js\");\nexports.privateDecrypt = __webpack_require__(/*! ./privateDecrypt */ \"./node_modules/public-encrypt/privateDecrypt.js\");\n\nexports.privateEncrypt = function privateEncrypt(key, buf) {\n  return exports.publicEncrypt(key, buf, true);\n};\n\nexports.publicDecrypt = function publicDecrypt(key, buf) {\n  return exports.privateDecrypt(key, buf, true);\n};\n\n//# sourceURL=webpack:///./node_modules/public-encrypt/browser.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/mgf.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/mgf.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\");\nmodule.exports = function (seed, len) {\n  var t = new Buffer('');\n  var  i = 0, c;\n  while (t.length < len) {\n    c = i2ops(i++);\n    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);\n  }\n  return t.slice(0, len);\n};\n\nfunction i2ops(c) {\n  var out = new Buffer(4);\n  out.writeUInt32BE(c,0);\n  return out;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/public-encrypt/mgf.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/privateDecrypt.js":
/*!*******************************************************!*\
  !*** ./node_modules/public-encrypt/privateDecrypt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var parseKeys = __webpack_require__(/*! parse-asn1 */ \"./node_modules/parse-asn1/index.js\");\nvar mgf = __webpack_require__(/*! ./mgf */ \"./node_modules/public-encrypt/mgf.js\");\nvar xor = __webpack_require__(/*! ./xor */ \"./node_modules/public-encrypt/xor.js\");\nvar bn = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar crt = __webpack_require__(/*! browserify-rsa */ \"./node_modules/browserify-rsa/index.js\");\nvar createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\");\nvar withPublic = __webpack_require__(/*! ./withPublic */ \"./node_modules/public-encrypt/withPublic.js\");\nmodule.exports = function privateDecrypt(private_key, enc, reverse) {\n  var padding;\n  if (private_key.padding) {\n    padding = private_key.padding;\n  } else if (reverse) {\n    padding = 1;\n  } else {\n    padding = 4;\n  }\n  \n  var key = parseKeys(private_key);\n  var k = key.modulus.byteLength();\n  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {\n    throw new Error('decryption error');\n  }\n  var msg;\n  if (reverse) {\n    msg = withPublic(new bn(enc), key);\n  } else {\n    msg = crt(enc, key);\n  }\n  var zBuffer = new Buffer(k - msg.length);\n  zBuffer.fill(0);\n  msg = Buffer.concat([zBuffer, msg], k);\n  if (padding === 4) {\n    return oaep(key, msg);\n  } else if (padding === 1) {\n    return pkcs1(key, msg, reverse);\n  } else if (padding === 3) {\n    return msg;\n  } else {\n    throw new Error('unknown padding');\n  }\n};\n\nfunction oaep(key, msg){\n  var n = key.modulus;\n  var k = key.modulus.byteLength();\n  var mLen = msg.length;\n  var iHash = createHash('sha1').update(new Buffer('')).digest();\n  var hLen = iHash.length;\n  var hLen2 = 2 * hLen;\n  if (msg[0] !== 0) {\n    throw new Error('decryption error');\n  }\n  var maskedSeed = msg.slice(1, hLen + 1);\n  var maskedDb =  msg.slice(hLen + 1);\n  var seed = xor(maskedSeed, mgf(maskedDb, hLen));\n  var db = xor(maskedDb, mgf(seed, k - hLen - 1));\n  if (compare(iHash, db.slice(0, hLen))) {\n    throw new Error('decryption error');\n  }\n  var i = hLen;\n  while (db[i] === 0) {\n    i++;\n  }\n  if (db[i++] !== 1) {\n    throw new Error('decryption error');\n  }\n  return db.slice(i);\n}\n\nfunction pkcs1(key, msg, reverse){\n  var p1 = msg.slice(0, 2);\n  var i = 2;\n  var status = 0;\n  while (msg[i++] !== 0) {\n    if (i >= msg.length) {\n      status++;\n      break;\n    }\n  }\n  var ps = msg.slice(2, i - 1);\n  var p2 = msg.slice(i - 1, i);\n\n  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){\n    status++;\n  }\n  if (ps.length < 8) {\n    status++;\n  }\n  if (status) {\n    throw new Error('decryption error');\n  }\n  return  msg.slice(i);\n}\nfunction compare(a, b){\n  a = new Buffer(a);\n  b = new Buffer(b);\n  var dif = 0;\n  var len = a.length;\n  if (a.length !== b.length) {\n    dif++;\n    len = Math.min(a.length, b.length);\n  }\n  var i = -1;\n  while (++i < len) {\n    dif += (a[i] ^ b[i]);\n  }\n  return dif;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/public-encrypt/privateDecrypt.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/publicEncrypt.js":
/*!******************************************************!*\
  !*** ./node_modules/public-encrypt/publicEncrypt.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var parseKeys = __webpack_require__(/*! parse-asn1 */ \"./node_modules/parse-asn1/index.js\");\nvar randomBytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\");\nvar createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\");\nvar mgf = __webpack_require__(/*! ./mgf */ \"./node_modules/public-encrypt/mgf.js\");\nvar xor = __webpack_require__(/*! ./xor */ \"./node_modules/public-encrypt/xor.js\");\nvar bn = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar withPublic = __webpack_require__(/*! ./withPublic */ \"./node_modules/public-encrypt/withPublic.js\");\nvar crt = __webpack_require__(/*! browserify-rsa */ \"./node_modules/browserify-rsa/index.js\");\n\nvar constants = {\n  RSA_PKCS1_OAEP_PADDING: 4,\n  RSA_PKCS1_PADDIN: 1,\n  RSA_NO_PADDING: 3\n};\n\nmodule.exports = function publicEncrypt(public_key, msg, reverse) {\n  var padding;\n  if (public_key.padding) {\n    padding = public_key.padding;\n  } else if (reverse) {\n    padding = 1;\n  } else {\n    padding = 4;\n  }\n  var key = parseKeys(public_key);\n  var paddedMsg;\n  if (padding === 4) {\n    paddedMsg = oaep(key, msg);\n  } else if (padding === 1) {\n    paddedMsg = pkcs1(key, msg, reverse);\n  } else if (padding === 3) {\n    paddedMsg = new bn(msg);\n    if (paddedMsg.cmp(key.modulus) >= 0) {\n      throw new Error('data too long for modulus');\n    }\n  } else {\n    throw new Error('unknown padding');\n  }\n  if (reverse) {\n    return crt(paddedMsg, key);\n  } else {\n    return withPublic(paddedMsg, key);\n  }\n};\n\nfunction oaep(key, msg){\n  var k = key.modulus.byteLength();\n  var mLen = msg.length;\n  var iHash = createHash('sha1').update(new Buffer('')).digest();\n  var hLen = iHash.length;\n  var hLen2 = 2 * hLen;\n  if (mLen > k - hLen2 - 2) {\n    throw new Error('message too long');\n  }\n  var ps = new Buffer(k - mLen - hLen2 - 2);\n  ps.fill(0);\n  var dblen = k - hLen - 1;\n  var seed = randomBytes(hLen);\n  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));\n  var maskedSeed = xor(seed, mgf(maskedDb, hLen));\n  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));\n}\nfunction pkcs1(key, msg, reverse){\n  var mLen = msg.length;\n  var k = key.modulus.byteLength();\n  if (mLen > k - 11) {\n    throw new Error('message too long');\n  }\n  var ps;\n  if (reverse) {\n    ps = new Buffer(k - mLen - 3);\n    ps.fill(0xff);\n  } else {\n    ps = nonZero(k - mLen - 3);\n  }\n  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));\n}\nfunction nonZero(len, crypto) {\n  var out = new Buffer(len);\n  var i = 0;\n  var cache = randomBytes(len*2);\n  var cur = 0;\n  var num;\n  while (i < len) {\n    if (cur === cache.length) {\n      cache = randomBytes(len*2);\n      cur = 0;\n    }\n    num = cache[cur++];\n    if (num) {\n      out[i++] = num;\n    }\n  }\n  return out;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/public-encrypt/publicEncrypt.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/withPublic.js":
/*!***************************************************!*\
  !*** ./node_modules/public-encrypt/withPublic.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nfunction withPublic(paddedMsg, key) {\n  return new Buffer(paddedMsg\n    .toRed(bn.mont(key.modulus))\n    .redPow(new bn(key.publicExponent))\n    .fromRed()\n    .toArray());\n}\n\nmodule.exports = withPublic;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/public-encrypt/withPublic.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/xor.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/xor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function xor(a, b) {\n  var len = a.length;\n  var i = -1;\n  while (++i < len) {\n    a[i] ^= b[i];\n  }\n  return a\n};\n\n//# sourceURL=webpack:///./node_modules/public-encrypt/xor.js?");

/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\n\nfunction oldBrowser () {\n  throw new Error('Secure random number generation is not supported by this browser.\\nUse Chrome, Firefox or Internet Explorer 11')\n}\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar crypto = global.crypto || global.msCrypto\n\nif (crypto && crypto.getRandomValues) {\n  module.exports = randomBytes\n} else {\n  module.exports = oldBrowser\n}\n\nfunction randomBytes (size, cb) {\n  // phantomjs needs to throw\n  if (size > 65536) throw new Error('requested too many random bytes')\n  // in case browserify  isn't using the Uint8Array version\n  var rawBytes = new global.Uint8Array(size)\n\n  // This will not work in older browsers.\n  // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n  if (size > 0) {  // getRandomValues fails on IE if size == 0\n    crypto.getRandomValues(rawBytes)\n  }\n\n  // XXX: phantomjs doesn't like a buffer being passed here\n  var bytes = Buffer.from(rawBytes.buffer)\n\n  if (typeof cb === 'function') {\n    return process.nextTick(function () {\n      cb(null, bytes)\n    })\n  }\n\n  return bytes\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/randombytes/browser.js?");

/***/ }),

/***/ "./node_modules/randomfill/browser.js":
/*!********************************************!*\
  !*** ./node_modules/randomfill/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\n\nfunction oldBrowser () {\n  throw new Error('secure random number generation not supported by this browser\\nuse chrome, FireFox or Internet Explorer 11')\n}\nvar safeBuffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\")\nvar randombytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\")\nvar Buffer = safeBuffer.Buffer\nvar kBufferMaxLength = safeBuffer.kMaxLength\nvar crypto = global.crypto || global.msCrypto\nvar kMaxUint32 = Math.pow(2, 32) - 1\nfunction assertOffset (offset, length) {\n  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare\n    throw new TypeError('offset must be a number')\n  }\n\n  if (offset > kMaxUint32 || offset < 0) {\n    throw new TypeError('offset must be a uint32')\n  }\n\n  if (offset > kBufferMaxLength || offset > length) {\n    throw new RangeError('offset out of range')\n  }\n}\n\nfunction assertSize (size, offset, length) {\n  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare\n    throw new TypeError('size must be a number')\n  }\n\n  if (size > kMaxUint32 || size < 0) {\n    throw new TypeError('size must be a uint32')\n  }\n\n  if (size + offset > length || size > kBufferMaxLength) {\n    throw new RangeError('buffer too small')\n  }\n}\nif ((crypto && crypto.getRandomValues) || !process.browser) {\n  exports.randomFill = randomFill\n  exports.randomFillSync = randomFillSync\n} else {\n  exports.randomFill = oldBrowser\n  exports.randomFillSync = oldBrowser\n}\nfunction randomFill (buf, offset, size, cb) {\n  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {\n    throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array')\n  }\n\n  if (typeof offset === 'function') {\n    cb = offset\n    offset = 0\n    size = buf.length\n  } else if (typeof size === 'function') {\n    cb = size\n    size = buf.length - offset\n  } else if (typeof cb !== 'function') {\n    throw new TypeError('\"cb\" argument must be a function')\n  }\n  assertOffset(offset, buf.length)\n  assertSize(size, offset, buf.length)\n  return actualFill(buf, offset, size, cb)\n}\n\nfunction actualFill (buf, offset, size, cb) {\n  if (process.browser) {\n    var ourBuf = buf.buffer\n    var uint = new Uint8Array(ourBuf, offset, size)\n    crypto.getRandomValues(uint)\n    if (cb) {\n      process.nextTick(function () {\n        cb(null, buf)\n      })\n      return\n    }\n    return buf\n  }\n  if (cb) {\n    randombytes(size, function (err, bytes) {\n      if (err) {\n        return cb(err)\n      }\n      bytes.copy(buf, offset)\n      cb(null, buf)\n    })\n    return\n  }\n  var bytes = randombytes(size)\n  bytes.copy(buf, offset)\n  return buf\n}\nfunction randomFillSync (buf, offset, size) {\n  if (typeof offset === 'undefined') {\n    offset = 0\n  }\n  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {\n    throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array')\n  }\n\n  assertOffset(offset, buf.length)\n\n  if (size === undefined) size = buf.length - offset\n\n  assertSize(size, offset, buf.length)\n\n  return actualFill(buf, offset, size)\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/randomfill/browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/duplex-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ 0);\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"./node_modules/readable-stream/lib/internal/streams/BufferList.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar util = __webpack_require__(/*! util */ 1);\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/internal/streams/BufferList.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/internal/streams/stream-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").PassThrough\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/readable-stream/lib/_stream_passthrough.js\");\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/readable-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").Transform\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/writable-browser.js?");

/***/ }),

/***/ "./node_modules/ripemd160/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ripemd160/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar HashBase = __webpack_require__(/*! hash-base */ \"./node_modules/hash-base/index.js\")\n\nvar ARRAY16 = new Array(16)\n\nvar zl = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n]\n\nvar zr = [\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n]\n\nvar sl = [\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n]\n\nvar sr = [\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n]\n\nvar hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]\nvar hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]\n\nfunction RIPEMD160 () {\n  HashBase.call(this, 64)\n\n  // state\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n}\n\ninherits(RIPEMD160, HashBase)\n\nRIPEMD160.prototype._update = function () {\n  var words = ARRAY16\n  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)\n\n  var al = this._a | 0\n  var bl = this._b | 0\n  var cl = this._c | 0\n  var dl = this._d | 0\n  var el = this._e | 0\n\n  var ar = this._a | 0\n  var br = this._b | 0\n  var cr = this._c | 0\n  var dr = this._d | 0\n  var er = this._e | 0\n\n  // computation\n  for (var i = 0; i < 80; i += 1) {\n    var tl\n    var tr\n    if (i < 16) {\n      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])\n      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])\n    } else if (i < 32) {\n      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])\n      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])\n    } else if (i < 48) {\n      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])\n      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])\n    } else if (i < 64) {\n      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])\n      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])\n    } else { // if (i<80) {\n      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])\n      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])\n    }\n\n    al = el\n    el = dl\n    dl = rotl(cl, 10)\n    cl = bl\n    bl = tl\n\n    ar = er\n    er = dr\n    dr = rotl(cr, 10)\n    cr = br\n    br = tr\n  }\n\n  // update state\n  var t = (this._b + cl + dr) | 0\n  this._b = (this._c + dl + er) | 0\n  this._c = (this._d + el + ar) | 0\n  this._d = (this._e + al + br) | 0\n  this._e = (this._a + bl + cr) | 0\n  this._a = t\n}\n\nRIPEMD160.prototype._digest = function () {\n  // create padding and handle blocks\n  this._block[this._blockOffset++] = 0x80\n  if (this._blockOffset > 56) {\n    this._block.fill(0, this._blockOffset, 64)\n    this._update()\n    this._blockOffset = 0\n  }\n\n  this._block.fill(0, this._blockOffset, 56)\n  this._block.writeUInt32LE(this._length[0], 56)\n  this._block.writeUInt32LE(this._length[1], 60)\n  this._update()\n\n  // produce result\n  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)\n  buffer.writeInt32LE(this._a, 0)\n  buffer.writeInt32LE(this._b, 4)\n  buffer.writeInt32LE(this._c, 8)\n  buffer.writeInt32LE(this._d, 12)\n  buffer.writeInt32LE(this._e, 16)\n  return buffer\n}\n\nfunction rotl (x, n) {\n  return (x << n) | (x >>> (32 - n))\n}\n\nfunction fn1 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn2 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn3 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn4 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn5 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0\n}\n\nmodule.exports = RIPEMD160\n\n\n//# sourceURL=webpack:///./node_modules/ripemd160/index.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack:///./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\n// prototype class for hash functions\nfunction Hash (blockSize, finalSize) {\n  this._block = Buffer.alloc(blockSize)\n  this._finalSize = finalSize\n  this._blockSize = blockSize\n  this._len = 0\n}\n\nHash.prototype.update = function (data, enc) {\n  if (typeof data === 'string') {\n    enc = enc || 'utf8'\n    data = Buffer.from(data, enc)\n  }\n\n  var block = this._block\n  var blockSize = this._blockSize\n  var length = data.length\n  var accum = this._len\n\n  for (var offset = 0; offset < length;) {\n    var assigned = accum % blockSize\n    var remainder = Math.min(length - offset, blockSize - assigned)\n\n    for (var i = 0; i < remainder; i++) {\n      block[assigned + i] = data[offset + i]\n    }\n\n    accum += remainder\n    offset += remainder\n\n    if ((accum % blockSize) === 0) {\n      this._update(block)\n    }\n  }\n\n  this._len += length\n  return this\n}\n\nHash.prototype.digest = function (enc) {\n  var rem = this._len % this._blockSize\n\n  this._block[rem] = 0x80\n\n  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest\n  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize\n  this._block.fill(0, rem + 1)\n\n  if (rem >= this._finalSize) {\n    this._update(this._block)\n    this._block.fill(0)\n  }\n\n  var bits = this._len * 8\n\n  // uint32\n  if (bits <= 0xffffffff) {\n    this._block.writeUInt32BE(bits, this._blockSize - 4)\n\n  // uint64\n  } else {\n    var lowBits = (bits & 0xffffffff) >>> 0\n    var highBits = (bits - lowBits) / 0x100000000\n\n    this._block.writeUInt32BE(highBits, this._blockSize - 8)\n    this._block.writeUInt32BE(lowBits, this._blockSize - 4)\n  }\n\n  this._update(this._block)\n  var hash = this._hash()\n\n  return enc ? hash.toString(enc) : hash\n}\n\nHash.prototype._update = function () {\n  throw new Error('_update must be implemented by subclass')\n}\n\nmodule.exports = Hash\n\n\n//# sourceURL=webpack:///./node_modules/sha.js/hash.js?");

/***/ }),

/***/ "./node_modules/sha.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/sha.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var exports = module.exports = function SHA (algorithm) {\n  algorithm = algorithm.toLowerCase()\n\n  var Algorithm = exports[algorithm]\n  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')\n\n  return new Algorithm()\n}\n\nexports.sha = __webpack_require__(/*! ./sha */ \"./node_modules/sha.js/sha.js\")\nexports.sha1 = __webpack_require__(/*! ./sha1 */ \"./node_modules/sha.js/sha1.js\")\nexports.sha224 = __webpack_require__(/*! ./sha224 */ \"./node_modules/sha.js/sha224.js\")\nexports.sha256 = __webpack_require__(/*! ./sha256 */ \"./node_modules/sha.js/sha256.js\")\nexports.sha384 = __webpack_require__(/*! ./sha384 */ \"./node_modules/sha.js/sha384.js\")\nexports.sha512 = __webpack_require__(/*! ./sha512 */ \"./node_modules/sha.js/sha512.js\")\n\n\n//# sourceURL=webpack:///./node_modules/sha.js/index.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha.js":
/*!************************************!*\
  !*** ./node_modules/sha.js/sha.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined\n * in FIPS PUB 180-1\n * This source code is derived from sha1.js of the same repository.\n * The difference between SHA-0 and SHA-1 is just a bitwise rotate left\n * operation was added.\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar K = [\n  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\n]\n\nvar W = new Array(80)\n\nfunction Sha () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha, Hash)\n\nSha.prototype.init = function () {\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n\n  return this\n}\n\nfunction rotl5 (num) {\n  return (num << 5) | (num >>> 27)\n}\n\nfunction rotl30 (num) {\n  return (num << 30) | (num >>> 2)\n}\n\nfunction ft (s, b, c, d) {\n  if (s === 0) return (b & c) | ((~b) & d)\n  if (s === 2) return (b & c) | (b & d) | (c & d)\n  return b ^ c ^ d\n}\n\nSha.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]\n\n  for (var j = 0; j < 80; ++j) {\n    var s = ~~(j / 20)\n    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\n\n    e = d\n    d = c\n    c = rotl30(b)\n    b = a\n    a = t\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n}\n\nSha.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(20)\n\n  H.writeInt32BE(this._a | 0, 0)\n  H.writeInt32BE(this._b | 0, 4)\n  H.writeInt32BE(this._c | 0, 8)\n  H.writeInt32BE(this._d | 0, 12)\n  H.writeInt32BE(this._e | 0, 16)\n\n  return H\n}\n\nmodule.exports = Sha\n\n\n//# sourceURL=webpack:///./node_modules/sha.js/sha.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha1.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar K = [\n  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\n]\n\nvar W = new Array(80)\n\nfunction Sha1 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha1, Hash)\n\nSha1.prototype.init = function () {\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n\n  return this\n}\n\nfunction rotl1 (num) {\n  return (num << 1) | (num >>> 31)\n}\n\nfunction rotl5 (num) {\n  return (num << 5) | (num >>> 27)\n}\n\nfunction rotl30 (num) {\n  return (num << 30) | (num >>> 2)\n}\n\nfunction ft (s, b, c, d) {\n  if (s === 0) return (b & c) | ((~b) & d)\n  if (s === 2) return (b & c) | (b & d) | (c & d)\n  return b ^ c ^ d\n}\n\nSha1.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])\n\n  for (var j = 0; j < 80; ++j) {\n    var s = ~~(j / 20)\n    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\n\n    e = d\n    d = c\n    c = rotl30(b)\n    b = a\n    a = t\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n}\n\nSha1.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(20)\n\n  H.writeInt32BE(this._a | 0, 0)\n  H.writeInt32BE(this._b | 0, 4)\n  H.writeInt32BE(this._c | 0, 8)\n  H.writeInt32BE(this._d | 0, 12)\n  H.writeInt32BE(this._e | 0, 16)\n\n  return H\n}\n\nmodule.exports = Sha1\n\n\n//# sourceURL=webpack:///./node_modules/sha.js/sha1.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha224.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha224.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Sha256 = __webpack_require__(/*! ./sha256 */ \"./node_modules/sha.js/sha256.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar W = new Array(64)\n\nfunction Sha224 () {\n  this.init()\n\n  this._w = W // new Array(64)\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha224, Sha256)\n\nSha224.prototype.init = function () {\n  this._a = 0xc1059ed8\n  this._b = 0x367cd507\n  this._c = 0x3070dd17\n  this._d = 0xf70e5939\n  this._e = 0xffc00b31\n  this._f = 0x68581511\n  this._g = 0x64f98fa7\n  this._h = 0xbefa4fa4\n\n  return this\n}\n\nSha224.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(28)\n\n  H.writeInt32BE(this._a, 0)\n  H.writeInt32BE(this._b, 4)\n  H.writeInt32BE(this._c, 8)\n  H.writeInt32BE(this._d, 12)\n  H.writeInt32BE(this._e, 16)\n  H.writeInt32BE(this._f, 20)\n  H.writeInt32BE(this._g, 24)\n\n  return H\n}\n\nmodule.exports = Sha224\n\n\n//# sourceURL=webpack:///./node_modules/sha.js/sha224.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha256.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar K = [\n  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n]\n\nvar W = new Array(64)\n\nfunction Sha256 () {\n  this.init()\n\n  this._w = W // new Array(64)\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha256, Hash)\n\nSha256.prototype.init = function () {\n  this._a = 0x6a09e667\n  this._b = 0xbb67ae85\n  this._c = 0x3c6ef372\n  this._d = 0xa54ff53a\n  this._e = 0x510e527f\n  this._f = 0x9b05688c\n  this._g = 0x1f83d9ab\n  this._h = 0x5be0cd19\n\n  return this\n}\n\nfunction ch (x, y, z) {\n  return z ^ (x & (y ^ z))\n}\n\nfunction maj (x, y, z) {\n  return (x & y) | (z & (x | y))\n}\n\nfunction sigma0 (x) {\n  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)\n}\n\nfunction sigma1 (x) {\n  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)\n}\n\nfunction gamma0 (x) {\n  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)\n}\n\nfunction gamma1 (x) {\n  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)\n}\n\nSha256.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n  var f = this._f | 0\n  var g = this._g | 0\n  var h = this._h | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0\n\n  for (var j = 0; j < 64; ++j) {\n    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0\n    var T2 = (sigma0(a) + maj(a, b, c)) | 0\n\n    h = g\n    g = f\n    f = e\n    e = (d + T1) | 0\n    d = c\n    c = b\n    b = a\n    a = (T1 + T2) | 0\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n  this._f = (f + this._f) | 0\n  this._g = (g + this._g) | 0\n  this._h = (h + this._h) | 0\n}\n\nSha256.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(32)\n\n  H.writeInt32BE(this._a, 0)\n  H.writeInt32BE(this._b, 4)\n  H.writeInt32BE(this._c, 8)\n  H.writeInt32BE(this._d, 12)\n  H.writeInt32BE(this._e, 16)\n  H.writeInt32BE(this._f, 20)\n  H.writeInt32BE(this._g, 24)\n  H.writeInt32BE(this._h, 28)\n\n  return H\n}\n\nmodule.exports = Sha256\n\n\n//# sourceURL=webpack:///./node_modules/sha.js/sha256.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha384.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha384.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar SHA512 = __webpack_require__(/*! ./sha512 */ \"./node_modules/sha.js/sha512.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar W = new Array(160)\n\nfunction Sha384 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 128, 112)\n}\n\ninherits(Sha384, SHA512)\n\nSha384.prototype.init = function () {\n  this._ah = 0xcbbb9d5d\n  this._bh = 0x629a292a\n  this._ch = 0x9159015a\n  this._dh = 0x152fecd8\n  this._eh = 0x67332667\n  this._fh = 0x8eb44a87\n  this._gh = 0xdb0c2e0d\n  this._hh = 0x47b5481d\n\n  this._al = 0xc1059ed8\n  this._bl = 0x367cd507\n  this._cl = 0x3070dd17\n  this._dl = 0xf70e5939\n  this._el = 0xffc00b31\n  this._fl = 0x68581511\n  this._gl = 0x64f98fa7\n  this._hl = 0xbefa4fa4\n\n  return this\n}\n\nSha384.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(48)\n\n  function writeInt64BE (h, l, offset) {\n    H.writeInt32BE(h, offset)\n    H.writeInt32BE(l, offset + 4)\n  }\n\n  writeInt64BE(this._ah, this._al, 0)\n  writeInt64BE(this._bh, this._bl, 8)\n  writeInt64BE(this._ch, this._cl, 16)\n  writeInt64BE(this._dh, this._dl, 24)\n  writeInt64BE(this._eh, this._el, 32)\n  writeInt64BE(this._fh, this._fl, 40)\n\n  return H\n}\n\nmodule.exports = Sha384\n\n\n//# sourceURL=webpack:///./node_modules/sha.js/sha384.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha512.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha512.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n]\n\nvar W = new Array(160)\n\nfunction Sha512 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 128, 112)\n}\n\ninherits(Sha512, Hash)\n\nSha512.prototype.init = function () {\n  this._ah = 0x6a09e667\n  this._bh = 0xbb67ae85\n  this._ch = 0x3c6ef372\n  this._dh = 0xa54ff53a\n  this._eh = 0x510e527f\n  this._fh = 0x9b05688c\n  this._gh = 0x1f83d9ab\n  this._hh = 0x5be0cd19\n\n  this._al = 0xf3bcc908\n  this._bl = 0x84caa73b\n  this._cl = 0xfe94f82b\n  this._dl = 0x5f1d36f1\n  this._el = 0xade682d1\n  this._fl = 0x2b3e6c1f\n  this._gl = 0xfb41bd6b\n  this._hl = 0x137e2179\n\n  return this\n}\n\nfunction Ch (x, y, z) {\n  return z ^ (x & (y ^ z))\n}\n\nfunction maj (x, y, z) {\n  return (x & y) | (z & (x | y))\n}\n\nfunction sigma0 (x, xl) {\n  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)\n}\n\nfunction sigma1 (x, xl) {\n  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)\n}\n\nfunction Gamma0 (x, xl) {\n  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)\n}\n\nfunction Gamma0l (x, xl) {\n  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)\n}\n\nfunction Gamma1 (x, xl) {\n  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)\n}\n\nfunction Gamma1l (x, xl) {\n  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)\n}\n\nfunction getCarry (a, b) {\n  return (a >>> 0) < (b >>> 0) ? 1 : 0\n}\n\nSha512.prototype._update = function (M) {\n  var W = this._w\n\n  var ah = this._ah | 0\n  var bh = this._bh | 0\n  var ch = this._ch | 0\n  var dh = this._dh | 0\n  var eh = this._eh | 0\n  var fh = this._fh | 0\n  var gh = this._gh | 0\n  var hh = this._hh | 0\n\n  var al = this._al | 0\n  var bl = this._bl | 0\n  var cl = this._cl | 0\n  var dl = this._dl | 0\n  var el = this._el | 0\n  var fl = this._fl | 0\n  var gl = this._gl | 0\n  var hl = this._hl | 0\n\n  for (var i = 0; i < 32; i += 2) {\n    W[i] = M.readInt32BE(i * 4)\n    W[i + 1] = M.readInt32BE(i * 4 + 4)\n  }\n  for (; i < 160; i += 2) {\n    var xh = W[i - 15 * 2]\n    var xl = W[i - 15 * 2 + 1]\n    var gamma0 = Gamma0(xh, xl)\n    var gamma0l = Gamma0l(xl, xh)\n\n    xh = W[i - 2 * 2]\n    xl = W[i - 2 * 2 + 1]\n    var gamma1 = Gamma1(xh, xl)\n    var gamma1l = Gamma1l(xl, xh)\n\n    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n    var Wi7h = W[i - 7 * 2]\n    var Wi7l = W[i - 7 * 2 + 1]\n\n    var Wi16h = W[i - 16 * 2]\n    var Wi16l = W[i - 16 * 2 + 1]\n\n    var Wil = (gamma0l + Wi7l) | 0\n    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0\n    Wil = (Wil + gamma1l) | 0\n    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0\n    Wil = (Wil + Wi16l) | 0\n    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0\n\n    W[i] = Wih\n    W[i + 1] = Wil\n  }\n\n  for (var j = 0; j < 160; j += 2) {\n    Wih = W[j]\n    Wil = W[j + 1]\n\n    var majh = maj(ah, bh, ch)\n    var majl = maj(al, bl, cl)\n\n    var sigma0h = sigma0(ah, al)\n    var sigma0l = sigma0(al, ah)\n    var sigma1h = sigma1(eh, el)\n    var sigma1l = sigma1(el, eh)\n\n    // t1 = h + sigma1 + ch + K[j] + W[j]\n    var Kih = K[j]\n    var Kil = K[j + 1]\n\n    var chh = Ch(eh, fh, gh)\n    var chl = Ch(el, fl, gl)\n\n    var t1l = (hl + sigma1l) | 0\n    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0\n    t1l = (t1l + chl) | 0\n    t1h = (t1h + chh + getCarry(t1l, chl)) | 0\n    t1l = (t1l + Kil) | 0\n    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0\n    t1l = (t1l + Wil) | 0\n    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0\n\n    // t2 = sigma0 + maj\n    var t2l = (sigma0l + majl) | 0\n    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0\n\n    hh = gh\n    hl = gl\n    gh = fh\n    gl = fl\n    fh = eh\n    fl = el\n    el = (dl + t1l) | 0\n    eh = (dh + t1h + getCarry(el, dl)) | 0\n    dh = ch\n    dl = cl\n    ch = bh\n    cl = bl\n    bh = ah\n    bl = al\n    al = (t1l + t2l) | 0\n    ah = (t1h + t2h + getCarry(al, t1l)) | 0\n  }\n\n  this._al = (this._al + al) | 0\n  this._bl = (this._bl + bl) | 0\n  this._cl = (this._cl + cl) | 0\n  this._dl = (this._dl + dl) | 0\n  this._el = (this._el + el) | 0\n  this._fl = (this._fl + fl) | 0\n  this._gl = (this._gl + gl) | 0\n  this._hl = (this._hl + hl) | 0\n\n  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0\n  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0\n  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0\n  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0\n  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0\n  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0\n  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0\n  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0\n}\n\nSha512.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(64)\n\n  function writeInt64BE (h, l, offset) {\n    H.writeInt32BE(h, offset)\n    H.writeInt32BE(l, offset + 4)\n  }\n\n  writeInt64BE(this._ah, this._al, 0)\n  writeInt64BE(this._bh, this._bl, 8)\n  writeInt64BE(this._ch, this._cl, 16)\n  writeInt64BE(this._dh, this._dl, 24)\n  writeInt64BE(this._eh, this._el, 32)\n  writeInt64BE(this._fh, this._fl, 40)\n  writeInt64BE(this._gh, this._gl, 48)\n  writeInt64BE(this._hh, this._hl, 56)\n\n  return H\n}\n\nmodule.exports = Sha512\n\n\n//# sourceURL=webpack:///./node_modules/sha.js/sha512.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\ninherits(Stream, EE);\nStream.Readable = __webpack_require__(/*! readable-stream/readable.js */ \"./node_modules/readable-stream/readable-browser.js\");\nStream.Writable = __webpack_require__(/*! readable-stream/writable.js */ \"./node_modules/readable-stream/writable-browser.js\");\nStream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ \"./node_modules/readable-stream/duplex-browser.js\");\nStream.Transform = __webpack_require__(/*! readable-stream/transform.js */ \"./node_modules/readable-stream/transform.js\");\nStream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ \"./node_modules/readable-stream/passthrough.js\");\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n\n//# sourceURL=webpack:///./node_modules/stream-browserify/index.js?");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack:///./node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/util-deprecate/browser.js?");

/***/ }),

/***/ "./node_modules/vm-browserify/index.js":
/*!*********************************************!*\
  !*** ./node_modules/vm-browserify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var indexOf = __webpack_require__(/*! indexof */ \"./node_modules/indexof/index.js\");\n\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nfunction Context() {}\nContext.prototype = {};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    if (!(context instanceof Context)) {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n    \n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    forEach(Object_keys(ctx), function (key) {\n        context[key] = ctx[key];\n    });\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    var copy = new Context();\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n\n\n//# sourceURL=webpack:///./node_modules/vm-browserify/index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 2:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///buffer_(ignored)?");

/***/ }),

/***/ 3:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///crypto_(ignored)?");

/***/ })

/******/ });